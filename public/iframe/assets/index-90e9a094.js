
const stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.top = '0px';
document.body.appendChild( stats.domElement );

console.log('gamemcu su7 assets index.js');

var _L = Object.defineProperty;
var yL = (t,n,r)=>n in t ? _L(t, n, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : t[n] = r;
var B = (t,n,r)=>(yL(t, typeof n != "symbol" ? n + "" : n, r),
r);
(function() {
    const n = document.createElement("link").relList;
    if (n && n.supports && n.supports("modulepreload"))
        return;
    for (const h of document.querySelectorAll('link[rel="modulepreload"]'))
        s(h);
    new MutationObserver(h=>{
        for (const l of h)
            if (l.type === "childList")
                for (const g of l.addedNodes)
                    g.tagName === "LINK" && g.rel === "modulepreload" && s(g)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function r(h) {
        const l = {};
        return h.integrity && (l.integrity = h.integrity),
        h.referrerPolicy && (l.referrerPolicy = h.referrerPolicy),
        h.crossOrigin === "use-credentials" ? l.credentials = "include" : h.crossOrigin === "anonymous" ? l.credentials = "omit" : l.credentials = "same-origin",
        l
    }
    function s(h) {
        if (h.ep)
            return;
        h.ep = !0;
        const l = r(h);
        fetch(h.href, l)
    }
}
)();
function xL(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var jS = {
    exports: {}
}
  , rg = {}
  , XS = {
    exports: {}
}
  , Ii = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cf = Symbol.for("react.element")
  , bL = Symbol.for("react.portal")
  , wL = Symbol.for("react.fragment")
  , AL = Symbol.for("react.strict_mode")
  , SL = Symbol.for("react.profiler")
  , TL = Symbol.for("react.provider")
  , EL = Symbol.for("react.context")
  , ML = Symbol.for("react.forward_ref")
  , CL = Symbol.for("react.suspense")
  , PL = Symbol.for("react.memo")
  , RL = Symbol.for("react.lazy")
  , ew = Symbol.iterator;
function DL(t) {
    return t === null || typeof t != "object" ? null : (t = ew && t[ew] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var YS = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , QS = Object.assign
  , KS = {};
function Ih(t, n, r) {
    this.props = t,
    this.context = n,
    this.refs = KS,
    this.updater = r || YS
}
Ih.prototype.isReactComponent = {};
Ih.prototype.setState = function(t, n) {
    if (typeof t != "object" && typeof t != "function" && t != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, n, "setState")
}
;
Ih.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
}
;
function ZS() {}
ZS.prototype = Ih.prototype;
function ey(t, n, r) {
    this.props = t,
    this.context = n,
    this.refs = KS,
    this.updater = r || YS
}
var ty = ey.prototype = new ZS;
ty.constructor = ey;
QS(ty, Ih.prototype);
ty.isPureReactComponent = !0;
var tw = Array.isArray
  , qS = Object.prototype.hasOwnProperty
  , ny = {
    current: null
}
  , JS = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function $S(t, n, r) {
    var s, h = {}, l = null, g = null;
    if (n != null)
        for (s in n.ref !== void 0 && (g = n.ref),
        n.key !== void 0 && (l = "" + n.key),
        n)
            qS.call(n, s) && !JS.hasOwnProperty(s) && (h[s] = n[s]);
    var _ = arguments.length - 2;
    if (_ === 1)
        h.children = r;
    else if (1 < _) {
        for (var A = Array(_), m = 0; m < _; m++)
            A[m] = arguments[m + 2];
        h.children = A
    }
    if (t && t.defaultProps)
        for (s in _ = t.defaultProps,
        _)
            h[s] === void 0 && (h[s] = _[s]);
    return {
        $$typeof: Cf,
        type: t,
        key: l,
        ref: g,
        props: h,
        _owner: ny.current
    }
}
function LL(t, n) {
    return {
        $$typeof: Cf,
        type: t.type,
        key: n,
        ref: t.ref,
        props: t.props,
        _owner: t._owner
    }
}
function iy(t) {
    return typeof t == "object" && t !== null && t.$$typeof === Cf
}
function IL(t) {
    var n = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(r) {
        return n[r]
    })
}
var nw = /\/+/g;
function J0(t, n) {
    return typeof t == "object" && t !== null && t.key != null ? IL("" + t.key) : n.toString(36)
}
function hm(t, n, r, s, h) {
    var l = typeof t;
    (l === "undefined" || l === "boolean") && (t = null);
    var g = !1;
    if (t === null)
        g = !0;
    else
        switch (l) {
        case "string":
        case "number":
            g = !0;
            break;
        case "object":
            switch (t.$$typeof) {
            case Cf:
            case bL:
                g = !0
            }
        }
    if (g)
        return g = t,
        h = h(g),
        t = s === "" ? "." + J0(g, 0) : s,
        tw(h) ? (r = "",
        t != null && (r = t.replace(nw, "$&/") + "/"),
        hm(h, n, r, "", function(m) {
            return m
        })) : h != null && (iy(h) && (h = LL(h, r + (!h.key || g && g.key === h.key ? "" : ("" + h.key).replace(nw, "$&/") + "/") + t)),
        n.push(h)),
        1;
    if (g = 0,
    s = s === "" ? "." : s + ":",
    tw(t))
        for (var _ = 0; _ < t.length; _++) {
            l = t[_];
            var A = s + J0(l, _);
            g += hm(l, n, r, A, h)
        }
    else if (A = DL(t),
    typeof A == "function")
        for (t = A.call(t),
        _ = 0; !(l = t.next()).done; )
            l = l.value,
            A = s + J0(l, _++),
            g += hm(l, n, r, A, h);
    else if (l === "object")
        throw n = String(t),
        Error("Objects are not valid as a React child (found: " + (n === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : n) + "). If you meant to render a collection of children, use an array instead.");
    return g
}
function Gp(t, n, r) {
    if (t == null)
        return t;
    var s = []
      , h = 0;
    return hm(t, s, "", "", function(l) {
        return n.call(r, l, h++)
    }),
    s
}
function OL(t) {
    if (t._status === -1) {
        var n = t._result;
        n = n(),
        n.then(function(r) {
            (t._status === 0 || t._status === -1) && (t._status = 1,
            t._result = r)
        }, function(r) {
            (t._status === 0 || t._status === -1) && (t._status = 2,
            t._result = r)
        }),
        t._status === -1 && (t._status = 0,
        t._result = n)
    }
    if (t._status === 1)
        return t._result.default;
    throw t._result
}
var lo = {
    current: null
}
  , dm = {
    transition: null
}
  , BL = {
    ReactCurrentDispatcher: lo,
    ReactCurrentBatchConfig: dm,
    ReactCurrentOwner: ny
};
Ii.Children = {
    map: Gp,
    forEach: function(t, n, r) {
        Gp(t, function() {
            n.apply(this, arguments)
        }, r)
    },
    count: function(t) {
        var n = 0;
        return Gp(t, function() {
            n++
        }),
        n
    },
    toArray: function(t) {
        return Gp(t, function(n) {
            return n
        }) || []
    },
    only: function(t) {
        if (!iy(t))
            throw Error("React.Children.only expected to receive a single React element child.");
        return t
    }
};
Ii.Component = Ih;
Ii.Fragment = wL;
Ii.Profiler = SL;
Ii.PureComponent = ey;
Ii.StrictMode = AL;
Ii.Suspense = CL;
Ii.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = BL;
Ii.cloneElement = function(t, n, r) {
    if (t == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var s = QS({}, t.props)
      , h = t.key
      , l = t.ref
      , g = t._owner;
    if (n != null) {
        if (n.ref !== void 0 && (l = n.ref,
        g = ny.current),
        n.key !== void 0 && (h = "" + n.key),
        t.type && t.type.defaultProps)
            var _ = t.type.defaultProps;
        for (A in n)
            qS.call(n, A) && !JS.hasOwnProperty(A) && (s[A] = n[A] === void 0 && _ !== void 0 ? _[A] : n[A])
    }
    var A = arguments.length - 2;
    if (A === 1)
        s.children = r;
    else if (1 < A) {
        _ = Array(A);
        for (var m = 0; m < A; m++)
            _[m] = arguments[m + 2];
        s.children = _
    }
    return {
        $$typeof: Cf,
        type: t.type,
        key: h,
        ref: l,
        props: s,
        _owner: g
    }
}
;
Ii.createContext = function(t) {
    return t = {
        $$typeof: EL,
        _currentValue: t,
        _currentValue2: t,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    t.Provider = {
        $$typeof: TL,
        _context: t
    },
    t.Consumer = t
}
;
Ii.createElement = $S;
Ii.createFactory = function(t) {
    var n = $S.bind(null, t);
    return n.type = t,
    n
}
;
Ii.createRef = function() {
    return {
        current: null
    }
}
;
Ii.forwardRef = function(t) {
    return {
        $$typeof: ML,
        render: t
    }
}
;
Ii.isValidElement = iy;
Ii.lazy = function(t) {
    return {
        $$typeof: RL,
        _payload: {
            _status: -1,
            _result: t
        },
        _init: OL
    }
}
;
Ii.memo = function(t, n) {
    return {
        $$typeof: PL,
        type: t,
        compare: n === void 0 ? null : n
    }
}
;
Ii.startTransition = function(t) {
    var n = dm.transition;
    dm.transition = {};
    try {
        t()
    } finally {
        dm.transition = n
    }
}
;
Ii.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
Ii.useCallback = function(t, n) {
    return lo.current.useCallback(t, n)
}
;
Ii.useContext = function(t) {
    return lo.current.useContext(t)
}
;
Ii.useDebugValue = function() {}
;
Ii.useDeferredValue = function(t) {
    return lo.current.useDeferredValue(t)
}
;
Ii.useEffect = function(t, n) {
    return lo.current.useEffect(t, n)
}
;
Ii.useId = function() {
    return lo.current.useId()
}
;
Ii.useImperativeHandle = function(t, n, r) {
    return lo.current.useImperativeHandle(t, n, r)
}
;
Ii.useInsertionEffect = function(t, n) {
    return lo.current.useInsertionEffect(t, n)
}
;
Ii.useLayoutEffect = function(t, n) {
    return lo.current.useLayoutEffect(t, n)
}
;
Ii.useMemo = function(t, n) {
    return lo.current.useMemo(t, n)
}
;
Ii.useReducer = function(t, n, r) {
    return lo.current.useReducer(t, n, r)
}
;
Ii.useRef = function(t) {
    return lo.current.useRef(t)
}
;
Ii.useState = function(t) {
    return lo.current.useState(t)
}
;
Ii.useSyncExternalStore = function(t, n, r) {
    return lo.current.useSyncExternalStore(t, n, r)
}
;
Ii.useTransition = function() {
    return lo.current.useTransition()
}
;
Ii.version = "18.2.0";
XS.exports = Ii;
var nt = XS.exports;
const Oh = xL(nt);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FL = nt
  , kL = Symbol.for("react.element")
  , UL = Symbol.for("react.fragment")
  , NL = Object.prototype.hasOwnProperty
  , zL = FL.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , GL = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function eT(t, n, r) {
    var s, h = {}, l = null, g = null;
    r !== void 0 && (l = "" + r),
    n.key !== void 0 && (l = "" + n.key),
    n.ref !== void 0 && (g = n.ref);
    for (s in n)
        NL.call(n, s) && !GL.hasOwnProperty(s) && (h[s] = n[s]);
    if (t && t.defaultProps)
        for (s in n = t.defaultProps,
        n)
            h[s] === void 0 && (h[s] = n[s]);
    return {
        $$typeof: kL,
        type: t,
        key: l,
        ref: g,
        props: h,
        _owner: zL.current
    }
}
rg.Fragment = UL;
rg.jsx = eT;
rg.jsxs = eT;
jS.exports = rg;
var Oe = jS.exports
  , Vv = {}
  , tT = {
    exports: {}
}
  , Ho = {}
  , nT = {
    exports: {}
}
  , iT = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function n(zt, Sn) {
        var rn = zt.length;
        zt.push(Sn);
        e: for (; 0 < rn; ) {
            var Ft = rn - 1 >>> 1
              , jt = zt[Ft];
            if (0 < h(jt, Sn))
                zt[Ft] = Sn,
                zt[rn] = jt,
                rn = Ft;
            else
                break e
        }
    }
    function r(zt) {
        return zt.length === 0 ? null : zt[0]
    }
    function s(zt) {
        if (zt.length === 0)
            return null;
        var Sn = zt[0]
          , rn = zt.pop();
        if (rn !== Sn) {
            zt[0] = rn;
            e: for (var Ft = 0, jt = zt.length, Xt = jt >>> 1; Ft < Xt; ) {
                var Rt = 2 * (Ft + 1) - 1
                  , Wn = zt[Rt]
                  , He = Rt + 1
                  , pt = zt[He];
                if (0 > h(Wn, rn))
                    He < jt && 0 > h(pt, Wn) ? (zt[Ft] = pt,
                    zt[He] = rn,
                    Ft = He) : (zt[Ft] = Wn,
                    zt[Rt] = rn,
                    Ft = Rt);
                else if (He < jt && 0 > h(pt, rn))
                    zt[Ft] = pt,
                    zt[He] = rn,
                    Ft = He;
                else
                    break e
            }
        }
        return Sn
    }
    function h(zt, Sn) {
        var rn = zt.sortIndex - Sn.sortIndex;
        return rn !== 0 ? rn : zt.id - Sn.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var l = performance;
        t.unstable_now = function() {
            return l.now()
        }
    } else {
        var g = Date
          , _ = g.now();
        t.unstable_now = function() {
            return g.now() - _
        }
    }
    var A = []
      , m = []
      , D = 1
      , U = null
      , R = 3
      , ne = !1
      , ce = !1
      , xe = !1
      , Se = typeof setTimeout == "function" ? setTimeout : null
      , $ = typeof clearTimeout == "function" ? clearTimeout : null
      , q = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function N(zt) {
        for (var Sn = r(m); Sn !== null; ) {
            if (Sn.callback === null)
                s(m);
            else if (Sn.startTime <= zt)
                s(m),
                Sn.sortIndex = Sn.expirationTime,
                n(A, Sn);
            else
                break;
            Sn = r(m)
        }
    }
    function ie(zt) {
        if (xe = !1,
        N(zt),
        !ce)
            if (r(A) !== null)
                ce = !0,
                di(_e);
            else {
                var Sn = r(m);
                Sn !== null && xi(ie, Sn.startTime - zt)
            }
    }
    function _e(zt, Sn) {
        ce = !1,
        xe && (xe = !1,
        $(Re),
        Re = -1),
        ne = !0;
        var rn = R;
        try {
            for (N(Sn),
            U = r(A); U !== null && (!(U.expirationTime > Sn) || zt && !Ze()); ) {
                var Ft = U.callback;
                if (typeof Ft == "function") {
                    U.callback = null,
                    R = U.priorityLevel;
                    var jt = Ft(U.expirationTime <= Sn);
                    Sn = t.unstable_now(),
                    typeof jt == "function" ? U.callback = jt : U === r(A) && s(A),
                    N(Sn)
                } else
                    s(A);
                U = r(A)
            }
            if (U !== null)
                var Xt = !0;
            else {
                var Rt = r(m);
                Rt !== null && xi(ie, Rt.startTime - Sn),
                Xt = !1
            }
            return Xt
        } finally {
            U = null,
            R = rn,
            ne = !1
        }
    }
    var Pe = !1
      , Be = null
      , Re = -1
      , ct = 5
      , et = -1;
    function Ze() {
        return !(t.unstable_now() - et < ct)
    }
    function Nt() {
        if (Be !== null) {
            var zt = t.unstable_now();
            et = zt;
            var Sn = !0;
            try {
                Sn = Be(!0, zt)
            } finally {
                Sn ? Bt() : (Pe = !1,
                Be = null)
            }
        } else
            Pe = !1
    }
    var Bt;
    if (typeof q == "function")
        Bt = function() {
            q(Nt)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var en = new MessageChannel
          , li = en.port2;
        en.port1.onmessage = Nt,
        Bt = function() {
            li.postMessage(null)
        }
    } else
        Bt = function() {
            Se(Nt, 0)
        }
        ;
    function di(zt) {
        Be = zt,
        Pe || (Pe = !0,
        Bt())
    }
    function xi(zt, Sn) {
        Re = Se(function() {
            zt(t.unstable_now())
        }, Sn)
    }
    t.unstable_IdlePriority = 5,
    t.unstable_ImmediatePriority = 1,
    t.unstable_LowPriority = 4,
    t.unstable_NormalPriority = 3,
    t.unstable_Profiling = null,
    t.unstable_UserBlockingPriority = 2,
    t.unstable_cancelCallback = function(zt) {
        zt.callback = null
    }
    ,
    t.unstable_continueExecution = function() {
        ce || ne || (ce = !0,
        di(_e))
    }
    ,
    t.unstable_forceFrameRate = function(zt) {
        0 > zt || 125 < zt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ct = 0 < zt ? Math.floor(1e3 / zt) : 5
    }
    ,
    t.unstable_getCurrentPriorityLevel = function() {
        return R
    }
    ,
    t.unstable_getFirstCallbackNode = function() {
        return r(A)
    }
    ,
    t.unstable_next = function(zt) {
        switch (R) {
        case 1:
        case 2:
        case 3:
            var Sn = 3;
            break;
        default:
            Sn = R
        }
        var rn = R;
        R = Sn;
        try {
            return zt()
        } finally {
            R = rn
        }
    }
    ,
    t.unstable_pauseExecution = function() {}
    ,
    t.unstable_requestPaint = function() {}
    ,
    t.unstable_runWithPriority = function(zt, Sn) {
        switch (zt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            zt = 3
        }
        var rn = R;
        R = zt;
        try {
            return Sn()
        } finally {
            R = rn
        }
    }
    ,
    t.unstable_scheduleCallback = function(zt, Sn, rn) {
        var Ft = t.unstable_now();
        switch (typeof rn == "object" && rn !== null ? (rn = rn.delay,
        rn = typeof rn == "number" && 0 < rn ? Ft + rn : Ft) : rn = Ft,
        zt) {
        case 1:
            var jt = -1;
            break;
        case 2:
            jt = 250;
            break;
        case 5:
            jt = 1073741823;
            break;
        case 4:
            jt = 1e4;
            break;
        default:
            jt = 5e3
        }
        return jt = rn + jt,
        zt = {
            id: D++,
            callback: Sn,
            priorityLevel: zt,
            startTime: rn,
            expirationTime: jt,
            sortIndex: -1
        },
        rn > Ft ? (zt.sortIndex = rn,
        n(m, zt),
        r(A) === null && zt === r(m) && (xe ? ($(Re),
        Re = -1) : xe = !0,
        xi(ie, rn - Ft))) : (zt.sortIndex = jt,
        n(A, zt),
        ce || ne || (ce = !0,
        di(_e))),
        zt
    }
    ,
    t.unstable_shouldYield = Ze,
    t.unstable_wrapCallback = function(zt) {
        var Sn = R;
        return function() {
            var rn = R;
            R = Sn;
            try {
                return zt.apply(this, arguments)
            } finally {
                R = rn
            }
        }
    }
}
)(iT);
nT.exports = iT;
var HL = nT.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rT = nt
  , zo = HL;
function Ct(t) {
    for (var n = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, r = 1; r < arguments.length; r++)
        n += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified React error #" + t + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var sT = new Set
  , sf = {};
function wu(t, n) {
    Th(t, n),
    Th(t + "Capture", n)
}
function Th(t, n) {
    for (sf[t] = n,
    t = 0; t < n.length; t++)
        sT.add(n[t])
}
var kl = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , Wv = Object.prototype.hasOwnProperty
  , VL = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , iw = {}
  , rw = {};
function WL(t) {
    return Wv.call(rw, t) ? !0 : Wv.call(iw, t) ? !1 : VL.test(t) ? rw[t] = !0 : (iw[t] = !0,
    !1)
}
function jL(t, n, r, s) {
    if (r !== null && r.type === 0)
        return !1;
    switch (typeof n) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return s ? !1 : r !== null ? !r.acceptsBooleans : (t = t.toLowerCase().slice(0, 5),
        t !== "data-" && t !== "aria-");
    default:
        return !1
    }
}
function XL(t, n, r, s) {
    if (n === null || typeof n > "u" || jL(t, n, r, s))
        return !0;
    if (s)
        return !1;
    if (r !== null)
        switch (r.type) {
        case 3:
            return !n;
        case 4:
            return n === !1;
        case 5:
            return isNaN(n);
        case 6:
            return isNaN(n) || 1 > n
        }
    return !1
}
function co(t, n, r, s, h, l, g) {
    this.acceptsBooleans = n === 2 || n === 3 || n === 4,
    this.attributeName = s,
    this.attributeNamespace = h,
    this.mustUseProperty = r,
    this.propertyName = t,
    this.type = n,
    this.sanitizeURL = l,
    this.removeEmptyString = g
}
var Fs = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    Fs[t] = new co(t,0,!1,t,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(t) {
    var n = t[0];
    Fs[n] = new co(n,1,!1,t[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    Fs[t] = new co(t,2,!1,t.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    Fs[t] = new co(t,2,!1,t,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    Fs[t] = new co(t,3,!1,t.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
    Fs[t] = new co(t,3,!0,t,null,!1,!1)
});
["capture", "download"].forEach(function(t) {
    Fs[t] = new co(t,4,!1,t,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
    Fs[t] = new co(t,6,!1,t,null,!1,!1)
});
["rowSpan", "start"].forEach(function(t) {
    Fs[t] = new co(t,5,!1,t.toLowerCase(),null,!1,!1)
});
var ry = /[\-:]([a-z])/g;
function sy(t) {
    return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var n = t.replace(ry, sy);
    Fs[n] = new co(n,1,!1,t,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var n = t.replace(ry, sy);
    Fs[n] = new co(n,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var n = t.replace(ry, sy);
    Fs[n] = new co(n,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
    Fs[t] = new co(t,1,!1,t.toLowerCase(),null,!1,!1)
});
Fs.xlinkHref = new co("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(t) {
    Fs[t] = new co(t,1,!1,t.toLowerCase(),null,!0,!0)
});
function oy(t, n, r, s) {
    var h = Fs.hasOwnProperty(n) ? Fs[n] : null;
    (h !== null ? h.type !== 0 : s || !(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (XL(n, r, h, s) && (r = null),
    s || h === null ? WL(n) && (r === null ? t.removeAttribute(n) : t.setAttribute(n, "" + r)) : h.mustUseProperty ? t[h.propertyName] = r === null ? h.type === 3 ? !1 : "" : r : (n = h.attributeName,
    s = h.attributeNamespace,
    r === null ? t.removeAttribute(n) : (h = h.type,
    r = h === 3 || h === 4 && r === !0 ? "" : "" + r,
    s ? t.setAttributeNS(s, n, r) : t.setAttribute(n, r))))
}
var Gl = rT.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Hp = Symbol.for("react.element")
  , nh = Symbol.for("react.portal")
  , ih = Symbol.for("react.fragment")
  , ay = Symbol.for("react.strict_mode")
  , jv = Symbol.for("react.profiler")
  , oT = Symbol.for("react.provider")
  , aT = Symbol.for("react.context")
  , ly = Symbol.for("react.forward_ref")
  , Xv = Symbol.for("react.suspense")
  , Yv = Symbol.for("react.suspense_list")
  , cy = Symbol.for("react.memo")
  , lc = Symbol.for("react.lazy")
  , lT = Symbol.for("react.offscreen")
  , sw = Symbol.iterator;
function Md(t) {
    return t === null || typeof t != "object" ? null : (t = sw && t[sw] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var Br = Object.assign, $0;
function Nd(t) {
    if ($0 === void 0)
        try {
            throw Error()
        } catch (r) {
            var n = r.stack.trim().match(/\n( *(at )?)/);
            $0 = n && n[1] || ""
        }
    return `
` + $0 + t
}
var ev = !1;
function tv(t, n) {
    if (!t || ev)
        return "";
    ev = !0;
    var r = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (n)
            if (n = function() {
                throw Error()
            }
            ,
            Object.defineProperty(n.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(n, [])
                } catch (m) {
                    var s = m
                }
                Reflect.construct(t, [], n)
            } else {
                try {
                    n.call()
                } catch (m) {
                    s = m
                }
                t.call(n.prototype)
            }
        else {
            try {
                throw Error()
            } catch (m) {
                s = m
            }
            t()
        }
    } catch (m) {
        if (m && s && typeof m.stack == "string") {
            for (var h = m.stack.split(`
`), l = s.stack.split(`
`), g = h.length - 1, _ = l.length - 1; 1 <= g && 0 <= _ && h[g] !== l[_]; )
                _--;
            for (; 1 <= g && 0 <= _; g--,
            _--)
                if (h[g] !== l[_]) {
                    if (g !== 1 || _ !== 1)
                        do
                            if (g--,
                            _--,
                            0 > _ || h[g] !== l[_]) {
                                var A = `
` + h[g].replace(" at new ", " at ");
                                return t.displayName && A.includes("<anonymous>") && (A = A.replace("<anonymous>", t.displayName)),
                                A
                            }
                        while (1 <= g && 0 <= _);
                    break
                }
        }
    } finally {
        ev = !1,
        Error.prepareStackTrace = r
    }
    return (t = t ? t.displayName || t.name : "") ? Nd(t) : ""
}
function YL(t) {
    switch (t.tag) {
    case 5:
        return Nd(t.type);
    case 16:
        return Nd("Lazy");
    case 13:
        return Nd("Suspense");
    case 19:
        return Nd("SuspenseList");
    case 0:
    case 2:
    case 15:
        return t = tv(t.type, !1),
        t;
    case 11:
        return t = tv(t.type.render, !1),
        t;
    case 1:
        return t = tv(t.type, !0),
        t;
    default:
        return ""
    }
}
function Qv(t) {
    if (t == null)
        return null;
    if (typeof t == "function")
        return t.displayName || t.name || null;
    if (typeof t == "string")
        return t;
    switch (t) {
    case ih:
        return "Fragment";
    case nh:
        return "Portal";
    case jv:
        return "Profiler";
    case ay:
        return "StrictMode";
    case Xv:
        return "Suspense";
    case Yv:
        return "SuspenseList"
    }
    if (typeof t == "object")
        switch (t.$$typeof) {
        case aT:
            return (t.displayName || "Context") + ".Consumer";
        case oT:
            return (t._context.displayName || "Context") + ".Provider";
        case ly:
            var n = t.render;
            return t = t.displayName,
            t || (t = n.displayName || n.name || "",
            t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"),
            t;
        case cy:
            return n = t.displayName || null,
            n !== null ? n : Qv(t.type) || "Memo";
        case lc:
            n = t._payload,
            t = t._init;
            try {
                return Qv(t(n))
            } catch {}
        }
    return null
}
function QL(t) {
    var n = t.type;
    switch (t.tag) {
    case 24:
        return "Cache";
    case 9:
        return (n.displayName || "Context") + ".Consumer";
    case 10:
        return (n._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return t = n.render,
        t = t.displayName || t.name || "",
        n.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return n;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Qv(n);
    case 8:
        return n === ay ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof n == "function")
            return n.displayName || n.name || null;
        if (typeof n == "string")
            return n
    }
    return null
}
function Sc(t) {
    switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return t;
    case "object":
        return t;
    default:
        return ""
    }
}
function cT(t) {
    var n = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (n === "checkbox" || n === "radio")
}
function KL(t) {
    var n = cT(t) ? "checked" : "value"
      , r = Object.getOwnPropertyDescriptor(t.constructor.prototype, n)
      , s = "" + t[n];
    if (!t.hasOwnProperty(n) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
        var h = r.get
          , l = r.set;
        return Object.defineProperty(t, n, {
            configurable: !0,
            get: function() {
                return h.call(this)
            },
            set: function(g) {
                s = "" + g,
                l.call(this, g)
            }
        }),
        Object.defineProperty(t, n, {
            enumerable: r.enumerable
        }),
        {
            getValue: function() {
                return s
            },
            setValue: function(g) {
                s = "" + g
            },
            stopTracking: function() {
                t._valueTracker = null,
                delete t[n]
            }
        }
    }
}
function Vp(t) {
    t._valueTracker || (t._valueTracker = KL(t))
}
function uT(t) {
    if (!t)
        return !1;
    var n = t._valueTracker;
    if (!n)
        return !0;
    var r = n.getValue()
      , s = "";
    return t && (s = cT(t) ? t.checked ? "true" : "false" : t.value),
    t = s,
    t !== r ? (n.setValue(t),
    !0) : !1
}
function Em(t) {
    if (t = t || (typeof document < "u" ? document : void 0),
    typeof t > "u")
        return null;
    try {
        return t.activeElement || t.body
    } catch {
        return t.body
    }
}
function Kv(t, n) {
    var r = n.checked;
    return Br({}, n, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: r ?? t._wrapperState.initialChecked
    })
}
function ow(t, n) {
    var r = n.defaultValue == null ? "" : n.defaultValue
      , s = n.checked != null ? n.checked : n.defaultChecked;
    r = Sc(n.value != null ? n.value : r),
    t._wrapperState = {
        initialChecked: s,
        initialValue: r,
        controlled: n.type === "checkbox" || n.type === "radio" ? n.checked != null : n.value != null
    }
}
function hT(t, n) {
    n = n.checked,
    n != null && oy(t, "checked", n, !1)
}
function Zv(t, n) {
    hT(t, n);
    var r = Sc(n.value)
      , s = n.type;
    if (r != null)
        s === "number" ? (r === 0 && t.value === "" || t.value != r) && (t.value = "" + r) : t.value !== "" + r && (t.value = "" + r);
    else if (s === "submit" || s === "reset") {
        t.removeAttribute("value");
        return
    }
    n.hasOwnProperty("value") ? qv(t, n.type, r) : n.hasOwnProperty("defaultValue") && qv(t, n.type, Sc(n.defaultValue)),
    n.checked == null && n.defaultChecked != null && (t.defaultChecked = !!n.defaultChecked)
}
function aw(t, n, r) {
    if (n.hasOwnProperty("value") || n.hasOwnProperty("defaultValue")) {
        var s = n.type;
        if (!(s !== "submit" && s !== "reset" || n.value !== void 0 && n.value !== null))
            return;
        n = "" + t._wrapperState.initialValue,
        r || n === t.value || (t.value = n),
        t.defaultValue = n
    }
    r = t.name,
    r !== "" && (t.name = ""),
    t.defaultChecked = !!t._wrapperState.initialChecked,
    r !== "" && (t.name = r)
}
function qv(t, n, r) {
    (n !== "number" || Em(t.ownerDocument) !== t) && (r == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + r && (t.defaultValue = "" + r))
}
var zd = Array.isArray;
function _h(t, n, r, s) {
    if (t = t.options,
    n) {
        n = {};
        for (var h = 0; h < r.length; h++)
            n["$" + r[h]] = !0;
        for (r = 0; r < t.length; r++)
            h = n.hasOwnProperty("$" + t[r].value),
            t[r].selected !== h && (t[r].selected = h),
            h && s && (t[r].defaultSelected = !0)
    } else {
        for (r = "" + Sc(r),
        n = null,
        h = 0; h < t.length; h++) {
            if (t[h].value === r) {
                t[h].selected = !0,
                s && (t[h].defaultSelected = !0);
                return
            }
            n !== null || t[h].disabled || (n = t[h])
        }
        n !== null && (n.selected = !0)
    }
}
function Jv(t, n) {
    if (n.dangerouslySetInnerHTML != null)
        throw Error(Ct(91));
    return Br({}, n, {
        value: void 0,
        defaultValue: void 0,
        children: "" + t._wrapperState.initialValue
    })
}
function lw(t, n) {
    var r = n.value;
    if (r == null) {
        if (r = n.children,
        n = n.defaultValue,
        r != null) {
            if (n != null)
                throw Error(Ct(92));
            if (zd(r)) {
                if (1 < r.length)
                    throw Error(Ct(93));
                r = r[0]
            }
            n = r
        }
        n == null && (n = ""),
        r = n
    }
    t._wrapperState = {
        initialValue: Sc(r)
    }
}
function dT(t, n) {
    var r = Sc(n.value)
      , s = Sc(n.defaultValue);
    r != null && (r = "" + r,
    r !== t.value && (t.value = r),
    n.defaultValue == null && t.defaultValue !== r && (t.defaultValue = r)),
    s != null && (t.defaultValue = "" + s)
}
function cw(t) {
    var n = t.textContent;
    n === t._wrapperState.initialValue && n !== "" && n !== null && (t.value = n)
}
function fT(t) {
    switch (t) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function $v(t, n) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? fT(n) : t === "http://www.w3.org/2000/svg" && n === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var Wp, pT = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(n, r, s, h) {
        MSApp.execUnsafeLocalFunction(function() {
            return t(n, r, s, h)
        })
    }
    : t
}(function(t, n) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in t)
        t.innerHTML = n;
    else {
        for (Wp = Wp || document.createElement("div"),
        Wp.innerHTML = "<svg>" + n.valueOf().toString() + "</svg>",
        n = Wp.firstChild; t.firstChild; )
            t.removeChild(t.firstChild);
        for (; n.firstChild; )
            t.appendChild(n.firstChild)
    }
});
function of(t, n) {
    if (n) {
        var r = t.firstChild;
        if (r && r === t.lastChild && r.nodeType === 3) {
            r.nodeValue = n;
            return
        }
    }
    t.textContent = n
}
var Wd = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , ZL = ["Webkit", "ms", "Moz", "O"];
Object.keys(Wd).forEach(function(t) {
    ZL.forEach(function(n) {
        n = n + t.charAt(0).toUpperCase() + t.substring(1),
        Wd[n] = Wd[t]
    })
});
function mT(t, n, r) {
    return n == null || typeof n == "boolean" || n === "" ? "" : r || typeof n != "number" || n === 0 || Wd.hasOwnProperty(t) && Wd[t] ? ("" + n).trim() : n + "px"
}
function gT(t, n) {
    t = t.style;
    for (var r in n)
        if (n.hasOwnProperty(r)) {
            var s = r.indexOf("--") === 0
              , h = mT(r, n[r], s);
            r === "float" && (r = "cssFloat"),
            s ? t.setProperty(r, h) : t[r] = h
        }
}
var qL = Br({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function e_(t, n) {
    if (n) {
        if (qL[t] && (n.children != null || n.dangerouslySetInnerHTML != null))
            throw Error(Ct(137, t));
        if (n.dangerouslySetInnerHTML != null) {
            if (n.children != null)
                throw Error(Ct(60));
            if (typeof n.dangerouslySetInnerHTML != "object" || !("__html"in n.dangerouslySetInnerHTML))
                throw Error(Ct(61))
        }
        if (n.style != null && typeof n.style != "object")
            throw Error(Ct(62))
    }
}
function t_(t, n) {
    if (t.indexOf("-") === -1)
        return typeof n.is == "string";
    switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var n_ = null;
function uy(t) {
    return t = t.target || t.srcElement || window,
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
}
var i_ = null
  , yh = null
  , xh = null;
function uw(t) {
    if (t = Df(t)) {
        if (typeof i_ != "function")
            throw Error(Ct(280));
        var n = t.stateNode;
        n && (n = cg(n),
        i_(t.stateNode, t.type, n))
    }
}
function vT(t) {
    yh ? xh ? xh.push(t) : xh = [t] : yh = t
}
function _T() {
    if (yh) {
        var t = yh
          , n = xh;
        if (xh = yh = null,
        uw(t),
        n)
            for (t = 0; t < n.length; t++)
                uw(n[t])
    }
}
function yT(t, n) {
    return t(n)
}
function xT() {}
var nv = !1;
function bT(t, n, r) {
    if (nv)
        return t(n, r);
    nv = !0;
    try {
        return yT(t, n, r)
    } finally {
        nv = !1,
        (yh !== null || xh !== null) && (xT(),
        _T())
    }
}
function af(t, n) {
    var r = t.stateNode;
    if (r === null)
        return null;
    var s = cg(r);
    if (s === null)
        return null;
    r = s[n];
    e: switch (n) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (s = !s.disabled) || (t = t.type,
        s = !(t === "button" || t === "input" || t === "select" || t === "textarea")),
        t = !s;
        break e;
    default:
        t = !1
    }
    if (t)
        return null;
    if (r && typeof r != "function")
        throw Error(Ct(231, n, typeof r));
    return r
}
var r_ = !1;
if (kl)
    try {
        var Cd = {};
        Object.defineProperty(Cd, "passive", {
            get: function() {
                r_ = !0
            }
        }),
        window.addEventListener("test", Cd, Cd),
        window.removeEventListener("test", Cd, Cd)
    } catch {
        r_ = !1
    }
function JL(t, n, r, s, h, l, g, _, A) {
    var m = Array.prototype.slice.call(arguments, 3);
    try {
        n.apply(r, m)
    } catch (D) {
        this.onError(D)
    }
}
var jd = !1
  , Mm = null
  , Cm = !1
  , s_ = null
  , $L = {
    onError: function(t) {
        jd = !0,
        Mm = t
    }
};
function eI(t, n, r, s, h, l, g, _, A) {
    jd = !1,
    Mm = null,
    JL.apply($L, arguments)
}
function tI(t, n, r, s, h, l, g, _, A) {
    if (eI.apply(this, arguments),
    jd) {
        if (jd) {
            var m = Mm;
            jd = !1,
            Mm = null
        } else
            throw Error(Ct(198));
        Cm || (Cm = !0,
        s_ = m)
    }
}
function Au(t) {
    var n = t
      , r = t;
    if (t.alternate)
        for (; n.return; )
            n = n.return;
    else {
        t = n;
        do
            n = t,
            n.flags & 4098 && (r = n.return),
            t = n.return;
        while (t)
    }
    return n.tag === 3 ? r : null
}
function wT(t) {
    if (t.tag === 13) {
        var n = t.memoizedState;
        if (n === null && (t = t.alternate,
        t !== null && (n = t.memoizedState)),
        n !== null)
            return n.dehydrated
    }
    return null
}
function hw(t) {
    if (Au(t) !== t)
        throw Error(Ct(188))
}
function nI(t) {
    var n = t.alternate;
    if (!n) {
        if (n = Au(t),
        n === null)
            throw Error(Ct(188));
        return n !== t ? null : t
    }
    for (var r = t, s = n; ; ) {
        var h = r.return;
        if (h === null)
            break;
        var l = h.alternate;
        if (l === null) {
            if (s = h.return,
            s !== null) {
                r = s;
                continue
            }
            break
        }
        if (h.child === l.child) {
            for (l = h.child; l; ) {
                if (l === r)
                    return hw(h),
                    t;
                if (l === s)
                    return hw(h),
                    n;
                l = l.sibling
            }
            throw Error(Ct(188))
        }
        if (r.return !== s.return)
            r = h,
            s = l;
        else {
            for (var g = !1, _ = h.child; _; ) {
                if (_ === r) {
                    g = !0,
                    r = h,
                    s = l;
                    break
                }
                if (_ === s) {
                    g = !0,
                    s = h,
                    r = l;
                    break
                }
                _ = _.sibling
            }
            if (!g) {
                for (_ = l.child; _; ) {
                    if (_ === r) {
                        g = !0,
                        r = l,
                        s = h;
                        break
                    }
                    if (_ === s) {
                        g = !0,
                        s = l,
                        r = h;
                        break
                    }
                    _ = _.sibling
                }
                if (!g)
                    throw Error(Ct(189))
            }
        }
        if (r.alternate !== s)
            throw Error(Ct(190))
    }
    if (r.tag !== 3)
        throw Error(Ct(188));
    return r.stateNode.current === r ? t : n
}
function AT(t) {
    return t = nI(t),
    t !== null ? ST(t) : null
}
function ST(t) {
    if (t.tag === 5 || t.tag === 6)
        return t;
    for (t = t.child; t !== null; ) {
        var n = ST(t);
        if (n !== null)
            return n;
        t = t.sibling
    }
    return null
}
var TT = zo.unstable_scheduleCallback
  , dw = zo.unstable_cancelCallback
  , iI = zo.unstable_shouldYield
  , rI = zo.unstable_requestPaint
  , jr = zo.unstable_now
  , sI = zo.unstable_getCurrentPriorityLevel
  , hy = zo.unstable_ImmediatePriority
  , ET = zo.unstable_UserBlockingPriority
  , Pm = zo.unstable_NormalPriority
  , oI = zo.unstable_LowPriority
  , MT = zo.unstable_IdlePriority
  , sg = null
  , tl = null;
function aI(t) {
    if (tl && typeof tl.onCommitFiberRoot == "function")
        try {
            tl.onCommitFiberRoot(sg, t, void 0, (t.current.flags & 128) === 128)
        } catch {}
}
var La = Math.clz32 ? Math.clz32 : uI
  , lI = Math.log
  , cI = Math.LN2;
function uI(t) {
    return t >>>= 0,
    t === 0 ? 32 : 31 - (lI(t) / cI | 0) | 0
}
var jp = 64
  , Xp = 4194304;
function Gd(t) {
    switch (t & -t) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return t & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return t
    }
}
function Rm(t, n) {
    var r = t.pendingLanes;
    if (r === 0)
        return 0;
    var s = 0
      , h = t.suspendedLanes
      , l = t.pingedLanes
      , g = r & 268435455;
    if (g !== 0) {
        var _ = g & ~h;
        _ !== 0 ? s = Gd(_) : (l &= g,
        l !== 0 && (s = Gd(l)))
    } else
        g = r & ~h,
        g !== 0 ? s = Gd(g) : l !== 0 && (s = Gd(l));
    if (s === 0)
        return 0;
    if (n !== 0 && n !== s && !(n & h) && (h = s & -s,
    l = n & -n,
    h >= l || h === 16 && (l & 4194240) !== 0))
        return n;
    if (s & 4 && (s |= r & 16),
    n = t.entangledLanes,
    n !== 0)
        for (t = t.entanglements,
        n &= s; 0 < n; )
            r = 31 - La(n),
            h = 1 << r,
            s |= t[r],
            n &= ~h;
    return s
}
function hI(t, n) {
    switch (t) {
    case 1:
    case 2:
    case 4:
        return n + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return n + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function dI(t, n) {
    for (var r = t.suspendedLanes, s = t.pingedLanes, h = t.expirationTimes, l = t.pendingLanes; 0 < l; ) {
        var g = 31 - La(l)
          , _ = 1 << g
          , A = h[g];
        A === -1 ? (!(_ & r) || _ & s) && (h[g] = hI(_, n)) : A <= n && (t.expiredLanes |= _),
        l &= ~_
    }
}
function o_(t) {
    return t = t.pendingLanes & -1073741825,
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}
function CT() {
    var t = jp;
    return jp <<= 1,
    !(jp & 4194240) && (jp = 64),
    t
}
function iv(t) {
    for (var n = [], r = 0; 31 > r; r++)
        n.push(t);
    return n
}
function Pf(t, n, r) {
    t.pendingLanes |= n,
    n !== 536870912 && (t.suspendedLanes = 0,
    t.pingedLanes = 0),
    t = t.eventTimes,
    n = 31 - La(n),
    t[n] = r
}
function fI(t, n) {
    var r = t.pendingLanes & ~n;
    t.pendingLanes = n,
    t.suspendedLanes = 0,
    t.pingedLanes = 0,
    t.expiredLanes &= n,
    t.mutableReadLanes &= n,
    t.entangledLanes &= n,
    n = t.entanglements;
    var s = t.eventTimes;
    for (t = t.expirationTimes; 0 < r; ) {
        var h = 31 - La(r)
          , l = 1 << h;
        n[h] = 0,
        s[h] = -1,
        t[h] = -1,
        r &= ~l
    }
}
function dy(t, n) {
    var r = t.entangledLanes |= n;
    for (t = t.entanglements; r; ) {
        var s = 31 - La(r)
          , h = 1 << s;
        h & n | t[s] & n && (t[s] |= n),
        r &= ~h
    }
}
var sr = 0;
function PT(t) {
    return t &= -t,
    1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
}
var RT, fy, DT, LT, IT, a_ = !1, Yp = [], mc = null, gc = null, vc = null, lf = new Map, cf = new Map, hc = [], pI = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function fw(t, n) {
    switch (t) {
    case "focusin":
    case "focusout":
        mc = null;
        break;
    case "dragenter":
    case "dragleave":
        gc = null;
        break;
    case "mouseover":
    case "mouseout":
        vc = null;
        break;
    case "pointerover":
    case "pointerout":
        lf.delete(n.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        cf.delete(n.pointerId)
    }
}
function Pd(t, n, r, s, h, l) {
    return t === null || t.nativeEvent !== l ? (t = {
        blockedOn: n,
        domEventName: r,
        eventSystemFlags: s,
        nativeEvent: l,
        targetContainers: [h]
    },
    n !== null && (n = Df(n),
    n !== null && fy(n)),
    t) : (t.eventSystemFlags |= s,
    n = t.targetContainers,
    h !== null && n.indexOf(h) === -1 && n.push(h),
    t)
}
function mI(t, n, r, s, h) {
    switch (n) {
    case "focusin":
        return mc = Pd(mc, t, n, r, s, h),
        !0;
    case "dragenter":
        return gc = Pd(gc, t, n, r, s, h),
        !0;
    case "mouseover":
        return vc = Pd(vc, t, n, r, s, h),
        !0;
    case "pointerover":
        var l = h.pointerId;
        return lf.set(l, Pd(lf.get(l) || null, t, n, r, s, h)),
        !0;
    case "gotpointercapture":
        return l = h.pointerId,
        cf.set(l, Pd(cf.get(l) || null, t, n, r, s, h)),
        !0
    }
    return !1
}
function OT(t) {
    var n = uu(t.target);
    if (n !== null) {
        var r = Au(n);
        if (r !== null) {
            if (n = r.tag,
            n === 13) {
                if (n = wT(r),
                n !== null) {
                    t.blockedOn = n,
                    IT(t.priority, function() {
                        DT(r)
                    });
                    return
                }
            } else if (n === 3 && r.stateNode.current.memoizedState.isDehydrated) {
                t.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
                return
            }
        }
    }
    t.blockedOn = null
}
function fm(t) {
    if (t.blockedOn !== null)
        return !1;
    for (var n = t.targetContainers; 0 < n.length; ) {
        var r = l_(t.domEventName, t.eventSystemFlags, n[0], t.nativeEvent);
        if (r === null) {
            r = t.nativeEvent;
            var s = new r.constructor(r.type,r);
            n_ = s,
            r.target.dispatchEvent(s),
            n_ = null
        } else
            return n = Df(r),
            n !== null && fy(n),
            t.blockedOn = r,
            !1;
        n.shift()
    }
    return !0
}
function pw(t, n, r) {
    fm(t) && r.delete(n)
}
function gI() {
    a_ = !1,
    mc !== null && fm(mc) && (mc = null),
    gc !== null && fm(gc) && (gc = null),
    vc !== null && fm(vc) && (vc = null),
    lf.forEach(pw),
    cf.forEach(pw)
}
function Rd(t, n) {
    t.blockedOn === n && (t.blockedOn = null,
    a_ || (a_ = !0,
    zo.unstable_scheduleCallback(zo.unstable_NormalPriority, gI)))
}
function uf(t) {
    function n(h) {
        return Rd(h, t)
    }
    if (0 < Yp.length) {
        Rd(Yp[0], t);
        for (var r = 1; r < Yp.length; r++) {
            var s = Yp[r];
            s.blockedOn === t && (s.blockedOn = null)
        }
    }
    for (mc !== null && Rd(mc, t),
    gc !== null && Rd(gc, t),
    vc !== null && Rd(vc, t),
    lf.forEach(n),
    cf.forEach(n),
    r = 0; r < hc.length; r++)
        s = hc[r],
        s.blockedOn === t && (s.blockedOn = null);
    for (; 0 < hc.length && (r = hc[0],
    r.blockedOn === null); )
        OT(r),
        r.blockedOn === null && hc.shift()
}
var bh = Gl.ReactCurrentBatchConfig
  , Dm = !0;
function vI(t, n, r, s) {
    var h = sr
      , l = bh.transition;
    bh.transition = null;
    try {
        sr = 1,
        py(t, n, r, s)
    } finally {
        sr = h,
        bh.transition = l
    }
}
function _I(t, n, r, s) {
    var h = sr
      , l = bh.transition;
    bh.transition = null;
    try {
        sr = 4,
        py(t, n, r, s)
    } finally {
        sr = h,
        bh.transition = l
    }
}
function py(t, n, r, s) {
    if (Dm) {
        var h = l_(t, n, r, s);
        if (h === null)
            fv(t, n, s, Lm, r),
            fw(t, s);
        else if (mI(h, t, n, r, s))
            s.stopPropagation();
        else if (fw(t, s),
        n & 4 && -1 < pI.indexOf(t)) {
            for (; h !== null; ) {
                var l = Df(h);
                if (l !== null && RT(l),
                l = l_(t, n, r, s),
                l === null && fv(t, n, s, Lm, r),
                l === h)
                    break;
                h = l
            }
            h !== null && s.stopPropagation()
        } else
            fv(t, n, s, null, r)
    }
}
var Lm = null;
function l_(t, n, r, s) {
    if (Lm = null,
    t = uy(s),
    t = uu(t),
    t !== null)
        if (n = Au(t),
        n === null)
            t = null;
        else if (r = n.tag,
        r === 13) {
            if (t = wT(n),
            t !== null)
                return t;
            t = null
        } else if (r === 3) {
            if (n.stateNode.current.memoizedState.isDehydrated)
                return n.tag === 3 ? n.stateNode.containerInfo : null;
            t = null
        } else
            n !== t && (t = null);
    return Lm = t,
    null
}
function BT(t) {
    switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (sI()) {
        case hy:
            return 1;
        case ET:
            return 4;
        case Pm:
        case oI:
            return 16;
        case MT:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var fc = null
  , my = null
  , pm = null;
function FT() {
    if (pm)
        return pm;
    var t, n = my, r = n.length, s, h = "value"in fc ? fc.value : fc.textContent, l = h.length;
    for (t = 0; t < r && n[t] === h[t]; t++)
        ;
    var g = r - t;
    for (s = 1; s <= g && n[r - s] === h[l - s]; s++)
        ;
    return pm = h.slice(t, 1 < s ? 1 - s : void 0)
}
function mm(t) {
    var n = t.keyCode;
    return "charCode"in t ? (t = t.charCode,
    t === 0 && n === 13 && (t = 13)) : t = n,
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
}
function Qp() {
    return !0
}
function mw() {
    return !1
}
function Vo(t) {
    function n(r, s, h, l, g) {
        this._reactName = r,
        this._targetInst = h,
        this.type = s,
        this.nativeEvent = l,
        this.target = g,
        this.currentTarget = null;
        for (var _ in t)
            t.hasOwnProperty(_) && (r = t[_],
            this[_] = r ? r(l) : l[_]);
        return this.isDefaultPrevented = (l.defaultPrevented != null ? l.defaultPrevented : l.returnValue === !1) ? Qp : mw,
        this.isPropagationStopped = mw,
        this
    }
    return Br(n.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var r = this.nativeEvent;
            r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1),
            this.isDefaultPrevented = Qp)
        },
        stopPropagation: function() {
            var r = this.nativeEvent;
            r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0),
            this.isPropagationStopped = Qp)
        },
        persist: function() {},
        isPersistent: Qp
    }),
    n
}
var Bh = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(t) {
        return t.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, gy = Vo(Bh), Rf = Br({}, Bh, {
    view: 0,
    detail: 0
}), yI = Vo(Rf), rv, sv, Dd, og = Br({}, Rf, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: vy,
    button: 0,
    buttons: 0,
    relatedTarget: function(t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
    },
    movementX: function(t) {
        return "movementX"in t ? t.movementX : (t !== Dd && (Dd && t.type === "mousemove" ? (rv = t.screenX - Dd.screenX,
        sv = t.screenY - Dd.screenY) : sv = rv = 0,
        Dd = t),
        rv)
    },
    movementY: function(t) {
        return "movementY"in t ? t.movementY : sv
    }
}), gw = Vo(og), xI = Br({}, og, {
    dataTransfer: 0
}), bI = Vo(xI), wI = Br({}, Rf, {
    relatedTarget: 0
}), ov = Vo(wI), AI = Br({}, Bh, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), SI = Vo(AI), TI = Br({}, Bh, {
    clipboardData: function(t) {
        return "clipboardData"in t ? t.clipboardData : window.clipboardData
    }
}), EI = Vo(TI), MI = Br({}, Bh, {
    data: 0
}), vw = Vo(MI), CI = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, PI = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, RI = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function DI(t) {
    var n = this.nativeEvent;
    return n.getModifierState ? n.getModifierState(t) : (t = RI[t]) ? !!n[t] : !1
}
function vy() {
    return DI
}
var LI = Br({}, Rf, {
    key: function(t) {
        if (t.key) {
            var n = CI[t.key] || t.key;
            if (n !== "Unidentified")
                return n
        }
        return t.type === "keypress" ? (t = mm(t),
        t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? PI[t.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: vy,
    charCode: function(t) {
        return t.type === "keypress" ? mm(t) : 0
    },
    keyCode: function(t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    },
    which: function(t) {
        return t.type === "keypress" ? mm(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    }
})
  , II = Vo(LI)
  , OI = Br({}, og, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , _w = Vo(OI)
  , BI = Br({}, Rf, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: vy
})
  , FI = Vo(BI)
  , kI = Br({}, Bh, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , UI = Vo(kI)
  , NI = Br({}, og, {
    deltaX: function(t) {
        return "deltaX"in t ? t.deltaX : "wheelDeltaX"in t ? -t.wheelDeltaX : 0
    },
    deltaY: function(t) {
        return "deltaY"in t ? t.deltaY : "wheelDeltaY"in t ? -t.wheelDeltaY : "wheelDelta"in t ? -t.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , zI = Vo(NI)
  , GI = [9, 13, 27, 32]
  , _y = kl && "CompositionEvent"in window
  , Xd = null;
kl && "documentMode"in document && (Xd = document.documentMode);
var HI = kl && "TextEvent"in window && !Xd
  , kT = kl && (!_y || Xd && 8 < Xd && 11 >= Xd)
  , yw = String.fromCharCode(32)
  , xw = !1;
function UT(t, n) {
    switch (t) {
    case "keyup":
        return GI.indexOf(n.keyCode) !== -1;
    case "keydown":
        return n.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function NT(t) {
    return t = t.detail,
    typeof t == "object" && "data"in t ? t.data : null
}
var rh = !1;
function VI(t, n) {
    switch (t) {
    case "compositionend":
        return NT(n);
    case "keypress":
        return n.which !== 32 ? null : (xw = !0,
        yw);
    case "textInput":
        return t = n.data,
        t === yw && xw ? null : t;
    default:
        return null
    }
}
function WI(t, n) {
    if (rh)
        return t === "compositionend" || !_y && UT(t, n) ? (t = FT(),
        pm = my = fc = null,
        rh = !1,
        t) : null;
    switch (t) {
    case "paste":
        return null;
    case "keypress":
        if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) {
            if (n.char && 1 < n.char.length)
                return n.char;
            if (n.which)
                return String.fromCharCode(n.which)
        }
        return null;
    case "compositionend":
        return kT && n.locale !== "ko" ? null : n.data;
    default:
        return null
    }
}
var jI = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function bw(t) {
    var n = t && t.nodeName && t.nodeName.toLowerCase();
    return n === "input" ? !!jI[t.type] : n === "textarea"
}
function zT(t, n, r, s) {
    vT(s),
    n = Im(n, "onChange"),
    0 < n.length && (r = new gy("onChange","change",null,r,s),
    t.push({
        event: r,
        listeners: n
    }))
}
var Yd = null
  , hf = null;
function XI(t) {
    qT(t, 0)
}
function ag(t) {
    var n = ah(t);
    if (uT(n))
        return t
}
function YI(t, n) {
    if (t === "change")
        return n
}
var GT = !1;
if (kl) {
    var av;
    if (kl) {
        var lv = "oninput"in document;
        if (!lv) {
            var ww = document.createElement("div");
            ww.setAttribute("oninput", "return;"),
            lv = typeof ww.oninput == "function"
        }
        av = lv
    } else
        av = !1;
    GT = av && (!document.documentMode || 9 < document.documentMode)
}
function Aw() {
    Yd && (Yd.detachEvent("onpropertychange", HT),
    hf = Yd = null)
}
function HT(t) {
    if (t.propertyName === "value" && ag(hf)) {
        var n = [];
        zT(n, hf, t, uy(t)),
        bT(XI, n)
    }
}
function QI(t, n, r) {
    t === "focusin" ? (Aw(),
    Yd = n,
    hf = r,
    Yd.attachEvent("onpropertychange", HT)) : t === "focusout" && Aw()
}
function KI(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return ag(hf)
}
function ZI(t, n) {
    if (t === "click")
        return ag(n)
}
function qI(t, n) {
    if (t === "input" || t === "change")
        return ag(n)
}
function JI(t, n) {
    return t === n && (t !== 0 || 1 / t === 1 / n) || t !== t && n !== n
}
var Oa = typeof Object.is == "function" ? Object.is : JI;
function df(t, n) {
    if (Oa(t, n))
        return !0;
    if (typeof t != "object" || t === null || typeof n != "object" || n === null)
        return !1;
    var r = Object.keys(t)
      , s = Object.keys(n);
    if (r.length !== s.length)
        return !1;
    for (s = 0; s < r.length; s++) {
        var h = r[s];
        if (!Wv.call(n, h) || !Oa(t[h], n[h]))
            return !1
    }
    return !0
}
function Sw(t) {
    for (; t && t.firstChild; )
        t = t.firstChild;
    return t
}
function Tw(t, n) {
    var r = Sw(t);
    t = 0;
    for (var s; r; ) {
        if (r.nodeType === 3) {
            if (s = t + r.textContent.length,
            t <= n && s >= n)
                return {
                    node: r,
                    offset: n - t
                };
            t = s
        }
        e: {
            for (; r; ) {
                if (r.nextSibling) {
                    r = r.nextSibling;
                    break e
                }
                r = r.parentNode
            }
            r = void 0
        }
        r = Sw(r)
    }
}
function VT(t, n) {
    return t && n ? t === n ? !0 : t && t.nodeType === 3 ? !1 : n && n.nodeType === 3 ? VT(t, n.parentNode) : "contains"in t ? t.contains(n) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(n) & 16) : !1 : !1
}
function WT() {
    for (var t = window, n = Em(); n instanceof t.HTMLIFrameElement; ) {
        try {
            var r = typeof n.contentWindow.location.href == "string"
        } catch {
            r = !1
        }
        if (r)
            t = n.contentWindow;
        else
            break;
        n = Em(t.document)
    }
    return n
}
function yy(t) {
    var n = t && t.nodeName && t.nodeName.toLowerCase();
    return n && (n === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || n === "textarea" || t.contentEditable === "true")
}
function $I(t) {
    var n = WT()
      , r = t.focusedElem
      , s = t.selectionRange;
    if (n !== r && r && r.ownerDocument && VT(r.ownerDocument.documentElement, r)) {
        if (s !== null && yy(r)) {
            if (n = s.start,
            t = s.end,
            t === void 0 && (t = n),
            "selectionStart"in r)
                r.selectionStart = n,
                r.selectionEnd = Math.min(t, r.value.length);
            else if (t = (n = r.ownerDocument || document) && n.defaultView || window,
            t.getSelection) {
                t = t.getSelection();
                var h = r.textContent.length
                  , l = Math.min(s.start, h);
                s = s.end === void 0 ? l : Math.min(s.end, h),
                !t.extend && l > s && (h = s,
                s = l,
                l = h),
                h = Tw(r, l);
                var g = Tw(r, s);
                h && g && (t.rangeCount !== 1 || t.anchorNode !== h.node || t.anchorOffset !== h.offset || t.focusNode !== g.node || t.focusOffset !== g.offset) && (n = n.createRange(),
                n.setStart(h.node, h.offset),
                t.removeAllRanges(),
                l > s ? (t.addRange(n),
                t.extend(g.node, g.offset)) : (n.setEnd(g.node, g.offset),
                t.addRange(n)))
            }
        }
        for (n = [],
        t = r; t = t.parentNode; )
            t.nodeType === 1 && n.push({
                element: t,
                left: t.scrollLeft,
                top: t.scrollTop
            });
        for (typeof r.focus == "function" && r.focus(),
        r = 0; r < n.length; r++)
            t = n[r],
            t.element.scrollLeft = t.left,
            t.element.scrollTop = t.top
    }
}
var e3 = kl && "documentMode"in document && 11 >= document.documentMode
  , sh = null
  , c_ = null
  , Qd = null
  , u_ = !1;
function Ew(t, n, r) {
    var s = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
    u_ || sh == null || sh !== Em(s) || (s = sh,
    "selectionStart"in s && yy(s) ? s = {
        start: s.selectionStart,
        end: s.selectionEnd
    } : (s = (s.ownerDocument && s.ownerDocument.defaultView || window).getSelection(),
    s = {
        anchorNode: s.anchorNode,
        anchorOffset: s.anchorOffset,
        focusNode: s.focusNode,
        focusOffset: s.focusOffset
    }),
    Qd && df(Qd, s) || (Qd = s,
    s = Im(c_, "onSelect"),
    0 < s.length && (n = new gy("onSelect","select",null,n,r),
    t.push({
        event: n,
        listeners: s
    }),
    n.target = sh)))
}
function Kp(t, n) {
    var r = {};
    return r[t.toLowerCase()] = n.toLowerCase(),
    r["Webkit" + t] = "webkit" + n,
    r["Moz" + t] = "moz" + n,
    r
}
var oh = {
    animationend: Kp("Animation", "AnimationEnd"),
    animationiteration: Kp("Animation", "AnimationIteration"),
    animationstart: Kp("Animation", "AnimationStart"),
    transitionend: Kp("Transition", "TransitionEnd")
}
  , cv = {}
  , jT = {};
kl && (jT = document.createElement("div").style,
"AnimationEvent"in window || (delete oh.animationend.animation,
delete oh.animationiteration.animation,
delete oh.animationstart.animation),
"TransitionEvent"in window || delete oh.transitionend.transition);
function lg(t) {
    if (cv[t])
        return cv[t];
    if (!oh[t])
        return t;
    var n = oh[t], r;
    for (r in n)
        if (n.hasOwnProperty(r) && r in jT)
            return cv[t] = n[r];
    return t
}
var XT = lg("animationend")
  , YT = lg("animationiteration")
  , QT = lg("animationstart")
  , KT = lg("transitionend")
  , ZT = new Map
  , Mw = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function Rc(t, n) {
    ZT.set(t, n),
    wu(n, [t])
}
for (var uv = 0; uv < Mw.length; uv++) {
    var hv = Mw[uv]
      , t3 = hv.toLowerCase()
      , n3 = hv[0].toUpperCase() + hv.slice(1);
    Rc(t3, "on" + n3)
}
Rc(XT, "onAnimationEnd");
Rc(YT, "onAnimationIteration");
Rc(QT, "onAnimationStart");
Rc("dblclick", "onDoubleClick");
Rc("focusin", "onFocus");
Rc("focusout", "onBlur");
Rc(KT, "onTransitionEnd");
Th("onMouseEnter", ["mouseout", "mouseover"]);
Th("onMouseLeave", ["mouseout", "mouseover"]);
Th("onPointerEnter", ["pointerout", "pointerover"]);
Th("onPointerLeave", ["pointerout", "pointerover"]);
wu("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
wu("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
wu("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
wu("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
wu("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
wu("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Hd = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , i3 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Hd));
function Cw(t, n, r) {
    var s = t.type || "unknown-event";
    t.currentTarget = r,
    tI(s, n, void 0, t),
    t.currentTarget = null
}
function qT(t, n) {
    n = (n & 4) !== 0;
    for (var r = 0; r < t.length; r++) {
        var s = t[r]
          , h = s.event;
        s = s.listeners;
        e: {
            var l = void 0;
            if (n)
                for (var g = s.length - 1; 0 <= g; g--) {
                    var _ = s[g]
                      , A = _.instance
                      , m = _.currentTarget;
                    if (_ = _.listener,
                    A !== l && h.isPropagationStopped())
                        break e;
                    Cw(h, _, m),
                    l = A
                }
            else
                for (g = 0; g < s.length; g++) {
                    if (_ = s[g],
                    A = _.instance,
                    m = _.currentTarget,
                    _ = _.listener,
                    A !== l && h.isPropagationStopped())
                        break e;
                    Cw(h, _, m),
                    l = A
                }
        }
    }
    if (Cm)
        throw t = s_,
        Cm = !1,
        s_ = null,
        t
}
function br(t, n) {
    var r = n[m_];
    r === void 0 && (r = n[m_] = new Set);
    var s = t + "__bubble";
    r.has(s) || (JT(n, t, 2, !1),
    r.add(s))
}
function dv(t, n, r) {
    var s = 0;
    n && (s |= 4),
    JT(r, t, s, n)
}
var Zp = "_reactListening" + Math.random().toString(36).slice(2);
function ff(t) {
    if (!t[Zp]) {
        t[Zp] = !0,
        sT.forEach(function(r) {
            r !== "selectionchange" && (i3.has(r) || dv(r, !1, t),
            dv(r, !0, t))
        });
        var n = t.nodeType === 9 ? t : t.ownerDocument;
        n === null || n[Zp] || (n[Zp] = !0,
        dv("selectionchange", !1, n))
    }
}
function JT(t, n, r, s) {
    switch (BT(n)) {
    case 1:
        var h = vI;
        break;
    case 4:
        h = _I;
        break;
    default:
        h = py
    }
    r = h.bind(null, n, r, t),
    h = void 0,
    !r_ || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (h = !0),
    s ? h !== void 0 ? t.addEventListener(n, r, {
        capture: !0,
        passive: h
    }) : t.addEventListener(n, r, !0) : h !== void 0 ? t.addEventListener(n, r, {
        passive: h
    }) : t.addEventListener(n, r, !1)
}
function fv(t, n, r, s, h) {
    var l = s;
    if (!(n & 1) && !(n & 2) && s !== null)
        e: for (; ; ) {
            if (s === null)
                return;
            var g = s.tag;
            if (g === 3 || g === 4) {
                var _ = s.stateNode.containerInfo;
                if (_ === h || _.nodeType === 8 && _.parentNode === h)
                    break;
                if (g === 4)
                    for (g = s.return; g !== null; ) {
                        var A = g.tag;
                        if ((A === 3 || A === 4) && (A = g.stateNode.containerInfo,
                        A === h || A.nodeType === 8 && A.parentNode === h))
                            return;
                        g = g.return
                    }
                for (; _ !== null; ) {
                    if (g = uu(_),
                    g === null)
                        return;
                    if (A = g.tag,
                    A === 5 || A === 6) {
                        s = l = g;
                        continue e
                    }
                    _ = _.parentNode
                }
            }
            s = s.return
        }
    bT(function() {
        var m = l
          , D = uy(r)
          , U = [];
        e: {
            var R = ZT.get(t);
            if (R !== void 0) {
                var ne = gy
                  , ce = t;
                switch (t) {
                case "keypress":
                    if (mm(r) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    ne = II;
                    break;
                case "focusin":
                    ce = "focus",
                    ne = ov;
                    break;
                case "focusout":
                    ce = "blur",
                    ne = ov;
                    break;
                case "beforeblur":
                case "afterblur":
                    ne = ov;
                    break;
                case "click":
                    if (r.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    ne = gw;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    ne = bI;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    ne = FI;
                    break;
                case XT:
                case YT:
                case QT:
                    ne = SI;
                    break;
                case KT:
                    ne = UI;
                    break;
                case "scroll":
                    ne = yI;
                    break;
                case "wheel":
                    ne = zI;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    ne = EI;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    ne = _w
                }
                var xe = (n & 4) !== 0
                  , Se = !xe && t === "scroll"
                  , $ = xe ? R !== null ? R + "Capture" : null : R;
                xe = [];
                for (var q = m, N; q !== null; ) {
                    N = q;
                    var ie = N.stateNode;
                    if (N.tag === 5 && ie !== null && (N = ie,
                    $ !== null && (ie = af(q, $),
                    ie != null && xe.push(pf(q, ie, N)))),
                    Se)
                        break;
                    q = q.return
                }
                0 < xe.length && (R = new ne(R,ce,null,r,D),
                U.push({
                    event: R,
                    listeners: xe
                }))
            }
        }
        if (!(n & 7)) {
            e: {
                if (R = t === "mouseover" || t === "pointerover",
                ne = t === "mouseout" || t === "pointerout",
                R && r !== n_ && (ce = r.relatedTarget || r.fromElement) && (uu(ce) || ce[Ul]))
                    break e;
                if ((ne || R) && (R = D.window === D ? D : (R = D.ownerDocument) ? R.defaultView || R.parentWindow : window,
                ne ? (ce = r.relatedTarget || r.toElement,
                ne = m,
                ce = ce ? uu(ce) : null,
                ce !== null && (Se = Au(ce),
                ce !== Se || ce.tag !== 5 && ce.tag !== 6) && (ce = null)) : (ne = null,
                ce = m),
                ne !== ce)) {
                    if (xe = gw,
                    ie = "onMouseLeave",
                    $ = "onMouseEnter",
                    q = "mouse",
                    (t === "pointerout" || t === "pointerover") && (xe = _w,
                    ie = "onPointerLeave",
                    $ = "onPointerEnter",
                    q = "pointer"),
                    Se = ne == null ? R : ah(ne),
                    N = ce == null ? R : ah(ce),
                    R = new xe(ie,q + "leave",ne,r,D),
                    R.target = Se,
                    R.relatedTarget = N,
                    ie = null,
                    uu(D) === m && (xe = new xe($,q + "enter",ce,r,D),
                    xe.target = N,
                    xe.relatedTarget = Se,
                    ie = xe),
                    Se = ie,
                    ne && ce)
                        t: {
                            for (xe = ne,
                            $ = ce,
                            q = 0,
                            N = xe; N; N = qu(N))
                                q++;
                            for (N = 0,
                            ie = $; ie; ie = qu(ie))
                                N++;
                            for (; 0 < q - N; )
                                xe = qu(xe),
                                q--;
                            for (; 0 < N - q; )
                                $ = qu($),
                                N--;
                            for (; q--; ) {
                                if (xe === $ || $ !== null && xe === $.alternate)
                                    break t;
                                xe = qu(xe),
                                $ = qu($)
                            }
                            xe = null
                        }
                    else
                        xe = null;
                    ne !== null && Pw(U, R, ne, xe, !1),
                    ce !== null && Se !== null && Pw(U, Se, ce, xe, !0)
                }
            }
            e: {
                if (R = m ? ah(m) : window,
                ne = R.nodeName && R.nodeName.toLowerCase(),
                ne === "select" || ne === "input" && R.type === "file")
                    var _e = YI;
                else if (bw(R))
                    if (GT)
                        _e = qI;
                    else {
                        _e = KI;
                        var Pe = QI
                    }
                else
                    (ne = R.nodeName) && ne.toLowerCase() === "input" && (R.type === "checkbox" || R.type === "radio") && (_e = ZI);
                if (_e && (_e = _e(t, m))) {
                    zT(U, _e, r, D);
                    break e
                }
                Pe && Pe(t, R, m),
                t === "focusout" && (Pe = R._wrapperState) && Pe.controlled && R.type === "number" && qv(R, "number", R.value)
            }
            switch (Pe = m ? ah(m) : window,
            t) {
            case "focusin":
                (bw(Pe) || Pe.contentEditable === "true") && (sh = Pe,
                c_ = m,
                Qd = null);
                break;
            case "focusout":
                Qd = c_ = sh = null;
                break;
            case "mousedown":
                u_ = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                u_ = !1,
                Ew(U, r, D);
                break;
            case "selectionchange":
                if (e3)
                    break;
            case "keydown":
            case "keyup":
                Ew(U, r, D)
            }
            var Be;
            if (_y)
                e: {
                    switch (t) {
                    case "compositionstart":
                        var Re = "onCompositionStart";
                        break e;
                    case "compositionend":
                        Re = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        Re = "onCompositionUpdate";
                        break e
                    }
                    Re = void 0
                }
            else
                rh ? UT(t, r) && (Re = "onCompositionEnd") : t === "keydown" && r.keyCode === 229 && (Re = "onCompositionStart");
            Re && (kT && r.locale !== "ko" && (rh || Re !== "onCompositionStart" ? Re === "onCompositionEnd" && rh && (Be = FT()) : (fc = D,
            my = "value"in fc ? fc.value : fc.textContent,
            rh = !0)),
            Pe = Im(m, Re),
            0 < Pe.length && (Re = new vw(Re,t,null,r,D),
            U.push({
                event: Re,
                listeners: Pe
            }),
            Be ? Re.data = Be : (Be = NT(r),
            Be !== null && (Re.data = Be)))),
            (Be = HI ? VI(t, r) : WI(t, r)) && (m = Im(m, "onBeforeInput"),
            0 < m.length && (D = new vw("onBeforeInput","beforeinput",null,r,D),
            U.push({
                event: D,
                listeners: m
            }),
            D.data = Be))
        }
        qT(U, n)
    })
}
function pf(t, n, r) {
    return {
        instance: t,
        listener: n,
        currentTarget: r
    }
}
function Im(t, n) {
    for (var r = n + "Capture", s = []; t !== null; ) {
        var h = t
          , l = h.stateNode;
        h.tag === 5 && l !== null && (h = l,
        l = af(t, r),
        l != null && s.unshift(pf(t, l, h)),
        l = af(t, n),
        l != null && s.push(pf(t, l, h))),
        t = t.return
    }
    return s
}
function qu(t) {
    if (t === null)
        return null;
    do
        t = t.return;
    while (t && t.tag !== 5);
    return t || null
}
function Pw(t, n, r, s, h) {
    for (var l = n._reactName, g = []; r !== null && r !== s; ) {
        var _ = r
          , A = _.alternate
          , m = _.stateNode;
        if (A !== null && A === s)
            break;
        _.tag === 5 && m !== null && (_ = m,
        h ? (A = af(r, l),
        A != null && g.unshift(pf(r, A, _))) : h || (A = af(r, l),
        A != null && g.push(pf(r, A, _)))),
        r = r.return
    }
    g.length !== 0 && t.push({
        event: n,
        listeners: g
    })
}
var r3 = /\r\n?/g
  , s3 = /\u0000|\uFFFD/g;
function Rw(t) {
    return (typeof t == "string" ? t : "" + t).replace(r3, `
`).replace(s3, "")
}
function qp(t, n, r) {
    if (n = Rw(n),
    Rw(t) !== n && r)
        throw Error(Ct(425))
}
function Om() {}
var h_ = null
  , d_ = null;
function f_(t, n) {
    return t === "textarea" || t === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null
}
var p_ = typeof setTimeout == "function" ? setTimeout : void 0
  , o3 = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Dw = typeof Promise == "function" ? Promise : void 0
  , a3 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Dw < "u" ? function(t) {
    return Dw.resolve(null).then(t).catch(l3)
}
: p_;
function l3(t) {
    setTimeout(function() {
        throw t
    })
}
function pv(t, n) {
    var r = n
      , s = 0;
    do {
        var h = r.nextSibling;
        if (t.removeChild(r),
        h && h.nodeType === 8)
            if (r = h.data,
            r === "/$") {
                if (s === 0) {
                    t.removeChild(h),
                    uf(n);
                    return
                }
                s--
            } else
                r !== "$" && r !== "$?" && r !== "$!" || s++;
        r = h
    } while (r);
    uf(n)
}
function _c(t) {
    for (; t != null; t = t.nextSibling) {
        var n = t.nodeType;
        if (n === 1 || n === 3)
            break;
        if (n === 8) {
            if (n = t.data,
            n === "$" || n === "$!" || n === "$?")
                break;
            if (n === "/$")
                return null
        }
    }
    return t
}
function Lw(t) {
    t = t.previousSibling;
    for (var n = 0; t; ) {
        if (t.nodeType === 8) {
            var r = t.data;
            if (r === "$" || r === "$!" || r === "$?") {
                if (n === 0)
                    return t;
                n--
            } else
                r === "/$" && n++
        }
        t = t.previousSibling
    }
    return null
}
var Fh = Math.random().toString(36).slice(2)
  , qa = "__reactFiber$" + Fh
  , mf = "__reactProps$" + Fh
  , Ul = "__reactContainer$" + Fh
  , m_ = "__reactEvents$" + Fh
  , c3 = "__reactListeners$" + Fh
  , u3 = "__reactHandles$" + Fh;
function uu(t) {
    var n = t[qa];
    if (n)
        return n;
    for (var r = t.parentNode; r; ) {
        if (n = r[Ul] || r[qa]) {
            if (r = n.alternate,
            n.child !== null || r !== null && r.child !== null)
                for (t = Lw(t); t !== null; ) {
                    if (r = t[qa])
                        return r;
                    t = Lw(t)
                }
            return n
        }
        t = r,
        r = t.parentNode
    }
    return null
}
function Df(t) {
    return t = t[qa] || t[Ul],
    !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}
function ah(t) {
    if (t.tag === 5 || t.tag === 6)
        return t.stateNode;
    throw Error(Ct(33))
}
function cg(t) {
    return t[mf] || null
}
var g_ = []
  , lh = -1;
function Dc(t) {
    return {
        current: t
    }
}
function wr(t) {
    0 > lh || (t.current = g_[lh],
    g_[lh] = null,
    lh--)
}
function gr(t, n) {
    lh++,
    g_[lh] = t.current,
    t.current = n
}
var Tc = {}
  , qs = Dc(Tc)
  , yo = Dc(!1)
  , vu = Tc;
function Eh(t, n) {
    var r = t.type.contextTypes;
    if (!r)
        return Tc;
    var s = t.stateNode;
    if (s && s.__reactInternalMemoizedUnmaskedChildContext === n)
        return s.__reactInternalMemoizedMaskedChildContext;
    var h = {}, l;
    for (l in r)
        h[l] = n[l];
    return s && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = n,
    t.__reactInternalMemoizedMaskedChildContext = h),
    h
}
function xo(t) {
    return t = t.childContextTypes,
    t != null
}
function Bm() {
    wr(yo),
    wr(qs)
}
function Iw(t, n, r) {
    if (qs.current !== Tc)
        throw Error(Ct(168));
    gr(qs, n),
    gr(yo, r)
}
function $T(t, n, r) {
    var s = t.stateNode;
    if (n = n.childContextTypes,
    typeof s.getChildContext != "function")
        return r;
    s = s.getChildContext();
    for (var h in s)
        if (!(h in n))
            throw Error(Ct(108, QL(t) || "Unknown", h));
    return Br({}, r, s)
}
function Fm(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Tc,
    vu = qs.current,
    gr(qs, t),
    gr(yo, yo.current),
    !0
}
function Ow(t, n, r) {
    var s = t.stateNode;
    if (!s)
        throw Error(Ct(169));
    r ? (t = $T(t, n, vu),
    s.__reactInternalMemoizedMergedChildContext = t,
    wr(yo),
    wr(qs),
    gr(qs, t)) : wr(yo),
    gr(yo, r)
}
var Cl = null
  , ug = !1
  , mv = !1;
function eE(t) {
    Cl === null ? Cl = [t] : Cl.push(t)
}
function h3(t) {
    ug = !0,
    eE(t)
}
function Lc() {
    if (!mv && Cl !== null) {
        mv = !0;
        var t = 0
          , n = sr;
        try {
            var r = Cl;
            for (sr = 1; t < r.length; t++) {
                var s = r[t];
                do
                    s = s(!0);
                while (s !== null)
            }
            Cl = null,
            ug = !1
        } catch (h) {
            throw Cl !== null && (Cl = Cl.slice(t + 1)),
            TT(hy, Lc),
            h
        } finally {
            sr = n,
            mv = !1
        }
    }
    return null
}
var ch = []
  , uh = 0
  , km = null
  , Um = 0
  , ia = []
  , ra = 0
  , _u = null
  , Pl = 1
  , Rl = "";
function su(t, n) {
    ch[uh++] = Um,
    ch[uh++] = km,
    km = t,
    Um = n
}
function tE(t, n, r) {
    ia[ra++] = Pl,
    ia[ra++] = Rl,
    ia[ra++] = _u,
    _u = t;
    var s = Pl;
    t = Rl;
    var h = 32 - La(s) - 1;
    s &= ~(1 << h),
    r += 1;
    var l = 32 - La(n) + h;
    if (30 < l) {
        var g = h - h % 5;
        l = (s & (1 << g) - 1).toString(32),
        s >>= g,
        h -= g,
        Pl = 1 << 32 - La(n) + h | r << h | s,
        Rl = l + t
    } else
        Pl = 1 << l | r << h | s,
        Rl = t
}
function xy(t) {
    t.return !== null && (su(t, 1),
    tE(t, 1, 0))
}
function by(t) {
    for (; t === km; )
        km = ch[--uh],
        ch[uh] = null,
        Um = ch[--uh],
        ch[uh] = null;
    for (; t === _u; )
        _u = ia[--ra],
        ia[ra] = null,
        Rl = ia[--ra],
        ia[ra] = null,
        Pl = ia[--ra],
        ia[ra] = null
}
var No = null
  , Uo = null
  , Sr = !1
  , Ra = null;
function nE(t, n) {
    var r = oa(5, null, null, 0);
    r.elementType = "DELETED",
    r.stateNode = n,
    r.return = t,
    n = t.deletions,
    n === null ? (t.deletions = [r],
    t.flags |= 16) : n.push(r)
}
function Bw(t, n) {
    switch (t.tag) {
    case 5:
        var r = t.type;
        return n = n.nodeType !== 1 || r.toLowerCase() !== n.nodeName.toLowerCase() ? null : n,
        n !== null ? (t.stateNode = n,
        No = t,
        Uo = _c(n.firstChild),
        !0) : !1;
    case 6:
        return n = t.pendingProps === "" || n.nodeType !== 3 ? null : n,
        n !== null ? (t.stateNode = n,
        No = t,
        Uo = null,
        !0) : !1;
    case 13:
        return n = n.nodeType !== 8 ? null : n,
        n !== null ? (r = _u !== null ? {
            id: Pl,
            overflow: Rl
        } : null,
        t.memoizedState = {
            dehydrated: n,
            treeContext: r,
            retryLane: 1073741824
        },
        r = oa(18, null, null, 0),
        r.stateNode = n,
        r.return = t,
        t.child = r,
        No = t,
        Uo = null,
        !0) : !1;
    default:
        return !1
    }
}
function v_(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}
function __(t) {
    if (Sr) {
        var n = Uo;
        if (n) {
            var r = n;
            if (!Bw(t, n)) {
                if (v_(t))
                    throw Error(Ct(418));
                n = _c(r.nextSibling);
                var s = No;
                n && Bw(t, n) ? nE(s, r) : (t.flags = t.flags & -4097 | 2,
                Sr = !1,
                No = t)
            }
        } else {
            if (v_(t))
                throw Error(Ct(418));
            t.flags = t.flags & -4097 | 2,
            Sr = !1,
            No = t
        }
    }
}
function Fw(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
        t = t.return;
    No = t
}
function Jp(t) {
    if (t !== No)
        return !1;
    if (!Sr)
        return Fw(t),
        Sr = !0,
        !1;
    var n;
    if ((n = t.tag !== 3) && !(n = t.tag !== 5) && (n = t.type,
    n = n !== "head" && n !== "body" && !f_(t.type, t.memoizedProps)),
    n && (n = Uo)) {
        if (v_(t))
            throw iE(),
            Error(Ct(418));
        for (; n; )
            nE(t, n),
            n = _c(n.nextSibling)
    }
    if (Fw(t),
    t.tag === 13) {
        if (t = t.memoizedState,
        t = t !== null ? t.dehydrated : null,
        !t)
            throw Error(Ct(317));
        e: {
            for (t = t.nextSibling,
            n = 0; t; ) {
                if (t.nodeType === 8) {
                    var r = t.data;
                    if (r === "/$") {
                        if (n === 0) {
                            Uo = _c(t.nextSibling);
                            break e
                        }
                        n--
                    } else
                        r !== "$" && r !== "$!" && r !== "$?" || n++
                }
                t = t.nextSibling
            }
            Uo = null
        }
    } else
        Uo = No ? _c(t.stateNode.nextSibling) : null;
    return !0
}
function iE() {
    for (var t = Uo; t; )
        t = _c(t.nextSibling)
}
function Mh() {
    Uo = No = null,
    Sr = !1
}
function wy(t) {
    Ra === null ? Ra = [t] : Ra.push(t)
}
var d3 = Gl.ReactCurrentBatchConfig;
function Ca(t, n) {
    if (t && t.defaultProps) {
        n = Br({}, n),
        t = t.defaultProps;
        for (var r in t)
            n[r] === void 0 && (n[r] = t[r]);
        return n
    }
    return n
}
var Nm = Dc(null)
  , zm = null
  , hh = null
  , Ay = null;
function Sy() {
    Ay = hh = zm = null
}
function Ty(t) {
    var n = Nm.current;
    wr(Nm),
    t._currentValue = n
}
function y_(t, n, r) {
    for (; t !== null; ) {
        var s = t.alternate;
        if ((t.childLanes & n) !== n ? (t.childLanes |= n,
        s !== null && (s.childLanes |= n)) : s !== null && (s.childLanes & n) !== n && (s.childLanes |= n),
        t === r)
            break;
        t = t.return
    }
}
function wh(t, n) {
    zm = t,
    Ay = hh = null,
    t = t.dependencies,
    t !== null && t.firstContext !== null && (t.lanes & n && (_o = !0),
    t.firstContext = null)
}
function la(t) {
    var n = t._currentValue;
    if (Ay !== t)
        if (t = {
            context: t,
            memoizedValue: n,
            next: null
        },
        hh === null) {
            if (zm === null)
                throw Error(Ct(308));
            hh = t,
            zm.dependencies = {
                lanes: 0,
                firstContext: t
            }
        } else
            hh = hh.next = t;
    return n
}
var hu = null;
function Ey(t) {
    hu === null ? hu = [t] : hu.push(t)
}
function rE(t, n, r, s) {
    var h = n.interleaved;
    return h === null ? (r.next = r,
    Ey(n)) : (r.next = h.next,
    h.next = r),
    n.interleaved = r,
    Nl(t, s)
}
function Nl(t, n) {
    t.lanes |= n;
    var r = t.alternate;
    for (r !== null && (r.lanes |= n),
    r = t,
    t = t.return; t !== null; )
        t.childLanes |= n,
        r = t.alternate,
        r !== null && (r.childLanes |= n),
        r = t,
        t = t.return;
    return r.tag === 3 ? r.stateNode : null
}
var cc = !1;
function My(t) {
    t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function sE(t, n) {
    t = t.updateQueue,
    n.updateQueue === t && (n.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects
    })
}
function Ll(t, n) {
    return {
        eventTime: t,
        lane: n,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function yc(t, n, r) {
    var s = t.updateQueue;
    if (s === null)
        return null;
    if (s = s.shared,
    Yi & 2) {
        var h = s.pending;
        return h === null ? n.next = n : (n.next = h.next,
        h.next = n),
        s.pending = n,
        Nl(t, r)
    }
    return h = s.interleaved,
    h === null ? (n.next = n,
    Ey(s)) : (n.next = h.next,
    h.next = n),
    s.interleaved = n,
    Nl(t, r)
}
function gm(t, n, r) {
    if (n = n.updateQueue,
    n !== null && (n = n.shared,
    (r & 4194240) !== 0)) {
        var s = n.lanes;
        s &= t.pendingLanes,
        r |= s,
        n.lanes = r,
        dy(t, r)
    }
}
function kw(t, n) {
    var r = t.updateQueue
      , s = t.alternate;
    if (s !== null && (s = s.updateQueue,
    r === s)) {
        var h = null
          , l = null;
        if (r = r.firstBaseUpdate,
        r !== null) {
            do {
                var g = {
                    eventTime: r.eventTime,
                    lane: r.lane,
                    tag: r.tag,
                    payload: r.payload,
                    callback: r.callback,
                    next: null
                };
                l === null ? h = l = g : l = l.next = g,
                r = r.next
            } while (r !== null);
            l === null ? h = l = n : l = l.next = n
        } else
            h = l = n;
        r = {
            baseState: s.baseState,
            firstBaseUpdate: h,
            lastBaseUpdate: l,
            shared: s.shared,
            effects: s.effects
        },
        t.updateQueue = r;
        return
    }
    t = r.lastBaseUpdate,
    t === null ? r.firstBaseUpdate = n : t.next = n,
    r.lastBaseUpdate = n
}
function Gm(t, n, r, s) {
    var h = t.updateQueue;
    cc = !1;
    var l = h.firstBaseUpdate
      , g = h.lastBaseUpdate
      , _ = h.shared.pending;
    if (_ !== null) {
        h.shared.pending = null;
        var A = _
          , m = A.next;
        A.next = null,
        g === null ? l = m : g.next = m,
        g = A;
        var D = t.alternate;
        D !== null && (D = D.updateQueue,
        _ = D.lastBaseUpdate,
        _ !== g && (_ === null ? D.firstBaseUpdate = m : _.next = m,
        D.lastBaseUpdate = A))
    }
    if (l !== null) {
        var U = h.baseState;
        g = 0,
        D = m = A = null,
        _ = l;
        do {
            var R = _.lane
              , ne = _.eventTime;
            if ((s & R) === R) {
                D !== null && (D = D.next = {
                    eventTime: ne,
                    lane: 0,
                    tag: _.tag,
                    payload: _.payload,
                    callback: _.callback,
                    next: null
                });
                e: {
                    var ce = t
                      , xe = _;
                    switch (R = n,
                    ne = r,
                    xe.tag) {
                    case 1:
                        if (ce = xe.payload,
                        typeof ce == "function") {
                            U = ce.call(ne, U, R);
                            break e
                        }
                        U = ce;
                        break e;
                    case 3:
                        ce.flags = ce.flags & -65537 | 128;
                    case 0:
                        if (ce = xe.payload,
                        R = typeof ce == "function" ? ce.call(ne, U, R) : ce,
                        R == null)
                            break e;
                        U = Br({}, U, R);
                        break e;
                    case 2:
                        cc = !0
                    }
                }
                _.callback !== null && _.lane !== 0 && (t.flags |= 64,
                R = h.effects,
                R === null ? h.effects = [_] : R.push(_))
            } else
                ne = {
                    eventTime: ne,
                    lane: R,
                    tag: _.tag,
                    payload: _.payload,
                    callback: _.callback,
                    next: null
                },
                D === null ? (m = D = ne,
                A = U) : D = D.next = ne,
                g |= R;
            if (_ = _.next,
            _ === null) {
                if (_ = h.shared.pending,
                _ === null)
                    break;
                R = _,
                _ = R.next,
                R.next = null,
                h.lastBaseUpdate = R,
                h.shared.pending = null
            }
        } while (1);
        if (D === null && (A = U),
        h.baseState = A,
        h.firstBaseUpdate = m,
        h.lastBaseUpdate = D,
        n = h.shared.interleaved,
        n !== null) {
            h = n;
            do
                g |= h.lane,
                h = h.next;
            while (h !== n)
        } else
            l === null && (h.shared.lanes = 0);
        xu |= g,
        t.lanes = g,
        t.memoizedState = U
    }
}
function Uw(t, n, r) {
    if (t = n.effects,
    n.effects = null,
    t !== null)
        for (n = 0; n < t.length; n++) {
            var s = t[n]
              , h = s.callback;
            if (h !== null) {
                if (s.callback = null,
                s = r,
                typeof h != "function")
                    throw Error(Ct(191, h));
                h.call(s)
            }
        }
}
var oE = new rT.Component().refs;
function x_(t, n, r, s) {
    n = t.memoizedState,
    r = r(s, n),
    r = r == null ? n : Br({}, n, r),
    t.memoizedState = r,
    t.lanes === 0 && (t.updateQueue.baseState = r)
}
var hg = {
    isMounted: function(t) {
        return (t = t._reactInternals) ? Au(t) === t : !1
    },
    enqueueSetState: function(t, n, r) {
        t = t._reactInternals;
        var s = ao()
          , h = bc(t)
          , l = Ll(s, h);
        l.payload = n,
        r != null && (l.callback = r),
        n = yc(t, l, h),
        n !== null && (Ia(n, t, h, s),
        gm(n, t, h))
    },
    enqueueReplaceState: function(t, n, r) {
        t = t._reactInternals;
        var s = ao()
          , h = bc(t)
          , l = Ll(s, h);
        l.tag = 1,
        l.payload = n,
        r != null && (l.callback = r),
        n = yc(t, l, h),
        n !== null && (Ia(n, t, h, s),
        gm(n, t, h))
    },
    enqueueForceUpdate: function(t, n) {
        t = t._reactInternals;
        var r = ao()
          , s = bc(t)
          , h = Ll(r, s);
        h.tag = 2,
        n != null && (h.callback = n),
        n = yc(t, h, s),
        n !== null && (Ia(n, t, s, r),
        gm(n, t, s))
    }
};
function Nw(t, n, r, s, h, l, g) {
    return t = t.stateNode,
    typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(s, l, g) : n.prototype && n.prototype.isPureReactComponent ? !df(r, s) || !df(h, l) : !0
}
function aE(t, n, r) {
    var s = !1
      , h = Tc
      , l = n.contextType;
    return typeof l == "object" && l !== null ? l = la(l) : (h = xo(n) ? vu : qs.current,
    s = n.contextTypes,
    l = (s = s != null) ? Eh(t, h) : Tc),
    n = new n(r,l),
    t.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null,
    n.updater = hg,
    t.stateNode = n,
    n._reactInternals = t,
    s && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = h,
    t.__reactInternalMemoizedMaskedChildContext = l),
    n
}
function zw(t, n, r, s) {
    t = n.state,
    typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(r, s),
    typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(r, s),
    n.state !== t && hg.enqueueReplaceState(n, n.state, null)
}
function b_(t, n, r, s) {
    var h = t.stateNode;
    h.props = r,
    h.state = t.memoizedState,
    h.refs = oE,
    My(t);
    var l = n.contextType;
    typeof l == "object" && l !== null ? h.context = la(l) : (l = xo(n) ? vu : qs.current,
    h.context = Eh(t, l)),
    h.state = t.memoizedState,
    l = n.getDerivedStateFromProps,
    typeof l == "function" && (x_(t, n, l, r),
    h.state = t.memoizedState),
    typeof n.getDerivedStateFromProps == "function" || typeof h.getSnapshotBeforeUpdate == "function" || typeof h.UNSAFE_componentWillMount != "function" && typeof h.componentWillMount != "function" || (n = h.state,
    typeof h.componentWillMount == "function" && h.componentWillMount(),
    typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(),
    n !== h.state && hg.enqueueReplaceState(h, h.state, null),
    Gm(t, r, h, s),
    h.state = t.memoizedState),
    typeof h.componentDidMount == "function" && (t.flags |= 4194308)
}
function Ld(t, n, r) {
    if (t = r.ref,
    t !== null && typeof t != "function" && typeof t != "object") {
        if (r._owner) {
            if (r = r._owner,
            r) {
                if (r.tag !== 1)
                    throw Error(Ct(309));
                var s = r.stateNode
            }
            if (!s)
                throw Error(Ct(147, t));
            var h = s
              , l = "" + t;
            return n !== null && n.ref !== null && typeof n.ref == "function" && n.ref._stringRef === l ? n.ref : (n = function(g) {
                var _ = h.refs;
                _ === oE && (_ = h.refs = {}),
                g === null ? delete _[l] : _[l] = g
            }
            ,
            n._stringRef = l,
            n)
        }
        if (typeof t != "string")
            throw Error(Ct(284));
        if (!r._owner)
            throw Error(Ct(290, t))
    }
    return t
}
function $p(t, n) {
    throw t = Object.prototype.toString.call(n),
    Error(Ct(31, t === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : t))
}
function Gw(t) {
    var n = t._init;
    return n(t._payload)
}
function lE(t) {
    function n($, q) {
        if (t) {
            var N = $.deletions;
            N === null ? ($.deletions = [q],
            $.flags |= 16) : N.push(q)
        }
    }
    function r($, q) {
        if (!t)
            return null;
        for (; q !== null; )
            n($, q),
            q = q.sibling;
        return null
    }
    function s($, q) {
        for ($ = new Map; q !== null; )
            q.key !== null ? $.set(q.key, q) : $.set(q.index, q),
            q = q.sibling;
        return $
    }
    function h($, q) {
        return $ = wc($, q),
        $.index = 0,
        $.sibling = null,
        $
    }
    function l($, q, N) {
        return $.index = N,
        t ? (N = $.alternate,
        N !== null ? (N = N.index,
        N < q ? ($.flags |= 2,
        q) : N) : ($.flags |= 2,
        q)) : ($.flags |= 1048576,
        q)
    }
    function g($) {
        return t && $.alternate === null && ($.flags |= 2),
        $
    }
    function _($, q, N, ie) {
        return q === null || q.tag !== 6 ? (q = wv(N, $.mode, ie),
        q.return = $,
        q) : (q = h(q, N),
        q.return = $,
        q)
    }
    function A($, q, N, ie) {
        var _e = N.type;
        return _e === ih ? D($, q, N.props.children, ie, N.key) : q !== null && (q.elementType === _e || typeof _e == "object" && _e !== null && _e.$$typeof === lc && Gw(_e) === q.type) ? (ie = h(q, N.props),
        ie.ref = Ld($, q, N),
        ie.return = $,
        ie) : (ie = wm(N.type, N.key, N.props, null, $.mode, ie),
        ie.ref = Ld($, q, N),
        ie.return = $,
        ie)
    }
    function m($, q, N, ie) {
        return q === null || q.tag !== 4 || q.stateNode.containerInfo !== N.containerInfo || q.stateNode.implementation !== N.implementation ? (q = Av(N, $.mode, ie),
        q.return = $,
        q) : (q = h(q, N.children || []),
        q.return = $,
        q)
    }
    function D($, q, N, ie, _e) {
        return q === null || q.tag !== 7 ? (q = mu(N, $.mode, ie, _e),
        q.return = $,
        q) : (q = h(q, N),
        q.return = $,
        q)
    }
    function U($, q, N) {
        if (typeof q == "string" && q !== "" || typeof q == "number")
            return q = wv("" + q, $.mode, N),
            q.return = $,
            q;
        if (typeof q == "object" && q !== null) {
            switch (q.$$typeof) {
            case Hp:
                return N = wm(q.type, q.key, q.props, null, $.mode, N),
                N.ref = Ld($, null, q),
                N.return = $,
                N;
            case nh:
                return q = Av(q, $.mode, N),
                q.return = $,
                q;
            case lc:
                var ie = q._init;
                return U($, ie(q._payload), N)
            }
            if (zd(q) || Md(q))
                return q = mu(q, $.mode, N, null),
                q.return = $,
                q;
            $p($, q)
        }
        return null
    }
    function R($, q, N, ie) {
        var _e = q !== null ? q.key : null;
        if (typeof N == "string" && N !== "" || typeof N == "number")
            return _e !== null ? null : _($, q, "" + N, ie);
        if (typeof N == "object" && N !== null) {
            switch (N.$$typeof) {
            case Hp:
                return N.key === _e ? A($, q, N, ie) : null;
            case nh:
                return N.key === _e ? m($, q, N, ie) : null;
            case lc:
                return _e = N._init,
                R($, q, _e(N._payload), ie)
            }
            if (zd(N) || Md(N))
                return _e !== null ? null : D($, q, N, ie, null);
            $p($, N)
        }
        return null
    }
    function ne($, q, N, ie, _e) {
        if (typeof ie == "string" && ie !== "" || typeof ie == "number")
            return $ = $.get(N) || null,
            _(q, $, "" + ie, _e);
        if (typeof ie == "object" && ie !== null) {
            switch (ie.$$typeof) {
            case Hp:
                return $ = $.get(ie.key === null ? N : ie.key) || null,
                A(q, $, ie, _e);
            case nh:
                return $ = $.get(ie.key === null ? N : ie.key) || null,
                m(q, $, ie, _e);
            case lc:
                var Pe = ie._init;
                return ne($, q, N, Pe(ie._payload), _e)
            }
            if (zd(ie) || Md(ie))
                return $ = $.get(N) || null,
                D(q, $, ie, _e, null);
            $p(q, ie)
        }
        return null
    }
    function ce($, q, N, ie) {
        for (var _e = null, Pe = null, Be = q, Re = q = 0, ct = null; Be !== null && Re < N.length; Re++) {
            Be.index > Re ? (ct = Be,
            Be = null) : ct = Be.sibling;
            var et = R($, Be, N[Re], ie);
            if (et === null) {
                Be === null && (Be = ct);
                break
            }
            t && Be && et.alternate === null && n($, Be),
            q = l(et, q, Re),
            Pe === null ? _e = et : Pe.sibling = et,
            Pe = et,
            Be = ct
        }
        if (Re === N.length)
            return r($, Be),
            Sr && su($, Re),
            _e;
        if (Be === null) {
            for (; Re < N.length; Re++)
                Be = U($, N[Re], ie),
                Be !== null && (q = l(Be, q, Re),
                Pe === null ? _e = Be : Pe.sibling = Be,
                Pe = Be);
            return Sr && su($, Re),
            _e
        }
        for (Be = s($, Be); Re < N.length; Re++)
            ct = ne(Be, $, Re, N[Re], ie),
            ct !== null && (t && ct.alternate !== null && Be.delete(ct.key === null ? Re : ct.key),
            q = l(ct, q, Re),
            Pe === null ? _e = ct : Pe.sibling = ct,
            Pe = ct);
        return t && Be.forEach(function(Ze) {
            return n($, Ze)
        }),
        Sr && su($, Re),
        _e
    }
    function xe($, q, N, ie) {
        var _e = Md(N);
        if (typeof _e != "function")
            throw Error(Ct(150));
        if (N = _e.call(N),
        N == null)
            throw Error(Ct(151));
        for (var Pe = _e = null, Be = q, Re = q = 0, ct = null, et = N.next(); Be !== null && !et.done; Re++,
        et = N.next()) {
            Be.index > Re ? (ct = Be,
            Be = null) : ct = Be.sibling;
            var Ze = R($, Be, et.value, ie);
            if (Ze === null) {
                Be === null && (Be = ct);
                break
            }
            t && Be && Ze.alternate === null && n($, Be),
            q = l(Ze, q, Re),
            Pe === null ? _e = Ze : Pe.sibling = Ze,
            Pe = Ze,
            Be = ct
        }
        if (et.done)
            return r($, Be),
            Sr && su($, Re),
            _e;
        if (Be === null) {
            for (; !et.done; Re++,
            et = N.next())
                et = U($, et.value, ie),
                et !== null && (q = l(et, q, Re),
                Pe === null ? _e = et : Pe.sibling = et,
                Pe = et);
            return Sr && su($, Re),
            _e
        }
        for (Be = s($, Be); !et.done; Re++,
        et = N.next())
            et = ne(Be, $, Re, et.value, ie),
            et !== null && (t && et.alternate !== null && Be.delete(et.key === null ? Re : et.key),
            q = l(et, q, Re),
            Pe === null ? _e = et : Pe.sibling = et,
            Pe = et);
        return t && Be.forEach(function(Nt) {
            return n($, Nt)
        }),
        Sr && su($, Re),
        _e
    }
    function Se($, q, N, ie) {
        if (typeof N == "object" && N !== null && N.type === ih && N.key === null && (N = N.props.children),
        typeof N == "object" && N !== null) {
            switch (N.$$typeof) {
            case Hp:
                e: {
                    for (var _e = N.key, Pe = q; Pe !== null; ) {
                        if (Pe.key === _e) {
                            if (_e = N.type,
                            _e === ih) {
                                if (Pe.tag === 7) {
                                    r($, Pe.sibling),
                                    q = h(Pe, N.props.children),
                                    q.return = $,
                                    $ = q;
                                    break e
                                }
                            } else if (Pe.elementType === _e || typeof _e == "object" && _e !== null && _e.$$typeof === lc && Gw(_e) === Pe.type) {
                                r($, Pe.sibling),
                                q = h(Pe, N.props),
                                q.ref = Ld($, Pe, N),
                                q.return = $,
                                $ = q;
                                break e
                            }
                            r($, Pe);
                            break
                        } else
                            n($, Pe);
                        Pe = Pe.sibling
                    }
                    N.type === ih ? (q = mu(N.props.children, $.mode, ie, N.key),
                    q.return = $,
                    $ = q) : (ie = wm(N.type, N.key, N.props, null, $.mode, ie),
                    ie.ref = Ld($, q, N),
                    ie.return = $,
                    $ = ie)
                }
                return g($);
            case nh:
                e: {
                    for (Pe = N.key; q !== null; ) {
                        if (q.key === Pe)
                            if (q.tag === 4 && q.stateNode.containerInfo === N.containerInfo && q.stateNode.implementation === N.implementation) {
                                r($, q.sibling),
                                q = h(q, N.children || []),
                                q.return = $,
                                $ = q;
                                break e
                            } else {
                                r($, q);
                                break
                            }
                        else
                            n($, q);
                        q = q.sibling
                    }
                    q = Av(N, $.mode, ie),
                    q.return = $,
                    $ = q
                }
                return g($);
            case lc:
                return Pe = N._init,
                Se($, q, Pe(N._payload), ie)
            }
            if (zd(N))
                return ce($, q, N, ie);
            if (Md(N))
                return xe($, q, N, ie);
            $p($, N)
        }
        return typeof N == "string" && N !== "" || typeof N == "number" ? (N = "" + N,
        q !== null && q.tag === 6 ? (r($, q.sibling),
        q = h(q, N),
        q.return = $,
        $ = q) : (r($, q),
        q = wv(N, $.mode, ie),
        q.return = $,
        $ = q),
        g($)) : r($, q)
    }
    return Se
}
var Ch = lE(!0)
  , cE = lE(!1)
  , Lf = {}
  , nl = Dc(Lf)
  , gf = Dc(Lf)
  , vf = Dc(Lf);
function du(t) {
    if (t === Lf)
        throw Error(Ct(174));
    return t
}
function Cy(t, n) {
    switch (gr(vf, n),
    gr(gf, t),
    gr(nl, Lf),
    t = n.nodeType,
    t) {
    case 9:
    case 11:
        n = (n = n.documentElement) ? n.namespaceURI : $v(null, "");
        break;
    default:
        t = t === 8 ? n.parentNode : n,
        n = t.namespaceURI || null,
        t = t.tagName,
        n = $v(n, t)
    }
    wr(nl),
    gr(nl, n)
}
function Ph() {
    wr(nl),
    wr(gf),
    wr(vf)
}
function uE(t) {
    du(vf.current);
    var n = du(nl.current)
      , r = $v(n, t.type);
    n !== r && (gr(gf, t),
    gr(nl, r))
}
function Py(t) {
    gf.current === t && (wr(nl),
    wr(gf))
}
var Lr = Dc(0);
function Hm(t) {
    for (var n = t; n !== null; ) {
        if (n.tag === 13) {
            var r = n.memoizedState;
            if (r !== null && (r = r.dehydrated,
            r === null || r.data === "$?" || r.data === "$!"))
                return n
        } else if (n.tag === 19 && n.memoizedProps.revealOrder !== void 0) {
            if (n.flags & 128)
                return n
        } else if (n.child !== null) {
            n.child.return = n,
            n = n.child;
            continue
        }
        if (n === t)
            break;
        for (; n.sibling === null; ) {
            if (n.return === null || n.return === t)
                return null;
            n = n.return
        }
        n.sibling.return = n.return,
        n = n.sibling
    }
    return null
}
var gv = [];
function Ry() {
    for (var t = 0; t < gv.length; t++)
        gv[t]._workInProgressVersionPrimary = null;
    gv.length = 0
}
var vm = Gl.ReactCurrentDispatcher
  , vv = Gl.ReactCurrentBatchConfig
  , yu = 0
  , Or = null
  , ls = null
  , ms = null
  , Vm = !1
  , Kd = !1
  , _f = 0
  , f3 = 0;
function Xs() {
    throw Error(Ct(321))
}
function Dy(t, n) {
    if (n === null)
        return !1;
    for (var r = 0; r < n.length && r < t.length; r++)
        if (!Oa(t[r], n[r]))
            return !1;
    return !0
}
function Ly(t, n, r, s, h, l) {
    if (yu = l,
    Or = n,
    n.memoizedState = null,
    n.updateQueue = null,
    n.lanes = 0,
    vm.current = t === null || t.memoizedState === null ? v3 : _3,
    t = r(s, h),
    Kd) {
        l = 0;
        do {
            if (Kd = !1,
            _f = 0,
            25 <= l)
                throw Error(Ct(301));
            l += 1,
            ms = ls = null,
            n.updateQueue = null,
            vm.current = y3,
            t = r(s, h)
        } while (Kd)
    }
    if (vm.current = Wm,
    n = ls !== null && ls.next !== null,
    yu = 0,
    ms = ls = Or = null,
    Vm = !1,
    n)
        throw Error(Ct(300));
    return t
}
function Iy() {
    var t = _f !== 0;
    return _f = 0,
    t
}
function Ka() {
    var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return ms === null ? Or.memoizedState = ms = t : ms = ms.next = t,
    ms
}
function ca() {
    if (ls === null) {
        var t = Or.alternate;
        t = t !== null ? t.memoizedState : null
    } else
        t = ls.next;
    var n = ms === null ? Or.memoizedState : ms.next;
    if (n !== null)
        ms = n,
        ls = t;
    else {
        if (t === null)
            throw Error(Ct(310));
        ls = t,
        t = {
            memoizedState: ls.memoizedState,
            baseState: ls.baseState,
            baseQueue: ls.baseQueue,
            queue: ls.queue,
            next: null
        },
        ms === null ? Or.memoizedState = ms = t : ms = ms.next = t
    }
    return ms
}
function yf(t, n) {
    return typeof n == "function" ? n(t) : n
}
function _v(t) {
    var n = ca()
      , r = n.queue;
    if (r === null)
        throw Error(Ct(311));
    r.lastRenderedReducer = t;
    var s = ls
      , h = s.baseQueue
      , l = r.pending;
    if (l !== null) {
        if (h !== null) {
            var g = h.next;
            h.next = l.next,
            l.next = g
        }
        s.baseQueue = h = l,
        r.pending = null
    }
    if (h !== null) {
        l = h.next,
        s = s.baseState;
        var _ = g = null
          , A = null
          , m = l;
        do {
            var D = m.lane;
            if ((yu & D) === D)
                A !== null && (A = A.next = {
                    lane: 0,
                    action: m.action,
                    hasEagerState: m.hasEagerState,
                    eagerState: m.eagerState,
                    next: null
                }),
                s = m.hasEagerState ? m.eagerState : t(s, m.action);
            else {
                var U = {
                    lane: D,
                    action: m.action,
                    hasEagerState: m.hasEagerState,
                    eagerState: m.eagerState,
                    next: null
                };
                A === null ? (_ = A = U,
                g = s) : A = A.next = U,
                Or.lanes |= D,
                xu |= D
            }
            m = m.next
        } while (m !== null && m !== l);
        A === null ? g = s : A.next = _,
        Oa(s, n.memoizedState) || (_o = !0),
        n.memoizedState = s,
        n.baseState = g,
        n.baseQueue = A,
        r.lastRenderedState = s
    }
    if (t = r.interleaved,
    t !== null) {
        h = t;
        do
            l = h.lane,
            Or.lanes |= l,
            xu |= l,
            h = h.next;
        while (h !== t)
    } else
        h === null && (r.lanes = 0);
    return [n.memoizedState, r.dispatch]
}
function yv(t) {
    var n = ca()
      , r = n.queue;
    if (r === null)
        throw Error(Ct(311));
    r.lastRenderedReducer = t;
    var s = r.dispatch
      , h = r.pending
      , l = n.memoizedState;
    if (h !== null) {
        r.pending = null;
        var g = h = h.next;
        do
            l = t(l, g.action),
            g = g.next;
        while (g !== h);
        Oa(l, n.memoizedState) || (_o = !0),
        n.memoizedState = l,
        n.baseQueue === null && (n.baseState = l),
        r.lastRenderedState = l
    }
    return [l, s]
}
function hE() {}
function dE(t, n) {
    var r = Or
      , s = ca()
      , h = n()
      , l = !Oa(s.memoizedState, h);
    if (l && (s.memoizedState = h,
    _o = !0),
    s = s.queue,
    Oy(mE.bind(null, r, s, t), [t]),
    s.getSnapshot !== n || l || ms !== null && ms.memoizedState.tag & 1) {
        if (r.flags |= 2048,
        xf(9, pE.bind(null, r, s, h, n), void 0, null),
        vs === null)
            throw Error(Ct(349));
        yu & 30 || fE(r, n, h)
    }
    return h
}
function fE(t, n, r) {
    t.flags |= 16384,
    t = {
        getSnapshot: n,
        value: r
    },
    n = Or.updateQueue,
    n === null ? (n = {
        lastEffect: null,
        stores: null
    },
    Or.updateQueue = n,
    n.stores = [t]) : (r = n.stores,
    r === null ? n.stores = [t] : r.push(t))
}
function pE(t, n, r, s) {
    n.value = r,
    n.getSnapshot = s,
    gE(n) && vE(t)
}
function mE(t, n, r) {
    return r(function() {
        gE(n) && vE(t)
    })
}
function gE(t) {
    var n = t.getSnapshot;
    t = t.value;
    try {
        var r = n();
        return !Oa(t, r)
    } catch {
        return !0
    }
}
function vE(t) {
    var n = Nl(t, 1);
    n !== null && Ia(n, t, 1, -1)
}
function Hw(t) {
    var n = Ka();
    return typeof t == "function" && (t = t()),
    n.memoizedState = n.baseState = t,
    t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: yf,
        lastRenderedState: t
    },
    n.queue = t,
    t = t.dispatch = g3.bind(null, Or, t),
    [n.memoizedState, t]
}
function xf(t, n, r, s) {
    return t = {
        tag: t,
        create: n,
        destroy: r,
        deps: s,
        next: null
    },
    n = Or.updateQueue,
    n === null ? (n = {
        lastEffect: null,
        stores: null
    },
    Or.updateQueue = n,
    n.lastEffect = t.next = t) : (r = n.lastEffect,
    r === null ? n.lastEffect = t.next = t : (s = r.next,
    r.next = t,
    t.next = s,
    n.lastEffect = t)),
    t
}
function _E() {
    return ca().memoizedState
}
function _m(t, n, r, s) {
    var h = Ka();
    Or.flags |= t,
    h.memoizedState = xf(1 | n, r, void 0, s === void 0 ? null : s)
}
function dg(t, n, r, s) {
    var h = ca();
    s = s === void 0 ? null : s;
    var l = void 0;
    if (ls !== null) {
        var g = ls.memoizedState;
        if (l = g.destroy,
        s !== null && Dy(s, g.deps)) {
            h.memoizedState = xf(n, r, l, s);
            return
        }
    }
    Or.flags |= t,
    h.memoizedState = xf(1 | n, r, l, s)
}
function Vw(t, n) {
    return _m(8390656, 8, t, n)
}
function Oy(t, n) {
    return dg(2048, 8, t, n)
}
function yE(t, n) {
    return dg(4, 2, t, n)
}
function xE(t, n) {
    return dg(4, 4, t, n)
}
function bE(t, n) {
    if (typeof n == "function")
        return t = t(),
        n(t),
        function() {
            n(null)
        }
        ;
    if (n != null)
        return t = t(),
        n.current = t,
        function() {
            n.current = null
        }
}
function wE(t, n, r) {
    return r = r != null ? r.concat([t]) : null,
    dg(4, 4, bE.bind(null, n, t), r)
}
function By() {}
function AE(t, n) {
    var r = ca();
    n = n === void 0 ? null : n;
    var s = r.memoizedState;
    return s !== null && n !== null && Dy(n, s[1]) ? s[0] : (r.memoizedState = [t, n],
    t)
}
function SE(t, n) {
    var r = ca();
    n = n === void 0 ? null : n;
    var s = r.memoizedState;
    return s !== null && n !== null && Dy(n, s[1]) ? s[0] : (t = t(),
    r.memoizedState = [t, n],
    t)
}
function TE(t, n, r) {
    return yu & 21 ? (Oa(r, n) || (r = CT(),
    Or.lanes |= r,
    xu |= r,
    t.baseState = !0),
    n) : (t.baseState && (t.baseState = !1,
    _o = !0),
    t.memoizedState = r)
}
function p3(t, n) {
    var r = sr;
    sr = r !== 0 && 4 > r ? r : 4,
    t(!0);
    var s = vv.transition;
    vv.transition = {};
    try {
        t(!1),
        n()
    } finally {
        sr = r,
        vv.transition = s
    }
}
function EE() {
    return ca().memoizedState
}
function m3(t, n, r) {
    var s = bc(t);
    if (r = {
        lane: s,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    ME(t))
        CE(n, r);
    else if (r = rE(t, n, r, s),
    r !== null) {
        var h = ao();
        Ia(r, t, s, h),
        PE(r, n, s)
    }
}
function g3(t, n, r) {
    var s = bc(t)
      , h = {
        lane: s,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (ME(t))
        CE(n, h);
    else {
        var l = t.alternate;
        if (t.lanes === 0 && (l === null || l.lanes === 0) && (l = n.lastRenderedReducer,
        l !== null))
            try {
                var g = n.lastRenderedState
                  , _ = l(g, r);
                if (h.hasEagerState = !0,
                h.eagerState = _,
                Oa(_, g)) {
                    var A = n.interleaved;
                    A === null ? (h.next = h,
                    Ey(n)) : (h.next = A.next,
                    A.next = h),
                    n.interleaved = h;
                    return
                }
            } catch {} finally {}
        r = rE(t, n, h, s),
        r !== null && (h = ao(),
        Ia(r, t, s, h),
        PE(r, n, s))
    }
}
function ME(t) {
    var n = t.alternate;
    return t === Or || n !== null && n === Or
}
function CE(t, n) {
    Kd = Vm = !0;
    var r = t.pending;
    r === null ? n.next = n : (n.next = r.next,
    r.next = n),
    t.pending = n
}
function PE(t, n, r) {
    if (r & 4194240) {
        var s = n.lanes;
        s &= t.pendingLanes,
        r |= s,
        n.lanes = r,
        dy(t, r)
    }
}
var Wm = {
    readContext: la,
    useCallback: Xs,
    useContext: Xs,
    useEffect: Xs,
    useImperativeHandle: Xs,
    useInsertionEffect: Xs,
    useLayoutEffect: Xs,
    useMemo: Xs,
    useReducer: Xs,
    useRef: Xs,
    useState: Xs,
    useDebugValue: Xs,
    useDeferredValue: Xs,
    useTransition: Xs,
    useMutableSource: Xs,
    useSyncExternalStore: Xs,
    useId: Xs,
    unstable_isNewReconciler: !1
}
  , v3 = {
    readContext: la,
    useCallback: function(t, n) {
        return Ka().memoizedState = [t, n === void 0 ? null : n],
        t
    },
    useContext: la,
    useEffect: Vw,
    useImperativeHandle: function(t, n, r) {
        return r = r != null ? r.concat([t]) : null,
        _m(4194308, 4, bE.bind(null, n, t), r)
    },
    useLayoutEffect: function(t, n) {
        return _m(4194308, 4, t, n)
    },
    useInsertionEffect: function(t, n) {
        return _m(4, 2, t, n)
    },
    useMemo: function(t, n) {
        var r = Ka();
        return n = n === void 0 ? null : n,
        t = t(),
        r.memoizedState = [t, n],
        t
    },
    useReducer: function(t, n, r) {
        var s = Ka();
        return n = r !== void 0 ? r(n) : n,
        s.memoizedState = s.baseState = n,
        t = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: t,
            lastRenderedState: n
        },
        s.queue = t,
        t = t.dispatch = m3.bind(null, Or, t),
        [s.memoizedState, t]
    },
    useRef: function(t) {
        var n = Ka();
        return t = {
            current: t
        },
        n.memoizedState = t
    },
    useState: Hw,
    useDebugValue: By,
    useDeferredValue: function(t) {
        return Ka().memoizedState = t
    },
    useTransition: function() {
        var t = Hw(!1)
          , n = t[0];
        return t = p3.bind(null, t[1]),
        Ka().memoizedState = t,
        [n, t]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(t, n, r) {
        var s = Or
          , h = Ka();
        if (Sr) {
            if (r === void 0)
                throw Error(Ct(407));
            r = r()
        } else {
            if (r = n(),
            vs === null)
                throw Error(Ct(349));
            yu & 30 || fE(s, n, r)
        }
        h.memoizedState = r;
        var l = {
            value: r,
            getSnapshot: n
        };
        return h.queue = l,
        Vw(mE.bind(null, s, l, t), [t]),
        s.flags |= 2048,
        xf(9, pE.bind(null, s, l, r, n), void 0, null),
        r
    },
    useId: function() {
        var t = Ka()
          , n = vs.identifierPrefix;
        if (Sr) {
            var r = Rl
              , s = Pl;
            r = (s & ~(1 << 32 - La(s) - 1)).toString(32) + r,
            n = ":" + n + "R" + r,
            r = _f++,
            0 < r && (n += "H" + r.toString(32)),
            n += ":"
        } else
            r = f3++,
            n = ":" + n + "r" + r.toString(32) + ":";
        return t.memoizedState = n
    },
    unstable_isNewReconciler: !1
}
  , _3 = {
    readContext: la,
    useCallback: AE,
    useContext: la,
    useEffect: Oy,
    useImperativeHandle: wE,
    useInsertionEffect: yE,
    useLayoutEffect: xE,
    useMemo: SE,
    useReducer: _v,
    useRef: _E,
    useState: function() {
        return _v(yf)
    },
    useDebugValue: By,
    useDeferredValue: function(t) {
        var n = ca();
        return TE(n, ls.memoizedState, t)
    },
    useTransition: function() {
        var t = _v(yf)[0]
          , n = ca().memoizedState;
        return [t, n]
    },
    useMutableSource: hE,
    useSyncExternalStore: dE,
    useId: EE,
    unstable_isNewReconciler: !1
}
  , y3 = {
    readContext: la,
    useCallback: AE,
    useContext: la,
    useEffect: Oy,
    useImperativeHandle: wE,
    useInsertionEffect: yE,
    useLayoutEffect: xE,
    useMemo: SE,
    useReducer: yv,
    useRef: _E,
    useState: function() {
        return yv(yf)
    },
    useDebugValue: By,
    useDeferredValue: function(t) {
        var n = ca();
        return ls === null ? n.memoizedState = t : TE(n, ls.memoizedState, t)
    },
    useTransition: function() {
        var t = yv(yf)[0]
          , n = ca().memoizedState;
        return [t, n]
    },
    useMutableSource: hE,
    useSyncExternalStore: dE,
    useId: EE,
    unstable_isNewReconciler: !1
};
function Rh(t, n) {
    try {
        var r = ""
          , s = n;
        do
            r += YL(s),
            s = s.return;
        while (s);
        var h = r
    } catch (l) {
        h = `
Error generating stack: ` + l.message + `
` + l.stack
    }
    return {
        value: t,
        source: n,
        stack: h,
        digest: null
    }
}
function xv(t, n, r) {
    return {
        value: t,
        source: null,
        stack: r ?? null,
        digest: n ?? null
    }
}
function w_(t, n) {
    try {
        console.error(n.value)
    } catch (r) {
        setTimeout(function() {
            throw r
        })
    }
}
var x3 = typeof WeakMap == "function" ? WeakMap : Map;
function RE(t, n, r) {
    r = Ll(-1, r),
    r.tag = 3,
    r.payload = {
        element: null
    };
    var s = n.value;
    return r.callback = function() {
        Xm || (Xm = !0,
        L_ = s),
        w_(t, n)
    }
    ,
    r
}
function DE(t, n, r) {
    r = Ll(-1, r),
    r.tag = 3;
    var s = t.type.getDerivedStateFromError;
    if (typeof s == "function") {
        var h = n.value;
        r.payload = function() {
            return s(h)
        }
        ,
        r.callback = function() {
            w_(t, n)
        }
    }
    var l = t.stateNode;
    return l !== null && typeof l.componentDidCatch == "function" && (r.callback = function() {
        w_(t, n),
        typeof s != "function" && (xc === null ? xc = new Set([this]) : xc.add(this));
        var g = n.stack;
        this.componentDidCatch(n.value, {
            componentStack: g !== null ? g : ""
        })
    }
    ),
    r
}
function Ww(t, n, r) {
    var s = t.pingCache;
    if (s === null) {
        s = t.pingCache = new x3;
        var h = new Set;
        s.set(n, h)
    } else
        h = s.get(n),
        h === void 0 && (h = new Set,
        s.set(n, h));
    h.has(r) || (h.add(r),
    t = O3.bind(null, t, n, r),
    n.then(t, t))
}
function jw(t) {
    do {
        var n;
        if ((n = t.tag === 13) && (n = t.memoizedState,
        n = n !== null ? n.dehydrated !== null : !0),
        n)
            return t;
        t = t.return
    } while (t !== null);
    return null
}
function Xw(t, n, r, s, h) {
    return t.mode & 1 ? (t.flags |= 65536,
    t.lanes = h,
    t) : (t === n ? t.flags |= 65536 : (t.flags |= 128,
    r.flags |= 131072,
    r.flags &= -52805,
    r.tag === 1 && (r.alternate === null ? r.tag = 17 : (n = Ll(-1, 1),
    n.tag = 2,
    yc(r, n, 1))),
    r.lanes |= 1),
    t)
}
var b3 = Gl.ReactCurrentOwner
  , _o = !1;
function so(t, n, r, s) {
    n.child = t === null ? cE(n, null, r, s) : Ch(n, t.child, r, s)
}
function Yw(t, n, r, s, h) {
    r = r.render;
    var l = n.ref;
    return wh(n, h),
    s = Ly(t, n, r, s, l, h),
    r = Iy(),
    t !== null && !_o ? (n.updateQueue = t.updateQueue,
    n.flags &= -2053,
    t.lanes &= ~h,
    zl(t, n, h)) : (Sr && r && xy(n),
    n.flags |= 1,
    so(t, n, s, h),
    n.child)
}
function Qw(t, n, r, s, h) {
    if (t === null) {
        var l = r.type;
        return typeof l == "function" && !Vy(l) && l.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (n.tag = 15,
        n.type = l,
        LE(t, n, l, s, h)) : (t = wm(r.type, null, s, n, n.mode, h),
        t.ref = n.ref,
        t.return = n,
        n.child = t)
    }
    if (l = t.child,
    !(t.lanes & h)) {
        var g = l.memoizedProps;
        if (r = r.compare,
        r = r !== null ? r : df,
        r(g, s) && t.ref === n.ref)
            return zl(t, n, h)
    }
    return n.flags |= 1,
    t = wc(l, s),
    t.ref = n.ref,
    t.return = n,
    n.child = t
}
function LE(t, n, r, s, h) {
    if (t !== null) {
        var l = t.memoizedProps;
        if (df(l, s) && t.ref === n.ref)
            if (_o = !1,
            n.pendingProps = s = l,
            (t.lanes & h) !== 0)
                t.flags & 131072 && (_o = !0);
            else
                return n.lanes = t.lanes,
                zl(t, n, h)
    }
    return A_(t, n, r, s, h)
}
function IE(t, n, r) {
    var s = n.pendingProps
      , h = s.children
      , l = t !== null ? t.memoizedState : null;
    if (s.mode === "hidden")
        if (!(n.mode & 1))
            n.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            gr(fh, ko),
            ko |= r;
        else {
            if (!(r & 1073741824))
                return t = l !== null ? l.baseLanes | r : r,
                n.lanes = n.childLanes = 1073741824,
                n.memoizedState = {
                    baseLanes: t,
                    cachePool: null,
                    transitions: null
                },
                n.updateQueue = null,
                gr(fh, ko),
                ko |= t,
                null;
            n.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            s = l !== null ? l.baseLanes : r,
            gr(fh, ko),
            ko |= s
        }
    else
        l !== null ? (s = l.baseLanes | r,
        n.memoizedState = null) : s = r,
        gr(fh, ko),
        ko |= s;
    return so(t, n, h, r),
    n.child
}
function OE(t, n) {
    var r = n.ref;
    (t === null && r !== null || t !== null && t.ref !== r) && (n.flags |= 512,
    n.flags |= 2097152)
}
function A_(t, n, r, s, h) {
    var l = xo(r) ? vu : qs.current;
    return l = Eh(n, l),
    wh(n, h),
    r = Ly(t, n, r, s, l, h),
    s = Iy(),
    t !== null && !_o ? (n.updateQueue = t.updateQueue,
    n.flags &= -2053,
    t.lanes &= ~h,
    zl(t, n, h)) : (Sr && s && xy(n),
    n.flags |= 1,
    so(t, n, r, h),
    n.child)
}
function Kw(t, n, r, s, h) {
    if (xo(r)) {
        var l = !0;
        Fm(n)
    } else
        l = !1;
    if (wh(n, h),
    n.stateNode === null)
        ym(t, n),
        aE(n, r, s),
        b_(n, r, s, h),
        s = !0;
    else if (t === null) {
        var g = n.stateNode
          , _ = n.memoizedProps;
        g.props = _;
        var A = g.context
          , m = r.contextType;
        typeof m == "object" && m !== null ? m = la(m) : (m = xo(r) ? vu : qs.current,
        m = Eh(n, m));
        var D = r.getDerivedStateFromProps
          , U = typeof D == "function" || typeof g.getSnapshotBeforeUpdate == "function";
        U || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (_ !== s || A !== m) && zw(n, g, s, m),
        cc = !1;
        var R = n.memoizedState;
        g.state = R,
        Gm(n, s, g, h),
        A = n.memoizedState,
        _ !== s || R !== A || yo.current || cc ? (typeof D == "function" && (x_(n, r, D, s),
        A = n.memoizedState),
        (_ = cc || Nw(n, r, _, s, R, A, m)) ? (U || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(),
        typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()),
        typeof g.componentDidMount == "function" && (n.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (n.flags |= 4194308),
        n.memoizedProps = s,
        n.memoizedState = A),
        g.props = s,
        g.state = A,
        g.context = m,
        s = _) : (typeof g.componentDidMount == "function" && (n.flags |= 4194308),
        s = !1)
    } else {
        g = n.stateNode,
        sE(t, n),
        _ = n.memoizedProps,
        m = n.type === n.elementType ? _ : Ca(n.type, _),
        g.props = m,
        U = n.pendingProps,
        R = g.context,
        A = r.contextType,
        typeof A == "object" && A !== null ? A = la(A) : (A = xo(r) ? vu : qs.current,
        A = Eh(n, A));
        var ne = r.getDerivedStateFromProps;
        (D = typeof ne == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (_ !== U || R !== A) && zw(n, g, s, A),
        cc = !1,
        R = n.memoizedState,
        g.state = R,
        Gm(n, s, g, h);
        var ce = n.memoizedState;
        _ !== U || R !== ce || yo.current || cc ? (typeof ne == "function" && (x_(n, r, ne, s),
        ce = n.memoizedState),
        (m = cc || Nw(n, r, m, s, R, ce, A) || !1) ? (D || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(s, ce, A),
        typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(s, ce, A)),
        typeof g.componentDidUpdate == "function" && (n.flags |= 4),
        typeof g.getSnapshotBeforeUpdate == "function" && (n.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || _ === t.memoizedProps && R === t.memoizedState || (n.flags |= 4),
        typeof g.getSnapshotBeforeUpdate != "function" || _ === t.memoizedProps && R === t.memoizedState || (n.flags |= 1024),
        n.memoizedProps = s,
        n.memoizedState = ce),
        g.props = s,
        g.state = ce,
        g.context = A,
        s = m) : (typeof g.componentDidUpdate != "function" || _ === t.memoizedProps && R === t.memoizedState || (n.flags |= 4),
        typeof g.getSnapshotBeforeUpdate != "function" || _ === t.memoizedProps && R === t.memoizedState || (n.flags |= 1024),
        s = !1)
    }
    return S_(t, n, r, s, l, h)
}
function S_(t, n, r, s, h, l) {
    OE(t, n);
    var g = (n.flags & 128) !== 0;
    if (!s && !g)
        return h && Ow(n, r, !1),
        zl(t, n, l);
    s = n.stateNode,
    b3.current = n;
    var _ = g && typeof r.getDerivedStateFromError != "function" ? null : s.render();
    return n.flags |= 1,
    t !== null && g ? (n.child = Ch(n, t.child, null, l),
    n.child = Ch(n, null, _, l)) : so(t, n, _, l),
    n.memoizedState = s.state,
    h && Ow(n, r, !0),
    n.child
}
function BE(t) {
    var n = t.stateNode;
    n.pendingContext ? Iw(t, n.pendingContext, n.pendingContext !== n.context) : n.context && Iw(t, n.context, !1),
    Cy(t, n.containerInfo)
}
function Zw(t, n, r, s, h) {
    return Mh(),
    wy(h),
    n.flags |= 256,
    so(t, n, r, s),
    n.child
}
var T_ = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function E_(t) {
    return {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }
}
function FE(t, n, r) {
    var s = n.pendingProps, h = Lr.current, l = !1, g = (n.flags & 128) !== 0, _;
    if ((_ = g) || (_ = t !== null && t.memoizedState === null ? !1 : (h & 2) !== 0),
    _ ? (l = !0,
    n.flags &= -129) : (t === null || t.memoizedState !== null) && (h |= 1),
    gr(Lr, h & 1),
    t === null)
        return __(n),
        t = n.memoizedState,
        t !== null && (t = t.dehydrated,
        t !== null) ? (n.mode & 1 ? t.data === "$!" ? n.lanes = 8 : n.lanes = 1073741824 : n.lanes = 1,
        null) : (g = s.children,
        t = s.fallback,
        l ? (s = n.mode,
        l = n.child,
        g = {
            mode: "hidden",
            children: g
        },
        !(s & 1) && l !== null ? (l.childLanes = 0,
        l.pendingProps = g) : l = mg(g, s, 0, null),
        t = mu(t, s, r, null),
        l.return = n,
        t.return = n,
        l.sibling = t,
        n.child = l,
        n.child.memoizedState = E_(r),
        n.memoizedState = T_,
        t) : Fy(n, g));
    if (h = t.memoizedState,
    h !== null && (_ = h.dehydrated,
    _ !== null))
        return w3(t, n, g, s, _, h, r);
    if (l) {
        l = s.fallback,
        g = n.mode,
        h = t.child,
        _ = h.sibling;
        var A = {
            mode: "hidden",
            children: s.children
        };
        return !(g & 1) && n.child !== h ? (s = n.child,
        s.childLanes = 0,
        s.pendingProps = A,
        n.deletions = null) : (s = wc(h, A),
        s.subtreeFlags = h.subtreeFlags & 14680064),
        _ !== null ? l = wc(_, l) : (l = mu(l, g, r, null),
        l.flags |= 2),
        l.return = n,
        s.return = n,
        s.sibling = l,
        n.child = s,
        s = l,
        l = n.child,
        g = t.child.memoizedState,
        g = g === null ? E_(r) : {
            baseLanes: g.baseLanes | r,
            cachePool: null,
            transitions: g.transitions
        },
        l.memoizedState = g,
        l.childLanes = t.childLanes & ~r,
        n.memoizedState = T_,
        s
    }
    return l = t.child,
    t = l.sibling,
    s = wc(l, {
        mode: "visible",
        children: s.children
    }),
    !(n.mode & 1) && (s.lanes = r),
    s.return = n,
    s.sibling = null,
    t !== null && (r = n.deletions,
    r === null ? (n.deletions = [t],
    n.flags |= 16) : r.push(t)),
    n.child = s,
    n.memoizedState = null,
    s
}
function Fy(t, n) {
    return n = mg({
        mode: "visible",
        children: n
    }, t.mode, 0, null),
    n.return = t,
    t.child = n
}
function em(t, n, r, s) {
    return s !== null && wy(s),
    Ch(n, t.child, null, r),
    t = Fy(n, n.pendingProps.children),
    t.flags |= 2,
    n.memoizedState = null,
    t
}
function w3(t, n, r, s, h, l, g) {
    if (r)
        return n.flags & 256 ? (n.flags &= -257,
        s = xv(Error(Ct(422))),
        em(t, n, g, s)) : n.memoizedState !== null ? (n.child = t.child,
        n.flags |= 128,
        null) : (l = s.fallback,
        h = n.mode,
        s = mg({
            mode: "visible",
            children: s.children
        }, h, 0, null),
        l = mu(l, h, g, null),
        l.flags |= 2,
        s.return = n,
        l.return = n,
        s.sibling = l,
        n.child = s,
        n.mode & 1 && Ch(n, t.child, null, g),
        n.child.memoizedState = E_(g),
        n.memoizedState = T_,
        l);
    if (!(n.mode & 1))
        return em(t, n, g, null);
    if (h.data === "$!") {
        if (s = h.nextSibling && h.nextSibling.dataset,
        s)
            var _ = s.dgst;
        return s = _,
        l = Error(Ct(419)),
        s = xv(l, s, void 0),
        em(t, n, g, s)
    }
    if (_ = (g & t.childLanes) !== 0,
    _o || _) {
        if (s = vs,
        s !== null) {
            switch (g & -g) {
            case 4:
                h = 2;
                break;
            case 16:
                h = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                h = 32;
                break;
            case 536870912:
                h = 268435456;
                break;
            default:
                h = 0
            }
            h = h & (s.suspendedLanes | g) ? 0 : h,
            h !== 0 && h !== l.retryLane && (l.retryLane = h,
            Nl(t, h),
            Ia(s, t, h, -1))
        }
        return Hy(),
        s = xv(Error(Ct(421))),
        em(t, n, g, s)
    }
    return h.data === "$?" ? (n.flags |= 128,
    n.child = t.child,
    n = B3.bind(null, t),
    h._reactRetry = n,
    null) : (t = l.treeContext,
    Uo = _c(h.nextSibling),
    No = n,
    Sr = !0,
    Ra = null,
    t !== null && (ia[ra++] = Pl,
    ia[ra++] = Rl,
    ia[ra++] = _u,
    Pl = t.id,
    Rl = t.overflow,
    _u = n),
    n = Fy(n, s.children),
    n.flags |= 4096,
    n)
}
function qw(t, n, r) {
    t.lanes |= n;
    var s = t.alternate;
    s !== null && (s.lanes |= n),
    y_(t.return, n, r)
}
function bv(t, n, r, s, h) {
    var l = t.memoizedState;
    l === null ? t.memoizedState = {
        isBackwards: n,
        rendering: null,
        renderingStartTime: 0,
        last: s,
        tail: r,
        tailMode: h
    } : (l.isBackwards = n,
    l.rendering = null,
    l.renderingStartTime = 0,
    l.last = s,
    l.tail = r,
    l.tailMode = h)
}
function kE(t, n, r) {
    var s = n.pendingProps
      , h = s.revealOrder
      , l = s.tail;
    if (so(t, n, s.children, r),
    s = Lr.current,
    s & 2)
        s = s & 1 | 2,
        n.flags |= 128;
    else {
        if (t !== null && t.flags & 128)
            e: for (t = n.child; t !== null; ) {
                if (t.tag === 13)
                    t.memoizedState !== null && qw(t, r, n);
                else if (t.tag === 19)
                    qw(t, r, n);
                else if (t.child !== null) {
                    t.child.return = t,
                    t = t.child;
                    continue
                }
                if (t === n)
                    break e;
                for (; t.sibling === null; ) {
                    if (t.return === null || t.return === n)
                        break e;
                    t = t.return
                }
                t.sibling.return = t.return,
                t = t.sibling
            }
        s &= 1
    }
    if (gr(Lr, s),
    !(n.mode & 1))
        n.memoizedState = null;
    else
        switch (h) {
        case "forwards":
            for (r = n.child,
            h = null; r !== null; )
                t = r.alternate,
                t !== null && Hm(t) === null && (h = r),
                r = r.sibling;
            r = h,
            r === null ? (h = n.child,
            n.child = null) : (h = r.sibling,
            r.sibling = null),
            bv(n, !1, h, r, l);
            break;
        case "backwards":
            for (r = null,
            h = n.child,
            n.child = null; h !== null; ) {
                if (t = h.alternate,
                t !== null && Hm(t) === null) {
                    n.child = h;
                    break
                }
                t = h.sibling,
                h.sibling = r,
                r = h,
                h = t
            }
            bv(n, !0, r, null, l);
            break;
        case "together":
            bv(n, !1, null, null, void 0);
            break;
        default:
            n.memoizedState = null
        }
    return n.child
}
function ym(t, n) {
    !(n.mode & 1) && t !== null && (t.alternate = null,
    n.alternate = null,
    n.flags |= 2)
}
function zl(t, n, r) {
    if (t !== null && (n.dependencies = t.dependencies),
    xu |= n.lanes,
    !(r & n.childLanes))
        return null;
    if (t !== null && n.child !== t.child)
        throw Error(Ct(153));
    if (n.child !== null) {
        for (t = n.child,
        r = wc(t, t.pendingProps),
        n.child = r,
        r.return = n; t.sibling !== null; )
            t = t.sibling,
            r = r.sibling = wc(t, t.pendingProps),
            r.return = n;
        r.sibling = null
    }
    return n.child
}
function A3(t, n, r) {
    switch (n.tag) {
    case 3:
        BE(n),
        Mh();
        break;
    case 5:
        uE(n);
        break;
    case 1:
        xo(n.type) && Fm(n);
        break;
    case 4:
        Cy(n, n.stateNode.containerInfo);
        break;
    case 10:
        var s = n.type._context
          , h = n.memoizedProps.value;
        gr(Nm, s._currentValue),
        s._currentValue = h;
        break;
    case 13:
        if (s = n.memoizedState,
        s !== null)
            return s.dehydrated !== null ? (gr(Lr, Lr.current & 1),
            n.flags |= 128,
            null) : r & n.child.childLanes ? FE(t, n, r) : (gr(Lr, Lr.current & 1),
            t = zl(t, n, r),
            t !== null ? t.sibling : null);
        gr(Lr, Lr.current & 1);
        break;
    case 19:
        if (s = (r & n.childLanes) !== 0,
        t.flags & 128) {
            if (s)
                return kE(t, n, r);
            n.flags |= 128
        }
        if (h = n.memoizedState,
        h !== null && (h.rendering = null,
        h.tail = null,
        h.lastEffect = null),
        gr(Lr, Lr.current),
        s)
            break;
        return null;
    case 22:
    case 23:
        return n.lanes = 0,
        IE(t, n, r)
    }
    return zl(t, n, r)
}
var UE, M_, NE, zE;
UE = function(t, n) {
    for (var r = n.child; r !== null; ) {
        if (r.tag === 5 || r.tag === 6)
            t.appendChild(r.stateNode);
        else if (r.tag !== 4 && r.child !== null) {
            r.child.return = r,
            r = r.child;
            continue
        }
        if (r === n)
            break;
        for (; r.sibling === null; ) {
            if (r.return === null || r.return === n)
                return;
            r = r.return
        }
        r.sibling.return = r.return,
        r = r.sibling
    }
}
;
M_ = function() {}
;
NE = function(t, n, r, s) {
    var h = t.memoizedProps;
    if (h !== s) {
        t = n.stateNode,
        du(nl.current);
        var l = null;
        switch (r) {
        case "input":
            h = Kv(t, h),
            s = Kv(t, s),
            l = [];
            break;
        case "select":
            h = Br({}, h, {
                value: void 0
            }),
            s = Br({}, s, {
                value: void 0
            }),
            l = [];
            break;
        case "textarea":
            h = Jv(t, h),
            s = Jv(t, s),
            l = [];
            break;
        default:
            typeof h.onClick != "function" && typeof s.onClick == "function" && (t.onclick = Om)
        }
        e_(r, s);
        var g;
        r = null;
        for (m in h)
            if (!s.hasOwnProperty(m) && h.hasOwnProperty(m) && h[m] != null)
                if (m === "style") {
                    var _ = h[m];
                    for (g in _)
                        _.hasOwnProperty(g) && (r || (r = {}),
                        r[g] = "")
                } else
                    m !== "dangerouslySetInnerHTML" && m !== "children" && m !== "suppressContentEditableWarning" && m !== "suppressHydrationWarning" && m !== "autoFocus" && (sf.hasOwnProperty(m) ? l || (l = []) : (l = l || []).push(m, null));
        for (m in s) {
            var A = s[m];
            if (_ = h != null ? h[m] : void 0,
            s.hasOwnProperty(m) && A !== _ && (A != null || _ != null))
                if (m === "style")
                    if (_) {
                        for (g in _)
                            !_.hasOwnProperty(g) || A && A.hasOwnProperty(g) || (r || (r = {}),
                            r[g] = "");
                        for (g in A)
                            A.hasOwnProperty(g) && _[g] !== A[g] && (r || (r = {}),
                            r[g] = A[g])
                    } else
                        r || (l || (l = []),
                        l.push(m, r)),
                        r = A;
                else
                    m === "dangerouslySetInnerHTML" ? (A = A ? A.__html : void 0,
                    _ = _ ? _.__html : void 0,
                    A != null && _ !== A && (l = l || []).push(m, A)) : m === "children" ? typeof A != "string" && typeof A != "number" || (l = l || []).push(m, "" + A) : m !== "suppressContentEditableWarning" && m !== "suppressHydrationWarning" && (sf.hasOwnProperty(m) ? (A != null && m === "onScroll" && br("scroll", t),
                    l || _ === A || (l = [])) : (l = l || []).push(m, A))
        }
        r && (l = l || []).push("style", r);
        var m = l;
        (n.updateQueue = m) && (n.flags |= 4)
    }
}
;
zE = function(t, n, r, s) {
    r !== s && (n.flags |= 4)
}
;
function Id(t, n) {
    if (!Sr)
        switch (t.tailMode) {
        case "hidden":
            n = t.tail;
            for (var r = null; n !== null; )
                n.alternate !== null && (r = n),
                n = n.sibling;
            r === null ? t.tail = null : r.sibling = null;
            break;
        case "collapsed":
            r = t.tail;
            for (var s = null; r !== null; )
                r.alternate !== null && (s = r),
                r = r.sibling;
            s === null ? n || t.tail === null ? t.tail = null : t.tail.sibling = null : s.sibling = null
        }
}
function Ys(t) {
    var n = t.alternate !== null && t.alternate.child === t.child
      , r = 0
      , s = 0;
    if (n)
        for (var h = t.child; h !== null; )
            r |= h.lanes | h.childLanes,
            s |= h.subtreeFlags & 14680064,
            s |= h.flags & 14680064,
            h.return = t,
            h = h.sibling;
    else
        for (h = t.child; h !== null; )
            r |= h.lanes | h.childLanes,
            s |= h.subtreeFlags,
            s |= h.flags,
            h.return = t,
            h = h.sibling;
    return t.subtreeFlags |= s,
    t.childLanes = r,
    n
}
function S3(t, n, r) {
    var s = n.pendingProps;
    switch (by(n),
    n.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return Ys(n),
        null;
    case 1:
        return xo(n.type) && Bm(),
        Ys(n),
        null;
    case 3:
        return s = n.stateNode,
        Ph(),
        wr(yo),
        wr(qs),
        Ry(),
        s.pendingContext && (s.context = s.pendingContext,
        s.pendingContext = null),
        (t === null || t.child === null) && (Jp(n) ? n.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(n.flags & 256) || (n.flags |= 1024,
        Ra !== null && (B_(Ra),
        Ra = null))),
        M_(t, n),
        Ys(n),
        null;
    case 5:
        Py(n);
        var h = du(vf.current);
        if (r = n.type,
        t !== null && n.stateNode != null)
            NE(t, n, r, s, h),
            t.ref !== n.ref && (n.flags |= 512,
            n.flags |= 2097152);
        else {
            if (!s) {
                if (n.stateNode === null)
                    throw Error(Ct(166));
                return Ys(n),
                null
            }
            if (t = du(nl.current),
            Jp(n)) {
                s = n.stateNode,
                r = n.type;
                var l = n.memoizedProps;
                switch (s[qa] = n,
                s[mf] = l,
                t = (n.mode & 1) !== 0,
                r) {
                case "dialog":
                    br("cancel", s),
                    br("close", s);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    br("load", s);
                    break;
                case "video":
                case "audio":
                    for (h = 0; h < Hd.length; h++)
                        br(Hd[h], s);
                    break;
                case "source":
                    br("error", s);
                    break;
                case "img":
                case "image":
                case "link":
                    br("error", s),
                    br("load", s);
                    break;
                case "details":
                    br("toggle", s);
                    break;
                case "input":
                    ow(s, l),
                    br("invalid", s);
                    break;
                case "select":
                    s._wrapperState = {
                        wasMultiple: !!l.multiple
                    },
                    br("invalid", s);
                    break;
                case "textarea":
                    lw(s, l),
                    br("invalid", s)
                }
                e_(r, l),
                h = null;
                for (var g in l)
                    if (l.hasOwnProperty(g)) {
                        var _ = l[g];
                        g === "children" ? typeof _ == "string" ? s.textContent !== _ && (l.suppressHydrationWarning !== !0 && qp(s.textContent, _, t),
                        h = ["children", _]) : typeof _ == "number" && s.textContent !== "" + _ && (l.suppressHydrationWarning !== !0 && qp(s.textContent, _, t),
                        h = ["children", "" + _]) : sf.hasOwnProperty(g) && _ != null && g === "onScroll" && br("scroll", s)
                    }
                switch (r) {
                case "input":
                    Vp(s),
                    aw(s, l, !0);
                    break;
                case "textarea":
                    Vp(s),
                    cw(s);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof l.onClick == "function" && (s.onclick = Om)
                }
                s = h,
                n.updateQueue = s,
                s !== null && (n.flags |= 4)
            } else {
                g = h.nodeType === 9 ? h : h.ownerDocument,
                t === "http://www.w3.org/1999/xhtml" && (t = fT(r)),
                t === "http://www.w3.org/1999/xhtml" ? r === "script" ? (t = g.createElement("div"),
                t.innerHTML = "<script><\/script>",
                t = t.removeChild(t.firstChild)) : typeof s.is == "string" ? t = g.createElement(r, {
                    is: s.is
                }) : (t = g.createElement(r),
                r === "select" && (g = t,
                s.multiple ? g.multiple = !0 : s.size && (g.size = s.size))) : t = g.createElementNS(t, r),
                t[qa] = n,
                t[mf] = s,
                UE(t, n, !1, !1),
                n.stateNode = t;
                e: {
                    switch (g = t_(r, s),
                    r) {
                    case "dialog":
                        br("cancel", t),
                        br("close", t),
                        h = s;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        br("load", t),
                        h = s;
                        break;
                    case "video":
                    case "audio":
                        for (h = 0; h < Hd.length; h++)
                            br(Hd[h], t);
                        h = s;
                        break;
                    case "source":
                        br("error", t),
                        h = s;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        br("error", t),
                        br("load", t),
                        h = s;
                        break;
                    case "details":
                        br("toggle", t),
                        h = s;
                        break;
                    case "input":
                        ow(t, s),
                        h = Kv(t, s),
                        br("invalid", t);
                        break;
                    case "option":
                        h = s;
                        break;
                    case "select":
                        t._wrapperState = {
                            wasMultiple: !!s.multiple
                        },
                        h = Br({}, s, {
                            value: void 0
                        }),
                        br("invalid", t);
                        break;
                    case "textarea":
                        lw(t, s),
                        h = Jv(t, s),
                        br("invalid", t);
                        break;
                    default:
                        h = s
                    }
                    e_(r, h),
                    _ = h;
                    for (l in _)
                        if (_.hasOwnProperty(l)) {
                            var A = _[l];
                            l === "style" ? gT(t, A) : l === "dangerouslySetInnerHTML" ? (A = A ? A.__html : void 0,
                            A != null && pT(t, A)) : l === "children" ? typeof A == "string" ? (r !== "textarea" || A !== "") && of(t, A) : typeof A == "number" && of(t, "" + A) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (sf.hasOwnProperty(l) ? A != null && l === "onScroll" && br("scroll", t) : A != null && oy(t, l, A, g))
                        }
                    switch (r) {
                    case "input":
                        Vp(t),
                        aw(t, s, !1);
                        break;
                    case "textarea":
                        Vp(t),
                        cw(t);
                        break;
                    case "option":
                        s.value != null && t.setAttribute("value", "" + Sc(s.value));
                        break;
                    case "select":
                        t.multiple = !!s.multiple,
                        l = s.value,
                        l != null ? _h(t, !!s.multiple, l, !1) : s.defaultValue != null && _h(t, !!s.multiple, s.defaultValue, !0);
                        break;
                    default:
                        typeof h.onClick == "function" && (t.onclick = Om)
                    }
                    switch (r) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        s = !!s.autoFocus;
                        break e;
                    case "img":
                        s = !0;
                        break e;
                    default:
                        s = !1
                    }
                }
                s && (n.flags |= 4)
            }
            n.ref !== null && (n.flags |= 512,
            n.flags |= 2097152)
        }
        return Ys(n),
        null;
    case 6:
        if (t && n.stateNode != null)
            zE(t, n, t.memoizedProps, s);
        else {
            if (typeof s != "string" && n.stateNode === null)
                throw Error(Ct(166));
            if (r = du(vf.current),
            du(nl.current),
            Jp(n)) {
                if (s = n.stateNode,
                r = n.memoizedProps,
                s[qa] = n,
                (l = s.nodeValue !== r) && (t = No,
                t !== null))
                    switch (t.tag) {
                    case 3:
                        qp(s.nodeValue, r, (t.mode & 1) !== 0);
                        break;
                    case 5:
                        t.memoizedProps.suppressHydrationWarning !== !0 && qp(s.nodeValue, r, (t.mode & 1) !== 0)
                    }
                l && (n.flags |= 4)
            } else
                s = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(s),
                s[qa] = n,
                n.stateNode = s
        }
        return Ys(n),
        null;
    case 13:
        if (wr(Lr),
        s = n.memoizedState,
        t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (Sr && Uo !== null && n.mode & 1 && !(n.flags & 128))
                iE(),
                Mh(),
                n.flags |= 98560,
                l = !1;
            else if (l = Jp(n),
            s !== null && s.dehydrated !== null) {
                if (t === null) {
                    if (!l)
                        throw Error(Ct(318));
                    if (l = n.memoizedState,
                    l = l !== null ? l.dehydrated : null,
                    !l)
                        throw Error(Ct(317));
                    l[qa] = n
                } else
                    Mh(),
                    !(n.flags & 128) && (n.memoizedState = null),
                    n.flags |= 4;
                Ys(n),
                l = !1
            } else
                Ra !== null && (B_(Ra),
                Ra = null),
                l = !0;
            if (!l)
                return n.flags & 65536 ? n : null
        }
        return n.flags & 128 ? (n.lanes = r,
        n) : (s = s !== null,
        s !== (t !== null && t.memoizedState !== null) && s && (n.child.flags |= 8192,
        n.mode & 1 && (t === null || Lr.current & 1 ? cs === 0 && (cs = 3) : Hy())),
        n.updateQueue !== null && (n.flags |= 4),
        Ys(n),
        null);
    case 4:
        return Ph(),
        M_(t, n),
        t === null && ff(n.stateNode.containerInfo),
        Ys(n),
        null;
    case 10:
        return Ty(n.type._context),
        Ys(n),
        null;
    case 17:
        return xo(n.type) && Bm(),
        Ys(n),
        null;
    case 19:
        if (wr(Lr),
        l = n.memoizedState,
        l === null)
            return Ys(n),
            null;
        if (s = (n.flags & 128) !== 0,
        g = l.rendering,
        g === null)
            if (s)
                Id(l, !1);
            else {
                if (cs !== 0 || t !== null && t.flags & 128)
                    for (t = n.child; t !== null; ) {
                        if (g = Hm(t),
                        g !== null) {
                            for (n.flags |= 128,
                            Id(l, !1),
                            s = g.updateQueue,
                            s !== null && (n.updateQueue = s,
                            n.flags |= 4),
                            n.subtreeFlags = 0,
                            s = r,
                            r = n.child; r !== null; )
                                l = r,
                                t = s,
                                l.flags &= 14680066,
                                g = l.alternate,
                                g === null ? (l.childLanes = 0,
                                l.lanes = t,
                                l.child = null,
                                l.subtreeFlags = 0,
                                l.memoizedProps = null,
                                l.memoizedState = null,
                                l.updateQueue = null,
                                l.dependencies = null,
                                l.stateNode = null) : (l.childLanes = g.childLanes,
                                l.lanes = g.lanes,
                                l.child = g.child,
                                l.subtreeFlags = 0,
                                l.deletions = null,
                                l.memoizedProps = g.memoizedProps,
                                l.memoizedState = g.memoizedState,
                                l.updateQueue = g.updateQueue,
                                l.type = g.type,
                                t = g.dependencies,
                                l.dependencies = t === null ? null : {
                                    lanes: t.lanes,
                                    firstContext: t.firstContext
                                }),
                                r = r.sibling;
                            return gr(Lr, Lr.current & 1 | 2),
                            n.child
                        }
                        t = t.sibling
                    }
                l.tail !== null && jr() > Dh && (n.flags |= 128,
                s = !0,
                Id(l, !1),
                n.lanes = 4194304)
            }
        else {
            if (!s)
                if (t = Hm(g),
                t !== null) {
                    if (n.flags |= 128,
                    s = !0,
                    r = t.updateQueue,
                    r !== null && (n.updateQueue = r,
                    n.flags |= 4),
                    Id(l, !0),
                    l.tail === null && l.tailMode === "hidden" && !g.alternate && !Sr)
                        return Ys(n),
                        null
                } else
                    2 * jr() - l.renderingStartTime > Dh && r !== 1073741824 && (n.flags |= 128,
                    s = !0,
                    Id(l, !1),
                    n.lanes = 4194304);
            l.isBackwards ? (g.sibling = n.child,
            n.child = g) : (r = l.last,
            r !== null ? r.sibling = g : n.child = g,
            l.last = g)
        }
        return l.tail !== null ? (n = l.tail,
        l.rendering = n,
        l.tail = n.sibling,
        l.renderingStartTime = jr(),
        n.sibling = null,
        r = Lr.current,
        gr(Lr, s ? r & 1 | 2 : r & 1),
        n) : (Ys(n),
        null);
    case 22:
    case 23:
        return Gy(),
        s = n.memoizedState !== null,
        t !== null && t.memoizedState !== null !== s && (n.flags |= 8192),
        s && n.mode & 1 ? ko & 1073741824 && (Ys(n),
        n.subtreeFlags & 6 && (n.flags |= 8192)) : Ys(n),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(Ct(156, n.tag))
}
function T3(t, n) {
    switch (by(n),
    n.tag) {
    case 1:
        return xo(n.type) && Bm(),
        t = n.flags,
        t & 65536 ? (n.flags = t & -65537 | 128,
        n) : null;
    case 3:
        return Ph(),
        wr(yo),
        wr(qs),
        Ry(),
        t = n.flags,
        t & 65536 && !(t & 128) ? (n.flags = t & -65537 | 128,
        n) : null;
    case 5:
        return Py(n),
        null;
    case 13:
        if (wr(Lr),
        t = n.memoizedState,
        t !== null && t.dehydrated !== null) {
            if (n.alternate === null)
                throw Error(Ct(340));
            Mh()
        }
        return t = n.flags,
        t & 65536 ? (n.flags = t & -65537 | 128,
        n) : null;
    case 19:
        return wr(Lr),
        null;
    case 4:
        return Ph(),
        null;
    case 10:
        return Ty(n.type._context),
        null;
    case 22:
    case 23:
        return Gy(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var tm = !1
  , Ks = !1
  , E3 = typeof WeakSet == "function" ? WeakSet : Set
  , wn = null;
function dh(t, n) {
    var r = t.ref;
    if (r !== null)
        if (typeof r == "function")
            try {
                r(null)
            } catch (s) {
                Nr(t, n, s)
            }
        else
            r.current = null
}
function C_(t, n, r) {
    try {
        r()
    } catch (s) {
        Nr(t, n, s)
    }
}
var Jw = !1;
function M3(t, n) {
    if (h_ = Dm,
    t = WT(),
    yy(t)) {
        if ("selectionStart"in t)
            var r = {
                start: t.selectionStart,
                end: t.selectionEnd
            };
        else
            e: {
                r = (r = t.ownerDocument) && r.defaultView || window;
                var s = r.getSelection && r.getSelection();
                if (s && s.rangeCount !== 0) {
                    r = s.anchorNode;
                    var h = s.anchorOffset
                      , l = s.focusNode;
                    s = s.focusOffset;
                    try {
                        r.nodeType,
                        l.nodeType
                    } catch {
                        r = null;
                        break e
                    }
                    var g = 0
                      , _ = -1
                      , A = -1
                      , m = 0
                      , D = 0
                      , U = t
                      , R = null;
                    t: for (; ; ) {
                        for (var ne; U !== r || h !== 0 && U.nodeType !== 3 || (_ = g + h),
                        U !== l || s !== 0 && U.nodeType !== 3 || (A = g + s),
                        U.nodeType === 3 && (g += U.nodeValue.length),
                        (ne = U.firstChild) !== null; )
                            R = U,
                            U = ne;
                        for (; ; ) {
                            if (U === t)
                                break t;
                            if (R === r && ++m === h && (_ = g),
                            R === l && ++D === s && (A = g),
                            (ne = U.nextSibling) !== null)
                                break;
                            U = R,
                            R = U.parentNode
                        }
                        U = ne
                    }
                    r = _ === -1 || A === -1 ? null : {
                        start: _,
                        end: A
                    }
                } else
                    r = null
            }
        r = r || {
            start: 0,
            end: 0
        }
    } else
        r = null;
    for (d_ = {
        focusedElem: t,
        selectionRange: r
    },
    Dm = !1,
    wn = n; wn !== null; )
        if (n = wn,
        t = n.child,
        (n.subtreeFlags & 1028) !== 0 && t !== null)
            t.return = n,
            wn = t;
        else
            for (; wn !== null; ) {
                n = wn;
                try {
                    var ce = n.alternate;
                    if (n.flags & 1024)
                        switch (n.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (ce !== null) {
                                var xe = ce.memoizedProps
                                  , Se = ce.memoizedState
                                  , $ = n.stateNode
                                  , q = $.getSnapshotBeforeUpdate(n.elementType === n.type ? xe : Ca(n.type, xe), Se);
                                $.__reactInternalSnapshotBeforeUpdate = q
                            }
                            break;
                        case 3:
                            var N = n.stateNode.containerInfo;
                            N.nodeType === 1 ? N.textContent = "" : N.nodeType === 9 && N.documentElement && N.removeChild(N.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(Ct(163))
                        }
                } catch (ie) {
                    Nr(n, n.return, ie)
                }
                if (t = n.sibling,
                t !== null) {
                    t.return = n.return,
                    wn = t;
                    break
                }
                wn = n.return
            }
    return ce = Jw,
    Jw = !1,
    ce
}
function Zd(t, n, r) {
    var s = n.updateQueue;
    if (s = s !== null ? s.lastEffect : null,
    s !== null) {
        var h = s = s.next;
        do {
            if ((h.tag & t) === t) {
                var l = h.destroy;
                h.destroy = void 0,
                l !== void 0 && C_(n, r, l)
            }
            h = h.next
        } while (h !== s)
    }
}
function fg(t, n) {
    if (n = n.updateQueue,
    n = n !== null ? n.lastEffect : null,
    n !== null) {
        var r = n = n.next;
        do {
            if ((r.tag & t) === t) {
                var s = r.create;
                r.destroy = s()
            }
            r = r.next
        } while (r !== n)
    }
}
function P_(t) {
    var n = t.ref;
    if (n !== null) {
        var r = t.stateNode;
        switch (t.tag) {
        case 5:
            t = r;
            break;
        default:
            t = r
        }
        typeof n == "function" ? n(t) : n.current = t
    }
}
function GE(t) {
    var n = t.alternate;
    n !== null && (t.alternate = null,
    GE(n)),
    t.child = null,
    t.deletions = null,
    t.sibling = null,
    t.tag === 5 && (n = t.stateNode,
    n !== null && (delete n[qa],
    delete n[mf],
    delete n[m_],
    delete n[c3],
    delete n[u3])),
    t.stateNode = null,
    t.return = null,
    t.dependencies = null,
    t.memoizedProps = null,
    t.memoizedState = null,
    t.pendingProps = null,
    t.stateNode = null,
    t.updateQueue = null
}
function HE(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4
}
function $w(t) {
    e: for (; ; ) {
        for (; t.sibling === null; ) {
            if (t.return === null || HE(t.return))
                return null;
            t = t.return
        }
        for (t.sibling.return = t.return,
        t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
            if (t.flags & 2 || t.child === null || t.tag === 4)
                continue e;
            t.child.return = t,
            t = t.child
        }
        if (!(t.flags & 2))
            return t.stateNode
    }
}
function R_(t, n, r) {
    var s = t.tag;
    if (s === 5 || s === 6)
        t = t.stateNode,
        n ? r.nodeType === 8 ? r.parentNode.insertBefore(t, n) : r.insertBefore(t, n) : (r.nodeType === 8 ? (n = r.parentNode,
        n.insertBefore(t, r)) : (n = r,
        n.appendChild(t)),
        r = r._reactRootContainer,
        r != null || n.onclick !== null || (n.onclick = Om));
    else if (s !== 4 && (t = t.child,
    t !== null))
        for (R_(t, n, r),
        t = t.sibling; t !== null; )
            R_(t, n, r),
            t = t.sibling
}
function D_(t, n, r) {
    var s = t.tag;
    if (s === 5 || s === 6)
        t = t.stateNode,
        n ? r.insertBefore(t, n) : r.appendChild(t);
    else if (s !== 4 && (t = t.child,
    t !== null))
        for (D_(t, n, r),
        t = t.sibling; t !== null; )
            D_(t, n, r),
            t = t.sibling
}
var Ps = null
  , Pa = !1;
function rc(t, n, r) {
    for (r = r.child; r !== null; )
        VE(t, n, r),
        r = r.sibling
}
function VE(t, n, r) {
    if (tl && typeof tl.onCommitFiberUnmount == "function")
        try {
            tl.onCommitFiberUnmount(sg, r)
        } catch {}
    switch (r.tag) {
    case 5:
        Ks || dh(r, n);
    case 6:
        var s = Ps
          , h = Pa;
        Ps = null,
        rc(t, n, r),
        Ps = s,
        Pa = h,
        Ps !== null && (Pa ? (t = Ps,
        r = r.stateNode,
        t.nodeType === 8 ? t.parentNode.removeChild(r) : t.removeChild(r)) : Ps.removeChild(r.stateNode));
        break;
    case 18:
        Ps !== null && (Pa ? (t = Ps,
        r = r.stateNode,
        t.nodeType === 8 ? pv(t.parentNode, r) : t.nodeType === 1 && pv(t, r),
        uf(t)) : pv(Ps, r.stateNode));
        break;
    case 4:
        s = Ps,
        h = Pa,
        Ps = r.stateNode.containerInfo,
        Pa = !0,
        rc(t, n, r),
        Ps = s,
        Pa = h;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!Ks && (s = r.updateQueue,
        s !== null && (s = s.lastEffect,
        s !== null))) {
            h = s = s.next;
            do {
                var l = h
                  , g = l.destroy;
                l = l.tag,
                g !== void 0 && (l & 2 || l & 4) && C_(r, n, g),
                h = h.next
            } while (h !== s)
        }
        rc(t, n, r);
        break;
    case 1:
        if (!Ks && (dh(r, n),
        s = r.stateNode,
        typeof s.componentWillUnmount == "function"))
            try {
                s.props = r.memoizedProps,
                s.state = r.memoizedState,
                s.componentWillUnmount()
            } catch (_) {
                Nr(r, n, _)
            }
        rc(t, n, r);
        break;
    case 21:
        rc(t, n, r);
        break;
    case 22:
        r.mode & 1 ? (Ks = (s = Ks) || r.memoizedState !== null,
        rc(t, n, r),
        Ks = s) : rc(t, n, r);
        break;
    default:
        rc(t, n, r)
    }
}
function eA(t) {
    var n = t.updateQueue;
    if (n !== null) {
        t.updateQueue = null;
        var r = t.stateNode;
        r === null && (r = t.stateNode = new E3),
        n.forEach(function(s) {
            var h = F3.bind(null, t, s);
            r.has(s) || (r.add(s),
            s.then(h, h))
        })
    }
}
function Ma(t, n) {
    var r = n.deletions;
    if (r !== null)
        for (var s = 0; s < r.length; s++) {
            var h = r[s];
            try {
                var l = t
                  , g = n
                  , _ = g;
                e: for (; _ !== null; ) {
                    switch (_.tag) {
                    case 5:
                        Ps = _.stateNode,
                        Pa = !1;
                        break e;
                    case 3:
                        Ps = _.stateNode.containerInfo,
                        Pa = !0;
                        break e;
                    case 4:
                        Ps = _.stateNode.containerInfo,
                        Pa = !0;
                        break e
                    }
                    _ = _.return
                }
                if (Ps === null)
                    throw Error(Ct(160));
                VE(l, g, h),
                Ps = null,
                Pa = !1;
                var A = h.alternate;
                A !== null && (A.return = null),
                h.return = null
            } catch (m) {
                Nr(h, n, m)
            }
        }
    if (n.subtreeFlags & 12854)
        for (n = n.child; n !== null; )
            WE(n, t),
            n = n.sibling
}
function WE(t, n) {
    var r = t.alternate
      , s = t.flags;
    switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (Ma(n, t),
        Qa(t),
        s & 4) {
            try {
                Zd(3, t, t.return),
                fg(3, t)
            } catch (xe) {
                Nr(t, t.return, xe)
            }
            try {
                Zd(5, t, t.return)
            } catch (xe) {
                Nr(t, t.return, xe)
            }
        }
        break;
    case 1:
        Ma(n, t),
        Qa(t),
        s & 512 && r !== null && dh(r, r.return);
        break;
    case 5:
        if (Ma(n, t),
        Qa(t),
        s & 512 && r !== null && dh(r, r.return),
        t.flags & 32) {
            var h = t.stateNode;
            try {
                of(h, "")
            } catch (xe) {
                Nr(t, t.return, xe)
            }
        }
        if (s & 4 && (h = t.stateNode,
        h != null)) {
            var l = t.memoizedProps
              , g = r !== null ? r.memoizedProps : l
              , _ = t.type
              , A = t.updateQueue;
            if (t.updateQueue = null,
            A !== null)
                try {
                    _ === "input" && l.type === "radio" && l.name != null && hT(h, l),
                    t_(_, g);
                    var m = t_(_, l);
                    for (g = 0; g < A.length; g += 2) {
                        var D = A[g]
                          , U = A[g + 1];
                        D === "style" ? gT(h, U) : D === "dangerouslySetInnerHTML" ? pT(h, U) : D === "children" ? of(h, U) : oy(h, D, U, m)
                    }
                    switch (_) {
                    case "input":
                        Zv(h, l);
                        break;
                    case "textarea":
                        dT(h, l);
                        break;
                    case "select":
                        var R = h._wrapperState.wasMultiple;
                        h._wrapperState.wasMultiple = !!l.multiple;
                        var ne = l.value;
                        ne != null ? _h(h, !!l.multiple, ne, !1) : R !== !!l.multiple && (l.defaultValue != null ? _h(h, !!l.multiple, l.defaultValue, !0) : _h(h, !!l.multiple, l.multiple ? [] : "", !1))
                    }
                    h[mf] = l
                } catch (xe) {
                    Nr(t, t.return, xe)
                }
        }
        break;
    case 6:
        if (Ma(n, t),
        Qa(t),
        s & 4) {
            if (t.stateNode === null)
                throw Error(Ct(162));
            h = t.stateNode,
            l = t.memoizedProps;
            try {
                h.nodeValue = l
            } catch (xe) {
                Nr(t, t.return, xe)
            }
        }
        break;
    case 3:
        if (Ma(n, t),
        Qa(t),
        s & 4 && r !== null && r.memoizedState.isDehydrated)
            try {
                uf(n.containerInfo)
            } catch (xe) {
                Nr(t, t.return, xe)
            }
        break;
    case 4:
        Ma(n, t),
        Qa(t);
        break;
    case 13:
        Ma(n, t),
        Qa(t),
        h = t.child,
        h.flags & 8192 && (l = h.memoizedState !== null,
        h.stateNode.isHidden = l,
        !l || h.alternate !== null && h.alternate.memoizedState !== null || (Ny = jr())),
        s & 4 && eA(t);
        break;
    case 22:
        if (D = r !== null && r.memoizedState !== null,
        t.mode & 1 ? (Ks = (m = Ks) || D,
        Ma(n, t),
        Ks = m) : Ma(n, t),
        Qa(t),
        s & 8192) {
            if (m = t.memoizedState !== null,
            (t.stateNode.isHidden = m) && !D && t.mode & 1)
                for (wn = t,
                D = t.child; D !== null; ) {
                    for (U = wn = D; wn !== null; ) {
                        switch (R = wn,
                        ne = R.child,
                        R.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Zd(4, R, R.return);
                            break;
                        case 1:
                            dh(R, R.return);
                            var ce = R.stateNode;
                            if (typeof ce.componentWillUnmount == "function") {
                                s = R,
                                r = R.return;
                                try {
                                    n = s,
                                    ce.props = n.memoizedProps,
                                    ce.state = n.memoizedState,
                                    ce.componentWillUnmount()
                                } catch (xe) {
                                    Nr(s, r, xe)
                                }
                            }
                            break;
                        case 5:
                            dh(R, R.return);
                            break;
                        case 22:
                            if (R.memoizedState !== null) {
                                nA(U);
                                continue
                            }
                        }
                        ne !== null ? (ne.return = R,
                        wn = ne) : nA(U)
                    }
                    D = D.sibling
                }
            e: for (D = null,
            U = t; ; ) {
                if (U.tag === 5) {
                    if (D === null) {
                        D = U;
                        try {
                            h = U.stateNode,
                            m ? (l = h.style,
                            typeof l.setProperty == "function" ? l.setProperty("display", "none", "important") : l.display = "none") : (_ = U.stateNode,
                            A = U.memoizedProps.style,
                            g = A != null && A.hasOwnProperty("display") ? A.display : null,
                            _.style.display = mT("display", g))
                        } catch (xe) {
                            Nr(t, t.return, xe)
                        }
                    }
                } else if (U.tag === 6) {
                    if (D === null)
                        try {
                            U.stateNode.nodeValue = m ? "" : U.memoizedProps
                        } catch (xe) {
                            Nr(t, t.return, xe)
                        }
                } else if ((U.tag !== 22 && U.tag !== 23 || U.memoizedState === null || U === t) && U.child !== null) {
                    U.child.return = U,
                    U = U.child;
                    continue
                }
                if (U === t)
                    break e;
                for (; U.sibling === null; ) {
                    if (U.return === null || U.return === t)
                        break e;
                    D === U && (D = null),
                    U = U.return
                }
                D === U && (D = null),
                U.sibling.return = U.return,
                U = U.sibling
            }
        }
        break;
    case 19:
        Ma(n, t),
        Qa(t),
        s & 4 && eA(t);
        break;
    case 21:
        break;
    default:
        Ma(n, t),
        Qa(t)
    }
}
function Qa(t) {
    var n = t.flags;
    if (n & 2) {
        try {
            e: {
                for (var r = t.return; r !== null; ) {
                    if (HE(r)) {
                        var s = r;
                        break e
                    }
                    r = r.return
                }
                throw Error(Ct(160))
            }
            switch (s.tag) {
            case 5:
                var h = s.stateNode;
                s.flags & 32 && (of(h, ""),
                s.flags &= -33);
                var l = $w(t);
                D_(t, l, h);
                break;
            case 3:
            case 4:
                var g = s.stateNode.containerInfo
                  , _ = $w(t);
                R_(t, _, g);
                break;
            default:
                throw Error(Ct(161))
            }
        } catch (A) {
            Nr(t, t.return, A)
        }
        t.flags &= -3
    }
    n & 4096 && (t.flags &= -4097)
}
function C3(t, n, r) {
    wn = t,
    jE(t)
}
function jE(t, n, r) {
    for (var s = (t.mode & 1) !== 0; wn !== null; ) {
        var h = wn
          , l = h.child;
        if (h.tag === 22 && s) {
            var g = h.memoizedState !== null || tm;
            if (!g) {
                var _ = h.alternate
                  , A = _ !== null && _.memoizedState !== null || Ks;
                _ = tm;
                var m = Ks;
                if (tm = g,
                (Ks = A) && !m)
                    for (wn = h; wn !== null; )
                        g = wn,
                        A = g.child,
                        g.tag === 22 && g.memoizedState !== null ? iA(h) : A !== null ? (A.return = g,
                        wn = A) : iA(h);
                for (; l !== null; )
                    wn = l,
                    jE(l),
                    l = l.sibling;
                wn = h,
                tm = _,
                Ks = m
            }
            tA(t)
        } else
            h.subtreeFlags & 8772 && l !== null ? (l.return = h,
            wn = l) : tA(t)
    }
}
function tA(t) {
    for (; wn !== null; ) {
        var n = wn;
        if (n.flags & 8772) {
            var r = n.alternate;
            try {
                if (n.flags & 8772)
                    switch (n.tag) {
                    case 0:
                    case 11:
                    case 15:
                        Ks || fg(5, n);
                        break;
                    case 1:
                        var s = n.stateNode;
                        if (n.flags & 4 && !Ks)
                            if (r === null)
                                s.componentDidMount();
                            else {
                                var h = n.elementType === n.type ? r.memoizedProps : Ca(n.type, r.memoizedProps);
                                s.componentDidUpdate(h, r.memoizedState, s.__reactInternalSnapshotBeforeUpdate)
                            }
                        var l = n.updateQueue;
                        l !== null && Uw(n, l, s);
                        break;
                    case 3:
                        var g = n.updateQueue;
                        if (g !== null) {
                            if (r = null,
                            n.child !== null)
                                switch (n.child.tag) {
                                case 5:
                                    r = n.child.stateNode;
                                    break;
                                case 1:
                                    r = n.child.stateNode
                                }
                            Uw(n, g, r)
                        }
                        break;
                    case 5:
                        var _ = n.stateNode;
                        if (r === null && n.flags & 4) {
                            r = _;
                            var A = n.memoizedProps;
                            switch (n.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                A.autoFocus && r.focus();
                                break;
                            case "img":
                                A.src && (r.src = A.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (n.memoizedState === null) {
                            var m = n.alternate;
                            if (m !== null) {
                                var D = m.memoizedState;
                                if (D !== null) {
                                    var U = D.dehydrated;
                                    U !== null && uf(U)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(Ct(163))
                    }
                Ks || n.flags & 512 && P_(n)
            } catch (R) {
                Nr(n, n.return, R)
            }
        }
        if (n === t) {
            wn = null;
            break
        }
        if (r = n.sibling,
        r !== null) {
            r.return = n.return,
            wn = r;
            break
        }
        wn = n.return
    }
}
function nA(t) {
    for (; wn !== null; ) {
        var n = wn;
        if (n === t) {
            wn = null;
            break
        }
        var r = n.sibling;
        if (r !== null) {
            r.return = n.return,
            wn = r;
            break
        }
        wn = n.return
    }
}
function iA(t) {
    for (; wn !== null; ) {
        var n = wn;
        try {
            switch (n.tag) {
            case 0:
            case 11:
            case 15:
                var r = n.return;
                try {
                    fg(4, n)
                } catch (A) {
                    Nr(n, r, A)
                }
                break;
            case 1:
                var s = n.stateNode;
                if (typeof s.componentDidMount == "function") {
                    var h = n.return;
                    try {
                        s.componentDidMount()
                    } catch (A) {
                        Nr(n, h, A)
                    }
                }
                var l = n.return;
                try {
                    P_(n)
                } catch (A) {
                    Nr(n, l, A)
                }
                break;
            case 5:
                var g = n.return;
                try {
                    P_(n)
                } catch (A) {
                    Nr(n, g, A)
                }
            }
        } catch (A) {
            Nr(n, n.return, A)
        }
        if (n === t) {
            wn = null;
            break
        }
        var _ = n.sibling;
        if (_ !== null) {
            _.return = n.return,
            wn = _;
            break
        }
        wn = n.return
    }
}
var P3 = Math.ceil
  , jm = Gl.ReactCurrentDispatcher
  , ky = Gl.ReactCurrentOwner
  , aa = Gl.ReactCurrentBatchConfig
  , Yi = 0
  , vs = null
  , es = null
  , Os = 0
  , ko = 0
  , fh = Dc(0)
  , cs = 0
  , bf = null
  , xu = 0
  , pg = 0
  , Uy = 0
  , qd = null
  , vo = null
  , Ny = 0
  , Dh = 1 / 0
  , Ml = null
  , Xm = !1
  , L_ = null
  , xc = null
  , nm = !1
  , pc = null
  , Ym = 0
  , Jd = 0
  , I_ = null
  , xm = -1
  , bm = 0;
function ao() {
    return Yi & 6 ? jr() : xm !== -1 ? xm : xm = jr()
}
function bc(t) {
    return t.mode & 1 ? Yi & 2 && Os !== 0 ? Os & -Os : d3.transition !== null ? (bm === 0 && (bm = CT()),
    bm) : (t = sr,
    t !== 0 || (t = window.event,
    t = t === void 0 ? 16 : BT(t.type)),
    t) : 1
}
function Ia(t, n, r, s) {
    if (50 < Jd)
        throw Jd = 0,
        I_ = null,
        Error(Ct(185));
    Pf(t, r, s),
    (!(Yi & 2) || t !== vs) && (t === vs && (!(Yi & 2) && (pg |= r),
    cs === 4 && dc(t, Os)),
    bo(t, s),
    r === 1 && Yi === 0 && !(n.mode & 1) && (Dh = jr() + 500,
    ug && Lc()))
}
function bo(t, n) {
    var r = t.callbackNode;
    dI(t, n);
    var s = Rm(t, t === vs ? Os : 0);
    if (s === 0)
        r !== null && dw(r),
        t.callbackNode = null,
        t.callbackPriority = 0;
    else if (n = s & -s,
    t.callbackPriority !== n) {
        if (r != null && dw(r),
        n === 1)
            t.tag === 0 ? h3(rA.bind(null, t)) : eE(rA.bind(null, t)),
            a3(function() {
                !(Yi & 6) && Lc()
            }),
            r = null;
        else {
            switch (PT(s)) {
            case 1:
                r = hy;
                break;
            case 4:
                r = ET;
                break;
            case 16:
                r = Pm;
                break;
            case 536870912:
                r = MT;
                break;
            default:
                r = Pm
            }
            r = $E(r, XE.bind(null, t))
        }
        t.callbackPriority = n,
        t.callbackNode = r
    }
}
function XE(t, n) {
    if (xm = -1,
    bm = 0,
    Yi & 6)
        throw Error(Ct(327));
    var r = t.callbackNode;
    if (Ah() && t.callbackNode !== r)
        return null;
    var s = Rm(t, t === vs ? Os : 0);
    if (s === 0)
        return null;
    if (s & 30 || s & t.expiredLanes || n)
        n = Qm(t, s);
    else {
        n = s;
        var h = Yi;
        Yi |= 2;
        var l = QE();
        (vs !== t || Os !== n) && (Ml = null,
        Dh = jr() + 500,
        pu(t, n));
        do
            try {
                L3();
                break
            } catch (_) {
                YE(t, _)
            }
        while (1);
        Sy(),
        jm.current = l,
        Yi = h,
        es !== null ? n = 0 : (vs = null,
        Os = 0,
        n = cs)
    }
    if (n !== 0) {
        if (n === 2 && (h = o_(t),
        h !== 0 && (s = h,
        n = O_(t, h))),
        n === 1)
            throw r = bf,
            pu(t, 0),
            dc(t, s),
            bo(t, jr()),
            r;
        if (n === 6)
            dc(t, s);
        else {
            if (h = t.current.alternate,
            !(s & 30) && !R3(h) && (n = Qm(t, s),
            n === 2 && (l = o_(t),
            l !== 0 && (s = l,
            n = O_(t, l))),
            n === 1))
                throw r = bf,
                pu(t, 0),
                dc(t, s),
                bo(t, jr()),
                r;
            switch (t.finishedWork = h,
            t.finishedLanes = s,
            n) {
            case 0:
            case 1:
                throw Error(Ct(345));
            case 2:
                ou(t, vo, Ml);
                break;
            case 3:
                if (dc(t, s),
                (s & 130023424) === s && (n = Ny + 500 - jr(),
                10 < n)) {
                    if (Rm(t, 0) !== 0)
                        break;
                    if (h = t.suspendedLanes,
                    (h & s) !== s) {
                        ao(),
                        t.pingedLanes |= t.suspendedLanes & h;
                        break
                    }
                    t.timeoutHandle = p_(ou.bind(null, t, vo, Ml), n);
                    break
                }
                ou(t, vo, Ml);
                break;
            case 4:
                if (dc(t, s),
                (s & 4194240) === s)
                    break;
                for (n = t.eventTimes,
                h = -1; 0 < s; ) {
                    var g = 31 - La(s);
                    l = 1 << g,
                    g = n[g],
                    g > h && (h = g),
                    s &= ~l
                }
                if (s = h,
                s = jr() - s,
                s = (120 > s ? 120 : 480 > s ? 480 : 1080 > s ? 1080 : 1920 > s ? 1920 : 3e3 > s ? 3e3 : 4320 > s ? 4320 : 1960 * P3(s / 1960)) - s,
                10 < s) {
                    t.timeoutHandle = p_(ou.bind(null, t, vo, Ml), s);
                    break
                }
                ou(t, vo, Ml);
                break;
            case 5:
                ou(t, vo, Ml);
                break;
            default:
                throw Error(Ct(329))
            }
        }
    }
    return bo(t, jr()),
    t.callbackNode === r ? XE.bind(null, t) : null
}
function O_(t, n) {
    var r = qd;
    return t.current.memoizedState.isDehydrated && (pu(t, n).flags |= 256),
    t = Qm(t, n),
    t !== 2 && (n = vo,
    vo = r,
    n !== null && B_(n)),
    t
}
function B_(t) {
    vo === null ? vo = t : vo.push.apply(vo, t)
}
function R3(t) {
    for (var n = t; ; ) {
        if (n.flags & 16384) {
            var r = n.updateQueue;
            if (r !== null && (r = r.stores,
            r !== null))
                for (var s = 0; s < r.length; s++) {
                    var h = r[s]
                      , l = h.getSnapshot;
                    h = h.value;
                    try {
                        if (!Oa(l(), h))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (r = n.child,
        n.subtreeFlags & 16384 && r !== null)
            r.return = n,
            n = r;
        else {
            if (n === t)
                break;
            for (; n.sibling === null; ) {
                if (n.return === null || n.return === t)
                    return !0;
                n = n.return
            }
            n.sibling.return = n.return,
            n = n.sibling
        }
    }
    return !0
}
function dc(t, n) {
    for (n &= ~Uy,
    n &= ~pg,
    t.suspendedLanes |= n,
    t.pingedLanes &= ~n,
    t = t.expirationTimes; 0 < n; ) {
        var r = 31 - La(n)
          , s = 1 << r;
        t[r] = -1,
        n &= ~s
    }
}
function rA(t) {
    if (Yi & 6)
        throw Error(Ct(327));
    Ah();
    var n = Rm(t, 0);
    if (!(n & 1))
        return bo(t, jr()),
        null;
    var r = Qm(t, n);
    if (t.tag !== 0 && r === 2) {
        var s = o_(t);
        s !== 0 && (n = s,
        r = O_(t, s))
    }
    if (r === 1)
        throw r = bf,
        pu(t, 0),
        dc(t, n),
        bo(t, jr()),
        r;
    if (r === 6)
        throw Error(Ct(345));
    return t.finishedWork = t.current.alternate,
    t.finishedLanes = n,
    ou(t, vo, Ml),
    bo(t, jr()),
    null
}
function zy(t, n) {
    var r = Yi;
    Yi |= 1;
    try {
        return t(n)
    } finally {
        Yi = r,
        Yi === 0 && (Dh = jr() + 500,
        ug && Lc())
    }
}
function bu(t) {
    pc !== null && pc.tag === 0 && !(Yi & 6) && Ah();
    var n = Yi;
    Yi |= 1;
    var r = aa.transition
      , s = sr;
    try {
        if (aa.transition = null,
        sr = 1,
        t)
            return t()
    } finally {
        sr = s,
        aa.transition = r,
        Yi = n,
        !(Yi & 6) && Lc()
    }
}
function Gy() {
    ko = fh.current,
    wr(fh)
}
function pu(t, n) {
    t.finishedWork = null,
    t.finishedLanes = 0;
    var r = t.timeoutHandle;
    if (r !== -1 && (t.timeoutHandle = -1,
    o3(r)),
    es !== null)
        for (r = es.return; r !== null; ) {
            var s = r;
            switch (by(s),
            s.tag) {
            case 1:
                s = s.type.childContextTypes,
                s != null && Bm();
                break;
            case 3:
                Ph(),
                wr(yo),
                wr(qs),
                Ry();
                break;
            case 5:
                Py(s);
                break;
            case 4:
                Ph();
                break;
            case 13:
                wr(Lr);
                break;
            case 19:
                wr(Lr);
                break;
            case 10:
                Ty(s.type._context);
                break;
            case 22:
            case 23:
                Gy()
            }
            r = r.return
        }
    if (vs = t,
    es = t = wc(t.current, null),
    Os = ko = n,
    cs = 0,
    bf = null,
    Uy = pg = xu = 0,
    vo = qd = null,
    hu !== null) {
        for (n = 0; n < hu.length; n++)
            if (r = hu[n],
            s = r.interleaved,
            s !== null) {
                r.interleaved = null;
                var h = s.next
                  , l = r.pending;
                if (l !== null) {
                    var g = l.next;
                    l.next = h,
                    s.next = g
                }
                r.pending = s
            }
        hu = null
    }
    return t
}
function YE(t, n) {
    do {
        var r = es;
        try {
            if (Sy(),
            vm.current = Wm,
            Vm) {
                for (var s = Or.memoizedState; s !== null; ) {
                    var h = s.queue;
                    h !== null && (h.pending = null),
                    s = s.next
                }
                Vm = !1
            }
            if (yu = 0,
            ms = ls = Or = null,
            Kd = !1,
            _f = 0,
            ky.current = null,
            r === null || r.return === null) {
                cs = 1,
                bf = n,
                es = null;
                break
            }
            e: {
                var l = t
                  , g = r.return
                  , _ = r
                  , A = n;
                if (n = Os,
                _.flags |= 32768,
                A !== null && typeof A == "object" && typeof A.then == "function") {
                    var m = A
                      , D = _
                      , U = D.tag;
                    if (!(D.mode & 1) && (U === 0 || U === 11 || U === 15)) {
                        var R = D.alternate;
                        R ? (D.updateQueue = R.updateQueue,
                        D.memoizedState = R.memoizedState,
                        D.lanes = R.lanes) : (D.updateQueue = null,
                        D.memoizedState = null)
                    }
                    var ne = jw(g);
                    if (ne !== null) {
                        ne.flags &= -257,
                        Xw(ne, g, _, l, n),
                        ne.mode & 1 && Ww(l, m, n),
                        n = ne,
                        A = m;
                        var ce = n.updateQueue;
                        if (ce === null) {
                            var xe = new Set;
                            xe.add(A),
                            n.updateQueue = xe
                        } else
                            ce.add(A);
                        break e
                    } else {
                        if (!(n & 1)) {
                            Ww(l, m, n),
                            Hy();
                            break e
                        }
                        A = Error(Ct(426))
                    }
                } else if (Sr && _.mode & 1) {
                    var Se = jw(g);
                    if (Se !== null) {
                        !(Se.flags & 65536) && (Se.flags |= 256),
                        Xw(Se, g, _, l, n),
                        wy(Rh(A, _));
                        break e
                    }
                }
                l = A = Rh(A, _),
                cs !== 4 && (cs = 2),
                qd === null ? qd = [l] : qd.push(l),
                l = g;
                do {
                    switch (l.tag) {
                    case 3:
                        l.flags |= 65536,
                        n &= -n,
                        l.lanes |= n;
                        var $ = RE(l, A, n);
                        kw(l, $);
                        break e;
                    case 1:
                        _ = A;
                        var q = l.type
                          , N = l.stateNode;
                        if (!(l.flags & 128) && (typeof q.getDerivedStateFromError == "function" || N !== null && typeof N.componentDidCatch == "function" && (xc === null || !xc.has(N)))) {
                            l.flags |= 65536,
                            n &= -n,
                            l.lanes |= n;
                            var ie = DE(l, _, n);
                            kw(l, ie);
                            break e
                        }
                    }
                    l = l.return
                } while (l !== null)
            }
            ZE(r)
        } catch (_e) {
            n = _e,
            es === r && r !== null && (es = r = r.return);
            continue
        }
        break
    } while (1)
}
function QE() {
    var t = jm.current;
    return jm.current = Wm,
    t === null ? Wm : t
}
function Hy() {
    (cs === 0 || cs === 3 || cs === 2) && (cs = 4),
    vs === null || !(xu & 268435455) && !(pg & 268435455) || dc(vs, Os)
}
function Qm(t, n) {
    var r = Yi;
    Yi |= 2;
    var s = QE();
    (vs !== t || Os !== n) && (Ml = null,
    pu(t, n));
    do
        try {
            D3();
            break
        } catch (h) {
            YE(t, h)
        }
    while (1);
    if (Sy(),
    Yi = r,
    jm.current = s,
    es !== null)
        throw Error(Ct(261));
    return vs = null,
    Os = 0,
    cs
}
function D3() {
    for (; es !== null; )
        KE(es)
}
function L3() {
    for (; es !== null && !iI(); )
        KE(es)
}
function KE(t) {
    var n = JE(t.alternate, t, ko);
    t.memoizedProps = t.pendingProps,
    n === null ? ZE(t) : es = n,
    ky.current = null
}
function ZE(t) {
    var n = t;
    do {
        var r = n.alternate;
        if (t = n.return,
        n.flags & 32768) {
            if (r = T3(r, n),
            r !== null) {
                r.flags &= 32767,
                es = r;
                return
            }
            if (t !== null)
                t.flags |= 32768,
                t.subtreeFlags = 0,
                t.deletions = null;
            else {
                cs = 6,
                es = null;
                return
            }
        } else if (r = S3(r, n, ko),
        r !== null) {
            es = r;
            return
        }
        if (n = n.sibling,
        n !== null) {
            es = n;
            return
        }
        es = n = t
    } while (n !== null);
    cs === 0 && (cs = 5)
}
function ou(t, n, r) {
    var s = sr
      , h = aa.transition;
    try {
        aa.transition = null,
        sr = 1,
        I3(t, n, r, s)
    } finally {
        aa.transition = h,
        sr = s
    }
    return null
}
function I3(t, n, r, s) {
    do
        Ah();
    while (pc !== null);
    if (Yi & 6)
        throw Error(Ct(327));
    r = t.finishedWork;
    var h = t.finishedLanes;
    if (r === null)
        return null;
    if (t.finishedWork = null,
    t.finishedLanes = 0,
    r === t.current)
        throw Error(Ct(177));
    t.callbackNode = null,
    t.callbackPriority = 0;
    var l = r.lanes | r.childLanes;
    if (fI(t, l),
    t === vs && (es = vs = null,
    Os = 0),
    !(r.subtreeFlags & 2064) && !(r.flags & 2064) || nm || (nm = !0,
    $E(Pm, function() {
        return Ah(),
        null
    })),
    l = (r.flags & 15990) !== 0,
    r.subtreeFlags & 15990 || l) {
        l = aa.transition,
        aa.transition = null;
        var g = sr;
        sr = 1;
        var _ = Yi;
        Yi |= 4,
        ky.current = null,
        M3(t, r),
        WE(r, t),
        $I(d_),
        Dm = !!h_,
        d_ = h_ = null,
        t.current = r,
        C3(r),
        rI(),
        Yi = _,
        sr = g,
        aa.transition = l
    } else
        t.current = r;
    if (nm && (nm = !1,
    pc = t,
    Ym = h),
    l = t.pendingLanes,
    l === 0 && (xc = null),
    aI(r.stateNode),
    bo(t, jr()),
    n !== null)
        for (s = t.onRecoverableError,
        r = 0; r < n.length; r++)
            h = n[r],
            s(h.value, {
                componentStack: h.stack,
                digest: h.digest
            });
    if (Xm)
        throw Xm = !1,
        t = L_,
        L_ = null,
        t;
    return Ym & 1 && t.tag !== 0 && Ah(),
    l = t.pendingLanes,
    l & 1 ? t === I_ ? Jd++ : (Jd = 0,
    I_ = t) : Jd = 0,
    Lc(),
    null
}
function Ah() {
    if (pc !== null) {
        var t = PT(Ym)
          , n = aa.transition
          , r = sr;
        try {
            if (aa.transition = null,
            sr = 16 > t ? 16 : t,
            pc === null)
                var s = !1;
            else {
                if (t = pc,
                pc = null,
                Ym = 0,
                Yi & 6)
                    throw Error(Ct(331));
                var h = Yi;
                for (Yi |= 4,
                wn = t.current; wn !== null; ) {
                    var l = wn
                      , g = l.child;
                    if (wn.flags & 16) {
                        var _ = l.deletions;
                        if (_ !== null) {
                            for (var A = 0; A < _.length; A++) {
                                var m = _[A];
                                for (wn = m; wn !== null; ) {
                                    var D = wn;
                                    switch (D.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Zd(8, D, l)
                                    }
                                    var U = D.child;
                                    if (U !== null)
                                        U.return = D,
                                        wn = U;
                                    else
                                        for (; wn !== null; ) {
                                            D = wn;
                                            var R = D.sibling
                                              , ne = D.return;
                                            if (GE(D),
                                            D === m) {
                                                wn = null;
                                                break
                                            }
                                            if (R !== null) {
                                                R.return = ne,
                                                wn = R;
                                                break
                                            }
                                            wn = ne
                                        }
                                }
                            }
                            var ce = l.alternate;
                            if (ce !== null) {
                                var xe = ce.child;
                                if (xe !== null) {
                                    ce.child = null;
                                    do {
                                        var Se = xe.sibling;
                                        xe.sibling = null,
                                        xe = Se
                                    } while (xe !== null)
                                }
                            }
                            wn = l
                        }
                    }
                    if (l.subtreeFlags & 2064 && g !== null)
                        g.return = l,
                        wn = g;
                    else
                        e: for (; wn !== null; ) {
                            if (l = wn,
                            l.flags & 2048)
                                switch (l.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Zd(9, l, l.return)
                                }
                            var $ = l.sibling;
                            if ($ !== null) {
                                $.return = l.return,
                                wn = $;
                                break e
                            }
                            wn = l.return
                        }
                }
                var q = t.current;
                for (wn = q; wn !== null; ) {
                    g = wn;
                    var N = g.child;
                    if (g.subtreeFlags & 2064 && N !== null)
                        N.return = g,
                        wn = N;
                    else
                        e: for (g = q; wn !== null; ) {
                            if (_ = wn,
                            _.flags & 2048)
                                try {
                                    switch (_.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        fg(9, _)
                                    }
                                } catch (_e) {
                                    Nr(_, _.return, _e)
                                }
                            if (_ === g) {
                                wn = null;
                                break e
                            }
                            var ie = _.sibling;
                            if (ie !== null) {
                                ie.return = _.return,
                                wn = ie;
                                break e
                            }
                            wn = _.return
                        }
                }
                if (Yi = h,
                Lc(),
                tl && typeof tl.onPostCommitFiberRoot == "function")
                    try {
                        tl.onPostCommitFiberRoot(sg, t)
                    } catch {}
                s = !0
            }
            return s
        } finally {
            sr = r,
            aa.transition = n
        }
    }
    return !1
}
function sA(t, n, r) {
    n = Rh(r, n),
    n = RE(t, n, 1),
    t = yc(t, n, 1),
    n = ao(),
    t !== null && (Pf(t, 1, n),
    bo(t, n))
}
function Nr(t, n, r) {
    if (t.tag === 3)
        sA(t, t, r);
    else
        for (; n !== null; ) {
            if (n.tag === 3) {
                sA(n, t, r);
                break
            } else if (n.tag === 1) {
                var s = n.stateNode;
                if (typeof n.type.getDerivedStateFromError == "function" || typeof s.componentDidCatch == "function" && (xc === null || !xc.has(s))) {
                    t = Rh(r, t),
                    t = DE(n, t, 1),
                    n = yc(n, t, 1),
                    t = ao(),
                    n !== null && (Pf(n, 1, t),
                    bo(n, t));
                    break
                }
            }
            n = n.return
        }
}
function O3(t, n, r) {
    var s = t.pingCache;
    s !== null && s.delete(n),
    n = ao(),
    t.pingedLanes |= t.suspendedLanes & r,
    vs === t && (Os & r) === r && (cs === 4 || cs === 3 && (Os & 130023424) === Os && 500 > jr() - Ny ? pu(t, 0) : Uy |= r),
    bo(t, n)
}
function qE(t, n) {
    n === 0 && (t.mode & 1 ? (n = Xp,
    Xp <<= 1,
    !(Xp & 130023424) && (Xp = 4194304)) : n = 1);
    var r = ao();
    t = Nl(t, n),
    t !== null && (Pf(t, n, r),
    bo(t, r))
}
function B3(t) {
    var n = t.memoizedState
      , r = 0;
    n !== null && (r = n.retryLane),
    qE(t, r)
}
function F3(t, n) {
    var r = 0;
    switch (t.tag) {
    case 13:
        var s = t.stateNode
          , h = t.memoizedState;
        h !== null && (r = h.retryLane);
        break;
    case 19:
        s = t.stateNode;
        break;
    default:
        throw Error(Ct(314))
    }
    s !== null && s.delete(n),
    qE(t, r)
}
var JE;
JE = function(t, n, r) {
    if (t !== null)
        if (t.memoizedProps !== n.pendingProps || yo.current)
            _o = !0;
        else {
            if (!(t.lanes & r) && !(n.flags & 128))
                return _o = !1,
                A3(t, n, r);
            _o = !!(t.flags & 131072)
        }
    else
        _o = !1,
        Sr && n.flags & 1048576 && tE(n, Um, n.index);
    switch (n.lanes = 0,
    n.tag) {
    case 2:
        var s = n.type;
        ym(t, n),
        t = n.pendingProps;
        var h = Eh(n, qs.current);
        wh(n, r),
        h = Ly(null, n, s, t, h, r);
        var l = Iy();
        return n.flags |= 1,
        typeof h == "object" && h !== null && typeof h.render == "function" && h.$$typeof === void 0 ? (n.tag = 1,
        n.memoizedState = null,
        n.updateQueue = null,
        xo(s) ? (l = !0,
        Fm(n)) : l = !1,
        n.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null,
        My(n),
        h.updater = hg,
        n.stateNode = h,
        h._reactInternals = n,
        b_(n, s, t, r),
        n = S_(null, n, s, !0, l, r)) : (n.tag = 0,
        Sr && l && xy(n),
        so(null, n, h, r),
        n = n.child),
        n;
    case 16:
        s = n.elementType;
        e: {
            switch (ym(t, n),
            t = n.pendingProps,
            h = s._init,
            s = h(s._payload),
            n.type = s,
            h = n.tag = U3(s),
            t = Ca(s, t),
            h) {
            case 0:
                n = A_(null, n, s, t, r);
                break e;
            case 1:
                n = Kw(null, n, s, t, r);
                break e;
            case 11:
                n = Yw(null, n, s, t, r);
                break e;
            case 14:
                n = Qw(null, n, s, Ca(s.type, t), r);
                break e
            }
            throw Error(Ct(306, s, ""))
        }
        return n;
    case 0:
        return s = n.type,
        h = n.pendingProps,
        h = n.elementType === s ? h : Ca(s, h),
        A_(t, n, s, h, r);
    case 1:
        return s = n.type,
        h = n.pendingProps,
        h = n.elementType === s ? h : Ca(s, h),
        Kw(t, n, s, h, r);
    case 3:
        e: {
            if (BE(n),
            t === null)
                throw Error(Ct(387));
            s = n.pendingProps,
            l = n.memoizedState,
            h = l.element,
            sE(t, n),
            Gm(n, s, null, r);
            var g = n.memoizedState;
            if (s = g.element,
            l.isDehydrated)
                if (l = {
                    element: s,
                    isDehydrated: !1,
                    cache: g.cache,
                    pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                    transitions: g.transitions
                },
                n.updateQueue.baseState = l,
                n.memoizedState = l,
                n.flags & 256) {
                    h = Rh(Error(Ct(423)), n),
                    n = Zw(t, n, s, r, h);
                    break e
                } else if (s !== h) {
                    h = Rh(Error(Ct(424)), n),
                    n = Zw(t, n, s, r, h);
                    break e
                } else
                    for (Uo = _c(n.stateNode.containerInfo.firstChild),
                    No = n,
                    Sr = !0,
                    Ra = null,
                    r = cE(n, null, s, r),
                    n.child = r; r; )
                        r.flags = r.flags & -3 | 4096,
                        r = r.sibling;
            else {
                if (Mh(),
                s === h) {
                    n = zl(t, n, r);
                    break e
                }
                so(t, n, s, r)
            }
            n = n.child
        }
        return n;
    case 5:
        return uE(n),
        t === null && __(n),
        s = n.type,
        h = n.pendingProps,
        l = t !== null ? t.memoizedProps : null,
        g = h.children,
        f_(s, h) ? g = null : l !== null && f_(s, l) && (n.flags |= 32),
        OE(t, n),
        so(t, n, g, r),
        n.child;
    case 6:
        return t === null && __(n),
        null;
    case 13:
        return FE(t, n, r);
    case 4:
        return Cy(n, n.stateNode.containerInfo),
        s = n.pendingProps,
        t === null ? n.child = Ch(n, null, s, r) : so(t, n, s, r),
        n.child;
    case 11:
        return s = n.type,
        h = n.pendingProps,
        h = n.elementType === s ? h : Ca(s, h),
        Yw(t, n, s, h, r);
    case 7:
        return so(t, n, n.pendingProps, r),
        n.child;
    case 8:
        return so(t, n, n.pendingProps.children, r),
        n.child;
    case 12:
        return so(t, n, n.pendingProps.children, r),
        n.child;
    case 10:
        e: {
            if (s = n.type._context,
            h = n.pendingProps,
            l = n.memoizedProps,
            g = h.value,
            gr(Nm, s._currentValue),
            s._currentValue = g,
            l !== null)
                if (Oa(l.value, g)) {
                    if (l.children === h.children && !yo.current) {
                        n = zl(t, n, r);
                        break e
                    }
                } else
                    for (l = n.child,
                    l !== null && (l.return = n); l !== null; ) {
                        var _ = l.dependencies;
                        if (_ !== null) {
                            g = l.child;
                            for (var A = _.firstContext; A !== null; ) {
                                if (A.context === s) {
                                    if (l.tag === 1) {
                                        A = Ll(-1, r & -r),
                                        A.tag = 2;
                                        var m = l.updateQueue;
                                        if (m !== null) {
                                            m = m.shared;
                                            var D = m.pending;
                                            D === null ? A.next = A : (A.next = D.next,
                                            D.next = A),
                                            m.pending = A
                                        }
                                    }
                                    l.lanes |= r,
                                    A = l.alternate,
                                    A !== null && (A.lanes |= r),
                                    y_(l.return, r, n),
                                    _.lanes |= r;
                                    break
                                }
                                A = A.next
                            }
                        } else if (l.tag === 10)
                            g = l.type === n.type ? null : l.child;
                        else if (l.tag === 18) {
                            if (g = l.return,
                            g === null)
                                throw Error(Ct(341));
                            g.lanes |= r,
                            _ = g.alternate,
                            _ !== null && (_.lanes |= r),
                            y_(g, r, n),
                            g = l.sibling
                        } else
                            g = l.child;
                        if (g !== null)
                            g.return = l;
                        else
                            for (g = l; g !== null; ) {
                                if (g === n) {
                                    g = null;
                                    break
                                }
                                if (l = g.sibling,
                                l !== null) {
                                    l.return = g.return,
                                    g = l;
                                    break
                                }
                                g = g.return
                            }
                        l = g
                    }
            so(t, n, h.children, r),
            n = n.child
        }
        return n;
    case 9:
        return h = n.type,
        s = n.pendingProps.children,
        wh(n, r),
        h = la(h),
        s = s(h),
        n.flags |= 1,
        so(t, n, s, r),
        n.child;
    case 14:
        return s = n.type,
        h = Ca(s, n.pendingProps),
        h = Ca(s.type, h),
        Qw(t, n, s, h, r);
    case 15:
        return LE(t, n, n.type, n.pendingProps, r);
    case 17:
        return s = n.type,
        h = n.pendingProps,
        h = n.elementType === s ? h : Ca(s, h),
        ym(t, n),
        n.tag = 1,
        xo(s) ? (t = !0,
        Fm(n)) : t = !1,
        wh(n, r),
        aE(n, s, h),
        b_(n, s, h, r),
        S_(null, n, s, !0, t, r);
    case 19:
        return kE(t, n, r);
    case 22:
        return IE(t, n, r)
    }
    throw Error(Ct(156, n.tag))
}
;
function $E(t, n) {
    return TT(t, n)
}
function k3(t, n, r, s) {
    this.tag = t,
    this.key = r,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = n,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = s,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function oa(t, n, r, s) {
    return new k3(t,n,r,s)
}
function Vy(t) {
    return t = t.prototype,
    !(!t || !t.isReactComponent)
}
function U3(t) {
    if (typeof t == "function")
        return Vy(t) ? 1 : 0;
    if (t != null) {
        if (t = t.$$typeof,
        t === ly)
            return 11;
        if (t === cy)
            return 14
    }
    return 2
}
function wc(t, n) {
    var r = t.alternate;
    return r === null ? (r = oa(t.tag, n, t.key, t.mode),
    r.elementType = t.elementType,
    r.type = t.type,
    r.stateNode = t.stateNode,
    r.alternate = t,
    t.alternate = r) : (r.pendingProps = n,
    r.type = t.type,
    r.flags = 0,
    r.subtreeFlags = 0,
    r.deletions = null),
    r.flags = t.flags & 14680064,
    r.childLanes = t.childLanes,
    r.lanes = t.lanes,
    r.child = t.child,
    r.memoizedProps = t.memoizedProps,
    r.memoizedState = t.memoizedState,
    r.updateQueue = t.updateQueue,
    n = t.dependencies,
    r.dependencies = n === null ? null : {
        lanes: n.lanes,
        firstContext: n.firstContext
    },
    r.sibling = t.sibling,
    r.index = t.index,
    r.ref = t.ref,
    r
}
function wm(t, n, r, s, h, l) {
    var g = 2;
    if (s = t,
    typeof t == "function")
        Vy(t) && (g = 1);
    else if (typeof t == "string")
        g = 5;
    else
        e: switch (t) {
        case ih:
            return mu(r.children, h, l, n);
        case ay:
            g = 8,
            h |= 8;
            break;
        case jv:
            return t = oa(12, r, n, h | 2),
            t.elementType = jv,
            t.lanes = l,
            t;
        case Xv:
            return t = oa(13, r, n, h),
            t.elementType = Xv,
            t.lanes = l,
            t;
        case Yv:
            return t = oa(19, r, n, h),
            t.elementType = Yv,
            t.lanes = l,
            t;
        case lT:
            return mg(r, h, l, n);
        default:
            if (typeof t == "object" && t !== null)
                switch (t.$$typeof) {
                case oT:
                    g = 10;
                    break e;
                case aT:
                    g = 9;
                    break e;
                case ly:
                    g = 11;
                    break e;
                case cy:
                    g = 14;
                    break e;
                case lc:
                    g = 16,
                    s = null;
                    break e
                }
            throw Error(Ct(130, t == null ? t : typeof t, ""))
        }
    return n = oa(g, r, n, h),
    n.elementType = t,
    n.type = s,
    n.lanes = l,
    n
}
function mu(t, n, r, s) {
    return t = oa(7, t, s, n),
    t.lanes = r,
    t
}
function mg(t, n, r, s) {
    return t = oa(22, t, s, n),
    t.elementType = lT,
    t.lanes = r,
    t.stateNode = {
        isHidden: !1
    },
    t
}
function wv(t, n, r) {
    return t = oa(6, t, null, n),
    t.lanes = r,
    t
}
function Av(t, n, r) {
    return n = oa(4, t.children !== null ? t.children : [], t.key, n),
    n.lanes = r,
    n.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
    },
    n
}
function N3(t, n, r, s, h) {
    this.tag = n,
    this.containerInfo = t,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = iv(0),
    this.expirationTimes = iv(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = iv(0),
    this.identifierPrefix = s,
    this.onRecoverableError = h,
    this.mutableSourceEagerHydrationData = null
}
function Wy(t, n, r, s, h, l, g, _, A) {
    return t = new N3(t,n,r,_,A),
    n === 1 ? (n = 1,
    l === !0 && (n |= 8)) : n = 0,
    l = oa(3, null, null, n),
    t.current = l,
    l.stateNode = t,
    l.memoizedState = {
        element: s,
        isDehydrated: r,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    My(l),
    t
}
function z3(t, n, r) {
    var s = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: nh,
        key: s == null ? null : "" + s,
        children: t,
        containerInfo: n,
        implementation: r
    }
}
function eM(t) {
    if (!t)
        return Tc;
    t = t._reactInternals;
    e: {
        if (Au(t) !== t || t.tag !== 1)
            throw Error(Ct(170));
        var n = t;
        do {
            switch (n.tag) {
            case 3:
                n = n.stateNode.context;
                break e;
            case 1:
                if (xo(n.type)) {
                    n = n.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            n = n.return
        } while (n !== null);
        throw Error(Ct(171))
    }
    if (t.tag === 1) {
        var r = t.type;
        if (xo(r))
            return $T(t, r, n)
    }
    return n
}
function tM(t, n, r, s, h, l, g, _, A) {
    return t = Wy(r, s, !0, t, h, l, g, _, A),
    t.context = eM(null),
    r = t.current,
    s = ao(),
    h = bc(r),
    l = Ll(s, h),
    l.callback = n ?? null,
    yc(r, l, h),
    t.current.lanes = h,
    Pf(t, h, s),
    bo(t, s),
    t
}
function gg(t, n, r, s) {
    var h = n.current
      , l = ao()
      , g = bc(h);
    return r = eM(r),
    n.context === null ? n.context = r : n.pendingContext = r,
    n = Ll(l, g),
    n.payload = {
        element: t
    },
    s = s === void 0 ? null : s,
    s !== null && (n.callback = s),
    t = yc(h, n, g),
    t !== null && (Ia(t, h, g, l),
    gm(t, h, g)),
    g
}
function Km(t) {
    if (t = t.current,
    !t.child)
        return null;
    switch (t.child.tag) {
    case 5:
        return t.child.stateNode;
    default:
        return t.child.stateNode
    }
}
function oA(t, n) {
    if (t = t.memoizedState,
    t !== null && t.dehydrated !== null) {
        var r = t.retryLane;
        t.retryLane = r !== 0 && r < n ? r : n
    }
}
function jy(t, n) {
    oA(t, n),
    (t = t.alternate) && oA(t, n)
}
function G3() {
    return null
}
var nM = typeof reportError == "function" ? reportError : function(t) {
    console.error(t)
}
;
function Xy(t) {
    this._internalRoot = t
}
vg.prototype.render = Xy.prototype.render = function(t) {
    var n = this._internalRoot;
    if (n === null)
        throw Error(Ct(409));
    gg(t, n, null, null)
}
;
vg.prototype.unmount = Xy.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
        this._internalRoot = null;
        var n = t.containerInfo;
        bu(function() {
            gg(null, t, null, null)
        }),
        n[Ul] = null
    }
}
;
function vg(t) {
    this._internalRoot = t
}
vg.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
        var n = LT();
        t = {
            blockedOn: null,
            target: t,
            priority: n
        };
        for (var r = 0; r < hc.length && n !== 0 && n < hc[r].priority; r++)
            ;
        hc.splice(r, 0, t),
        r === 0 && OT(t)
    }
}
;
function Yy(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}
function _g(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}
function aA() {}
function H3(t, n, r, s, h) {
    if (h) {
        if (typeof s == "function") {
            var l = s;
            s = function() {
                var m = Km(g);
                l.call(m)
            }
        }
        var g = tM(n, s, t, 0, null, !1, !1, "", aA);
        return t._reactRootContainer = g,
        t[Ul] = g.current,
        ff(t.nodeType === 8 ? t.parentNode : t),
        bu(),
        g
    }
    for (; h = t.lastChild; )
        t.removeChild(h);
    if (typeof s == "function") {
        var _ = s;
        s = function() {
            var m = Km(A);
            _.call(m)
        }
    }
    var A = Wy(t, 0, !1, null, null, !1, !1, "", aA);
    return t._reactRootContainer = A,
    t[Ul] = A.current,
    ff(t.nodeType === 8 ? t.parentNode : t),
    bu(function() {
        gg(n, A, r, s)
    }),
    A
}
function yg(t, n, r, s, h) {
    var l = r._reactRootContainer;
    if (l) {
        var g = l;
        if (typeof h == "function") {
            var _ = h;
            h = function() {
                var A = Km(g);
                _.call(A)
            }
        }
        gg(n, g, t, h)
    } else
        g = H3(r, n, t, h, s);
    return Km(g)
}
RT = function(t) {
    switch (t.tag) {
    case 3:
        var n = t.stateNode;
        if (n.current.memoizedState.isDehydrated) {
            var r = Gd(n.pendingLanes);
            r !== 0 && (dy(n, r | 1),
            bo(n, jr()),
            !(Yi & 6) && (Dh = jr() + 500,
            Lc()))
        }
        break;
    case 13:
        bu(function() {
            var s = Nl(t, 1);
            if (s !== null) {
                var h = ao();
                Ia(s, t, 1, h)
            }
        }),
        jy(t, 1)
    }
}
;
fy = function(t) {
    if (t.tag === 13) {
        var n = Nl(t, 134217728);
        if (n !== null) {
            var r = ao();
            Ia(n, t, 134217728, r)
        }
        jy(t, 134217728)
    }
}
;
DT = function(t) {
    if (t.tag === 13) {
        var n = bc(t)
          , r = Nl(t, n);
        if (r !== null) {
            var s = ao();
            Ia(r, t, n, s)
        }
        jy(t, n)
    }
}
;
LT = function() {
    return sr
}
;
IT = function(t, n) {
    var r = sr;
    try {
        return sr = t,
        n()
    } finally {
        sr = r
    }
}
;
i_ = function(t, n, r) {
    switch (n) {
    case "input":
        if (Zv(t, r),
        n = r.name,
        r.type === "radio" && n != null) {
            for (r = t; r.parentNode; )
                r = r.parentNode;
            for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + n) + '][type="radio"]'),
            n = 0; n < r.length; n++) {
                var s = r[n];
                if (s !== t && s.form === t.form) {
                    var h = cg(s);
                    if (!h)
                        throw Error(Ct(90));
                    uT(s),
                    Zv(s, h)
                }
            }
        }
        break;
    case "textarea":
        dT(t, r);
        break;
    case "select":
        n = r.value,
        n != null && _h(t, !!r.multiple, n, !1)
    }
}
;
yT = zy;
xT = bu;
var V3 = {
    usingClientEntryPoint: !1,
    Events: [Df, ah, cg, vT, _T, zy]
}
  , Od = {
    findFiberByHostInstance: uu,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
}
  , W3 = {
    bundleType: Od.bundleType,
    version: Od.version,
    rendererPackageName: Od.rendererPackageName,
    rendererConfig: Od.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Gl.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(t) {
        return t = AT(t),
        t === null ? null : t.stateNode
    },
    findFiberByHostInstance: Od.findFiberByHostInstance || G3,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var im = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!im.isDisabled && im.supportsFiber)
        try {
            sg = im.inject(W3),
            tl = im
        } catch {}
}
Ho.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = V3;
Ho.createPortal = function(t, n) {
    var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Yy(n))
        throw Error(Ct(200));
    return z3(t, n, null, r)
}
;
Ho.createRoot = function(t, n) {
    if (!Yy(t))
        throw Error(Ct(299));
    var r = !1
      , s = ""
      , h = nM;
    return n != null && (n.unstable_strictMode === !0 && (r = !0),
    n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
    n.onRecoverableError !== void 0 && (h = n.onRecoverableError)),
    n = Wy(t, 1, !1, null, null, r, !1, s, h),
    t[Ul] = n.current,
    ff(t.nodeType === 8 ? t.parentNode : t),
    new Xy(n)
}
;
Ho.findDOMNode = function(t) {
    if (t == null)
        return null;
    if (t.nodeType === 1)
        return t;
    var n = t._reactInternals;
    if (n === void 0)
        throw typeof t.render == "function" ? Error(Ct(188)) : (t = Object.keys(t).join(","),
        Error(Ct(268, t)));
    return t = AT(n),
    t = t === null ? null : t.stateNode,
    t
}
;
Ho.flushSync = function(t) {
    return bu(t)
}
;
Ho.hydrate = function(t, n, r) {
    if (!_g(n))
        throw Error(Ct(200));
    return yg(null, t, n, !0, r)
}
;
Ho.hydrateRoot = function(t, n, r) {
    if (!Yy(t))
        throw Error(Ct(405));
    var s = r != null && r.hydratedSources || null
      , h = !1
      , l = ""
      , g = nM;
    if (r != null && (r.unstable_strictMode === !0 && (h = !0),
    r.identifierPrefix !== void 0 && (l = r.identifierPrefix),
    r.onRecoverableError !== void 0 && (g = r.onRecoverableError)),
    n = tM(n, null, t, 1, r ?? null, h, !1, l, g),
    t[Ul] = n.current,
    ff(t),
    s)
        for (t = 0; t < s.length; t++)
            r = s[t],
            h = r._getVersion,
            h = h(r._source),
            n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [r, h] : n.mutableSourceEagerHydrationData.push(r, h);
    return new vg(n)
}
;
Ho.render = function(t, n, r) {
    if (!_g(n))
        throw Error(Ct(200));
    return yg(null, t, n, !1, r)
}
;
Ho.unmountComponentAtNode = function(t) {
    if (!_g(t))
        throw Error(Ct(40));
    return t._reactRootContainer ? (bu(function() {
        yg(null, null, t, !1, function() {
            t._reactRootContainer = null,
            t[Ul] = null
        })
    }),
    !0) : !1
}
;
Ho.unstable_batchedUpdates = zy;
Ho.unstable_renderSubtreeIntoContainer = function(t, n, r, s) {
    if (!_g(r))
        throw Error(Ct(200));
    if (t == null || t._reactInternals === void 0)
        throw Error(Ct(38));
    return yg(t, n, r, !1, s)
}
;
Ho.version = "18.2.0-next-9e3b772b8-20220608";
function iM() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(iM)
        } catch (t) {
            console.error(t)
        }
}
iM(),
tT.exports = Ho;
var j3 = tT.exports
  , lA = j3;
Vv.createRoot = lA.createRoot,
Vv.hydrateRoot = lA.hydrateRoot;
var X3 = {
    879: (t,n,r)=>{
        r.d(n, {
            W: ()=>U
        });
        var s = r(591), h = r(25), l = r(481), g;
        (function(R) {
            R[R.Linear = 0] = "Linear",
            R[R.QuadraticIn = 1] = "QuadraticIn",
            R[R.QuadraticOut = 2] = "QuadraticOut",
            R[R.QuadraticInOut = 3] = "QuadraticInOut",
            R[R.CubicIn = 4] = "CubicIn",
            R[R.CubicOut = 5] = "CubicOut",
            R[R.CubicInOut = 6] = "CubicInOut",
            R[R.QuarticIn = 7] = "QuarticIn",
            R[R.QuarticOut = 8] = "QuarticOut",
            R[R.QuarticInOut = 9] = "QuarticInOut",
            R[R.QuinticIn = 10] = "QuinticIn",
            R[R.QuinticOut = 11] = "QuinticOut",
            R[R.QuinticInOut = 12] = "QuinticInOut",
            R[R.SinusoidalIn = 13] = "SinusoidalIn",
            R[R.SinusoidalOut = 14] = "SinusoidalOut",
            R[R.SinusoidalInOut = 15] = "SinusoidalInOut",
            R[R.ExponentialIn = 16] = "ExponentialIn",
            R[R.ExponentialOut = 17] = "ExponentialOut",
            R[R.ExponentialInOut = 18] = "ExponentialInOut",
            R[R.CircularIn = 19] = "CircularIn",
            R[R.CircularOut = 20] = "CircularOut",
            R[R.CircularInOut = 21] = "CircularInOut",
            R[R.ElasticIn = 22] = "ElasticIn",
            R[R.ElasticOut = 23] = "ElasticOut",
            R[R.ElasticInOut = 24] = "ElasticInOut",
            R[R.BackIn = 25] = "BackIn",
            R[R.BackOut = 26] = "BackOut",
            R[R.BackInOut = 27] = "BackInOut",
            R[R.BounceIn = 28] = "BounceIn",
            R[R.BounceOut = 29] = "BounceOut",
            R[R.BounceInOut = 30] = "BounceInOut"
        }
        )(g || (g = {}));
        const _ = [l.Easing.Linear.None, l.Easing.Quadratic.In, l.Easing.Quadratic.Out, l.Easing.Quadratic.InOut, l.Easing.Cubic.In, l.Easing.Cubic.Out, l.Easing.Cubic.InOut, l.Easing.Quintic.In, l.Easing.Quadratic.Out, l.Easing.Quadratic.InOut, l.Easing.Quintic.In, l.Easing.Quintic.Out, l.Easing.Quintic.InOut, l.Easing.Sinusoidal.In, l.Easing.Sinusoidal.Out, l.Easing.Sinusoidal.InOut, l.Easing.Exponential.In, l.Easing.Exponential.Out, l.Easing.Exponential.InOut, l.Easing.Circular.In, l.Easing.Circular.Out, l.Easing.Circular.InOut, l.Easing.Elastic.In, l.Easing.Elastic.Out, l.Easing.Elastic.InOut, l.Easing.Back.In, l.Easing.Back.Out, l.Easing.Back.InOut, l.Easing.Bounce.In, l.Easing.Bounce.Out, l.Easing.Bounce.InOut];
        class A {
            constructor() {
                B(this, "style", g.QuadraticInOut);
                B(this, "time", 4)
            }
        }
        const {clamp: m, lerp: D} = h.MathUtils;
        class U extends s.w {
            constructor() {
                super(...arguments);
                B(this, "_vcam", null);
                B(this, "_vcamSolo", null);
                B(this, "_vcams", []);
                B(this, "_lerpTime", 0);
                B(this, "brainBlend", new A)
            }
            get vcam() {
                return this._vcam
            }
            get vcams() {
                return this._vcams
            }
            update(ce) {
                let xe = this.getActiveCamera();
                if (xe != null) {
                    for (let Se of this._vcams)
                        Se.enabled = Se === xe;
                    if (this._lerpTime < this.brainBlend.time) {
                        this._lerpTime += ce;
                        let Se = m(this._lerpTime / this.brainBlend.time, 0, 1)
                          , $ = _[this.brainBlend.style];
                        $ && (Se = $(Se)),
                        this._lerpToMainCamera(xe, Se)
                    } else
                        this._lerpToMainCamera(xe, 1)
                }
            }
            activeCamera(ce, xe=4) {
                this._vcamSolo !== ce && (this._vcamSolo = ce,
                this._lerpTime = 0,
                this.brainBlend.time = xe)
            }
            addCamera(ce) {
                this._vcams.indexOf(ce) === -1 && this._vcams.push(ce)
            }
            removeCamera(ce) {
                let xe = this._vcams.indexOf(ce);
                xe !== -1 && this._vcams.splice(xe, 1)
            }
            getActiveCamera() {
                return this._vcamSolo || this._vcams.filter(ce=>ce.enabled).sort((ce,xe)=>xe.priority - ce.priority)[0]
            }
            _lerpToMainCamera(ce, xe) {
                let Se = this.viewer.camera
                  , $ = ce;
                Se.position.lerp($.finalPosition, xe),
                Se.quaternion.slerp($.finalRotation, xe),
                Se.fov = D(Se.fov, $.fov, xe),
                Se.near = D(Se.near, $.near, xe),
                Se.far = D(Se.far, $.far, xe),
                (Se.fov != $.fov || Se.near != $.near || Se.far != $.far) && Se.updateProjectionMatrix()
            }
        }
    }
    ,
    585: (t,n,r)=>{
        r.d(n, {
            M: ()=>Be,
            z: ()=>Re
        });
        var s = r(694)
          , h = r(25)
          , l = r(313);
        const {clamp: g, degToRad: _, quarticDamp: A} = h.MathUtils
          , {abs: m, tan: D} = Math;
        let U = new h.FM8
          , R = new h.FM8
          , ne = new h.FM8
          , ce = new h.FM8
          , xe = new h.FM8
          , Se = new h.Pa4
          , $ = new h.Pa4
          , q = new h.Pa4
          , N = new h.Pa4
          , ie = new h.Pa4
          , _e = new h._fP
          , Pe = new h.$V;
        var Be;
        (function(ct) {
            ct[ct.FREE = 0] = "FREE",
            ct[ct.TRANSLATE = 1] = "TRANSLATE"
        }
        )(Be || (Be = {}));
        class Re extends l._ {
            constructor() {
                super(...arguments);
                B(this, "_button", -1);
                B(this, "_touchID", -1);
                B(this, "_distanceDelta", 0);
                B(this, "_preLoc0", new h.FM8);
                B(this, "_preLoc1", new h.FM8);
                B(this, "_rotateDelta", new h.FM8);
                B(this, "_panDelta", new h.FM8);
                B(this, "mode", Be.FREE);
                B(this, "forbidX", !1);
                B(this, "forbidY", !1);
                B(this, "forbidZ", !1);
                B(this, "forbidPanX", !1);
                B(this, "forbidPanY", !1);
                B(this, "rotateSpeed", 2);
                B(this, "rotateSmoothing", .5);
                B(this, "panSpeed", 2);
                B(this, "panSmoothing", .5);
                B(this, "phiMin", .001);
                B(this, "phiMax", Math.PI - .001);
                B(this, "thetaMin", -1 / 0);
                B(this, "thetaMax", 1 / 0);
                B(this, "distanceMin", .001);
                B(this, "distanceMax", 1 / 0);
                B(this, "rotateTouchID", 0)
            }
            onEnable() {
                this.viewer.on(s.i.POINTER_DOWN, this._onPointerDown, this),
                this.viewer.on(s.i.POINTER_UP, this._onPointerUp, this),
                this.viewer.on(s.i.POINTER_MOVE, this._onPointerMove, this),
                this.viewer.on(s.i.MOUSE_WHEEL, this._onMouseWheel, this),
                this.viewer.on(s.i.TOUCH_START, this._onTouchStart, this),
                this.viewer.on(s.i.TOUCH_MOVE, this._onTouchMove, this),
                this.reset()
            }
            onDisable() {
                this.viewer.off(s.i.POINTER_DOWN, this._onPointerDown, this),
                this.viewer.off(s.i.POINTER_UP, this._onPointerUp, this),
                this.viewer.off(s.i.POINTER_MOVE, this._onPointerMove, this),
                this.viewer.off(s.i.MOUSE_WHEEL, this._onMouseWheel, this),
                this.viewer.off(s.i.TOUCH_START, this._onTouchStart, this),
                this.viewer.off(s.i.TOUCH_MOVE, this._onTouchMove, this)
            }
            reset() {
                this._button = -1,
                this._touchID = -1,
                this._rotateDelta.set(0, 0),
                this._panDelta.set(0, 0),
                this._distanceDelta = 0
            }
            _onPointerDown(Ze) {
                this.viewer.brower.isMobile || (this._button = Ze.button,
                this._preLoc0.set(Ze.pageX, Ze.pageY))
            }
            _onPointerUp(Ze) {
                this.viewer.brower.isMobile || (this._button = -1)
            }
            _onPointerMove(Ze) {
                if (!this.viewer.brower.isMobile) {
                    switch (U.set(Ze.pageX, Ze.pageY),
                    this._button) {
                    case 0:
                        this._rotateDelta.add(this._calculateRotateDelta(xe, this._preLoc0, U));
                        break;
                    case 1:
                        this._panDelta.add(this._calculatePanDelta(xe, this._preLoc0, U));
                        break
                    }
                    this._preLoc0.copy(U)
                }
            }
            _onMouseWheel(Ze) {
                if (this.lookAt) {
                    let Nt = Se.copy(this.lookAt.position).add(this.trackedObjectOffset).distanceTo(this.node.position)
                      , Bt = Nt + this._distanceDelta;
                    Ze.deltaY > 0 ? Bt *= this._calculateDistanceScale(1 / .85) : Ze.deltaY < 0 && (Bt *= this._calculateDistanceScale(.85)),
                    this._distanceDelta = Bt - Nt
                }
            }
            _onTouchStart(Ze) {
                if (!this.viewer.brower.isMobile)
                    return;
                let Nt = Ze.touches
                  , Bt = this.rotateTouchID;
                Nt.length > Bt + 1 ? (this._preLoc0.set(Nt[Bt].pageX, Nt[Bt].pageY),
                this._preLoc1.set(Nt[Bt + 1].pageX, Nt[Bt + 1].pageY)) : Nt.length > Bt && (this._touchID = Nt[Bt].identifier,
                this._preLoc0.set(Nt[Bt].pageX, Nt[Bt].pageY))
            }
            _onTouchMove(Ze) {
                if (!this.viewer.brower.isMobile)
                    return;
                let Nt = Ze.touches
                  , Bt = this.rotateTouchID;
                if (Nt.length > Bt + 1) {
                    if (U.set(Nt[Bt].pageX, Nt[Bt].pageY),
                    R.set(Nt[Bt + 1].pageX, Nt[Bt + 1].pageY),
                    this.lookAt) {
                        let en = Se.copy(this.lookAt.position).add(this.trackedObjectOffset).distanceTo(this.node.position)
                          , li = (en + this._distanceDelta) * this._calculateDistanceScale(this._preLoc0.distanceTo(this._preLoc1) / U.distanceTo(R));
                        this._distanceDelta = li - en
                    }
                    this._panDelta.add(this._calculatePanDelta(xe, ce.copy(this._preLoc0).add(this._preLoc1).multiplyScalar(.5), ne.copy(U).add(R).multiplyScalar(.5))),
                    this._preLoc0.copy(U),
                    this._preLoc1.copy(R)
                } else
                    Nt.length > Bt && this._touchID === Nt[Bt].identifier && (U.set(Nt[Bt].pageX, Nt[Bt].pageY),
                    this._rotateDelta.add(this._calculateRotateDelta(xe, this._preLoc0, U)),
                    this._preLoc0.copy(U))
            }
            _calculateDistanceScale(Ze) {
                return this.forbidZ && (Ze = 1),
                Ze
            }
            _calculateRotateDelta(Ze, Nt, Bt) {
                let en = this.viewer.renderer.domElement;
                return Ze.copy(Bt).sub(Nt).multiplyScalar(this.rotateSpeed * 2 * Math.PI / en.height),
                Ze.y = -Ze.y,
                this.forbidX && (Ze.x = 0),
                this.forbidY && (Ze.y = 0),
                Ze
            }
            _calculatePanDelta(Ze, Nt, Bt) {
                let en = this.viewer.renderer.domElement;
                return Ze.copy(Bt).sub(Nt).multiplyScalar(this.panSpeed / en.height),
                this.forbidPanX && (Ze.x = 0),
                this.forbidPanY && (Ze.y = 0),
                Ze
            }
            update(Ze) {
                if (this.lookAt) {
                    switch (Se.copy(this.lookAt.position).add(this.trackedObjectOffset),
                    this.mode) {
                    case Be.FREE:
                        if (m(this._rotateDelta.x) + m(this._rotateDelta.y) + m(this._distanceDelta) > .001) {
                            _e.setFromUnitVectors(this.node.up, h.Tme.DEFAULT_UP),
                            $.copy(this.node.position).sub(Se),
                            $.applyQuaternion(_e),
                            Pe.setFromVector3($);
                            let Nt = A(1, 0, this.rotateSmoothing, Ze);
                            this._rotateDelta.x = Pe.theta - g(Pe.theta - this._rotateDelta.x, this.thetaMin, this.thetaMax),
                            Pe.theta = Pe.theta - this._rotateDelta.x * (1 - Nt),
                            this._rotateDelta.y = g(Pe.phi + this._rotateDelta.y, this.phiMin, this.phiMax) - Pe.phi,
                            Pe.phi = g(Pe.phi + this._rotateDelta.y * (1 - Nt), .001, Math.PI - .001),
                            this._distanceDelta = g(Pe.radius + this._distanceDelta, this.distanceMin, this.distanceMax) - Pe.radius,
                            Pe.radius = Pe.radius + this._distanceDelta * (1 - Nt),
                            this._rotateDelta.multiplyScalar(Nt),
                            this._distanceDelta *= Nt,
                            $.setFromSpherical(Pe),
                            $.applyQuaternion(_e.invert()),
                            this.node.position.copy($.add(Se))
                        }
                        break;
                    case Be.TRANSLATE:
                        if (m(this._distanceDelta) > .001) {
                            $.copy(this.node.position).sub(this.lookAt.position);
                            let Nt = A(1, 0, this.rotateSmoothing, Ze)
                              , Bt = $.length();
                            this._distanceDelta = g(Bt + this._distanceDelta, this.distanceMin, this.distanceMax) - Bt;
                            let en = Bt + this._distanceDelta * (1 - Nt);
                            this._distanceDelta *= Nt;
                            let li = $.normalize().multiplyScalar(en).add(this.lookAt.position);
                            q.copy(li).sub(this.node.position),
                            this.trackedObjectOffset.add(q),
                            this.node.position.copy(li),
                            Se.copy(this.lookAt.position).add(this.trackedObjectOffset)
                        }
                        break
                    }
                    switch (this.mode) {
                    case Be.FREE:
                    case Be.TRANSLATE:
                        {
                            if (m(this._panDelta.x) + m(this._panDelta.y) > .001) {
                                $.copy(this.node.position).sub(Se),
                                N.setFromMatrixColumn(this.node.matrix, 0),
                                ie.setFromMatrixColumn(this.node.matrix, 1);
                                let Nt = $.length() * 2 * D(_(this.fov * .5))
                                  , Bt = A(1, 0, this.panSmoothing, Ze)
                                  , en = this.trackedObjectOffset;
                                en.sub(N.multiplyScalar(this._panDelta.x * Nt * (1 - Bt))),
                                en.add(ie.multiplyScalar(this._panDelta.y * Nt * (1 - Bt))),
                                this._panDelta.multiplyScalar(Bt),
                                Se.copy(this.lookAt.position).add(en),
                                this.node.position.copy($.add(Se))
                            }
                            this.node.lookAt(Se);
                            break
                        }
                    }
                }
            }
        }
    }
    ,
    313: (t,n,r)=>{
        r.d(n, {
            _: ()=>g
        });
        var s = r(591)
          , h = r(25)
          , l = r(879);
        class g extends s.w {
            constructor() {
                super(...arguments);
                B(this, "_finalPosition", new h.Pa4);
                B(this, "_finalRotation", new h._fP);
                B(this, "priority", 10);
                B(this, "lookAt", null);
                B(this, "follow", null);
                B(this, "fov", 45);
                B(this, "near", .1);
                B(this, "far", 1e3);
                B(this, "correctPosition", new h.Pa4);
                B(this, "correctRotation", new h._fP);
                B(this, "lookaheadPosition", new h.Pa4);
                B(this, "trackedObjectOffset", new h.Pa4);
                B(this, "brain")
            }
            get finalPosition() {
                return this._finalPosition.copy(this.node.position).add(this.correctPosition)
            }
            get finalRotation() {
                return this._finalRotation.copy(this.node.quaternion).multiply(this.correctRotation)
            }
            onLoad() {
                this.node.isCamera = !0,
                this.brain = this.viewer.getComponent(this.viewer.camera, l.W),
                this.brain.addCamera(this)
            }
            onDestroy() {
                this.brain.removeCamera(this)
            }
            update(m) {
                this.lookAt && this.node.lookAt(this.lookAt.position)
            }
        }
    }
    ,
    461: (t,n,r)=>{
        r.d(n, {
            Entity: ()=>g
        });
        var s = r(930), h;
        (function(_) {
            _[_.Destroyed = 1] = "Destroyed",
            _[_.OnLoadCalled = 2] = "OnLoadCalled",
            _[_.OnEnableCalled = 4] = "OnEnableCalled",
            _[_.StartCalled = 8] = "StartCalled",
            _[_.Deactivating = 16] = "Deactivating",
            _[_.IsStartCalled = 32] = "IsStartCalled"
        }
        )(h || (h = {}));
        let l = 0;
        class g extends s.v {
            constructor(m) {
                super();
                B(this, "uuid", "" + l++);
                B(this, "name", "");
                B(this, "_objFlags", 0);
                this.name = m || this.name
            }
            __setFlag(m) {
                this._objFlags |= m
            }
            __clearFlag(m) {
                this._objFlags &= ~m
            }
            __getFlag(m) {
                return !!(this._objFlags & m)
            }
            get isValid() {
                return !(this._objFlags & h.Destroyed)
            }
            destroy() {
                return this.__getFlag(h.Destroyed) ? !1 : (this.destroyImmediate(),
                !0)
            }
            destroyImmediate() {
                this._onPreDestroy && this._onPreDestroy(),
                this.__setFlag(h.Destroyed)
            }
        }
        B(g, "Flags", h)
    }
    ,
    128: (t,n,r)=>{
        r.d(n, {
            i: ()=>s
        });
        var s;
        (function(h) {
            h[h.AUTO = 0] = "AUTO",
            h[h.LANDSCAPE = 1] = "LANDSCAPE",
            h[h.PORTRAIT = 2] = "PORTRAIT"
        }
        )(s || (s = {}))
    }
    ,
    930: (t,n,r)=>{
        r.d(n, {
            v: ()=>s
        });
        class s {
            constructor() {
                B(this, "_events", {})
            }
            clear() {
                return this._events = {},
                this
            }
            has(l) {
                return !!this._events[l]
            }
            on(l, g, _, A=!1) {
                let m = this._events[l];
                if (m == null && (m = this._events[l] = []),
                m.findIndex(U=>U.callback === g && (!_ || U.target === _)) > -1) {
                    console.warn(`event: ${l} duplicate registered`);
                    return
                }
                return m.push({
                    name: l,
                    callback: g,
                    target: _,
                    once: A
                }),
                this
            }
            off(l, g, _) {
                let A = this._events[l];
                if (A) {
                    let m = A.findIndex(D=>D.callback === g && (!_ || D.target === _));
                    this._removeEvent(A, m, l)
                }
                return this
            }
            onof(l, g, _) {
                return _._listeners === void 0 && (_._listeners = []),
                _._listeners.push({
                    name: l,
                    callback: g
                }),
                this.on(l, g),
                this
            }
            offof(l) {
                for (let g of l._listeners)
                    this.off(g.name, g.callback);
                return this
            }
            _removeEvent(l, g, _) {
                return g > -1 && (l.splice(g, 1),
                l.length === 0 && delete this._events[_]),
                this
            }
            targetOff(l) {
                for (let g in this._events) {
                    let _ = this._events[g];
                    for (let A = _.length; A--; )
                        _[A].target === l && this._removeEvent(_, A, g)
                }
            }
            emit(l, ...g) {
                let _ = this._events[l];
                if (_)
                    for (let A = _.length; A--; ) {
                        let m = _[A];
                        m && (m.once && this._removeEvent(_, A, l),
                        m.target ? m.callback.apply(m.target, g) : m.callback(...g))
                    }
                return this
            }
        }
    }
    ,
    779: (t,n,r)=>{
        r.d(n, {
            b: ()=>l
        });
        class s {
            constructor(_, A, m, D) {
                B(this, "_target", null);
                B(this, "_callback", null);
                B(this, "_interval", 0);
                B(this, "_repeat", 0);
                B(this, "_elapsed", 0);
                B(this, "_lastTime", 0);
                B(this, "_repeatForever", !1);
                B(this, "_pause", !1);
                this._target = _,
                this._callback = A,
                this._interval = m,
                this._repeat = D,
                this._repeatForever = D === -1
            }
            get pause() {
                return this._pause
            }
            set pause(_) {
                this._pause = _
            }
            get target() {
                return this._target
            }
            get callback() {
                return this._callback
            }
            get lived() {
                return this._repeat > 0 || this._repeatForever
            }
            update(_) {
                this._pause || (this._repeat > 0 || this._repeatForever) && (this._elapsed += _,
                this._elapsed >= this._interval && (this.trigger(this._elapsed - this._lastTime),
                this._elapsed -= this._interval,
                this._lastTime = this._elapsed,
                this._repeat--))
            }
            trigger(_) {
                this._target && this._callback && this._callback.call(this._target, _, this._elapsed)
            }
        }
        class h {
            constructor(_, A) {
                B(this, "_target");
                B(this, "_callers");
                this._target = _,
                this._callers = A
            }
            get target() {
                return this._target
            }
            get callers() {
                return this._callers
            }
        }
        class l {
            constructor() {
                B(this, "_callers", {});
                B(this, "_callersArray", [])
            }
            pause(_) {
                let A = this._callers[_.uuid];
                A && A.forEach(m=>m.pause = !0)
            }
            resume(_) {
                let A = this._callers[_.uuid];
                A && A.forEach(m=>m.pause = !1)
            }
            schedule(_, A, m, D) {
                let U = this._callers[_.uuid];
                U === void 0 && (U = this._callers[_.uuid] = [],
                this._callersArray.push(new h(_,U))),
                U.push(new s(_,A,m,D))
            }
            unshedule(_, A) {
                let m = this._callers[_.uuid];
                if (m) {
                    let D = m.findIndex(U=>U.callback === A);
                    D !== -1 && m.splice(D, 1)
                }
            }
            unscheduleAll(_) {
                delete this._callers[_.uuid];
                let A = this._callersArray.findIndex(m=>m.target === _);
                A !== -1 && this._callersArray.splice(A, 1)
            }
            update(_) {
                let A, m = this._callersArray;
                for (let D = m.length; D--; ) {
                    A = m[D].callers;
                    for (let U = A.length; U--; )
                        A[U].lived ? A[U].update(_) : A.splice(U, 1)
                }
            }
        }
    }
    ,
    861: (t,n,r)=>{
        r.d(n, {
            $c: ()=>g,
            $p: ()=>l,
            $q: ()=>R,
            $r: ()=>U,
            L0: ()=>_,
            OE: ()=>ce,
            bd: ()=>D,
            eC: ()=>ne,
            i5: ()=>A,
            nX: ()=>m,
            ri: ()=>xe
        });
        var s = r(25);
        const {degToRad: h} = s.MathUtils;
        function l(Se, $, q=!1) {
            for (let N in $) {
                let ie = $[N];
                if (ie === void 0)
                    continue;
                let _e = N.split("-")
                  , Pe = Se
                  , Be = Pe;
                for (let Re = 0, ct = _e.length; Re < ct; Re++) {
                    let et = _e[Re];
                    if (q || Be.hasOwnProperty(et) || Be.constructor.prototype.hasOwnProperty(et)) {
                        if (Pe = Be[et],
                        Re == ct - 1) {
                            let Ze = Object.getOwnPropertyDescriptor(Be, et);
                            !Ze || Ze.writable || Ze.set ? Be[et] = ie : Pe && Pe.copy && Pe.copy(ie)
                        }
                        Be = Pe
                    }
                }
            }
            return Se
        }
        function g(...Se) {
            let $ = new s.Ilk;
            return Se.length === 1 ? $.set(Se[0]) : Se.length === 3 && $.setRGB(Se[0], Se[1], Se[2]),
            $
        }
        function _(Se, $, q, N) {
            let ie = new s.Ilk().setHex((Se << 16) + ($ << 8) + q);
            return N !== void 0 ? new s.Ltg(ie.r,ie.g,ie.b,N / 255) : ie
        }
        function A(Se, $) {
            return new s.FM8(Se,$ ?? Se)
        }
        function m(Se, $, q) {
            return new s.Pa4(Se,$ ?? Se,q ?? Se)
        }
        function D(Se, $, q, N) {
            return new s.Ltg(Se,$ ?? Se,q ?? Se,N ?? Se)
        }
        function U(Se, $, q, N=!1) {
            return N ? new s.USm(h(Se),h($),h(q)) : new s.USm(Se,$,q)
        }
        function R(Se, $, q, N) {
            return new s._fP(Se,$,q,N)
        }
        function ne(Se, $=new s.Ltg) {
            return $.x = Se.r,
            $.y = Se.g,
            $.z = Se.b,
            $
        }
        function ce(Se, $=new s.Ilk) {
            return $.r = Se.x,
            $.g = Se.y,
            $.b = Se.z,
            $
        }
        function xe(Se) {
            return Se != null
        }
    }
    ,
    591: (t,n,r)=>{
        r.d(n, {
            w: ()=>h
        });
        var s = r(461);
        class h extends s.Entity {
            constructor() {
                super(...arguments);
                B(this, "_enabled", !0);
                B(this, "node");
                B(this, "viewer");
                B(this, "isComponent", !0)
            }
            get enabled() {
                return this._enabled
            }
            set enabled(_) {
                var A;
                this._enabled !== _ && (this._enabled = _,
                (A = this.viewer) == null || A.componentScheduler.enableComponent(this, _))
            }
            _onPreDestroy() {
                var _, A, m;
                this.unscheduleAll(),
                (_ = this.viewer) == null || _.input.disconnect(this),
                (A = this.viewer) == null || A.removeComponent(this.node, this),
                this._enabled && ((m = this.viewer) == null || m.componentScheduler.enableComponent(this, !1)),
                this.onDestroy && this.__getFlag(s.Entity.Flags.OnLoadCalled) && this.onDestroy()
            }
            schedule(_, A, m=-1) {
                var D;
                (D = this.viewer) == null || D.scheduler.schedule(this, _, A, m)
            }
            unshedule(_) {
                var A;
                (A = this.viewer) == null || A.scheduler.unshedule(this, _)
            }
            unscheduleAll() {
                var _;
                (_ = this.viewer) == null || _.scheduler.unscheduleAll(this)
            }
            on(_, A, m, D) {
                var U;
                return super.on(_, A, m, D),
                (U = this.viewer) == null || U.input.connect(this, _),
                this
            }
        }
    }
    ,
    41: (t,n,r)=>{
        r.d(n, {
            Cb: ()=>s,
            HO: ()=>h,
            jf: ()=>l
        });
        function s(g={}) {
            return function(_, A) {
                _.hasOwnProperty("__properties") || (_.__properties = Object.assign({}, _.__proto__.__properties)),
                _.__properties[A] = g
            }
        }
        function h(...g) {
            return function(_) {
                let A = _.prototype;
                A.__dependencies == null && (A.__dependencies = []),
                A.__dependencies.push(...g)
            }
        }
        function l(g="", _=0, A=!1) {
            return function(m) {
                let D = m.prototype;
                D.__display == null && (D.__display = {
                    name: g || m.name || m.constructor.name,
                    order: _,
                    root: A
                })
            }
        }
    }
    ,
    694: (t,n,r)=>{
        r.d(n, {
            i: ()=>g
        });
        var s = r(25), h;
        (function(A) {
            A[A.NONE = 1] = "NONE",
            A[A.SELECTED = 2] = "SELECTED",
            A[A.IN = 4] = "IN"
        }
        )(h || (h = {}));
        class l {
            constructor() {
                B(this, "_raycaster", new s.iMs);
                B(this, "_connectors", [])
            }
            connect(m) {
                let D = this._connectors.find(U=>U.target === m);
                D === void 0 && (D = {
                    target: m,
                    state: h.NONE
                },
                this._connectors.push(D))
            }
            disconnect(m) {
                let D = this._connectors.findIndex(U=>U.target === m);
                D !== -1 && this._connectors.splice(D, 1)
            }
            pointerDown(m, D) {
                if (this._connectors.length !== 0) {
                    this._raycaster.setFromCamera(m, D);
                    for (let U of this._connectors)
                        if (U.target.has("click") || U.target.has("pointerdown")) {
                            let R = this._raycaster.intersectObject(U.target.node, !0);
                            R.length && (U.state |= h.SELECTED,
                            U.target.emit("pointerdown", {
                                intersects: R
                            }))
                        }
                }
            }
            pointerUp(m, D) {
                if (this._connectors.length !== 0) {
                    this._raycaster.setFromCamera(m, D);
                    for (let U of this._connectors)
                        if (U.target.has("click") || U.target.has("pointerup")) {
                            let R = this._raycaster.intersectObject(U.target.node, !0);
                            R.length && (U.state & h.SELECTED && (U.state &= ~h.SELECTED,
                            U.target.emit("click", {
                                intersects: R
                            })),
                            U.target.emit("pointerup", {
                                intersects: R
                            }))
                        }
                }
            }
            pointerMove(m, D) {
                if (this._connectors.length !== 0) {
                    this._raycaster.setFromCamera(m, D);
                    for (let U of this._connectors)
                        if (U.target.has("pointerover") || U.target.has("pointerout")) {
                            let R = this._raycaster.intersectObject(U.target.node, !0);
                            R.length ? U.state & h.IN || (U.state |= h.IN,
                            U.target.emit("pointerover", {
                                intersects: R
                            })) : U.state & h.IN && (U.state &= ~h.IN,
                            U.target.emit("pointerout", {
                                intersects: R
                            }))
                        }
                }
            }
        }
        const _ = class _ {
            constructor(m) {
                B(this, "viewer");
                B(this, "_listeners", []);
                B(this, "_mouseWheel", 0);
                B(this, "_touches", []);
                B(this, "_touchCount", 0);
                B(this, "_pointerButton", -1);
                B(this, "_pointerPosition", new s.FM8);
                B(this, "_pointer", new s.FM8);
                B(this, "_keys", {});
                B(this, "_pressability", new l);
                this.viewer = m
            }
            get pointerButton() {
                return this._pointerButton
            }
            get pointer() {
                return this._pointer
            }
            get pointerPosition() {
                return this._pointerPosition
            }
            get mouseWheel() {
                return this._mouseWheel
            }
            get touchCount() {
                return this._touchCount
            }
            get touches() {
                return this._touches
            }
            get keys() {
                return this._keys
            }
            addEventListeners() {
                const m = this.viewer.renderer.domElement;
                m.style.touchAction = "none",
                this._addEventListener(m, "contextmenu", D=>D.preventDefault()),
                this._addEventListener(m, "pointerdown", D=>this._onPointerDown(D), {
                    passive: !1
                }),
                this._addEventListener(m, "pointerup", D=>this._onPointerUp(D), {
                    passive: !1
                }),
                this._addEventListener(m, "pointercancel", D=>this._onPointerUp(D), {
                    passive: !1
                }),
                this._addEventListener(m, "pointerout", D=>this._onPointerUp(D), {
                    passive: !1
                }),
                this._addEventListener(m, "pointermove", D=>this._onPointerMove(D), {
                    passive: !0
                }),
                this._addEventListener(m, "wheel", D=>this._onMouseWheel(D), {
                    passive: !1
                }),
                this._addEventListener(m, "touchstart", D=>this._onTouchStart(D), {
                    passive: !0
                }),
                this._addEventListener(m, "touchend", D=>this._onTouchEnd(D), {
                    passive: !0
                }),
                this._addEventListener(m, "touchmove", D=>this._onTouchMove(D), {
                    passive: !0
                }),
                this._addEventListener(window, "keydown", D=>this._onKeyDown(D), {
                    passive: !1
                }),
                this._addEventListener(window, "keypress", D=>this._onKeyPress(D), {
                    passive: !1
                }),
                this._addEventListener(window, "keyup", D=>this._onKeyUp(D), {
                    passive: !1
                })
            }
            connect(m, D) {
                switch (D) {
                case _.CLICK:
                case _.POINTER_DOWN:
                case _.POINTER_UP:
                case _.POINTER_OVER:
                case _.POINTER_OUT:
                    this._pressability.connect(m);
                    break
                }
            }
            disconnect(m) {
                this._pressability.disconnect(m)
            }
            _addEventListener(m, D, U, R) {
                m.addEventListener ? m.addEventListener(D, U, R) : m.on && m.on(D, U, m),
                this._listeners.push({
                    target: m,
                    type: D,
                    callback: U
                })
            }
            removeAllListeners() {
                for (let {target: m, type: D, callback: U} of this._listeners)
                    m.removeEventListener ? m.removeEventListener(D, U) : m.off && m.off(D, U, m);
                this._listeners = []
            }
            _remapPointer(m) {
                const D = this.viewer.width;
                return this.viewer.rootRotated ? {
                    button: m.button,
                    buttons: m.buttons,
                    clientX: m.clientY,
                    clientY: D - m.clientX,
                    offsetX: m.offsetY,
                    offsetY: D - m.offsetX,
                    pageX: m.pageY,
                    pageY: D - m.pageX,
                    screenX: m.screenY,
                    screenY: D - m.screenX,
                    movementX: m.movementY,
                    movementY: m.movementX
                } : m
            }
            _remapTouch(m) {
                const D = this.viewer.width;
                return this.viewer.rootRotated ? {
                    touches: Array.from(m.touches).map(U=>({
                        identifier: U.identifier,
                        clientX: U.clientY,
                        clientY: D - U.clientX,
                        pageX: U.pageY,
                        pageY: D - U.pageX,
                        screenX: U.screenY,
                        screenY: D - U.screenX
                    }))
                } : m
            }
            _computePointer(m) {
                this._pointer.x = m.offsetX / this.viewer.width * 2 - 1,
                this._pointer.y = 1 - m.offsetY / this.viewer.height * 2,
                this._pointerPosition.set(m.offsetX, m.offsetY)
            }
            _onPointerDown(m) {
                m.preventDefault(),
                m = this._remapPointer(m),
                this._pointerButton = m.button,
                this._computePointer(m),
                this._pressability.pointerDown(this._pointer, this.viewer.camera),
                this.viewer.emit(_.POINTER_DOWN, m)
            }
            _onPointerUp(m) {
                m.preventDefault(),
                m = this._remapPointer(m),
                this._pointerButton = -1,
                this._computePointer(m),
                this._pressability.pointerUp(this._pointer, this.viewer.camera),
                this.viewer.emit(_.POINTER_UP, m)
            }
            _onPointerMove(m) {
                m = this._remapPointer(m),
                this._computePointer(m),
                this._pressability.pointerMove(this._pointer, this.viewer.camera),
                this.viewer.emit(_.POINTER_MOVE, m)
            }
            _onMouseWheel(m) {
                m.preventDefault(),
                this._mouseWheel = m.deltaY || m.wheelDelta,
                this.viewer.emit(_.MOUSE_WHEEL, m)
            }
            _onTouchStart(m) {
                m = this._remapTouch(m),
                this.viewer.emit(_.TOUCH_START, m)
            }
            _onTouchEnd(m) {
                m = this._remapTouch(m),
                this.viewer.emit(_.TOUCH_END, m)
            }
            _onTouchMove(m) {
                m = this._remapTouch(m);
                let D = m.touches
                  , U = this._touches;
                for (let R = D.length; R--; ) {
                    U[R] == null && (U[R] = {
                        id: -1,
                        position: new s.FM8
                    });
                    const ne = D[R];
                    U[R].id = ne.identifier,
                    U[R].position.set(ne.pageX, ne.pageY)
                }
                this._touchCount = D.length,
                this.viewer.emit(_.TOUCH_MOVE, m)
            }
            _onKeyDown(m) {
                this._keys[m.key] = !0,
                this.viewer.emit(_.KEYDOWN, m)
            }
            _onKeyPress(m) {
                this._keys[m.key] = !0,
                this.viewer.emit(_.KEYPRESS, m)
            }
            _onKeyUp(m) {
                this._keys[m.key] = !1,
                this.viewer.emit(_.KEYUP, m)
            }
        }
        ;
        B(_, "CLICK", "click"),
        B(_, "MOUSE_WHEEL", "mousewheel"),
        B(_, "TOUCH_START", "touchstart"),
        B(_, "TOUCH_END", "touchend"),
        B(_, "TOUCH_MOVE", "touchmove"),
        B(_, "POINTER_DOWN", "pointerdown"),
        B(_, "POINTER_UP", "pointerup"),
        B(_, "POINTER_MOVE", "pointermove"),
        B(_, "POINTER_OVER", "pointerover"),
        B(_, "POINTER_OUT", "pointerout"),
        B(_, "KEYDOWN", "keydown"),
        B(_, "KEYPRESS", "keypress"),
        B(_, "KEYUP", "keyup"),
        B(_, "RESIZE", "resize");
        let g = _
    }
    ,
    322: (t,n,r)=>{
        r.d(n, {
            c: ()=>A
        });
        var s = r(25)
          , h = r(774);
        const l = `
varying vec2      vUv;
uniform sampler2D tMain;
uniform float     uLod;

void main() {
    gl_FragColor = texture(tMain, vUv, uLod);
    #include <encodings_fragment>
}
`;
        var g = r(616);
        class _ {
            constructor() {
                B(this, "copyMaterial", new s.jyz({
                    vertexShader: g.n,
                    fragmentShader: l,
                    blending: s.jFi,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    uniforms: {
                        tMain: {
                            value: null
                        },
                        uLod: {
                            value: 0
                        }
                    }
                }));
                B(this, "fullscreenMesh", new s.Kj0((0,
                h.lD)(),this.copyMaterial));
                B(this, "fullscreenCamera", new s.iKG(-1,1,1,-1,0,1))
            }
        }
        const A = new _
    }
    ,
    282: (t,n,r)=>{
        r.d(n, {
            X: ()=>s
        });
        class s {
            constructor(l, g, _) {
                B(this, "texture");
                B(this, "texCoords");
                B(this, "meshCoords");
                this.texture = l,
                this.texCoords = g,
                this.meshCoords = _
            }
        }
    }
    ,
    811: (t,n,r)=>{
        r.d(n, {
            Y: ()=>g
        });
        var s = r(25)
          , h = r(282);
        const l = {
            x: .5,
            y: .5
        };
        class g {
            constructor(A, m) {
                B(this, "json");
                B(this, "texture");
                B(this, "_spriteFrames", {});
                B(this, "_animations", {});
                this.json = A,
                this.texture = m;
                let D = A.meta.size
                  , U = A.meta.scale / Math.max(D.w, D.h)
                  , R = A.frames;
                for (let ne in R) {
                    let {frame: ce, sourceSize: xe, spriteSourceSize: Se, anchor: $} = R[ne]
                      , q = ce.x / D.w
                      , N = ce.y / D.h
                      , ie = ce.w / D.w
                      , _e = ce.h / D.h
                      , Pe = xe
                      , Be = Se
                      , Re = $ || l
                      , ct = U;
                    this._spriteFrames[ne] = new h.X(m,new s.Ltg(q,1 - (N + _e),ie,_e),new s.Ltg(Be.x + .5 * Be.w - Pe.w * Re.x,-(Be.y + .5 * Be.h - Pe.h * Re.y),Be.w,Be.h).multiplyScalar(ct))
                }
                for (let ne in A.animations)
                    this._animations[ne] = A.animations[ne].map(ce=>this._spriteFrames[ce])
            }
            getAnimation(A) {
                return this._animations[A]
            }
            getSpriteFrame(A) {
                return this._spriteFrames[A]
            }
        }
    }
    ,
    822: (t,n,r)=>{
        r.d(n, {
            A: ()=>Rt
        });
        var s = r(25)
          , h = r(353)
          , l = r(461)
          , g = r(779)
          , _ = r(591);
        class A {
            constructor(pt) {
                B(this, "_targets", []);
                B(this, "_callback");
                this._callback = pt
            }
            add(pt) {
                this._targets.push(pt)
            }
            remove(pt) {
                let Fe = this._targets.indexOf(pt);
                Fe !== -1 && this._targets.splice(Fe, 1)
            }
            invoke(pt) {
                let Fe = this._callback;
                for (let qe of this._targets)
                    Fe(qe, pt)
            }
        }
        class m extends A {
            invoke(pt) {
                if (this._targets.length > 0) {
                    let Fe = this._callback;
                    for (let qe of this._targets)
                        Fe(qe, pt);
                    this._targets.length = 0
                }
            }
        }
        const {Flags: D} = l.Entity;
        class U {
            constructor() {
                B(this, "startInvoker", new m(pt=>pt.start()));
                B(this, "updateInvoker", new A((pt,Fe)=>pt.update(Fe)));
                B(this, "lastUpdateInvoker", new A((pt,Fe)=>pt.lastUpdate(Fe)))
            }
            start() {
                this.startInvoker.invoke(0)
            }
            update(pt) {
                this.updateInvoker.invoke(pt)
            }
            lastUpdate(pt) {
                this.lastUpdateInvoker.invoke(pt)
            }
            enableComponent(pt, Fe) {
                Fe ? pt.__getFlag(D.OnEnableCalled) === !1 && (pt.__setFlag(D.OnEnableCalled),
                pt.onEnable && pt.onEnable(),
                typeof pt.start == "function" && !pt.__getFlag(D.IsStartCalled) && (pt.__setFlag(D.IsStartCalled),
                this.startInvoker.add(pt)),
                typeof pt.update == "function" && this.updateInvoker.add(pt),
                typeof pt.lastUpdate == "function" && this.lastUpdateInvoker.add(pt)) : pt.__getFlag(D.OnEnableCalled) && (pt.__clearFlag(D.OnEnableCalled),
                pt.onDisable && pt.onDisable(),
                typeof pt.start == "function" && !pt.__getFlag(D.IsStartCalled) && this.startInvoker.remove(pt),
                typeof pt.update == "function" && this.updateInvoker.remove(pt),
                typeof pt.lastUpdate == "function" && this.lastUpdateInvoker.remove(pt))
            }
        }
        class R extends l.Entity {
            constructor() {
                super(...arguments);
                B(this, "_scheduler", new g.b);
                B(this, "_componentScheduler", new U)
            }
            get scheduler() {
                return this._scheduler
            }
            get componentScheduler() {
                return this._componentScheduler
            }
            update(Fe) {
                this._scheduler.update(Fe),
                this._componentScheduler.start(),
                this._componentScheduler.update(Fe),
                this._componentScheduler.lastUpdate(Fe)
            }
            destroyNode(Fe) {
                Fe.removeFromParent(),
                this.destroyComponents(Fe)
            }
            activeNode(Fe, qe) {
                Fe.visible = qe,
                this.activeComponents(Fe)
            }
            destroyComponents(Fe) {
                let qe = this._getComponents(Fe);
                for (let wt of qe)
                    wt.destroy();
                Fe._components = [];
                for (let wt of Fe.children)
                    this.destroyComponents(wt)
            }
            activeComponents(Fe) {
                let qe = Fe.visible;
                for (let wt of this._getComponents(Fe))
                    this._activeComponent(wt, qe);
                for (let wt of Fe.children)
                    this.activeComponents(wt)
            }
            addComponent(Fe, qe) {
                let wt = Fe instanceof _.w ? Fe.node : Fe
                  , An = typeof qe == "function"
                  , Qt = this._findComponent(wt, An ? qe : qe.constructor);
                if (Qt === void 0) {
                    Qt = An ? new qe : qe,
                    Qt.node = wt,
                    Qt.viewer = this;
                    let Pi = Qt.__dependencies;
                    if (Pi)
                        for (let ui of Pi)
                            this.getComponent(wt, ui) == null && this.addComponent(wt, ui);
                    Qt.__getFlag(l.Entity.Flags.OnLoadCalled) === !1 && (Qt.__setFlag(l.Entity.Flags.OnLoadCalled),
                    Qt.onInit && Qt.onInit(),
                    Qt.onLoad && Qt.onLoad()),
                    this._getComponents(wt).push(Qt),
                    this._activeComponent(Qt, Qt.enabled)
                }
                return Qt
            }
            removeComponent(Fe, qe) {
                let wt = this._getComponents(Fe)
                  , An = wt.indexOf(qe);
                return An != -1 && wt.splice(An, 1),
                this
            }
            getComponent(Fe, qe) {
                return this._findComponent(Fe, qe)
            }
            getComponentsInChidren(Fe, qe, wt=[]) {
                let An = this._getComponents(Fe);
                for (let Qt = An.length; Qt--; )
                    An[Qt]instanceof qe && wt.push(An[Qt]);
                for (let Qt of Fe.children)
                    this.getComponentsInChidren(Qt, qe, wt);
                return wt
            }
            _getComponents(Fe) {
                let qe = Fe._components;
                return qe == null && (qe = Fe._components = []),
                qe
            }
            _findComponent(Fe, qe) {
                let wt = this._getComponents(Fe);
                for (let An = wt.length; An--; ) {
                    let Qt = wt[An];
                    if (Qt instanceof qe)
                        return Qt
                }
            }
            _activeComponent(Fe, qe) {
                this._componentScheduler.enableComponent(Fe, qe)
            }
        }
        var ne = r(694)
          , ce = r(481)
          , xe = r(992);
        class Se extends xe.S {
            update(pt) {
                ce.TweenManager.TweenUpdate()
            }
        }
        var $ = r(774)
          , q = r(427)
          , N = r(861);
        const ie = typeof window > "u";
        class _e {
            constructor(pt) {
                B(this, "userAgent");
                B(this, "isAndroidDevice");
                B(this, "iOSDevice");
                this.userAgent = pt || (!ie && window.navigator ? window.navigator.userAgent : ""),
                this.isAndroidDevice = !/like android/i.test(this.userAgent) && /android/i.test(this.userAgent),
                this.iOSDevice = this.match(1, /(iphone|ipod|ipad)/i).toLowerCase(),
                !ie && navigator.platform === "MacIntel" && navigator.maxTouchPoints > 2 && !window.MSStream && (this.iOSDevice = "ipad")
            }
            match(pt, Fe) {
                const qe = this.userAgent.match(Fe);
                return qe && qe.length > 1 && qe[pt] || ""
            }
            get isMobile() {
                return !this.isTablet && (/[^-]mobi/i.test(this.userAgent) || this.iOSDevice === "iphone" || this.iOSDevice === "ipod" || this.isAndroidDevice || /nexus\s*[0-6]\s*/i.test(this.userAgent))
            }
            get isTablet() {
                return /tablet/i.test(this.userAgent) && !/tablet pc/i.test(this.userAgent) || this.iOSDevice === "ipad" || this.isAndroidDevice && !/[^-]mobi/i.test(this.userAgent) || !/nexus\s*[0-6]\s*/i.test(this.userAgent) && /nexus\s*[0-9]+/i.test(this.userAgent)
            }
            get isDesktop() {
                return !this.isMobile && !this.isTablet
            }
            get isMacOS() {
                return /macintosh/i.test(this.userAgent) && {
                    version: this.match(1, /mac os x (\d+(\.?_?\d+)+)/i).replace(/[_\s]/g, ".").split(".").map(pt=>pt)[1]
                }
            }
            get isWindows() {
                return /windows /i.test(this.userAgent) && {
                    version: this.match(1, /Windows ((NT|XP)( \d\d?.\d)?)/i)
                }
            }
            get isiOS() {
                return !!this.iOSDevice && {
                    version: this.match(1, /os (\d+([_\s]\d+)*) like mac os x/i).replace(/[_\s]/g, ".") || this.match(1, /version\/(\d+(\.\d+)?)/i)
                }
            }
            get isAndroid() {
                return this.isAndroidDevice && {
                    version: this.match(1, /android[ \/-](\d+(\.\d+)*)/i)
                }
            }
            get browser() {
                const pt = this.match(1, /version\/(\d+(\.\d+)?)/i);
                return /opera/i.test(this.userAgent) ? {
                    name: "Opera",
                    version: pt || this.match(1, /(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
                } : /opr\/|opios/i.test(this.userAgent) ? {
                    name: "Opera",
                    version: this.match(1, /(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || pt
                } : /SamsungBrowser/i.test(this.userAgent) ? {
                    name: "Samsung Internet for Android",
                    version: pt || this.match(1, /(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
                } : /yabrowser/i.test(this.userAgent) ? {
                    name: "Yandex Browser",
                    version: pt || this.match(1, /(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
                } : /ucbrowser/i.test(this.userAgent) ? {
                    name: "UC Browser",
                    version: this.match(1, /(?:ucbrowser)[\s\/](\d+(\.\d+)?)/i)
                } : /msie|trident/i.test(this.userAgent) ? {
                    name: "Internet Explorer",
                    version: this.match(1, /(?:msie |rv:)(\d+(\.\d+)?)/i)
                } : /(edge|edgios|edga|edg)/i.test(this.userAgent) ? {
                    name: "Microsoft Edge",
                    version: this.match(2, /(edge|edgios|edga|edg)\/(\d+(\.\d+)?)/i)
                } : /firefox|iceweasel|fxios/i.test(this.userAgent) ? {
                    name: "Firefox",
                    version: this.match(1, /(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
                } : /chromium/i.test(this.userAgent) ? {
                    name: "Chromium",
                    version: this.match(1, /(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || pt
                } : /chrome|crios|crmo/i.test(this.userAgent) ? {
                    name: "Chrome",
                    version: this.match(1, /(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
                } : /safari|applewebkit/i.test(this.userAgent) ? {
                    name: "Safari",
                    version: pt
                } : {
                    name: this.match(1, /^(.*)\/(.*) /),
                    version: this.match(2, /^(.*)\/(.*) /)
                }
            }
        }
        const Pe = new _e
          , Be = (navigator.userAgent || navigator.vendor).toLowerCase()
          , Re = typeof Pe.browser == "boolean" ? "" : Pe.browser.name
          , ct = document.createElement("audio");
        class et {
            constructor() {
                B(this, "isMobile", Pe.isMobile || Pe.isTablet);
                B(this, "isDesktop", Pe.isDesktop);
                B(this, "device", this.isMobile ? "mobile" : "desktop");
                B(this, "isAndroid", !!Pe.isAndroid);
                B(this, "isIOS", !!Pe.isiOS);
                B(this, "isMacOS", !!Pe.isMacOS);
                B(this, "isWindows", typeof Pe.isWindows == "boolean" ? Pe.isWindows : Pe.isWindows.version !== null);
                B(this, "isLinux", Be.indexOf("linux") != -1);
                B(this, "ua", Be);
                B(this, "isEdge", Re === "Microsoft Edge");
                B(this, "isIE", Re === "Internet Explorer");
                B(this, "isFirefox", Re === "Firefox");
                B(this, "isChrome", Re === "Chrome");
                B(this, "isOpera", Re === "Opera");
                B(this, "isSafari", Re === "Safari");
                B(this, "isSupportMSAA", !Be.match("version/15.4 "));
                B(this, "isSupportOgg", !!ct.canPlayType("audio/ogg"));
                B(this, "isRetina", window.devicePixelRatio && window.devicePixelRatio >= 1.5);
                B(this, "devicePixelRatio", window.devicePixelRatio || 1);
                B(this, "cpuCoreCount", navigator.hardwareConcurrency || 1);
                B(this, "baseUrl", document.location.origin);
                B(this, "isIFrame", window.self !== window.top)
            }
        }
        var Ze = r(128)
          , Nt = r(741);
        class Bt {
            constructor(pt, Fe) {
                B(this, "font");
                B(this, "texture");
                B(this, "material", null);
                this.font = pt,
                this.texture = Fe,
                this.material = new Nt.B,
                this.material.uniforms.texFont.value = Fe
            }
            build(pt, Fe) {
                const qe = this.font
                  , wt = qe.common.scaleW
                  , An = qe.common.scaleH
                  , Qt = pt.glyphs.filter(Gt=>Gt.data.width * Gt.data.height > 0)
                  , Pi = Fe.flipY !== !1
                  , ui = new Float32Array(Qt.length * 8)
                  , mi = new Float32Array(Qt.length * 8)
                  , Si = new Uint16Array(Qt.length * 6);
                for (let Gt = 0, On = 0, kn = 0, bi = 0, $i = 0; $i < Qt.length; $i++,
                Gt += 4) {
                    const zr = Qt[$i]
                      , Fi = zr.data;
                    let vr = zr.position[0] + Fi.xoffset
                      , Oi = zr.position[1] + Fi.yoffset
                      , ts = Fi.width
                      , Gr = Fi.height;
                    ui[On++] = vr,
                    ui[On++] = Oi,
                    ui[On++] = vr + ts,
                    ui[On++] = Oi,
                    ui[On++] = vr + ts,
                    ui[On++] = Oi + Gr,
                    ui[On++] = vr,
                    ui[On++] = Oi + Gr;
                    let ys = Fi.x + Fi.width
                      , xs = Fi.y + Fi.height
                      , hi = Fi.x / wt
                      , Ti = Fi.y / An
                      , gi = ys / wt
                      , qi = xs / An;
                    Pi && (Ti = 1 - Ti,
                    qi = 1 - qi),
                    mi[kn++] = hi,
                    mi[kn++] = Ti,
                    mi[kn++] = gi,
                    mi[kn++] = Ti,
                    mi[kn++] = gi,
                    mi[kn++] = qi,
                    mi[kn++] = hi,
                    mi[kn++] = qi,
                    Si[bi++] = Gt + 0,
                    Si[bi++] = Gt + 1,
                    Si[bi++] = Gt + 2,
                    Si[bi++] = Gt + 0,
                    Si[bi++] = Gt + 2,
                    Si[bi++] = Gt + 3
                }
                return {
                    position: ui,
                    uv: mi,
                    indice: Si
                }
            }
        }
        var en = r(745);
        class li extends en.g {
            constructor() {
                super(...arguments);
                B(this, "extensions", ["fnt"])
            }
            load({url: Fe, onLoad: qe, onProgress: wt, onError: An, texSettings: Qt}) {
                (async()=>{
                    try {
                        let Pi = await this.viewer.loadAsset({
                            url: Fe,
                            selExt: "json"
                        })
                          , ui = await this.viewer.loadAsset({
                            url: `${(0,
                            q.I_)(Fe)}/${Pi.pages[0]}`,
                            onProgress: wt
                        });
                        qe(new Bt(Pi,Object.assign(ui, Qt)))
                    } catch (Pi) {
                        An(Pi)
                    }
                }
                )()
            }
        }
        var di = r(930);
        class xi {
            constructor(pt, Fe="") {
                B(this, "excute");
                B(this, "name");
                this.excute = pt,
                this.name = Fe
            }
        }
        class zt extends di.v {
            constructor(Fe, qe, wt) {
                super();
                B(this, "onComplete");
                B(this, "onProgress");
                B(this, "onError");
                B(this, "_tasks", []);
                B(this, "_taskIndex", 0);
                B(this, "_percent", 0);
                this.onComplete = Fe,
                this.onProgress = qe,
                this.onError = wt
            }
            get percent() {
                return this._percent
            }
            add(Fe) {
                this._tasks.push(Fe)
            }
            update() {
                let Fe = this._tasks[this._taskIndex];
                if (Fe) {
                    try {
                        Fe.excute()
                    } catch (qe) {
                        console.error(qe),
                        this.onError && this.onError(Fe)
                    }
                    this._percent = ++this._taskIndex / this._tasks.length,
                    this.onProgress && this.onProgress(Fe, this._taskIndex, this._tasks.length),
                    this._taskIndex === this._tasks.length && (this._percent = 1,
                    this.onComplete && this.onComplete())
                }
            }
        }
        var Sn = r(371);
        let rn = new s.Pa4
          , Ft = new s.Pa4
          , jt = new s.FM8;
        function Xt(He, pt=[]) {
            return typeof He == "function" ? new He(...pt) : He
        }
        const Wn = class Wn extends R {
            constructor({root: Fe, canvas: qe=document.getElementById("canvas"), shadows: wt=!1, depth: An=!1, outputEncoding: Qt=s.knz, toneMapping: Pi=s.EoG, toneMappingExposure: ui=1, camera: mi={
                fov: 45,
                near: 1,
                far: 1e3,
                position: (0,
                N.nX)(0, 0, 4)
            }, autoStart: Si=!0, autoResize: Gt=!0, floatPacking: On=!1, maxDPR: kn=1.5, orientation: bi=Ze.i.AUTO, dracoPath: $i, targetFrameRate: zr, loader: Fi={}, tasker: vr={}, ...Oi}={}) {
                super();
                B(this, "_width", 0);
                B(this, "_height", 0);
                B(this, "_running", !1);
                B(this, "_renderer");
                B(this, "_root");
                B(this, "_canvas");
                B(this, "_context");
                B(this, "_loadingManager");
                B(this, "_taskManager");
                B(this, "_scene");
                B(this, "_camera");
                B(this, "_viewport", {
                    width: 1,
                    height: 1,
                    factor: 1
                });
                B(this, "_input", new ne.i(this));
                B(this, "_caches", new Map);
                B(this, "_loaders", new Map);
                B(this, "_brower", new et);
                B(this, "_autoResize", !0);
                B(this, "_floatPacking", !1);
                B(this, "_targetFrameRate", null);
                B(this, "_orientation", Ze.i.AUTO);
                B(this, "_dracoPath", "https://www.gstatic.com/draco/versioned/decoders/1.5.5/");
                B(this, "_RENDER_TARGET_FLOAT_TYPE", s.cLu);
                B(this, "_DATA_FLOAT_TYPE", s.VzW);
                B(this, "_rootRotated", !1);
                B(this, "_maxDPR", 1.5);
                B(this, "_time", 0);
                B(this, "_lastTime", 0);
                let ts = {
                    alpha: !1,
                    depth: !0,
                    stencil: !0,
                    antialias: !1,
                    premultipliedAlpha: !0,
                    preserveDrawingBuffer: !1,
                    powerPreference: "default",
                    failIfMajorPerformanceCaveat: !1
                }
                  , Gr = this._getContext(qe, Object.assign(ts, Oi));
                if (Gr === null) {
                    console.error("Unsupport WebGL in current platform");
                    return
                }
                this._root = Fe || qe,
                this._canvas = qe,
                this._context = Gr,
                this._maxDPR = kn,
                this._scene = new s.xsS,
                this._camera = (0,
                N.$p)(new s.cPb(mi.fov,mi.aspect || qe.width / qe.height,mi.near,mi.far), mi),
                this._renderer = new s.CP7({
                    canvas: qe,
                    context: Gr
                }),
                this._renderer.setPixelRatio(this.dpr),
                this._renderer.outputEncoding = Qt,
                this._renderer.toneMapping = Pi,
                this._renderer.toneMappingExposure = ui,
                this._renderer.shadowMap.enabled = !!wt,
                this._renderer.shadowMap.type = typeof wt == "boolean" ? s.ntZ : wt,
                this._renderer.info.autoReset = !1,
                this._autoResize = Gt,
                this._orientation = bi,
                this._loadingManager = new s.lLk(Fi.onLoad,Fi.onProgress,Fi.onError),
                this._taskManager = new zt(vr.onComplete,vr.onProgress,vr.onError),
                this._input.addEventListeners(),
                this._setColorSpace(),
                this._addDefaultPlugins(),
                this._addDefaultLoaders(),
                $i && (this._dracoPath = $i),
                zr && (this.targetFrameRate = zr),
                Si && this.start(),
                this.printInfo()
            }
            get width() {
                return this._width
            }
            get height() {
                return this._height
            }
            get rootRotated() {
                return this._rootRotated
            }
            get orientation() {
                return this._orientation
            }
            get dracoPath() {
                return this._dracoPath
            }
            get targetFrameRate() {
                return this._targetFrameRate
            }
            set targetFrameRate(Fe) {
                if (Fe <= 0)
                    throw Error("targetFrameRate must be greater than 0, or undefined.");
                this._targetFrameRate = Fe
            }
            get RENDER_TARGET_FLOAT_TYPE() {
                return this._RENDER_TARGET_FLOAT_TYPE
            }
            get DATA_FLOAT_TYPE() {
                return this._DATA_FLOAT_TYPE
            }
            get floatPacking() {
                return this._floatPacking
            }
            get canvas() {
                return this._canvas
            }
            get context() {
                return this._context
            }
            get brower() {
                return this._brower
            }
            get autoResize() {
                return this._autoResize
            }
            get environment() {
                return this._scene.userData.environment
            }
            get background() {
                return this._scene.userData.background
            }
            get input() {
                return this._input
            }
            get time() {
                return this._time
            }
            get renderer() {
                return this._renderer
            }
            get scene() {
                return this._scene
            }
            get camera() {
                return this._camera
            }
            get dpr() {
                return Math.min(this._maxDPR, window.devicePixelRatio)
            }
            get viewport() {
                return this._viewport
            }
            get size() {
                return this._renderer.getSize(jt)
            }
            get colorSpace() {
                return s.epp.enabled ? s.epp.workingColorSpace : "srgb"
            }
            get dom() {
                return this._renderer.domElement
            }
            get loadingManager() {
                return this._loadingManager
            }
            get root() {
                return this._root
            }
            printInfo() {
                const Fe = this._renderer.getContext();
                console.log(["Welcome to xviewer.js", "Three Version: " + s.UZH, "WebGL Version: " + Fe.getParameter(Fe.VERSION), "ColorSpace: " + this.colorSpace].join(`
`))
            }
            _getContext(Fe, qe) {
                const wt = this._brower;
                if (!((wt.isChrome || wt.isSafari || wt.isEdge || wt.isFirefox || wt.isOpera) && !wt.isIE))
                    return console.error("Unsupport platform"),
                    null;
                if (!(Fe instanceof HTMLCanvasElement))
                    return console.error("Canvas is null"),
                    null;
                if (window.WebGL2RenderingContext)
                    try {
                        let Qt = Fe.getContext("webgl2", qe);
                        return this._RENDER_TARGET_FLOAT_TYPE = s.cLu,
                        this._DATA_FLOAT_TYPE = s.VzW,
                        Qt
                    } catch (Qt) {
                        return console.error(Qt),
                        null
                    }
                else if (window.WebGLRenderingContext) {
                    let Qt = Fe.getContext("webgl", qe) || Fe.getContext("webgl2", qe) || Fe.getContext("experimental-webgl", qe);
                    return (Qt.getExtension("OES_texture_float") || Qt.getExtension("OES_texture_half_float")) && Qt.getParameter(Qt.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (this._RENDER_TARGET_FLOAT_TYPE = this._brower.isIOS || Qt.getExtension("OES_texture_half_float") ? s.cLu : s.VzW,
                    this._DATA_FLOAT_TYPE = s.VzW,
                    Qt) : this._floatPacking ? (this._RENDER_TARGET_FLOAT_TYPE = this._DATA_FLOAT_TYPE = s.ywz,
                    Qt) : (console.log("Unspport float type in current platform"),
                    null)
                }
                return null
            }
            _setColorSpace() {
                s.epp.enabled = this.renderer.outputEncoding === s.knz
            }
            _addDefaultPlugins() {
                this.addPlugin(Se)
            }
            _addDefaultLoaders() {
                this.addLoader(h.f0),
                this.addLoader(h.GP),
                this.addLoader(h.q7),
                this.addLoader(h.Ae),
                this.addLoader(h.uo),
                this.addLoader(h.k7),
                this.addLoader(h.Zt),
                this.addLoader(h.YQ),
                this.addLoader(li),
                this.addLoader(h.KC)
            }
            _onPreDestroy() {
                this._caches.clear(),
                this._renderer.dispose(),
                this._input.removeAllListeners(),
                this.destroyComponents(this._scene),
                this.stop()
            }
            async load({url: Fe, settings: qe, clear: wt=!1, castShadow: An=!1, receiveShadow: Qt=!1, parent: Pi=this._scene, onProgress: ui, ...mi}) {
                const Si = await this.loadAsset({
                    url: Fe,
                    onProgress: ui,
                    ...mi
                });
                return (An || Qt) && Si.meshData.meshes.forEach(Gt=>{
                    Gt.castShadow = An,
                    Gt.receiveShadow = Qt
                }
                ),
                wt && Pi.clear(),
                this.addNode(Si, mi),
                Si
            }
            loadAsset({url: Fe, selExt: qe, onProgress: wt, ...An}) {
                return new Promise((Qt,Pi)=>{
                    const {url: ui, file: mi, ext: Si} = (0,
                    q.BR)(Fe)
                      , Gt = (0,
                    q.G)(An)
                      , On = (0,
                    q.bk)(ui, Gt);
                    let kn = this._caches.get(On);
                    if (kn)
                        Qt(kn);
                    else {
                        const bi = zr=>{
                            this._caches.set(On, zr),
                            Qt(zr)
                        }
                        ;
                        let $i = qe || Si;
                        this._loaders.has($i) ? this._loaders.get($i).load({
                            url: ui,
                            file: mi,
                            texSettings: Gt,
                            onProgress: wt,
                            onLoad: bi,
                            onError: Pi
                        }) : Pi("missing loader for " + Si)
                    }
                }
                )
            }
            addLoader(Fe) {
                let qe = new Fe(this);
                for (let wt of qe.extensions)
                    this._loaders.set(wt, qe);
                return this
            }
            async setEnvironment(Fe={}) {
                let qe = Fe.url ?? null;
                this._scene.userData.environment !== qe && (this._scene.userData.environment = qe,
                this._scene.environment = qe ? await this.loadAsset(Object.assign({
                    mapping: s.dSO
                }, Fe)) : null),
                Fe && Fe.noBackground || this.setBackground(Fe)
            }
            async setBackground(Fe) {
                let qe = Fe.color || Fe.url || null;
                this._scene.userData.background !== qe && (this._scene.userData.background = qe,
                this._scene.background = qe ? Fe.color || await this.loadAsset(Object.assign({
                    mapping: s.dSO
                }, Fe)) : null)
            }
            portal(Fe) {
                const qe = this._scene
                  , wt = this._camera;
                this._scene = new s.xsS;
                const An = Fe();
                return this._scene = qe,
                this._camera = wt,
                An
            }
            addNode(Fe, {scale: qe, position: wt, rotation: An, debug: Qt, shadowArgs: Pi, makeDefault: ui, args: mi, parent: Si=this._scene, components: Gt=[], ...On}={}) {
                let kn, bi = Xt(Fe, mi);
                if (bi.isObject3D) {
                    kn = bi,
                    Si.add(bi);
                    for (let $i of Gt)
                        this.addComponent(kn, $i.ins),
                        (0,
                        N.$p)($i.ins, $i.props)
                } else if (bi.isComponent)
                    kn = bi.node || new s.Tme,
                    Si.add(kn),
                    this.addComponent(kn, bi);
                else
                    throw Error("unsuport object");
                return (0,
                N.$p)(bi, On, !0),
                (0,
                N.$p)(kn, {
                    scale: qe,
                    position: wt,
                    rotation: An
                }),
                bi.isCamera && ui && (bi.manual = bi.aspect !== this.camera.aspect,
                this._camera = bi),
                Pi && kn.isDirectionalLight && (0,
                $.lK)(kn.shadow, Pi),
                Qt && (kn.userData.debug = Qt),
                bi
            }
            addTask(Fe, qe) {
                this._taskManager.add(new xi(Fe,qe))
            }
            addPlugin(Fe, {args: qe, ...wt}={}) {
                let An = Xt(Fe, qe);
                return this.addComponent(this._scene, An),
                (0,
                N.$p)(An, wt),
                An
            }
            getPlugin(Fe) {
                return this.getComponent(this._scene, Fe)
            }
            requirePlugin(Fe) {
                let qe = this.getPlugin(Fe);
                return qe === void 0 && (qe = this.addPlugin(Fe)),
                qe
            }
            component(Fe, {args: qe, ...wt}={}) {
                return {
                    ins: Xt(Fe, qe),
                    props: wt
                }
            }
            resize(Fe=window.innerWidth, qe=window.innerHeight) {
                if (this._rootRotated = this._orientation === Ze.i.LANDSCAPE ? Fe < qe : this._orientation === Ze.i.PORTRAIT ? Fe > qe : !1,
                this._rootRotated) {
                    let wt = Fe;
                    Fe = qe,
                    qe = wt
                }
                if (this._width !== Fe || this._height !== qe) {
                    this._width = Fe,
                    this._height = qe;
                    let wt = this._root;
                    this._rootRotated ? (wt.style["-webkit-transform"] = "rotate(90deg)",
                    wt.style.transform = "rotate(90deg)",
                    wt.style["-webkit-transform-origin"] = "0px 0px 0px",
                    wt.style.transformOrigin = "0px 0px 0px",
                    wt.style.margin = `0 0 0 ${qe}px`,
                    wt.style.width = `${Fe}px`,
                    wt.style.height = `${qe}px`) : (wt.style["-webkit-transform"] = "rotate(0deg)",
                    wt.style.transform = "rotate(0deg)",
                    wt.style.margin = "0px auto",
                    wt.style.width = `${Fe}px`,
                    wt.style.height = `${qe}px`);
                    let An = this._camera;
                    if (An.isOrthographicCamera)
                        this._viewport = {
                            width: Fe / An.zoom,
                            height: qe / An.zoom,
                            factor: 1
                        };
                    else if (An.isPerspectiveCamera) {
                        An.manual || (An.aspect = Fe / qe,
                        An.updateProjectionMatrix());
                        let Qt = An.getWorldPosition(Ft).distanceTo(rn)
                          , Pi = 2 * Math.tan(s.MathUtils.degToRad(An.fov * .5)) * Qt
                          , ui = Pi * Fe / qe;
                        this._viewport = {
                            width: ui,
                            height: Pi,
                            factor: Fe / ui
                        }
                    }
                    this.resizeCallback(Fe, qe),
                    this.emit(ne.i.RESIZE, Fe, qe)
                }
            }
            render(Fe) {
                this._renderer.info.reset(),
                this.renderCallback(Fe)
            }
            resizeCallback(Fe, qe) {
                this._renderer.setSize(Fe, qe)
            }
            renderCallback(Fe) {
                this._renderer.render(this._scene, this.camera)
            }
            loop(Fe) {
                this._autoResize && this.resize(),
                Fe = Math.min(Fe, .067),
                this.update(Fe),
                this.emit(Wn.RENDER_BEFORE),
                this.render(Fe),
                this.emit(Wn.RENDER_AFTER)
            }
            _frame(Fe) {
                if( window.stopRender ){
                    return;
                }
                // console.log('_frame');
                stats.update();
                if (this._time = Fe,
                this._taskManager.update(),
                (0,
                N.ri)(this._targetFrameRate)) {
                    const qe = 1 / this._targetFrameRate
                      , wt = Fe - this._lastTime;
                    wt >= qe && (this.loop(wt),
                    this._lastTime = Fe - wt % qe)
                } else
                    this.loop(Fe - this._lastTime),
                    this._lastTime = Fe
            }
            start() {
                window.scene = this._scene;
                window.camera = this._camera;

                console.log('start');
                if (this._running == !1) {
                    this._running = !0;
                    const Fe = qe=>{
                        this._running && (this._frame(qe * .001),
                        requestAnimationFrame(Fe))
                    }
                    ;
                    requestAnimationFrame(Fe)
                }
                return this
            }
            stop() {
                return this._running = !1,
                this._time = this._lastTime = 0,
                this
            }
            compile(Fe) {
                if (Array.isArray(Fe))
                    if (Fe.every(qe=>qe.isMaterial))
                        (0,
                        Sn.Wr)(this._renderer, this._scene, this._camera, Fe);
                    else
                        throw Error("unsuport material");
                else
                    typeof Fe == "object" ? Fe.isMaterial ? (0,
                    Sn.Wr)(this._renderer, this._scene, this._camera, Fe) : Fe.isObject3D ? (Fe.meshData.materials && (0,
                    Sn.Wr)(this._renderer, this._scene, this._camera, Object.values(Fe.meshData.materials)),
                    Fe.meshData.textures && (0,
                    Sn.$S)(this._renderer, Object.values(Fe.meshData.textures)),
                    Fe.meshData.meshes || (0,
                    Sn.EK)(this._renderer, this._scene, this._camera, Fe)) : Fe.isTexture && (0,
                    Sn.$S)(this._renderer, Fe) : (0,
                    Sn.EK)(this._renderer, this._scene, this._camera, this._scene)
            }
            createRenderTarget(Fe, qe, wt=!1, An=!1, Qt=0, Pi=!1) {
                return new s.dd2(Fe,qe,{
                    wrapS: s.uWy,
                    wrapT: s.uWy,
                    magFilter: wt ? s.TyD : s.wem,
                    minFilter: wt ? s.TyD : Pi ? s.FDw : s.wem,
                    type: typeof An == "boolean" ? An ? this.DATA_FLOAT_TYPE : s.ywz : An,
                    anisotropy: 0,
                    encoding: s.rnI,
                    depthBuffer: !1,
                    stencilBuffer: !1,
                    samples: this._brower.isSupportMSAA ? Qt : 0,
                    generateMipmaps: Pi
                })
            }
            createCubeRenderTarget(Fe, qe=!1, wt=!1, An=0, Qt=!1) {
                return new s.oAp(Fe,{
                    wrapS: s.uWy,
                    wrapT: s.uWy,
                    magFilter: qe ? s.TyD : s.wem,
                    minFilter: qe ? s.TyD : Qt ? s.FDw : s.wem,
                    type: typeof wt == "boolean" ? wt ? this.DATA_FLOAT_TYPE : s.ywz : wt,
                    anisotropy: 0,
                    encoding: s.rnI,
                    depthBuffer: !1,
                    stencilBuffer: !1,
                    samples: this._brower.isSupportMSAA ? An : 0,
                    generateMipmaps: Qt
                })
            }
            createDataTexture(Fe, qe, wt, An=!1, Qt=!0) {
                return new s.IEO(Fe,qe,wt,s.wk1,An ? s.VzW : s.ywz,s.xfE,s.uWy,s.uWy,Qt ? s.TyD : s.wem,Qt ? s.TyD : s.wem,0)
            }
        }
        ;
        B(Wn, "RENDER_BEFORE", "renderbefore"),
        B(Wn, "RENDER_AFTER", "renderafter"),
        B(Wn, "ATTACH_HELPER", "attachhelper");
        let Rt = Wn
    }
    ,
    25: (t,n,r)=>{
        r.d(n, {
            $TI: ()=>s.$TI,
            $V: ()=>s.$V,
            $Vf: ()=>s.$Vf,
            $YQ: ()=>s.$YQ,
            A5E: ()=>s.A5E,
            AXT: ()=>s.AXT,
            Aip: ()=>s.Aip,
            B02: ()=>s.B02,
            BFQ: ()=>s.BFQ,
            BG$: ()=>s.BG$,
            BKK: ()=>s.BKK,
            BVF: ()=>s.BVF,
            BVQ: ()=>s.BVQ,
            BbS: ()=>s.BbS,
            Bf4: ()=>s.Bf4,
            BtG: ()=>s.BtG,
            CJI: ()=>s.CJI,
            CP7: ()=>s.CP7,
            CaW: ()=>s.CaW,
            CdI: ()=>s.CdI,
            Cne: ()=>s.Cne,
            CtA: ()=>s.CtA,
            CtF: ()=>s.CtF,
            D1R: ()=>s.D1R,
            D9w: ()=>s.D9w,
            DT1: ()=>s.DT1,
            Djp: ()=>s.Djp,
            DqL: ()=>s.DqL,
            DvJ: ()=>s.DvJ,
            E2K: ()=>s.E2K,
            EB7: ()=>s.EB7,
            EJi: ()=>s.EJi,
            EoG: ()=>s.EoG,
            F5T: ()=>s.F5T,
            FDw: ()=>s.FDw,
            FE5: ()=>s.FE5,
            FIo: ()=>s.FIo,
            FM8: ()=>s.FM8,
            FT0: ()=>s.FT0,
            FUD: ()=>s.FUD,
            FvO: ()=>s.FvO,
            GG6: ()=>s.GG6,
            GQ: ()=>s.GQ,
            GUF: ()=>s.GUF,
            GVz: ()=>s.GVz,
            GZb: ()=>s.GZb,
            Gih: ()=>s.Gih,
            Gql: ()=>s.Gql,
            H$k: ()=>s.H$k,
            HTd: ()=>s.HTd,
            HW6: ()=>s.HW6,
            HdW: ()=>s.HdW,
            HgB: ()=>s.HgB,
            HkE: ()=>s.HkE,
            Hmr: ()=>s.Hmr,
            Hw6: ()=>s.Hw6,
            Hy8: ()=>s.Hy8,
            Hyl: ()=>s.Hyl,
            IEO: ()=>s.IEO,
            IFH: ()=>s.IFH,
            IKL: ()=>s.IKL,
            ILR: ()=>s.ILR,
            IOt: ()=>s.IOt,
            Ilk: ()=>s.Ilk,
            Ir4: ()=>s.Ir4,
            JOQ: ()=>s.JOQ,
            JQ4: ()=>s.JQ4,
            JUT: ()=>s.JUT,
            JWc: ()=>s.JWc,
            KI_: ()=>s.KI_,
            Kgo: ()=>s.Kgo,
            KhW: ()=>s.KhW,
            Kj0: ()=>s.Kj0,
            Kz5: ()=>s.Kz5,
            L5g: ()=>s.L5g,
            L5s: ()=>s.L5s,
            LBq: ()=>s.LBq,
            LSk: ()=>s.LSk,
            LY2: ()=>s.LY2,
            L_r: ()=>s.L_r,
            Lcc: ()=>s.Lcc,
            LgZ: ()=>s.LgZ,
            LsT: ()=>s.LsT,
            Ltg: ()=>s.Ltg,
            Lun: ()=>s.Lun,
            M5h: ()=>s.M5h,
            M6v: ()=>s.M6v,
            MathUtils: ()=>s.M8C,
            Mig: ()=>s.Mig,
            MyG: ()=>s.MyG,
            N$j: ()=>s.N$j,
            N4l: ()=>s.N4l,
            NDo: ()=>s.NDo,
            NMF: ()=>s.NMF,
            NYV: ()=>s.NYV,
            Ns1: ()=>s.Ns1,
            NwF: ()=>s.NwF,
            Ny0: ()=>s.Ny0,
            O7d: ()=>s.O7d,
            OAl: ()=>s.OAl,
            OM3: ()=>s.OM3,
            OTo: ()=>s.OTo,
            OdW: ()=>s.OdW,
            OoA: ()=>s.OoA,
            Ox3: ()=>s.Ox3,
            PA7: ()=>s.PA7,
            PMe: ()=>s.PMe,
            Pa4: ()=>s.Pa4,
            PeU: ()=>s.PeU,
            Pnf: ()=>s.Pnf,
            PpQ: ()=>s.PpQ,
            QM0: ()=>s.QM0,
            QRU: ()=>s.QRU,
            QZ1: ()=>s.QZ1,
            QmN: ()=>s.QmN,
            Qpg: ()=>s.Qpg,
            R2R: ()=>s.R2R,
            REq: ()=>s.REq,
            RNb: ()=>s.RNb,
            ROQ: ()=>s.ROQ,
            RSm: ()=>s.RSm,
            Rki: ()=>s.Rki,
            RlZ: ()=>s.RlZ,
            RsA: ()=>s.RsA,
            RvT: ()=>s.RvT,
            S2y: ()=>s.S2y,
            S3k: ()=>s.S3k,
            S9g: ()=>s.S9g,
            SJI: ()=>s.SJI,
            SPe: ()=>s.SPe,
            SUY: ()=>s.SUY,
            Se2: ()=>s.Se2,
            Sm8: ()=>s.Sm8,
            So8: ()=>s.So8,
            SvJ: ()=>s.SvJ,
            Syv: ()=>s.Syv,
            T95: ()=>s.T95,
            TOt: ()=>s.TOt,
            TUj: ()=>s.TUj,
            TUv: ()=>s.TUv,
            T_1: ()=>s.T_1,
            T_J: ()=>s.T_J,
            T__: ()=>s.T__,
            T_f: ()=>s.T_f,
            TlE: ()=>s.TlE,
            Tme: ()=>s.Tme,
            Tn7: ()=>s.Tn7,
            TyD: ()=>s.TyD,
            U7: ()=>s.U7,
            USm: ()=>s.USm,
            UY4: ()=>s.UY4,
            UZH: ()=>s.UZH,
            Uk6: ()=>s.Uk6,
            UlW: ()=>s.UlW,
            Uol: ()=>s.Uol,
            V1s: ()=>s.V1s,
            V4E: ()=>s.V4E,
            VLJ: ()=>s.VLJ,
            VYz: ()=>s.VYz,
            Vdb: ()=>s.Vdb,
            Vj0: ()=>s.Vj0,
            Vkp: ()=>s.Vkp,
            VzW: ()=>s.VzW,
            W2J: ()=>s.W2J,
            WMw: ()=>s.WMw,
            WTc: ()=>s.WTc,
            WXh: ()=>s.WXh,
            Wbm: ()=>s.Wbm,
            WdD: ()=>s.WdD,
            Wid: ()=>s.Wid,
            Wjw: ()=>s.Wjw,
            Wl3: ()=>s.Wl3,
            Wpd: ()=>s.Wpd,
            Wqd: ()=>s.Wqd,
            WwZ: ()=>s.WwZ,
            Wzm: ()=>s.Wzm,
            XZw: ()=>s.XZw,
            Xaj: ()=>s.Xaj,
            Xcj: ()=>s.Xcj,
            XvJ: ()=>s.XvJ,
            Y8D: ()=>s.Y8D,
            YBo: ()=>s.YBo,
            YGz: ()=>s.YGz,
            YKA: ()=>s.YKA,
            YLQ: ()=>s.YLQ,
            YN5: ()=>s.YN5,
            YT8: ()=>s.YT8,
            Ywn: ()=>s.Ywn,
            Z6B: ()=>s.Z6B,
            ZAu: ()=>s.ZAu,
            ZQ6: ()=>s.ZQ6,
            ZRs: ()=>s.ZRs,
            ZTh: ()=>s.ZTh,
            ZZA: ()=>s.ZZA,
            Z_g: ()=>s.Z_g,
            Zp0: ()=>s.Zp0,
            Zr5: ()=>s.Zr5,
            ZzF: ()=>s.ZzF,
            Zzh: ()=>s.Zzh,
            _12: ()=>s._12,
            _3: ()=>s._3,
            _AM: ()=>s._AM,
            _C8: ()=>s._C8,
            _Li: ()=>s._Li,
            _MY: ()=>s._MY,
            _YM: ()=>s._YM,
            _YX: ()=>s._YX,
            _am: ()=>s._am,
            _fP: ()=>s._fP,
            _iA: ()=>s._iA,
            _kC: ()=>s._kC,
            _lf: ()=>s._lf,
            _sL: ()=>s._sL,
            a$l: ()=>s.a$l,
            aCh: ()=>s.aCh,
            aH4: ()=>s.aH4,
            aLr: ()=>s.aLr,
            aNw: ()=>s.aNw,
            aVm: ()=>s.aVm,
            ad5: ()=>s.ad5,
            anP: ()=>s.anP,
            aq0: ()=>s.aq0,
            av9: ()=>s.av9,
            b5g: ()=>s.b5g,
            bGH: ()=>s.bGH,
            b_z: ()=>s.b_z,
            bdR: ()=>s.bdR,
            blk: ()=>s.blk,
            bnF: ()=>s.bnF,
            brP: ()=>s.brP,
            bsb: ()=>s.bsb,
            c8b: ()=>s.c8b,
            cBI: ()=>s.cBI,
            cBK: ()=>s.cBK,
            cJO: ()=>s.cJO,
            cLu: ()=>s.cLu,
            cPb: ()=>s.cPb,
            cRx: ()=>s.cRx,
            cU9: ()=>s.cU9,
            ce8: ()=>s.ce8,
            cek: ()=>s.cek,
            cum: ()=>s.cum,
            dSO: ()=>s.dSO,
            dUE: ()=>s.dUE,
            dYG: ()=>s.dYG,
            dZ3: ()=>s.dZ3,
            dd2: ()=>s.dd2,
            dj0: ()=>s.dj0,
            dpR: ()=>s.dpR,
            dwk: ()=>s.dwk,
            e62: ()=>s.e62,
            eD: ()=>s.eD,
            eMJ: ()=>s.eMJ,
            eaV: ()=>s.eaV,
            ehD: ()=>s.ehD,
            ejS: ()=>s.ejS,
            ekQ: ()=>s.ekQ,
            epp: ()=>s.epp,
            fHI: ()=>s.fHI,
            fO1: ()=>s.fO1,
            fQA: ()=>s.fQA,
            fQK: ()=>s.fQK,
            fSK: ()=>s.fSK,
            fY$: ()=>s.fY$,
            fto: ()=>s.fto,
            g8_: ()=>s.g8_,
            gH0: ()=>s.gH0,
            gSk: ()=>s.gSk,
            g_z: ()=>s.g_z,
            ghN: ()=>s.ghN,
            gi4: ()=>s.gi4,
            gti: ()=>s.gti,
            hEm: ()=>s.hEm,
            hH6: ()=>s.hH6,
            iAb: ()=>s.iAb,
            iDF: ()=>s.iDF,
            iKG: ()=>s.iKG,
            iLg: ()=>s.iLg,
            iMs: ()=>s.iMs,
            iUV: ()=>s.iUV,
            iWC: ()=>s.iWC,
            iWj: ()=>s.iWj,
            i_9: ()=>s.i_9,
            iiP: ()=>s.iiP,
            irR: ()=>s.irR,
            j4z: ()=>s.j4z,
            j87: ()=>s.j87,
            jAl: ()=>s.jAl,
            jFi: ()=>s.jFi,
            jZA: ()=>s.jZA,
            jfJ: ()=>s.jfJ,
            jwo: ()=>s.jwo,
            jyi: ()=>s.jyi,
            jyz: ()=>s.jyz,
            k0A: ()=>s.k0A,
            k74: ()=>s.k74,
            kB5: ()=>s.kB5,
            kFz: ()=>s.kFz,
            kaV: ()=>s.kaV,
            knz: ()=>s.knz,
            kqm: ()=>s.kqm,
            ksN: ()=>s.ksN,
            l0P: ()=>s.l0P,
            l8J: ()=>s.l8J,
            lCJ: ()=>s.lCJ,
            lDi: ()=>s.lDi,
            lGU: ()=>s.lGU,
            lLk: ()=>s.lLk,
            lRF: ()=>s.lRF,
            lRj: ()=>s.lRj,
            lb7: ()=>s.lb7,
            lfu: ()=>s.lfu,
            lk7: ()=>s.lk7,
            m7l: ()=>s.m7l,
            mSO: ()=>s.mSO,
            mTL: ()=>s.mTL,
            mXe: ()=>s.mXe,
            m_w: ()=>s.m_w,
            mzJ: ()=>s.mzJ,
            nls: ()=>s.nls,
            ntZ: ()=>s.ntZ,
            ntt: ()=>s.ntt,
            nvb: ()=>s.nvb,
            o8S: ()=>s.o8S,
            oAp: ()=>s.oAp,
            oa8: ()=>s.oa8,
            oqc: ()=>s.oqc,
            p3g: ()=>s.p3g,
            p7y: ()=>s.p7y,
            pBf: ()=>s.pBf,
            pIN: ()=>s.pIN,
            pKu: ()=>s.pKu,
            pQR: ()=>s.pQR,
            ptH: ()=>s.ptH,
            qhX: ()=>s.qhX,
            qkB: ()=>s.qkB,
            qlB: ()=>s.qlB,
            qyh: ()=>s.qyh,
            rAo: ()=>s.rAo,
            rBU: ()=>s.rBU,
            rDY: ()=>s.rDY,
            rOj: ()=>s.rOj,
            r_: ()=>s.r_,
            rnI: ()=>s.rnI,
            rpg: ()=>s.rpg,
            s4_: ()=>s.s4_,
            sYA: ()=>s.sYA,
            tEQ: ()=>s.tEQ,
            tGC: ()=>s.tGC,
            tJx: ()=>s.tJx,
            tUh: ()=>s.tUh,
            tf: ()=>s.tf,
            tm_: ()=>s.tm_,
            trn: ()=>s.trn,
            u37: ()=>s.u37,
            u7G: ()=>s.u7G,
            u9r: ()=>s.u9r,
            uEv: ()=>s.uEv,
            uL9: ()=>s.uL9,
            uWy: ()=>s.uWy,
            uXU: ()=>s.uXU,
            ub3: ()=>s.ub3,
            ujx: ()=>s.ujx,
            v3W: ()=>s.v3W,
            v9Y: ()=>s.v9Y,
            vBJ: ()=>s.vBJ,
            vCF: ()=>s.vCF,
            vCx: ()=>s.vCx,
            vZf: ()=>s.vZf,
            vmT: ()=>s.vmT,
            vpT: ()=>s.vpT,
            vuL: ()=>s.vuL,
            vxC: ()=>s.vxC,
            w$m: ()=>s.w$m,
            wJv: ()=>s.wJv,
            wem: ()=>s.wem,
            wk1: ()=>s.wk1,
            woe: ()=>s.woe,
            wuA: ()=>s.wuA,
            x12: ()=>s.x12,
            x5V: ()=>s.x5V,
            xEZ: ()=>s.xEZ,
            xG9: ()=>s.xG9,
            xJs: ()=>s.xJs,
            xWb: ()=>s.xWb,
            xeV: ()=>s.xeV,
            xfE: ()=>s.xfE,
            xo$: ()=>s.xo$,
            xoR: ()=>s.xoR,
            xsS: ()=>s.xsS,
            y$t: ()=>s.y$t,
            y2t: ()=>s.y2t,
            y8_: ()=>s.y8_,
            yC1: ()=>s.yC1,
            yGw: ()=>s.yGw,
            ybr: ()=>s.ybr,
            yj7: ()=>s.yj7,
            ylh: ()=>s.ylh,
            yo9: ()=>s.yo9,
            yt0: ()=>s.yt0,
            ywz: ()=>s.ywz,
            yxD: ()=>s.yxD,
            z$h: ()=>s.z$h,
            z81: ()=>s.z81,
            z8B: ()=>s.z8B,
            zHn: ()=>s.zHn,
            zbs: ()=>s.zbs,
            zf8: ()=>s.zf8
        });
        var s = r(477)
    }
    ,
    481: (t,n,r)=>{
        r.r(n),
        r.d(n, {
            Easing: ()=>s.Easing,
            Group: ()=>s.Group,
            Interpolation: ()=>s.Interpolation,
            Sequence: ()=>s.Sequence,
            Tween: ()=>s.Tween,
            TweenChain: ()=>h.TweenChain,
            TweenManager: ()=>D,
            VERSION: ()=>s.VERSION,
            __esModule: ()=>s.__esModule,
            add: ()=>s.add,
            getAll: ()=>s.getAll,
            nextId: ()=>s.nextId,
            now: ()=>s.now,
            remove: ()=>s.remove,
            removeAll: ()=>s.removeAll,
            update: ()=>s.update
        });
        var s = r(622)
          , h = r(631);
        const {Tween: l, getAll: g, remove: _, update: A} = r(622)
          , {TweenChain: m} = r(631);
        class D {
            static Tween(R) {
                return new l(R)
            }
            static Timeline(R) {
                return new m(R)
            }
            static KillTweensOf(R) {
                let ne = g();
                for (let ce of ne)
                    ce._object === R && _(ce)
            }
            static TweenUpdate(R) {
                A(R)
            }
        }
    }
    ,
    400: (t,n,r)=>{
        r.d(n, {
            J12: ()=>Ji.J1,
            $c: ()=>ne.$c,
            I_b: ()=>Ji.I_,
            oGK: ()=>Ji.oG,
            $p: ()=>ne.$p,
            $q: ()=>ne.$q,
            $r: ()=>ne.$r,
            L0d: ()=>ne.L0,
            i5S: ()=>ne.i5,
            nXV: ()=>ne.nX,
            bd1: ()=>ne.bd,
            LY2: ()=>l.LY2,
            iAO: ()=>Ao,
            bGH: ()=>l.bGH,
            NDo: ()=>l.NDo,
            gSk: ()=>l.gSk,
            WMw: ()=>l.WMw,
            OTo: ()=>l.OTo,
            Se2: ()=>l.Se2,
            cum: ()=>l.cum,
            Mig: ()=>l.Mig,
            i_9: ()=>l.i_9,
            fwF: ()=>pt,
            m7l: ()=>l.m7l,
            vXP: ()=>m.vX,
            sYA: ()=>l.sYA,
            Xcj: ()=>l.Xcj,
            mzJ: ()=>l.mzJ,
            ZZA: ()=>l.ZZA,
            T__: ()=>l.T__,
            HkE: ()=>l.HkE,
            tGC: ()=>l.tGC,
            gOo: ()=>Ce.gO,
            f03: ()=>Ce.f0,
            BbS: ()=>l.BbS,
            kqm: ()=>l.kqm,
            GPr: ()=>Ce.GP,
            Hmr: ()=>l.Hmr,
            SJI: ()=>l.SJI,
            mTL: ()=>l.mTL,
            y8_: ()=>l.y8_,
            Xim: ()=>Ha,
            _Li: ()=>l._Li,
            z81: ()=>l.z81,
            _MY: ()=>l._MY,
            NBQ: ()=>po.NB,
            IIx: ()=>Re,
            N$j: ()=>l.N$j,
            _YM: ()=>l._YM,
            TUj: ()=>l.TUj,
            ZzF: ()=>l.ZzF,
            GQ: ()=>l.GQ,
            nvb: ()=>l.nvb,
            DvJ: ()=>l.DvJ,
            fQA: ()=>l.fQA,
            ePP: ()=>us,
            TlE: ()=>l.TlE,
            u9r: ()=>l.u9r,
            s4_: ()=>l.s4_,
            T95: ()=>l.T95,
            CtF: ()=>l.CtF,
            V1s: ()=>l.V1s,
            Rki: ()=>l.Rki,
            ROQ: ()=>l.ROQ,
            YN5: ()=>l.YN5,
            BVQ: ()=>l.BVQ,
            YT8: ()=>l.YT8,
            YGz: ()=>l.YGz,
            WXy: ()=>ie.W,
            trn: ()=>l.trn,
            zf8: ()=>l.zf8,
            uWy: ()=>l.uWy,
            SUY: ()=>l.SUY,
            Ilk: ()=>l.Ilk,
            R2R: ()=>l.R2R,
            epp: ()=>l.epp,
            Wrv: ()=>po.Wr,
            EKy: ()=>po.EK,
            $S: ()=>po.$S,
            wA2: ()=>ce.w,
            Z_g: ()=>l.Z_g,
            EB7: ()=>l.EB7,
            DqL: ()=>l.DqL,
            _3: ()=>l._3,
            b_z: ()=>l.b_z,
            unp: ()=>Be,
            _am: ()=>l._am,
            fY$: ()=>l.fY$,
            vxC: ()=>l.vxC,
            BtG: ()=>l.BtG,
            cBK: ()=>l.cBK,
            g8_: ()=>l.g8_,
            AXT: ()=>l.AXT,
            yj7: ()=>l.yj7,
            dYG: ()=>l.dYG,
            tm_: ()=>l.tm_,
            S2y: ()=>l.S2y,
            B02: ()=>l.B02,
            PeU: ()=>l.PeU,
            Hyl: ()=>l.Hyl,
            Wqd: ()=>l.Wqd,
            SVw: ()=>m.SV,
            Xaj: ()=>l.Xaj,
            dZ3: ()=>l.dZ3,
            m_w: ()=>l.m_w,
            fHI: ()=>l.fHI,
            LBq: ()=>l.LBq,
            JUT: ()=>l.JUT,
            p3g: ()=>l.p3g,
            IEO: ()=>l.IEO,
            yxD: ()=>l.yxD,
            A5E: ()=>l.A5E,
            jfJ: ()=>l.jfJ,
            T_J: ()=>l.T_J,
            tEQ: ()=>l.tEQ,
            qkB: ()=>l.qkB,
            brP: ()=>l.brP,
            $YQ: ()=>l.$YQ,
            iRp: ()=>Se.i,
            Ox3: ()=>l.Ox3,
            cBI: ()=>l.cBI,
            cU9: ()=>l.cU9,
            ntt: ()=>l.ntt,
            DT1: ()=>l.DT1,
            Kgo: ()=>l.Kgo,
            ehD: ()=>l.ehD,
            fSK: ()=>l.fSK,
            Vdb: ()=>l.Vdb,
            l8J: ()=>l.l8J,
            dj0: ()=>l.dj0,
            QM0: ()=>l.QM0,
            q7E: ()=>Ce.q7,
            TOt: ()=>l.TOt,
            Ny0: ()=>l.Ny0,
            qAh: ()=>eo,
            eD: ()=>l.eD,
            jwo: ()=>l.jwo,
            dSO: ()=>l.dSO,
            Bf4: ()=>l.Bf4,
            USm: ()=>l.USm,
            pBf: ()=>l.pBf,
            vpe: ()=>U.v,
            $Vf: ()=>l.$Vf,
            O7d: ()=>l.O7d,
            Aek: ()=>Ce.Ae,
            hH6: ()=>l.hH6,
            e62: ()=>l.e62,
            a$l: ()=>l.a$l,
            OM3: ()=>l.OM3,
            VzW: ()=>l.VzW,
            ybr: ()=>l.ybr,
            yo9: ()=>l.yo9,
            Wzm: ()=>l.Wzm,
            zUS: ()=>_e.z,
            Wl3: ()=>l.Wl3,
            iWj: ()=>l.iWj,
            ylh: ()=>l.ylh,
            v9Y: ()=>l.v9Y,
            LSk: ()=>l.LSk,
            uoT: ()=>Ce.uo,
            w$m: ()=>l.w$m,
            ksN: ()=>l.ksN,
            j4z: ()=>l.j4z,
            OAl: ()=>l.OAl,
            VLJ: ()=>l.VLJ,
            ZAu: ()=>l.ZAu,
            k7s: ()=>Ce.k7,
            cLu: ()=>l.cLu,
            vmT: ()=>l.vmT,
            Qpg: ()=>l.Qpg,
            So8: ()=>l.So8,
            Wjw: ()=>l.Wjw,
            cJO: ()=>l.cJO,
            KCx: ()=>Ce.KC,
            QRU: ()=>l.QRU,
            S3k: ()=>l.S3k,
            PpQ: ()=>l.PpQ,
            ZRs: ()=>l.ZRs,
            oqc: ()=>l.oqc,
            lb7: ()=>l.lb7,
            L5s: ()=>l.L5s,
            $TI: ()=>l.$TI,
            SPe: ()=>l.SPe,
            aVm: ()=>l.aVm,
            j87: ()=>l.j87,
            RNb: ()=>l.RNb,
            Kz5: ()=>l.Kz5,
            vpT: ()=>l.vpT,
            kB5: ()=>l.kB5,
            _C8: ()=>l._C8,
            Syv: ()=>l.Syv,
            NMF: ()=>l.NMF,
            pIN: ()=>l.pIN,
            eMJ: ()=>l.eMJ,
            ZtY: ()=>Ce.Zt,
            x5V: ()=>l.x5V,
            tUh: ()=>l.tUh,
            z8B: ()=>l.z8B,
            __J: ()=>ga,
            GZb: ()=>l.GZb,
            p7y: ()=>l.p7y,
            udN: ()=>se,
            S9g: ()=>l.S9g,
            Zr5: ()=>l.Zr5,
            vCF: ()=>l.vCF,
            yt0: ()=>l.yt0,
            uXU: ()=>l.uXU,
            _kC: ()=>l._kC,
            lk7: ()=>l.lk7,
            DvN: ()=>Ba,
            x12: ()=>l.x12,
            Zzh: ()=>l.Zzh,
            nls: ()=>l.nls,
            g_z: ()=>l.g_z,
            U7: ()=>l.U7,
            FT0: ()=>l.FT0,
            blk: ()=>l.blk,
            ejS: ()=>l.ejS,
            rnI: ()=>l.rnI,
            wem: ()=>l.wem,
            lfu: ()=>l.lfu,
            FDw: ()=>l.FDw,
            lRj: ()=>l.lRj,
            D1R: ()=>l.D1R,
            qyh: ()=>l.qyh,
            GUF: ()=>l.GUF,
            EoG: ()=>l.EoG,
            aNw: ()=>l.aNw,
            Zp0: ()=>l.Zp0,
            lLk: ()=>l.lLk,
            jAl: ()=>l.jAl,
            uEv: ()=>l.uEv,
            YKA: ()=>l.YKA,
            cRx: ()=>l.cRx,
            Y8D: ()=>l.Y8D,
            RsA: ()=>l.RsA,
            B51: ()=>ue.B,
            F5T: ()=>l.F5T,
            u7G: ()=>l.u7G,
            M8C: ()=>l.MathUtils,
            Vkp: ()=>l.Vkp,
            yGw: ()=>l.yGw,
            Sm8: ()=>l.Sm8,
            Kj0: ()=>l.Kj0,
            vBJ: ()=>l.vBJ,
            lRF: ()=>l.lRF,
            Lun: ()=>l.Lun,
            YBo: ()=>l.YBo,
            kaV: ()=>l.kaV,
            RSm: ()=>l.RSm,
            xoR: ()=>l.xoR,
            EJi: ()=>l.EJi,
            Qme: ()=>ct,
            Wid: ()=>l.Wid,
            jrH: ()=>ye,
            IKL: ()=>l.IKL,
            r_: ()=>l.r_,
            OPb: ()=>Co,
            OoA: ()=>l.OoA,
            qhX: ()=>l.qhX,
            M5h: ()=>l.M5h,
            Ns1: ()=>l.Ns1,
            TyD: ()=>l.TyD,
            vZf: ()=>l.vZf,
            HTd: ()=>l.HTd,
            aH4: ()=>l.aH4,
            YLQ: ()=>l.YLQ,
            BVF: ()=>l.BVF,
            MyG: ()=>l.MyG,
            jFi: ()=>l.jFi,
            aCh: ()=>l.aCh,
            uL9: ()=>l.uL9,
            fwl: ()=>He,
            IFH: ()=>l.IFH,
            bdR: ()=>l.bdR,
            M6v: ()=>l.M6v,
            RvT: ()=>l.RvT,
            dUE: ()=>l.dUE,
            Tme: ()=>l.Tme,
            Gql: ()=>l.Gql,
            PA7: ()=>l.PA7,
            REq: ()=>l.REq,
            pQR: ()=>l.pQR,
            ghN: ()=>l.ghN,
            Hy8: ()=>l.Hy8,
            Wpd: ()=>l.Wpd,
            LgZ: ()=>l.LgZ,
            iWC: ()=>l.iWC,
            i5E: ()=>D.i,
            iKG: ()=>l.iKG,
            _iA: ()=>l._iA,
            ntZ: ()=>l.ntZ,
            anP: ()=>l.anP,
            y$t: ()=>l.y$t,
            Ady: ()=>Fe,
            H8x: ()=>m.H8,
            cPb: ()=>l.cPb,
            JOQ: ()=>l.JOQ,
            BKK: ()=>l.BKK,
            _12: ()=>l._12,
            tJx: ()=>l.tJx,
            OdJ: ()=>rn,
            SyM: ()=>xa.S,
            cek: ()=>l.cek,
            xG9: ()=>l.xG9,
            woe: ()=>l.woe,
            UY4: ()=>l.UY4,
            aq0: ()=>l.aq0,
            ujx: ()=>l.ujx,
            Uol: ()=>l.Uol,
            VYz: ()=>l.VYz,
            XgS: ()=>Qr,
            iUV: ()=>l.iUV,
            tf: ()=>l.tf,
            ZQ6: ()=>l.ZQ6,
            mXe: ()=>l.mXe,
            _fP: ()=>l._fP,
            iLg: ()=>l.iLg,
            zbs: ()=>l.zbs,
            ZTh: ()=>l.ZTh,
            HdW: ()=>l.HdW,
            UZH: ()=>l.UZH,
            mSO: ()=>l.mSO,
            wk1: ()=>l.wk1,
            E2K: ()=>l.E2K,
            FUD: ()=>l.FUD,
            pKu: ()=>l.pKu,
            GG6: ()=>l.GG6,
            Gih: ()=>l.Gih,
            iiP: ()=>l.iiP,
            SvJ: ()=>l.SvJ,
            ptH: ()=>l.ptH,
            jZA: ()=>l.jZA,
            y2t: ()=>l.y2t,
            gi4: ()=>l.gi4,
            Djp: ()=>l.Djp,
            BG$: ()=>l.BG$,
            NYV: ()=>l.NYV,
            xJs: ()=>l.xJs,
            bsb: ()=>l.bsb,
            ekQ: ()=>l.ekQ,
            CaW: ()=>l.CaW,
            eaV: ()=>l.eaV,
            BFQ: ()=>l.BFQ,
            v3W: ()=>l.v3W,
            ILR: ()=>l.ILR,
            fto: ()=>l.fto,
            l0P: ()=>l.l0P,
            vCx: ()=>l.vCx,
            _AM: ()=>l._AM,
            wuA: ()=>l.wuA,
            av9: ()=>l.av9,
            CtA: ()=>l.CtA,
            mIn: ()=>Hi,
            FIo: ()=>l.FIo,
            zHn: ()=>l.zHn,
            iMs: ()=>l.iMs,
            T_f: ()=>l.T_f,
            hEm: ()=>l.hEm,
            D9w: ()=>l.D9w,
            CdI: ()=>l.CdI,
            TIb: ()=>Ft,
            rpg: ()=>l.rpg,
            ce8: ()=>l.ce8,
            rOj: ()=>l.rOj,
            V4E: ()=>l.V4E,
            o8S: ()=>l.o8S,
            lGU: ()=>l.lGU,
            vuL: ()=>l.vuL,
            KI_: ()=>l.KI_,
            xsS: ()=>l.xsS,
            b26: ()=>R.b,
            WdD: ()=>l.WdD,
            Vj0: ()=>l.Vj0,
            jyz: ()=>l.jyz,
            Tn7: ()=>l.Tn7,
            bnF: ()=>l.bnF,
            HW6: ()=>l.HW6,
            oa8: ()=>l.oa8,
            T_1: ()=>l.T_1,
            iDF: ()=>l.iDF,
            iAb: ()=>l.iAb,
            OdW: ()=>l.OdW,
            _YX: ()=>l._YX,
            TUv: ()=>l.TUv,
            Hw6: ()=>l.Hw6,
            aLr: ()=>l.aLr,
            Aip: ()=>l.Aip,
            xo$: ()=>l.xo$,
            $V: ()=>l.$V,
            lDi: ()=>l.lDi,
            gti: ()=>l.gti,
            PMe: ()=>l.PMe,
            FvO: ()=>l.FvO,
            jyi: ()=>l.jyi,
            xeV: ()=>l.xeV,
            k74: ()=>l.k74,
            RlZ: ()=>l.RlZ,
            KhW: ()=>l.KhW,
            HgB: ()=>l.HgB,
            W2J: ()=>l.W2J,
            JWc: ()=>l.JWc,
            kP0: ()=>Wi,
            u37: ()=>l.u37,
            Z6B: ()=>l.Z6B,
            QZ1: ()=>l.QZ1,
            Ir4: ()=>l.Ir4,
            NwF: ()=>l.NwF,
            Wbm: ()=>l.Wbm,
            N4l: ()=>l.N4l,
            QmN: ()=>l.QmN,
            wes: ()=>mt,
            IOt: ()=>l.IOt,
            L5g: ()=>l.L5g,
            H$k: ()=>l.H$k,
            xEZ: ()=>l.xEZ,
            YQ_: ()=>Ce.YQ,
            Yin: ()=>$.Y,
            dpR: ()=>l.dpR,
            Cne: ()=>l.Cne,
            XvJ: ()=>l.XvJ,
            XZw: ()=>l.XZw,
            FE5: ()=>l.FE5,
            Ys8: ()=>Wn,
            CJI: ()=>l.CJI,
            z$h: ()=>l.z$h,
            UlW: ()=>l.UlW,
            WwZ: ()=>l.WwZ,
            Lcc: ()=>l.Lcc,
            WXh: ()=>l.WXh,
            ub3: ()=>l.ub3,
            xfE: ()=>l.xfE,
            qlB: ()=>l.qlB,
            lCJ: ()=>l.lCJ,
            WTc: ()=>l.WTc,
            rAo: ()=>l.rAo,
            xWb: ()=>l.xWb,
            gH0: ()=>l.gH0,
            rBU: ()=>l.rBU,
            rDY: ()=>l.rDY,
            ywz: ()=>l.ywz,
            wJv: ()=>l.wJv,
            JQ4: ()=>l.JQ4,
            k0A: ()=>l.k0A,
            irR: ()=>l.irR,
            LsT: ()=>l.LsT,
            MiG: ()=>_e.M,
            dwk: ()=>l.dwk,
            FM8: ()=>l.FM8,
            Pa4: ()=>l.Pa4,
            Ltg: ()=>l.Ltg,
            yC1: ()=>l.yC1,
            fO1: ()=>l.fO1,
            AEx: ()=>xe.A,
            _9o: ()=>Pe._,
            k5T: ()=>Xt.k,
            b5g: ()=>l.b5g,
            Ywn: ()=>l.Ywn,
            GVz: ()=>l.GVz,
            oAp: ()=>l.oAp,
            kFz: ()=>l.kFz,
            dd2: ()=>l.dd2,
            CP7: ()=>l.CP7,
            fQK: ()=>l.fQK,
            Uk6: ()=>l.Uk6,
            _sL: ()=>l._sL,
            Pnf: ()=>l.Pnf,
            c8b: ()=>l.c8b,
            _lf: ()=>l._lf,
            ad5: ()=>l.ad5,
            L_r: ()=>l.L_r,
            eC3: ()=>ne.eC,
            BRj: ()=>Ji.BR,
            rif: ()=>ne.ri,
            HOT: ()=>q.HO,
            jfB: ()=>q.jf,
            wuM: ()=>ns.w,
            bkz: ()=>Ji.bk,
            lDs: ()=>gi.lD,
            tQ: ()=>gi.tQ,
            Oe_: ()=>gi.Oe,
            YRX: ()=>h,
            S6$: ()=>s,
            CbL: ()=>q.Cb,
            knz: ()=>l.knz,
            lKs: ()=>gi.lK,
            c1W: ()=>N.c,
            GaT: ()=>Ji.G,
            OEW: ()=>ne.OE,
            nB6: ()=>va.n
        });
        var s = {};
        r.r(s),
        r.d(s, {
            Box: ()=>An,
            Capsule: ()=>Qt,
            Circle: ()=>Pi,
            Cone: ()=>ui,
            Cylinder: ()=>mi,
            Dodecahedron: ()=>Si,
            Edges: ()=>Gt,
            Extrude: ()=>On,
            Icosahedron: ()=>kn,
            Lathe: ()=>bi,
            Octahedron: ()=>$i,
            Plane: ()=>zr,
            Polyhedron: ()=>Fi,
            Ring: ()=>vr,
            Shape: ()=>Oi,
            Sphere: ()=>ts,
            Tetrahedron: ()=>Gr,
            Torus: ()=>ys,
            TorusKnot: ()=>xs,
            Tube: ()=>hi,
            Wireframe: ()=>Ti
        });
        var h = {};
        r.r(h),
        r.d(h, {
            Alpha: ()=>Ei,
            BaseRenderer: ()=>Tr,
            Behaviour: ()=>En,
            Color: ()=>ar,
            Controller: ()=>ut,
            Emitter: ()=>ln,
            Force: ()=>fr,
            GPURenderer: ()=>Qo,
            Gravity: ()=>lr,
            Particle: ()=>gt,
            Scale: ()=>is,
            System: ()=>Hn,
            copyProperties: ()=>St,
            ease: ()=>te,
            setPrototypeByObj: ()=>Ge
        });
        var l = r(25);
        const g = `
uniform sampler2D   tCameraDepth;
uniform vec2        uCameraNearFar;

float getLinearEyeDepth(const in float fragCoordZ) {
    #if PERSPECTIVE_CAMERA == 1
        return -perspectiveDepthToViewZ(fragCoordZ, uCameraNearFar.x, uCameraNearFar.y );
    #else
        return -orthographicDepthToViewZ(fragCoordZ, uCameraNearFar.x, uCameraNearFar.y );
    #endif
}

float getLinear01Depth(const in float fragCoordZ) {
    #if PERSPECTIVE_CAMERA == 1
        float viewZ = perspectiveDepthToViewZ( fragCoordZ, uCameraNearFar.x, uCameraNearFar.y );
        return viewZToOrthographicDepth( viewZ, uCameraNearFar.x, uCameraNearFar.y );
    #else
        return fragCoordZ;
    #endif
}

float sampleDepth(const in vec2 screenPosition) {
    #if DEPTH_PACKING == 3201
        return unpackRGBAToDepth(texture2D(tCameraDepth, screenPosition));
    #else
        return texture2D(tCameraDepth, screenPosition).r;
    #endif
}

float sampleLinearEyeDepth(const in vec2 screenPosition) {
    return getLinearEyeDepth(sampleDepth(screenPosition));
}

float sampleLinear01Depth(const in vec2 screenPosition) {
    return getLinear01Depth(sampleDepth(screenPosition));
}
`
          , _ = `
#include <common>

float remap(float origFrom, float origTo, float targetFrom, float targetTo, float value) {
    return mix(targetFrom, targetTo, (value - origFrom) / (origTo - origFrom));
}

float remap01(float origFrom, float origTo, float value) {
    return saturate((value - origFrom) / (origTo - origFrom));
}

float remap10(float origFrom, float origTo, float value) {
    return saturate((origFrom - value) / (origTo - origFrom));
}

bool isPower2(int x) {
    return (x & (x - 1)) == 0;
}

// Input [0, 1] and output [0, PI/2]
// 9 VALU
float fastACosPos(float inX) {
    float x = abs(inX);
    float res = (0.0468878 * x + -0.203471) * x + 1.570796; // p(x)
    res *= sqrt(1.0 - x);

    return res;
}

// Ref: https://seblagarde.wordpress.com/2014/12/01/inverse-trigonometric-functions-gpu-optimization-for-amd-gcn-architecture/
// Input [-1, 1] and output [0, PI]
// 12 VALU
float fastACos(float inX) {
    float res = fastACosPos(inX);

    return (inX >= 0.) ? res : PI - res; // Undo range reduction
}

// Same cost as Acos + 1 FR
// Same error
// input [-1, 1] and output [-PI/2, PI/2]
float fastASin(float x) {
    return PI_HALF - fastACos(x);
}

// max absolute error 1.3x10^-3
// Eberly's odd polynomial degree 5 - respect bounds
// 4 VGPR, 14 FR (10 FR, 1 QR), 2 scalar
// input [0, infinity] and output [0, PI/2]
float fastATanPos(float x) {
    float t0 = (x < 1.0) ? x : 1.0 / x;
    float t1 = t0 * t0;
    float poly = 0.0872929;
    poly = -0.301895 + poly * t1;
    poly = 1.0 + poly * t1;
    poly = poly * t0;
    return (x < 1.0) ? poly : PI_HALF - poly;
}

// 4 VGPR, 16 FR (12 FR, 1 QR), 2 scalar
// input [-infinity, infinity] and output [-PI/2, PI/2]
float fastATan(float x) {
    float t0 = fastATanPos(abs(x));
    return (x < 0.0) ? -t0 : t0;
}

float fastAtan2(float y, float x) {
    return fastATan(y / x) + float(y >= 0.0 ? PI : -PI) * step(0., x);
}

// smoothstep that assumes that 'x' lies within the [0, 1] interval.
float smoothstep01(float x) {
    return x * x * (3. - (2. * x));
}

float smootherstep01(float x) {
  return x * x * x * (x * (x * 6. - 15.) + 10.);
}

// ref https://www.gamedev.net/topic/678043-how-to-blend-world-space-normals/#entry5287707
// assume compositing in world space
// Note: Using vtxNormal = vec3(0, 0, 1) give the blendNormalRNM formulation.
// TODO: Untested
vec3 blendNormalWorldspaceRNM(vec3 n1, vec3 n2, vec3 vtxNormal) {
    // Build the shortest-arc quaternion
    vec4 q = vec4(cross(vtxNormal, n2), dot(vtxNormal, n2) + 1.0) / sqrt(2.0 * (dot(vtxNormal, n2) + 1.));

    // Rotate the normal
    return n1 * (q.w * q.w - dot(q.xyz, q.xyz)) + 2. * q.xyz * dot(q.xyz, n1) + 2. * q.w * cross(q.xyz, n1);
}

// ref http://blog.selfshadow.com/publications/blending-in-detail/
// ref https://gist.github.com/selfshadow/8048308
// Reoriented Normal Mapping
// Blending when n1 and n2 are already 'unpacked' and normalised
// assume compositing in tangent space
vec3 blendNormalRNM(vec3 n1, vec3 n2) {
    vec3 t = n1.xyz + vec3(0.0, 0.0, 1.0);
    vec3 u = n2.xyz * vec3(-1.0, -1.0, 1.0);
    vec3 r = (t / t.z) * dot(t, u) - u;
    return r;
}

// assume compositing in tangent space
vec3 blendNormal(vec3 n1, vec3 n2) {
    return normalize(vec3(n1.xy * n2.z + n2.xy * n1.z, n1.z * n2.z));
}

vec2 cartesianToPolar(float x, float y, float z) {
    vec2 polar;
    polar.x = atan(z, x); // phi
    polar.y = asin(y); // theta
    return polar;
}

vec3 polarToCartesian(float phi, float theta) {
    vec3 cartesian;
    cartesian.x = sin(theta) * cos(phi);
    cartesian.y = cos(theta);
    cartesian.z = sin(theta) * sin(phi);
    return cartesian;
}

vec2 dirToUv(vec3 dir) {
    return cartesianToPolar(dir.x, dir.y, dir.z) * vec2(RECIPROCAL_PI2, RECIPROCAL_PI) + 0.5;
}

vec3 uvToDir(vec2 uv) {
    return polarToCartesian((uv.x - 0.5) * PI2, uv.y * PI);
}
`
          , A = `
mat4 getInstanceMatrix(vec3 p, vec4 q, vec3 s) {
    mat4 m;
    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;
    float x2 = x + x;
    float y2 = y + y;
    float z2 = z + z;
    float xx = x * x2;
    float xy = x * y2;
    float xz = x * z2;
    float yy = y * y2;
    float yz = y * z2;
    float zz = z * z2;
    float wx = w * x2;
    float wy = w * y2;
    float wz = w * z2;
    float sx = s.x;
    float sy = s.y;
    float sz = s.z;
    m[0][0] = (1. - (yy + zz)) * sx;
    m[0][1] = (xy + wz) * sx;
    m[0][2] = (xz - wy) * sx;
    m[0][3] = 0.;
    m[1][0] = (xy - wz) * sy;
    m[1][1] = (1. - (xx + zz)) * sy;
    m[1][2] = (yz + wx) * sy;
    m[1][3] = 0.;
    m[2][0] = (xz + wy) * sz;
    m[2][1] = (yz - wx) * sz;
    m[2][2] = (1. - (xx + yy)) * sz;
    m[2][3] = 0.;
    m[3][0] = p.x;
    m[3][1] = p.y;
    m[3][2] = p.z;
    m[3][3] = 1.;
    return m;
}
mat3 getInstanceRotationMatrix(vec4 q) {
    mat3 m;
    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;
    float x2 = x + x;
    float y2 = y + y;
    float z2 = z + z;
    float xx = x * x2;
    float xy = x * y2;
    float xz = x * z2;
    float yy = y * y2;
    float yz = y * z2;
    float zz = z * z2;
    float wx = w * x2;
    float wy = w * y2;
    float wz = w * z2;
    m[0][0] = (1. - (yy + zz));
    m[0][1] = (xy + wz);
    m[0][2] = (xz - wy);
    m[1][0] = (xy - wz);
    m[1][1] = (1. - (xx + zz));
    m[1][2] = (yz + wx);
    m[2][0] = (xz + wy);
    m[2][1] = (yz - wx);
    m[2][2] = (1. - (xx + yy));
    return m;
}
`;
        l.WdD.xv_common = _,
        l.WdD.xv_matrix = A,
        l.WdD.xv_camera_depth = g;
        var m = r(459)
          , D = r(128)
          , U = r(930)
          , R = r(779)
          , ne = r(861)
          , ce = r(591)
          , xe = r(822)
          , Se = r(694)
          , $ = r(811)
          , q = r(41)
          , N = r(322)
          , ie = r(879)
          , _e = r(585)
          , Pe = r(313);
        class Be extends l.jyz {
            constructor(G=new l.FM8) {
                super({
                    uniforms: {
                        inputBuffer: new l.xWb(null),
                        depthBuffer: new l.xWb(null),
                        resolution: new l.xWb(new l.FM8),
                        texelSize: new l.xWb(new l.FM8),
                        halfTexelSize: new l.xWb(new l.FM8),
                        kernel: new l.xWb(0),
                        scale: new l.xWb(1),
                        cameraNear: new l.xWb(0),
                        cameraFar: new l.xWb(1),
                        minDepthThreshold: new l.xWb(0),
                        maxDepthThreshold: new l.xWb(1),
                        depthScale: new l.xWb(0),
                        depthToBlurRatioBias: new l.xWb(.25)
                    },
                    fragmentShader: `#include <common>
        #include <dithering_pars_fragment>
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;

          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
            depthFactor *= depthScale;
            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));
          #endif

          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));
          gl_FragColor = sum * 0.25 ;

          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <encodings_fragment>
        }`,
                    vertexShader: `uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,
                    blending: l.jFi,
                    depthWrite: !1,
                    depthTest: !1
                });
                B(this, "kernel");
                this.toneMapped = !1,
                this.setTexelSize(G.x, G.y),
                this.kernel = new Float32Array([0, 1, 2, 2, 3])
            }
            setTexelSize(G, ee) {
                this.uniforms.texelSize.value.set(G, ee),
                this.uniforms.halfTexelSize.value.set(G, ee).multiplyScalar(.5)
            }
            setResolution(G) {
                this.uniforms.resolution.value.copy(G)
            }
        }
        class Re {
            constructor({resolution: oe, width: G=500, height: ee=500, minDepthThreshold: ke=0, maxDepthThreshold: Ne=1, depthScale: $e=0, depthToBlurRatioBias: vt=.25}) {
                B(this, "renderTargetA");
                B(this, "renderTargetB");
                B(this, "convolutionMaterial");
                B(this, "scene");
                B(this, "camera");
                B(this, "screen");
                B(this, "renderToScreen", !1);
                this.renderTargetA = new l.dd2(oe,oe,{
                    minFilter: l.wem,
                    magFilter: l.wem,
                    stencilBuffer: !1,
                    depthBuffer: !1,
                    type: l.cLu
                }),
                this.renderTargetB = this.renderTargetA.clone(),
                this.convolutionMaterial = new Be,
                this.convolutionMaterial.setTexelSize(1 / G, 1 / ee),
                this.convolutionMaterial.setResolution(new l.FM8(G,ee)),
                this.scene = new l.xsS,
                this.camera = new l.V1s,
                this.convolutionMaterial.uniforms.minDepthThreshold.value = ke,
                this.convolutionMaterial.uniforms.maxDepthThreshold.value = Ne,
                this.convolutionMaterial.uniforms.depthScale.value = $e,
                this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = vt,
                this.convolutionMaterial.defines.USE_DEPTH = $e > 0;
                const Lt = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0])
                  , Pn = new Float32Array([0, 0, 2, 0, 0, 2])
                  , un = new l.u9r;
                un.setAttribute("position", new l.TlE(Lt,3)),
                un.setAttribute("uv", new l.TlE(Pn,2)),
                this.screen = new l.Kj0(un,this.convolutionMaterial),
                this.screen.frustumCulled = !1,
                this.scene.add(this.screen)
            }
            render(oe, G, ee) {
                const ke = this.scene
                  , Ne = this.camera
                  , $e = this.renderTargetA
                  , vt = this.renderTargetB;
                let Lt = this.convolutionMaterial
                  , Pn = Lt.uniforms;
                Pn.depthBuffer.value = G.depthTexture;
                const un = Lt.kernel;
                let vn = G, _n, qn, ii;
                for (qn = 0,
                ii = un.length - 1; qn < ii; ++qn)
                    _n = qn & 1 ? vt : $e,
                    Pn.kernel.value = un[qn],
                    Pn.inputBuffer.value = vn.texture,
                    oe.setRenderTarget(_n),
                    oe.render(ke, Ne),
                    vn = _n;
                Pn.kernel.value = un[qn],
                Pn.inputBuffer.value = vn.texture,
                oe.setRenderTarget(this.renderToScreen ? null : ee),
                oe.render(ke, Ne)
            }
        }
        class ct extends l.Wid {
            constructor(G={}) {
                super(G);
                B(this, "_tDepth", {
                    value: null
                });
                B(this, "_distortionMap", {
                    value: null
                });
                B(this, "_tDiffuse", {
                    value: null
                });
                B(this, "_tDiffuseBlur", {
                    value: null
                });
                B(this, "_textureMatrix", {
                    value: null
                });
                B(this, "_hasBlur", {
                    value: !1
                });
                B(this, "_mirror", {
                    value: 0
                });
                B(this, "_mixBlur", {
                    value: 0
                });
                B(this, "_blurStrength", {
                    value: .5
                });
                B(this, "_minDepthThreshold", {
                    value: .9
                });
                B(this, "_maxDepthThreshold", {
                    value: 1
                });
                B(this, "_depthScale", {
                    value: 0
                });
                B(this, "_depthToBlurRatioBias", {
                    value: .25
                });
                B(this, "_distortion", {
                    value: 1
                });
                B(this, "_mixContrast", {
                    value: 1
                });
                this.setValues(G)
            }
            onBeforeCompile(G) {
                var ee;
                (ee = G.defines) != null && ee.USE_UV || (G.defines.USE_UV = ""),
                G.uniforms.hasBlur = this._hasBlur,
                G.uniforms.tDiffuse = this._tDiffuse,
                G.uniforms.tDepth = this._tDepth,
                G.uniforms.distortionMap = this._distortionMap,
                G.uniforms.tDiffuseBlur = this._tDiffuseBlur,
                G.uniforms.textureMatrix = this._textureMatrix,
                G.uniforms.mirror = this._mirror,
                G.uniforms.mixBlur = this._mixBlur,
                G.uniforms.mixStrength = this._blurStrength,
                G.uniforms.minDepthThreshold = this._minDepthThreshold,
                G.uniforms.maxDepthThreshold = this._maxDepthThreshold,
                G.uniforms.depthScale = this._depthScale,
                G.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias,
                G.uniforms.distortion = this._distortion,
                G.uniforms.mixContrast = this._mixContrast,
                G.vertexShader = `
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${G.vertexShader}`,
                G.vertexShader = G.vertexShader.replace("#include <project_vertex>", `#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`),
                G.fragmentShader = `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform bool hasBlur;
        uniform float mixBlur;
        uniform float mirror;
        uniform float mixStrength;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float mixContrast;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec4 my_vUv;
        ${G.fragmentShader}`,
                G.fragmentShader = G.fragmentShader.replace("#include <emissivemap_fragment>", `#include <emissivemap_fragment>

      float distortionFactor = 0.0;
      #ifdef USE_DISTORTION
        distortionFactor = texture2D(distortionMap, vUv).r * distortion;
      #endif

      vec4 new_vUv = my_vUv;
      new_vUv.x += distortionFactor;
      new_vUv.y += distortionFactor;

      vec4 base = texture2DProj(tDiffuse, new_vUv);
      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);

      vec4 merge = base;

      #ifdef USE_NORMALMAP
        vec2 normal_uv = vec2(0.0);
        vec4 normalColor = texture2D(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;
        vec4 base_normal = texture2D(tDiffuse, normal_uv);
        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);
        merge = base_normal;
        blur = blur_normal;
      #endif

      float depthFactor = 0.0001;
      float blurFactor = 0.0;

      #ifdef USE_DEPTH
        vec4 depth = texture2DProj(tDepth, new_vUv);
        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
        depthFactor *= depthScale;
        depthFactor = max(0.0001, min(1.0, depthFactor));

        #ifdef USE_BLUR
          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);
          merge = merge * min(1.0, depthFactor + 0.5);
        #else
          merge = merge * depthFactor;
        #endif

      #endif

      float reflectorRoughnessFactor = roughness;
      #ifdef USE_ROUGHNESSMAP
        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );
        reflectorRoughnessFactor *= reflectorTexelRoughness.g;
      #endif

      #ifdef USE_BLUR
        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);
        merge = mix(merge, blur, blurFactor);
      #endif

      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);
      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;
      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;
      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;

      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);
      `)
            }
            get tDiffuse() {
                return this._tDiffuse.value
            }
            set tDiffuse(G) {
                this._tDiffuse.value = G
            }
            get tDepth() {
                return this._tDepth.value
            }
            set tDepth(G) {
                this._tDepth.value = G
            }
            get distortionMap() {
                return this._distortionMap.value
            }
            set distortionMap(G) {
                this._distortionMap.value = G
            }
            get tDiffuseBlur() {
                return this._tDiffuseBlur.value
            }
            set tDiffuseBlur(G) {
                this._tDiffuseBlur.value = G
            }
            get textureMatrix() {
                return this._textureMatrix.value
            }
            set textureMatrix(G) {
                this._textureMatrix.value = G
            }
            get hasBlur() {
                return this._hasBlur.value
            }
            set hasBlur(G) {
                this._hasBlur.value = G
            }
            get mirror() {
                return this._mirror.value
            }
            set mirror(G) {
                this._mirror.value = G
            }
            get mixBlur() {
                return this._mixBlur.value
            }
            set mixBlur(G) {
                this._mixBlur.value = G
            }
            get mixStrength() {
                return this._blurStrength.value
            }
            set mixStrength(G) {
                this._blurStrength.value = G
            }
            get minDepthThreshold() {
                return this._minDepthThreshold.value
            }
            set minDepthThreshold(G) {
                this._minDepthThreshold.value = G
            }
            get maxDepthThreshold() {
                return this._maxDepthThreshold.value
            }
            set maxDepthThreshold(G) {
                this._maxDepthThreshold.value = G
            }
            get depthScale() {
                return this._depthScale.value
            }
            set depthScale(G) {
                this._depthScale.value = G
            }
            get depthToBlurRatioBias() {
                return this._depthToBlurRatioBias.value
            }
            set depthToBlurRatioBias(G) {
                this._depthToBlurRatioBias.value = G
            }
            get distortion() {
                return this._distortion.value
            }
            set distortion(G) {
                this._distortion.value = G
            }
            get mixContrast() {
                return this._mixContrast.value
            }
            set mixContrast(G) {
                this._mixContrast.value = G
            }
        }
        const et = new l.Ltg
          , Ze = new l.Ltg
          , Nt = new l.JOQ
          , Bt = new l.Pa4
          , en = new l.Pa4
          , li = new l.Pa4
          , di = new l.yGw
          , xi = new l.Pa4
          , zt = new l.Pa4
          , Sn = new l.Pa4;
        class rn extends ce.w {
            constructor({width: G=1, height: ee=1, mixBlur: ke=0, mixStrength: Ne=1, resolution: $e=256, blur: vt=[0, 0], minDepthThreshold: Lt=.9, maxDepthThreshold: Pn=1, depthScale: un=0, depthToBlurRatioBias: vn=.25, mirror: _n=0, distortion: qn=1, mixContrast: ii=1, distortionMap: Mi=0, reflectorOffset: Jn=0, color: cr=new l.Ilk(16777215), roughness: ur=1, metalness: fi=.8}) {
                super();
                B(this, "_fbo1");
                B(this, "_fbo2");
                B(this, "_blurPass");
                B(this, "_hasBlur", !1);
                B(this, "_virtualCamera", new l.cPb);
                B(this, "_reflectorOffset", 0);
                B(this, "_textureMatrix", new l.yGw);
                B(this, "_reflectorMaterial");
                const As = {
                    minFilter: l.wem,
                    magFilter: l.wem,
                    type: l.cLu
                };
                this._fbo1 = new l.dd2($e,$e,As),
                this._fbo1.depthBuffer = !0,
                this._fbo1.depthTexture = new l.$YQ($e,$e),
                this._fbo1.depthTexture.format = l.qkB,
                this._fbo1.depthTexture.type = l.LsT,
                this._fbo2 = new l.dd2($e,$e,As),
                this._blurPass = new Re({
                    resolution: $e,
                    width: vt[0],
                    height: vt[1],
                    minDepthThreshold: Lt,
                    maxDepthThreshold: Pn,
                    depthScale: un,
                    depthToBlurRatioBias: vn
                });
                let kr = this._hasBlur = vt[0] + vt[1] > 0;
                this._reflectorOffset = Jn,
                this._reflectorMaterial = Object.assign(new ct, {
                    color: cr,
                    roughness: ur,
                    metalness: fi,
                    mirror: _n,
                    mixBlur: ke,
                    textureMatrix: this._textureMatrix,
                    tDiffuse: this._fbo1.texture,
                    tDepth: this._fbo1.depthTexture,
                    tDiffuseBlur: this._fbo2.texture,
                    hasBlur: kr,
                    mixStrength: Ne,
                    minDepthThreshold: Lt,
                    maxDepthThreshold: Pn,
                    depthScale: un,
                    depthToBlurRatioBias: vn,
                    distortion: qn,
                    distortionMap: Mi,
                    mixContrast: ii,
                    defines: {
                        USE_BLUR: kr ? "" : void 0,
                        USE_DEPTH: un > 0 ? "" : void 0,
                        USE_DISTORTION: Mi ? "" : void 0
                    }
                }, !0),
                this.node = new l.Kj0(new l._12(G,ee),this._reflectorMaterial),
                this.node.rotation.set(-Math.PI / 2, 0, 0)
            }
            onDestroy() {
                this._fbo1.dispose(),
                this._fbo2.dispose(),
                this._reflectorMaterial.dispose()
            }
            beforeRender() {
                const G = this.viewer.camera
                  , ee = this._virtualCamera
                  , ke = this._textureMatrix;
                if (Bt.setFromMatrixPosition(this.node.matrixWorld),
                en.setFromMatrixPosition(G.matrixWorld),
                di.extractRotation(this.node.matrixWorld),
                xi.set(0, 0, 1),
                xi.applyMatrix4(di),
                Bt.addScaledVector(xi, this._reflectorOffset),
                li.subVectors(Bt, en),
                li.dot(xi) > 0)
                    return;
                li.reflect(xi).negate(),
                li.add(Bt),
                di.extractRotation(G.matrixWorld),
                Sn.set(0, 0, -1),
                Sn.applyMatrix4(di),
                Sn.add(en),
                zt.subVectors(Bt, Sn),
                zt.reflect(xi).negate(),
                zt.add(Bt),
                ee.position.copy(li),
                ee.up.set(0, 1, 0),
                ee.up.applyMatrix4(di),
                ee.up.reflect(xi),
                ee.lookAt(zt),
                ee.far = G.far,
                ee.updateMatrixWorld(),
                ee.projectionMatrix.copy(G.projectionMatrix),
                ke.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                ke.multiply(ee.projectionMatrix),
                ke.multiply(ee.matrixWorldInverse),
                ke.multiply(this.node.matrixWorld),
                Nt.setFromNormalAndCoplanarPoint(xi, Bt),
                Nt.applyMatrix4(ee.matrixWorldInverse),
                Ze.set(Nt.normal.x, Nt.normal.y, Nt.normal.z, Nt.constant);
                const Ne = ee.projectionMatrix;
                et.x = (Math.sign(Ze.x) + Ne.elements[8]) / Ne.elements[0],
                et.y = (Math.sign(Ze.y) + Ne.elements[9]) / Ne.elements[5],
                et.z = -1,
                et.w = (1 + Ne.elements[10]) / Ne.elements[14],
                Ze.multiplyScalar(2 / Ze.dot(et)),
                Ne.elements[2] = Ze.x,
                Ne.elements[6] = Ze.y,
                Ne.elements[10] = Ze.z + 1,
                Ne.elements[14] = Ze.w
            }
            update(G) {
                this.node.visible = !1;
                const ee = this.viewer.renderer
                  , ke = this.viewer.scene
                  , Ne = ee.xr.enabled
                  , $e = ee.shadowMap.autoUpdate;
                this.beforeRender(),
                ee.xr.enabled = !1,
                ee.shadowMap.autoUpdate = !1,
                ee.setRenderTarget(this._fbo1),
                ee.state.buffers.depth.setMask(!0),
                ee.autoClear || ee.clear(),
                ee.render(ke, this._virtualCamera),
                this._hasBlur && this._blurPass.render(ee, this._fbo1, this._fbo2),
                ee.xr.enabled = Ne,
                ee.shadowMap.autoUpdate = $e,
                this.node.visible = !0,
                ee.setRenderTarget(null)
            }
        }
        class Ft extends ce.w {
            constructor(...[G,ee,ke]) {
                super();
                B(this, "_fbo");
                B(this, "_scene");
                B(this, "_camera");
                this.onLoad = ()=>{
                    const {scene: Ne, camera: $e, size: vt} = this.viewer;
                    this._fbo = new l.dd2(G || vt.width,ee || vt.height,ke),
                    this._scene = Ne,
                    this._camera = $e
                }
            }
            get texture() {
                return this._fbo.texture
            }
            lastUpdate(G) {
                const ee = this.viewer.renderer;
                ee.setRenderTarget(this._fbo),
                ee.render(this._scene, this._camera),
                ee.setRenderTarget(null)
            }
        }
        var jt = r(150)
          , Xt = r(893)
          , Rt = function(ve, oe, G, ee) {
            var ke = arguments.length, Ne = ke < 3 ? oe : ee === null ? ee = Object.getOwnPropertyDescriptor(oe, G) : ee, $e;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                Ne = Reflect.decorate(ve, oe, G, ee);
            else
                for (var vt = ve.length - 1; vt >= 0; vt--)
                    ($e = ve[vt]) && (Ne = (ke < 3 ? $e(Ne) : ke > 3 ? $e(oe, G, Ne) : $e(oe, G)) || Ne);
            return ke > 3 && Ne && Object.defineProperty(oe, G, Ne),
            Ne
        };
        class Wn extends ce.w {
            constructor() {
                super(...arguments);
                B(this, "_vcamPlugin");
                B(this, "_transform")
            }
            get mode() {
                return this._transform.mode
            }
            set mode(G) {
                this._transform.mode = G
            }
            get space() {
                return this._transform.space
            }
            set space(G) {
                this._transform.setSpace(G)
            }
            get position() {
                return this.node.position
            }
            set position(G) {
                this.node.position.copy(G)
            }
            get rotation() {
                return this.node.rotation
            }
            set rotation(G) {
                this.node.rotation.copy(G)
            }
            get scale() {
                return this.node.scale
            }
            set scale(G) {
                this.node.scale.copy(G)
            }
            onEnable() {
                this._transform && this._transform.attach(this.node)
            }
            onDisable() {
                this._transform && this._transform.detach()
            }
            start() {
                this._vcamPlugin = this.viewer.getPlugin(Xt.k),
                this._transform = this.viewer.addNode(jt.Ys, {
                    args: [this.viewer.camera, this.viewer.renderer.domElement]
                }),
                this._transform.attach(this.node),
                this._transform.addEventListener("dragging-changed", G=>{
                    this._vcamPlugin && (this._vcamPlugin.enabled = !G.value)
                }
                ),
                this._transform.addEventListener("change", ()=>{
                    const G = this.__properties;
                    switch (this._transform.mode) {
                    case "translate":
                        G.position.$.updateDisplay();
                        break;
                    case "rotate":
                        G.rotation.$.updateDisplay();
                        break;
                    case "scale":
                        G.scale.$.updateDisplay();
                        break
                    }
                }
                ),
                this.name = this.node.name || "Node"
            }
        }
        Rt([(0,
        q.Cb)({
            value: {
                translate: "translate",
                rotate: "rotate",
                scale: "scale"
            }
        })], Wn.prototype, "mode", null),
        Rt([(0,
        q.Cb)({
            value: {
                local: "local",
                world: "world"
            }
        })], Wn.prototype, "space", null),
        Rt([(0,
        q.Cb)()], Wn.prototype, "position", null),
        Rt([(0,
        q.Cb)()], Wn.prototype, "rotation", null),
        Rt([(0,
        q.Cb)()], Wn.prototype, "scale", null);
        class He extends ce.w {
            constructor() {
                super(...arguments);
                B(this, "_helper")
            }
            start() {
                let G = this.node;
                G.isDirectionalLight && (this._helper = this.viewer.addNode(new l.cBI(G))),
                G.isPointLight && (this._helper = this.viewer.addNode(new l.xG9(G))),
                G.isSpotLight && (this._helper = this.viewer.addNode(new l.FvO(G))),
                G.isLight && G.castShadow && this.viewer.addNode(new l.Rki(G.shadow.camera))
            }
            update(G) {
                this._helper && this._helper.update()
            }
        }
        const Ko = class Ko extends ce.w {
            constructor() {
                super(...arguments);
                B(this, "_mixer");
                B(this, "_actions");
                B(this, "_action", null)
            }
            onLoad() {
                this._mixer = new l.Xcj(this.node),
                this._mixer.addEventListener(Ko.FINISHED, G=>this.emit(Ko.FINISHED, G)),
                this._mixer.addEventListener(Ko.LOOP, G=>this.emit(Ko.LOOP, G)),
                this._actions = this.node.animations.map(G=>this._mixer.clipAction(G))
            }
            update(G) {
                this._mixer.update(G)
            }
            play(G, ee={}) {
                let ke = G ? this._actions.find(Ne=>Ne.getClip().name === G) : this._actions[0];
                return ke && (ee.clampWhenFinished !== void 0 && (ke.clampWhenFinished = ee.clampWhenFinished),
                ee.zeroSlopeAtStart !== void 0 && (ke.zeroSlopeAtStart = ee.zeroSlopeAtStart),
                ee.zeroSlopeAtEnd !== void 0 && (ke.zeroSlopeAtEnd = ee.zeroSlopeAtEnd),
                ee.mode && ke.setLoop(ee.mode, ee.repetitions),
                ee.duration && ke.setDuration(ee.duration),
                this._action = ke.play()),
                this
            }
            stop() {
                return this._action && this._action.stop(),
                this
            }
        }
        ;
        B(Ko, "FINISHED", "finished"),
        B(Ko, "LOOP", "loop");
        let pt = Ko;
        class Fe extends ce.w {
            constructor({iterations: G=10, ms: ee=250, threshold: ke=.75, step: Ne=.1, factor: $e=.5, flipflops: vt=1 / 0, bounds: Lt=qn=>qn > 100 ? [60, 100] : [40, 60], onIncline: Pn, onDecline: un, onChange: vn, onFallback: _n}) {
                super();
                B(this, "fps", 0);
                B(this, "index", 0);
                B(this, "factor", .5);
                B(this, "flipped", 0);
                B(this, "refreshrate", 0);
                B(this, "fallback", !1);
                B(this, "frames", []);
                B(this, "averages", []);
                B(this, "subscriptions", new Map);
                let qn = 0;
                const ii = Math.pow(10, 0);
                this.update = Mi=>{
                    if (this.fallback)
                        return;
                    const {frames: Jn, averages: cr} = this;
                    if (cr.length < G) {
                        Jn.push(performance.now());
                        const ur = Jn[Jn.length - 1] - Jn[0];
                        if (ur >= ee) {
                            if (this.fps = Math.round(Jn.length / ur * 1e3 * ii) / ii,
                            this.refreshrate = Math.max(this.refreshrate, this.fps),
                            cr[this.index++ % G] = this.fps,
                            cr.length === G) {
                                const [fi,As] = Lt(this.refreshrate)
                                  , kr = cr.filter(vi=>vi >= As)
                                  , hr = cr.filter(vi=>vi < fi);
                                kr.length > G * ke && (this.factor = Math.min(1, this.factor + Ne),
                                this.flipped++,
                                Pn && Pn(this),
                                this.subscriptions.forEach(vi=>vi.onIncline && vi.onIncline(this))),
                                hr.length > G * ke && (this.factor = Math.max(0, this.factor - Ne),
                                this.flipped++,
                                un && un(this),
                                this.subscriptions.forEach(vi=>vi.onDecline && vi.onDecline(this))),
                                qn !== this.factor && (qn = this.factor,
                                vn && vn(this),
                                this.subscriptions.forEach(vi=>vi.onChange && vi.onChange(this))),
                                this.flipped > vt && !this.fallback && (this.fallback = !0,
                                _n && _n(this),
                                this.subscriptions.forEach(vi=>vi.onFallback && vi.onFallback(this))),
                                this.averages = []
                            }
                            this.frames = []
                        }
                    }
                }
            }
            subscribe(G) {
                this.subscriptions.set(Symbol(), G)
            }
        }
        function qe(ve, oe, G, ee) {
            return class extends l.jyz {
                constructor($e={}) {
                    const vt = Object.entries(ve);
                    super({
                        uniforms: vt.reduce((Lt,[Pn,un])=>{
                            const vn = l.rDY.clone({
                                [Pn]: {
                                    value: un
                                }
                            });
                            return {
                                ...Lt,
                                ...vn
                            }
                        }
                        , {}),
                        vertexShader: oe,
                        fragmentShader: G
                    });
                    B(this, "key", "");
                    vt.forEach(([Lt])=>Object.defineProperty(this, Lt, {
                        get: ()=>this.uniforms[Lt].value,
                        set: Pn=>this.uniforms[Lt].value = Pn
                    })),
                    Object.assign(this, $e),
                    ee && ee(this)
                }
            }
        }
        const wt = qe({}, "void main() { }", "void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }");
        class An extends l.Kj0 {
            constructor(...oe) {
                super(new l.DvJ(...oe))
            }
        }
        class Qt extends l.Kj0 {
            constructor(...oe) {
                super(new l.BVQ(...oe))
            }
        }
        class Pi extends l.Kj0 {
            constructor(...oe) {
                super(new l.zf8(...oe))
            }
        }
        class ui extends l.Kj0 {
            constructor(...oe) {
                super(new l.b_z(...oe))
            }
        }
        class mi extends l.Kj0 {
            constructor(...oe) {
                super(new l.fHI(...oe))
            }
        }
        class Si extends l.Kj0 {
            constructor(...oe) {
                super(new l.Kgo(...oe))
            }
        }
        class Gt extends l.Kj0 {
            constructor(...oe) {
                super(new l.TOt(...oe))
            }
        }
        class On extends l.Kj0 {
            constructor(...oe) {
                super(new l.O7d(...oe))
            }
        }
        class kn extends l.Kj0 {
            constructor(...oe) {
                super(new l.cJO(...oe))
            }
        }
        class bi extends l.Kj0 {
            constructor(...oe) {
                super(new l.p7y(...oe))
            }
        }
        class $i extends l.Kj0 {
            constructor(...oe) {
                super(new l.pQR(...oe))
            }
        }
        class zr extends l.Kj0 {
            constructor(...oe) {
                super(new l._12(...oe))
            }
        }
        class Fi extends l.Kj0 {
            constructor(...oe) {
                super(new l.Uol(...oe))
            }
        }
        class vr extends l.Kj0 {
            constructor(...oe) {
                super(new l.o8S(...oe))
            }
        }
        class Oi extends l.Kj0 {
            constructor(...oe) {
                super(new l.oa8(...oe))
            }
        }
        class ts extends l.Kj0 {
            constructor(...oe) {
                super(new l.xo$(...oe))
            }
        }
        class Gr extends l.Kj0 {
            constructor(...oe) {
                super(new l.H$k(...oe))
            }
        }
        class ys extends l.Kj0 {
            constructor(...oe) {
                super(new l.XvJ(...oe))
            }
        }
        class xs extends l.Kj0 {
            constructor(...oe) {
                super(new l.FE5(...oe))
            }
        }
        class hi extends l.Kj0 {
            constructor(...oe) {
                super(new l.WXh(...oe))
            }
        }
        class Ti extends l.Kj0 {
            constructor(...oe) {
                super(new l.Uk6(...oe))
            }
        }
        var gi = r(774);
        function qi(ve) {
            return ve.isLight
        }
        function ks(ve) {
            return !!ve.geometry
        }
        const Gi = qe({
            color: new l.Ilk,
            blend: 2,
            alphaTest: .75,
            opacity: 0,
            map: null
        }, `varying vec2 vUv;
     void main() {
       gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
       vUv = uv;
     }`, `varying vec2 vUv;
     uniform sampler2D map;
     uniform vec3 color;
     uniform float opacity;
     uniform float alphaTest;
     uniform float blend;
     void main() {
       vec4 sampledDiffuseColor = texture2D(map, vUv);
       gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);
       #include <tonemapping_fragment>
       #include <encodings_fragment>
     }`);
        class Ao extends ce.w {
            constructor({temporal: G, frames: ee=40, limit: ke=1 / 0, blend: Ne=20, scale: $e=10, opacity: vt=1, alphaTest: Lt=.75, color: Pn="black", colorBlend: un=2, resolution: vn=1024, toneMapped: _n=!0}={}) {
                super();
                B(this, "lights");
                B(this, "temporal");
                B(this, "frames");
                B(this, "blend");
                B(this, "count");
                this.lights = [],
                this.temporal = !!G,
                this.frames = Math.max(2, ee),
                this.blend = Math.max(2, ee === 1 / 0 ? Ne : ee),
                this.count = 0,
                this.onLoad = ()=>{
                    const {renderer: qn, scene: ii, camera: Mi} = this.viewer
                      , Jn = new Us(qn,ii,vn)
                      , cr = new l.ZAu
                      , ur = this.viewer.addNode(new zr, {
                        parent: this.node,
                        scale: (0,
                        ne.nX)($e),
                        rotation: (0,
                        ne.$r)(-Math.PI / 2, 0, 0),
                        material: (0,
                        ne.$p)(new Gi, {
                            transparent: !0,
                            depthWrite: !1,
                            toneMapped: _n,
                            color: (0,
                            ne.$c)(Pn),
                            blend: un,
                            map: Jn.progressiveLightMap2.texture
                        })
                    });
                    Jn.configure(cr),
                    cr.add(...this.lights);
                    const fi = (As=1)=>{
                        const kr = ur.material;
                        this.temporal ? (kr.opacity = Math.min(vt, kr.opacity + vt / this.blend),
                        kr.alphaTest = Math.min(Lt, kr.alphaTest + Lt / this.blend)) : (kr.opacity = vt,
                        kr.alphaTest = Lt),
                        cr.visible = !0,
                        Jn.prepare();
                        for (let hr = 0; hr < As; hr++)
                            this.lights.forEach(vi=>vi.update()),
                            Jn.update(Mi, this.blend);
                        cr.visible = !1,
                        Jn.finish()
                    }
                    ;
                    this.update = As=>{
                        (this.temporal || this.frames === 1 / 0) && this.count < this.frames && this.count < ke && (fi(),
                        this.count++)
                    }
                }
            }
        }
        class Hi extends l.Tme {
            constructor({castShadow: oe=!0, bias: G=.001, mapSize: ee=512, size: ke=5, near: Ne=.5, far: $e=500, frames: vt=1, position: Lt=[0, 0, 0], radius: Pn=1, amount: un=8, intensity: vn=1, ambient: _n=.5}={}) {
                super();
                for (let qn = 0; qn < un; qn++) {
                    let ii = new l.Ox3;
                    ii.intensity = vn,
                    ii.castShadow = oe,
                    (0,
                    gi.lK)(ii.shadow, [-ke, ke, ke, -ke, Ne, $e, G, ee, ee]),
                    this.add(ii)
                }
                this.update = ()=>{
                    let qn;
                    for (let ii = 0; ii < this.children.length; ii++)
                        if (qn = this.children[ii],
                        Math.random() > _n)
                            qn.position.set(Lt[0] + l.MathUtils.randFloatSpread(Pn), Lt[1] + l.MathUtils.randFloatSpread(Pn), Lt[2] + l.MathUtils.randFloatSpread(Pn));
                        else {
                            let Mi = Math.acos(2 * Math.random() - 1) - Math.PI / 2
                              , Jn = 2 * Math.PI * Math.random();
                            qn.position.set(Math.cos(Mi) * Math.cos(Jn) * length, Math.abs(Math.cos(Mi) * Math.sin(Jn) * length), Math.sin(Mi) * length)
                        }
                }
            }
        }
        class Us {
            constructor(oe, G, ee=1024) {
                B(this, "renderer");
                B(this, "res");
                B(this, "scene");
                B(this, "object");
                B(this, "buffer1Active");
                B(this, "progressiveLightMap1");
                B(this, "progressiveLightMap2");
                B(this, "discardMat");
                B(this, "targetMat");
                B(this, "previousShadowMap");
                B(this, "averagingWindow");
                B(this, "clearColor");
                B(this, "clearAlpha");
                B(this, "lights");
                B(this, "meshes");
                this.renderer = oe,
                this.res = ee,
                this.scene = G,
                this.buffer1Active = !1,
                this.lights = [],
                this.meshes = [],
                this.object = null,
                this.clearColor = new l.Ilk,
                this.clearAlpha = 0;
                const ke = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? l.cLu : l.VzW;
                this.progressiveLightMap1 = new l.dd2(this.res,this.res,{
                    type: ke
                }),
                this.progressiveLightMap2 = new l.dd2(this.res,this.res,{
                    type: ke
                }),
                this.discardMat = new wt,
                this.targetMat = new l.YBo({
                    fog: !1
                }),
                this.previousShadowMap = {
                    value: this.progressiveLightMap1.texture
                },
                this.averagingWindow = {
                    value: 100
                },
                this.targetMat.onBeforeCompile = Ne=>{
                    Ne.vertexShader = `varying vec2 vUv;
` + Ne.vertexShader.slice(0, -1) + "vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";
                    const $e = Ne.fragmentShader.indexOf("void main() {");
                    Ne.fragmentShader = `varying vec2 vUv;
` + Ne.fragmentShader.slice(0, $e) + `uniform sampler2D previousShadowMap;
    uniform float averagingWindow;
` + Ne.fragmentShader.slice($e - 1, -1) + `
vec3 texelOld = texture2D(previousShadowMap, vUv).rgb;
          gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);
        }`,
                    Ne.uniforms.previousShadowMap = this.previousShadowMap,
                    Ne.uniforms.averagingWindow = this.averagingWindow
                }
            }
            clear() {
                this.renderer.getClearColor(this.clearColor),
                this.clearAlpha = this.renderer.getClearAlpha(),
                this.renderer.setClearColor("black", 1),
                this.renderer.setRenderTarget(this.progressiveLightMap1),
                this.renderer.clear(),
                this.renderer.setRenderTarget(this.progressiveLightMap2),
                this.renderer.clear(),
                this.renderer.setRenderTarget(null),
                this.renderer.setClearColor(this.clearColor, this.clearAlpha),
                this.lights = [],
                this.meshes = [],
                this.scene.traverse(oe=>{
                    ks(oe) ? this.meshes.push({
                        object: oe,
                        material: oe.material
                    }) : qi(oe) && this.lights.push({
                        object: oe,
                        intensity: oe.intensity
                    })
                }
                )
            }
            prepare() {
                this.lights.forEach(oe=>oe.object.intensity = 0),
                this.meshes.forEach(oe=>oe.object.material = this.discardMat)
            }
            finish() {
                this.lights.forEach(oe=>oe.object.intensity = oe.intensity),
                this.meshes.forEach(oe=>oe.object.material = oe.material)
            }
            configure(oe) {
                this.object = oe
            }
            update(oe, G=100) {
                if (!this.object)
                    return;
                this.averagingWindow.value = G,
                this.object.material = this.targetMat;
                const ee = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2
                  , ke = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1
                  , Ne = this.scene.background;
                this.scene.background = null,
                this.renderer.setRenderTarget(ee),
                this.previousShadowMap.value = ke.texture,
                this.buffer1Active = !this.buffer1Active,
                this.renderer.render(this.scene, oe),
                this.renderer.setRenderTarget(null),
                this.scene.background = Ne
            }
        }
        class Ba extends l.Kj0 {
            constructor({map: oe, toneMapped: G=!1, color: ee="white", form: ke="rect", intensity: Ne=1, scale: $e=(0,
            ne.nX)(1), target: vt=(0,
            ne.nX)(), material: Lt}={}) {
                super(),
                this.geometry = ke === "circle" ? new l.o8S(0,1,64) : ke === "ring" ? new l.o8S(.5,1.64) : ke === "rect" ? new l._12 : ke,
                this.material = Lt ?? new l.vBJ({
                    toneMapped: G,
                    map: oe,
                    side: l.ehD
                }),
                this.material.color.set(ee).multiplyScalar(Ne),
                this.scale.copy($e),
                this.lookAt(vt)
            }
        }
        var Fr = r(876)
          , Ns = function(ve, oe, G, ee) {
            var ke = arguments.length, Ne = ke < 3 ? oe : ee === null ? ee = Object.getOwnPropertyDescriptor(oe, G) : ee, $e;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                Ne = Reflect.decorate(ve, oe, G, ee);
            else
                for (var vt = ve.length - 1; vt >= 0; vt--)
                    ($e = ve[vt]) && (Ne = (ke < 3 ? $e(Ne) : ke > 3 ? $e(oe, G, Ne) : $e(oe, G)) || Ne);
            return ke > 3 && Ne && Object.defineProperty(oe, G, Ne),
            Ne
        };
        let bs = (0,
        ne.nX)()
          , jo = (0,
        ne.nX)();
        class us extends ce.w {
            constructor() {
                super(...arguments);
                B(this, "enablePositionNoise", !0);
                B(this, "positionFrequency", .2);
                B(this, "positionAmplitude", .5);
                B(this, "positionScale", (0,
                ne.nX)(1));
                B(this, "positionFractalLevel", 3);
                B(this, "enableRotationNoise", !0);
                B(this, "rotationFrequency", .2);
                B(this, "rotationAmplitude", 10);
                B(this, "rotationScale", (0,
                ne.nX)(1, 1, 0));
                B(this, "rotationFractalLevel", 3);
                B(this, "_initialPosition", (0,
                ne.nX)());
                B(this, "_initialRotation", (0,
                ne.$r)());
                B(this, "_time", []);
                B(this, "_fbmNorm", 1 / .75)
            }
            rehash() {
                for (let G = 0; G < 6; G++)
                    this._time[G] = l.MathUtils.randFloat(-1e4, 0)
            }
            start() {
                this._initialPosition.copy(this.node.position),
                this._initialRotation.copy(this.node.rotation),
                this.rehash()
            }
            update(G) {
                if (this.enablePositionNoise) {
                    for (let ke = 0; ke < 3; ke++)
                        this._time[ke] += this.positionFrequency * G;
                    let ee = bs.set(Fr.H.Fbm(this.positionFractalLevel, this._time[0]), Fr.H.Fbm(this.positionFractalLevel, this._time[1]), Fr.H.Fbm(this.positionFractalLevel, this._time[2]));
                    ee = ee.multiply(this.positionScale),
                    ee.multiplyScalar(this.positionAmplitude * this._fbmNorm),
                    this.node.position.copy(this._initialPosition).add(ee)
                }
                if (this.enableRotationNoise) {
                    for (let ke = 0; ke < 3; ke++)
                        this._time[ke + 3] += this.rotationFrequency * G;
                    let ee = bs.set(Fr.H.Fbm(this.rotationFractalLevel, this._time[3]), Fr.H.Fbm(this.rotationFractalLevel, this._time[4]), Fr.H.Fbm(this.rotationFractalLevel, this._time[5]));
                    ee = ee.multiply(this.rotationScale),
                    ee.multiplyScalar(this.rotationAmplitude * this._fbmNorm),
                    jo.setFromEuler(this._initialRotation).add(ee),
                    this.node.rotation.setFromVector3(jo)
                }
            }
        }
        Ns([(0,
        q.Cb)({
            dir: "position"
        })], us.prototype, "enablePositionNoise", void 0),
        Ns([(0,
        q.Cb)({
            dir: "position"
        })], us.prototype, "positionFrequency", void 0),
        Ns([(0,
        q.Cb)({
            dir: "position"
        })], us.prototype, "positionAmplitude", void 0),
        Ns([(0,
        q.Cb)({
            dir: "position"
        })], us.prototype, "positionScale", void 0),
        Ns([(0,
        q.Cb)({
            dir: "position",
            min: 0,
            max: 8,
            step: 1
        })], us.prototype, "positionFractalLevel", void 0),
        Ns([(0,
        q.Cb)({
            dir: "rotation"
        })], us.prototype, "enableRotationNoise", void 0),
        Ns([(0,
        q.Cb)({
            dir: "rotation"
        })], us.prototype, "rotationFrequency", void 0),
        Ns([(0,
        q.Cb)({
            dir: "rotation"
        })], us.prototype, "rotationAmplitude", void 0),
        Ns([(0,
        q.Cb)({
            dir: "rotation"
        })], us.prototype, "rotationScale", void 0),
        Ns([(0,
        q.Cb)({
            dir: "rotation",
            min: 0,
            max: 8,
            step: 1
        })], us.prototype, "rotationFractalLevel", void 0);
        const ha = /\n/
          , da = `
`
          , uo = /\s/;
        function Js(ve, oe) {
            if (oe = oe || {},
            oe.width === 0 && oe.mode !== "nowrap")
                return [];
            ve = ve || "";
            const G = typeof oe.width == "number" ? oe.width : Number.MAX_VALUE
              , ee = Math.max(0, oe.start || 0)
              , ke = typeof oe.end == "number" ? oe.end : ve.length
              , Ne = oe.mode
              , $e = oe.letterSpacing || 0
              , vt = oe.measure || jl;
            return Ne === "pre" ? Wl(vt, ve, ee, ke, G, $e) : ti(vt, ve, ee, ke, G, Ne, $e)
        }
        function So(ve, oe, G, ee) {
            var ke = ve.indexOf(oe, G);
            return ke === -1 || ke > ee ? ee : ke
        }
        function Fa(ve) {
            return uo.test(ve)
        }
        function Wl(ve, oe, G, ee, ke, Ne) {
            for (var $e = [], vt = G, Lt = G; Lt < ee && Lt < oe.length; Lt++) {
                var Pn = oe.charAt(Lt)
                  , un = ha.test(Pn);
                if (un || Lt === ee - 1) {
                    var vn = un ? Lt : Lt + 1
                      , _n = ve(oe, vt, vn, ke, Ne);
                    $e.push(_n),
                    vt = Lt + 1
                }
            }
            return $e
        }
        function ti(ve, oe, G, ee, ke, Ne, $e) {
            var vt = []
              , Lt = ke;
            for (Ne === "nowrap" && (Lt = Number.MAX_VALUE); G < ee && G < oe.length; ) {
                for (var Pn = So(oe, da, G, ee); G < Pn && Fa(oe.charAt(G)); )
                    G++;
                var un = ve(oe, G, Pn, Lt, $e)
                  , vn = G + (un.end - un.start)
                  , _n = vn + da.length;
                if (vn < Pn) {
                    for (; vn > G && !Fa(oe.charAt(vn)); )
                        vn--;
                    if (vn === G)
                        _n > G + da.length && _n--,
                        vn = _n;
                    else
                        for (_n = vn; vn > G && Fa(oe.charAt(vn - da.length)); )
                            vn--
                }
                if (vn >= G) {
                    var qn = ve(oe, G, vn, Lt);
                    vt.push(qn)
                }
                G = _n
            }
            return vt
        }
        function jl(ve, oe, G, ee) {
            var ke = Math.min(ee, G - oe);
            return {
                start: oe,
                end: oe + ke
            }
        }
        const Xr = ["x", "e", "a", "o", "n", "s", "r", "c", "u", "m", "v", "w", "z"]
          , ol = ["m", "w"]
          , al = ["H", "I", "N", "E", "F", "K", "L", "T", "U", "V", "W", "X", "Y", "Z"]
          , $s = "  ".charCodeAt(0)
          , ho = " ".charCodeAt(0)
          , Xl = 0
          , ll = 1
          , cl = 2;
        function fa(ve, oe, G) {
            G = G || 0;
            for (let ee = G; ee < ve.length; ee++)
                if (ve[ee].id === oe)
                    return ee;
            return -1
        }
        function ul(ve, oe) {
            if (!ve.chars || ve.chars.length === 0)
                return null;
            let G = fa(ve.chars, oe);
            return G >= 0 ? ve.chars[G] : null
        }
        function ka(ve) {
            for (let oe = 0; oe < Xr.length; oe++) {
                let G = Xr[oe].charCodeAt(0)
                  , ee = fa(ve.chars, G);
                if (ee >= 0)
                    return ve.chars[ee].height
            }
            return 0
        }
        function Ua(ve) {
            for (let oe = 0; oe < ol.length; oe++) {
                let G = ol[oe].charCodeAt(0)
                  , ee = fa(ve.chars, G);
                if (ee >= 0)
                    return ve.chars[ee]
            }
            return 0
        }
        function Na(ve) {
            for (let oe = 0; oe < al.length; oe++) {
                let G = al[oe].charCodeAt(0)
                  , ee = fa(ve.chars, G);
                if (ee >= 0)
                    return ve.chars[ee].height
            }
            return 0
        }
        function pa(ve, oe, G) {
            if (!ve.kernings || ve.kernings.length === 0)
                return 0;
            let ee = ve.kernings;
            for (let ke = 0; ke < ee.length; ke++) {
                let Ne = ee[ke];
                if (Ne.first === oe && Ne.second === G)
                    return Ne.amount
            }
            return 0
        }
        function hl(ve) {
            return ve === "center" ? ll : ve === "right" ? cl : Xl
        }
        class za {
            constructor() {
                B(this, "_width", 0);
                B(this, "_height", 0);
                B(this, "_descender", 0);
                B(this, "_ascender", 0);
                B(this, "_xHeight", 0);
                B(this, "_baseline", 0);
                B(this, "_capHeight", 0);
                B(this, "_lineHeight", 0);
                B(this, "_linesTotal", 0);
                B(this, "_glyphs", []);
                B(this, "_fallbackSpaceGlyph", null);
                B(this, "_fallbackTabGlyph", null);
                B(this, "_font", null)
            }
            get width() {
                return this._width
            }
            get height() {
                return this._height
            }
            get descender() {
                return this._descender
            }
            get ascender() {
                return this._ascender
            }
            get xHeight() {
                return this._xHeight
            }
            get baseline() {
                return this._baseline
            }
            get capHeight() {
                return this._capHeight
            }
            get lineHeight() {
                return this._lineHeight
            }
            get glyphs() {
                return this._glyphs
            }
            get linesTotal() {
                return this._linesTotal
            }
            update(oe, G, ee) {
                ee = Object.assign({
                    tabSize: 4,
                    width: 0,
                    letterSpacing: 0,
                    mode: "nowrap",
                    align: "left"
                }, ee),
                this._font = oe;
                const ke = this._computeMetrics.bind(this)
                  , Ne = Js(G, {
                    measure: ke,
                    ...ee
                })
                  , $e = ee.width || 0
                  , vt = this._glyphs
                  , Lt = Ne.reduce((fi,As)=>Math.max(fi, As.width, $e), 0)
                  , Pn = ee.lineHeight ?? oe.common.lineHeight
                  , un = oe.common.base
                  , vn = Pn - un
                  , _n = ee.letterSpacing || 0
                  , qn = Pn * Ne.length - vn
                  , ii = hl(ee.align)
                  , Mi = ee.anchor ?? [.5, .5];
                this._setupSpaceGlyphs(oe, ee),
                this._width = Lt,
                this._height = qn,
                this._descender = vn,
                this._baseline = un,
                this._xHeight = ka(oe),
                this._capHeight = Na(oe),
                this._lineHeight = Pn,
                this._ascender = un - this._xHeight;
                const Jn = [-Lt * Mi[0], 2 * Pn * Mi[1] - un];
                let cr = 0
                  , ur = 0;
                ur -= qn,
                vt.length = 0;
                for (let fi = 0; fi < Ne.length; fi++) {
                    const As = Ne[fi];
                    let kr = As.start, hr = As.end, vi = As.width, Bc;
                    for (let Ro = kr; Ro < hr; Ro++) {
                        let Ss = G.charCodeAt(Ro)
                          , xr = this._getGlyph(oe, Ss);
                        if (xr) {
                            Bc && (cr += pa(oe, Bc.id, xr.id));
                            let ml = cr;
                            ii === ll ? ml += (Lt - vi) / 2 : ii === cl && (ml += Lt - vi),
                            vt.push({
                                position: [ml + Jn[0], ur + Jn[1]],
                                data: xr,
                                index: Ro,
                                line: fi
                            }),
                            cr += xr.xadvance + _n,
                            Bc = xr
                        }
                    }
                    ur += Pn,
                    cr = 0
                }
                this._linesTotal = Ne.length
            }
            _setupSpaceGlyphs(oe, G) {
                if (!oe.chars || oe.chars.length === 0)
                    return;
                const ee = Object.assign({}, ul(oe, ho) || Ua(oe) || oe.chars[0])
                  , ke = G.tabSize * ee.xadvance;
                this._fallbackSpaceGlyph = ee,
                this._fallbackTabGlyph = Object.assign(ee, {
                    x: 0,
                    y: 0,
                    xadvance: ke,
                    id: $s,
                    xoffset: 0,
                    yoffset: 0,
                    width: 0,
                    height: 0
                })
            }
            _getGlyph(oe, G) {
                let ee = ul(oe, G);
                return ee || (G === $s ? this._fallbackTabGlyph : G === ho ? this._fallbackSpaceGlyph : null)
            }
            _computeMetrics(oe, G, ee, ke, Ne=0) {
                let $e = this._font, vt = 0, Lt = 0, Pn = 0, un;
                if (!$e.chars || $e.chars.length === 0)
                    return {
                        start: G,
                        end: G,
                        width: 0
                    };
                ee = Math.min(oe.length, ee);
                for (let vn = G; vn < ee; vn++) {
                    let _n = oe.charCodeAt(vn)
                      , qn = this._getGlyph($e, _n);
                    if (qn) {
                        qn.xoffset;
                        let ii = un ? pa($e, un.id, qn.id) : 0;
                        vt += ii;
                        let Mi = vt + qn.xadvance + Ne
                          , Jn = vt + qn.width;
                        if (Jn >= ke || Mi >= ke)
                            break;
                        vt = Mi,
                        Lt = Jn,
                        un = qn
                    }
                    Pn++
                }
                return un && (Lt += un.xoffset),
                {
                    start: G,
                    end: G + Pn,
                    width: Lt
                }
            }
        }
        const ma = 2
          , nr = {
            min: [0, 0],
            max: [0, 0]
        };
        function fo(ve) {
            const oe = ve.length / ma;
            nr.min[0] = ve[0],
            nr.min[1] = ve[1],
            nr.max[0] = ve[0],
            nr.max[1] = ve[1];
            for (let G = 0; G < oe; G++) {
                const ee = ve[G * ma + 0]
                  , ke = ve[G * ma + 1];
                nr.min[0] = Math.min(ee, nr.min[0]),
                nr.min[1] = Math.min(ke, nr.min[1]),
                nr.max[0] = Math.max(ee, nr.max[0]),
                nr.max[1] = Math.max(ke, nr.max[1])
            }
        }
        function Ga(ve, oe) {
            fo(ve),
            oe.min.set(nr.min[0], nr.min[1], 0),
            oe.max.set(nr.max[0], nr.max[1], 0)
        }
        function dl(ve, oe) {
            fo(ve);
            const G = nr.min[0]
              , ee = nr.min[1]
              , ke = nr.max[0]
              , Ne = nr.max[1]
              , $e = ke - G
              , vt = Ne - ee
              , Lt = Math.sqrt($e * $e + vt * vt);
            oe.center.set(G + $e / 2, ee + vt / 2, 0),
            oe.radius = Lt / 2
        }
        class fl extends l.u9r {
            constructor() {
                super(...arguments);
                B(this, "layout", new za)
            }
            update(G, ee, ke) {
                this.layout.update(G.font, ee, ke);
                const {indice: Ne, position: $e, uv: vt} = G.build(this.layout, ke);
                this.setIndex(new l.TlE(Ne,1)),
                this.setAttribute("position", new l.TlE($e,2)),
                this.setAttribute("uv", new l.TlE(vt,2))
            }
            computeBoundingSphere() {
                this.boundingSphere === null && (this.boundingSphere = new l.aLr);
                const G = this.attributes.position.array
                  , ee = this.attributes.position.itemSize;
                if (!G || !ee || G.length < 2) {
                    this.boundingSphere.radius = 0,
                    this.boundingSphere.center.set(0, 0, 0);
                    return
                }
                dl(G, this.boundingSphere),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
            }
            computeBoundingBox() {
                this.boundingBox === null && (this.boundingBox = new l.ZzF);
                const G = this.boundingBox
                  , ee = this.attributes.position.array
                  , ke = this.attributes.position.itemSize;
                if (!ee || !ke || ee.length < 2) {
                    G.makeEmpty();
                    return
                }
                Ga(ee, G)
            }
        }
        var pl = function(ve, oe, G, ee) {
            var ke = arguments.length, Ne = ke < 3 ? oe : ee === null ? ee = Object.getOwnPropertyDescriptor(oe, G) : ee, $e;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                Ne = Reflect.decorate(ve, oe, G, ee);
            else
                for (var vt = ve.length - 1; vt >= 0; vt--)
                    ($e = ve[vt]) && (Ne = (ke < 3 ? $e(Ne) : ke > 3 ? $e(oe, G, Ne) : $e(oe, G)) || Ne);
            return ke > 3 && Ne && Object.defineProperty(oe, G, Ne),
            Ne
        };
        class ga extends ce.w {
            constructor({text: G="", font: ee, material: ke, ...Ne}) {
                super();
                B(this, "needsUpdate", !1);
                B(this, "_text", "");
                B(this, "_font", null);
                B(this, "_setting", null);
                this.text = G,
                this.font = ee,
                this.setting = Ne,
                this.node = new l.Kj0(new fl,ke || ee.material),
                this.node.geometry.update(this.font, this.text, this.setting)
            }
            get text() {
                return this._text
            }
            set text(G) {
                this._text !== G && (this._text = G,
                this.needsUpdate = !0)
            }
            get font() {
                return this._font
            }
            set font(G) {
                this._font !== G && (this._font = G,
                this.needsUpdate = !0)
            }
            get setting() {
                return this._setting
            }
            set setting(G) {
                JSON.stringify(this._setting) !== JSON.stringify(G) && (this._setting = G,
                this.needsUpdate = !0)
            }
            get layout() {
                return this.node.geometry.layout
            }
            forceUpdate() {
                this.node.geometry.update(this.font, this.text, this.setting)
            }
            update(G) {
                this.needsUpdate && (this.needsUpdate = !1,
                this.forceUpdate())
            }
        }
        pl([(0,
        q.Cb)()], ga.prototype, "text", null);
        class Ha extends ce.w {
            constructor(G) {
                super();
                B(this, "_scene");
                B(this, "_label");
                B(this, "_camera");
                B(this, "_renderer");
                B(this, "_cacheURL", {});
                this.onLoad = ()=>{
                    this._scene = new l.xsS,
                    this._label = this.viewer.addNode(new ga(G), {
                        parent: this._scene
                    }),
                    this._renderer = new l.CP7({
                        alpha: !0
                    }),
                    this._renderer.setPixelRatio(this.viewer.dpr),
                    this._renderer.outputEncoding = l.knz,
                    this._camera = new l.iKG(-1,1,1,-1,-1,1)
                }
            }
            textURL({text: G, scale: ee=1}) {
                if (this._cacheURL[G])
                    return this._cacheURL[G];
                this._label.text = G,
                this._label.forceUpdate(),
                this._label.node.scale.set(ee, -ee, ee);
                const {width: ke, height: Ne, baseline: $e} = this._label.layout
                  , vt = ke * ee
                  , Lt = Ne * ee
                  , Pn = $e * ee;
                return this._camera.left = -vt / 2,
                this._camera.right = vt / 2,
                Ne > $e ? (this._camera.top = Lt - Pn / 2,
                this._camera.bottom = -Pn / 2) : (this._camera.top = Lt / 2,
                this._camera.bottom = -Lt / 2),
                this._camera.updateProjectionMatrix(),
                this._renderer.setSize(vt, Lt),
                this._renderer.render(this._scene, this._camera),
                this._cacheURL[G] = this._renderer.domElement.toDataURL()
            }
        }
        var To = function(ve, oe, G, ee) {
            var ke = arguments.length, Ne = ke < 3 ? oe : ee === null ? ee = Object.getOwnPropertyDescriptor(oe, G) : ee, $e;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                Ne = Reflect.decorate(ve, oe, G, ee);
            else
                for (var vt = ve.length - 1; vt >= 0; vt--)
                    ($e = ve[vt]) && (Ne = (ke < 3 ? $e(Ne) : ke > 3 ? $e(oe, G, Ne) : $e(oe, G)) || Ne);
            return ke > 3 && Ne && Object.defineProperty(oe, G, Ne),
            Ne
        };
        let Eo = new l.ZzF
          , Yr = new l.Pa4;
        class Qr extends ce.w {
            constructor() {
                super(...arguments);
                B(this, "_boundingBox", new l.ZzF);
                B(this, "_probeBox", new l.ZzF);
                B(this, "_probeCenter", new l.Pa4);
                B(this, "_boxProjection", !0);
                B(this, "_needUpdate", !0);
                B(this, "_debug", !1)
            }
            onLoad() {
                this._boundingBox.setFromObject(this.node),
                this._probeBox.isEmpty() && this._probeBox.copy(this._boundingBox);
                let G = this.viewer.renderer.globalUniforms;
                G.probePos = new l.Ltg(0,0,0,1),
                G.probeBoxMin = this._probeBox.min.clone(),
                G.probeBoxMax = this._probeBox.max.clone();
                for (let ee of Object.values(this.node.meshData.materials))
                    ee.isMeshStandardMaterial && (ee.defines.USE_BOX_PROJECTION = "")
            }
            update(G) {
                if (this._needUpdate) {
                    this._needUpdate = !1,
                    Eo.copy(this._boundingBox),
                    Eo.translate(this.node.getWorldPosition(Yr)),
                    Eo.union(this._probeBox);
                    let ee = this.viewer.renderer.globalUniforms;
                    ee.probePos.set(this._probeCenter.x, this._probeCenter.y, this._probeCenter.z, this._boxProjection ? 1 : 0),
                    ee.probeBoxMin.copy(Eo.min),
                    ee.probeBoxMax.copy(Eo.max)
                }
            }
            get debug() {
                return this._debug
            }
            set debug(G) {
                this._debug = G,
                this.viewer.emit(xe.A.ATTACH_HELPER, this._probeBox, G)
            }
            get boxProjection() {
                return this._boxProjection
            }
            set boxProjection(G) {
                this._boxProjection = G,
                this._needUpdate = !0
            }
            get probeCenter() {
                return this._probeCenter
            }
            set probeCenter(G) {
                this._probeCenter = G,
                this._needUpdate = !0
            }
            get probeBoxMin() {
                return this._probeBox.min
            }
            set probeBoxMin(G) {
                this._probeBox.min = G,
                this._needUpdate = !0
            }
            get probeBoxMax() {
                return this._probeBox.max
            }
            set probeBoxMax(G) {
                this._probeBox.max = G,
                this._needUpdate = !0
            }
        }
        To([(0,
        q.Cb)()], Qr.prototype, "debug", null),
        To([(0,
        q.Cb)()], Qr.prototype, "boxProjection", null),
        To([(0,
        q.Cb)({
            step: .01
        })], Qr.prototype, "probeCenter", null),
        To([(0,
        q.Cb)({
            step: .01
        })], Qr.prototype, "probeBoxMin", null),
        To([(0,
        q.Cb)({
            step: .01
        })], Qr.prototype, "probeBoxMax", null);
        var va = r(616)
          , po = r(371)
          , Mo = r(28);
        const Xo = `
uniform samplerCube tLast;
uniform samplerCube tBlur;
uniform float       uLod;
uniform float       uWeight;
uniform float       uExposure;
uniform int         uFace;
varying vec2        vUv;

vec3 uvToXYZ(int face, vec2 uv) {
    if(face == 0)       return vec3(     1.f,   uv.y,    -uv.x);
    else if(face == 1)  return vec3(    -1.f,   uv.y,     uv.x);
    else if(face == 2)  return vec3(   +uv.x,   -1.f,    +uv.y);
    else if(face == 3)  return vec3(   +uv.x,    1.f,    -uv.y);
    else if(face == 4)  return vec3(   +uv.x,   uv.y,      1.f);
    else                return vec3(    -uv.x,  +uv.y,     -1.f);
}

vec3 uvToDir(vec2 uv) {
    vec3 dir = normalize(uvToXYZ(uFace, uv * 2. - 1.));
    dir.y = -dir.y;
    return dir;
}

void main() {
    vec3 dir = uvToDir(vUv);
    vec3 col0 = textureLod(tLast, dir, 0.).rgb;
    vec3 col1 = textureLod(tBlur, dir, uLod).rgb * uExposure;
    gl_FragColor = vec4(mix(col0, col1, uWeight), 1.);
}
`
          , zs = {
            vertexShader: va.n,
            blending: l.jFi,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1
        }
          , _a = 7;
        class Co {
            constructor(oe, G) {
                B(this, "exposure", 1);
                B(this, "blurIntensity", 2);
                B(this, "_viewer");
                B(this, "_mipmapRenderTargets", []);
                B(this, "_cubeRenderTarget");
                B(this, "_blurMaterial");
                B(this, "_blurIntensity", -1);
                B(this, "_blurTexture", {
                    value: null
                });
                B(this, "_sigma", 2);
                B(this, "_minLod", 0);
                B(this, "_maxLod", _a);
                this._viewer = oe,
                this._cubeRenderTarget = G;
                const ee = Math.min(256, G.width);
                for (let ke = 0; ke <= _a; ke++)
                    this._mipmapRenderTargets[ke] = oe.createCubeRenderTarget(ee >> ke, !1, l.cLu, 0, !1);
                this._blurMaterial = new l.jyz({
                    ...zs,
                    fragmentShader: Xo,
                    uniforms: {
                        tLast: {
                            value: null
                        },
                        tBlur: {
                            value: null
                        },
                        uWeight: {
                            value: 0
                        },
                        uLod: {
                            value: 0
                        },
                        uFace: {
                            value: 0
                        },
                        uExposure: {
                            value: 1
                        }
                    }
                })
            }
            get blurTexture() {
                return this._blurTexture
            }
            dispose() {
                for (let oe = 0; oe < this._mipmapRenderTargets.length; oe++)
                    this._mipmapRenderTargets[oe].dispose()
            }
            update() {
                const oe = this._viewer.renderer;
                this._lodUpdate(this.blurIntensity);
                let G = this._maxLod;
                for (let ee = 0; ee < 6; ee++)
                    this._blur(oe, this._mipmapRenderTargets[G], null, this._cubeRenderTarget.texture, 1, G, ee, 0, ee);
                for (; G-- > this._minLod; )
                    for (let ee = 0; ee < 6; ee++)
                        this._blur(oe, this._mipmapRenderTargets[G], this._mipmapRenderTargets[G + 1].texture, this._cubeRenderTarget.texture, (0,
                        Mo.U)(this._sigma, G), G, ee, 0, ee);
                this._blurTexture.value = this._mipmapRenderTargets[G + 1].texture
            }
            _lodUpdate(oe) {
                if (this._blurIntensity !== oe) {
                    this._blurIntensity = oe,
                    this._sigma = l.MathUtils.lerp(1, 40, this._blurIntensity / 10);
                    for (let G = 0; G <= _a; G++) {
                        let ee = (0,
                        Mo.U)(this._sigma, G);
                        if (ee < .002 && (this._minLod = G),
                        ee >= 1) {
                            this._maxLod = G;
                            break
                        }
                    }
                }
            }
            _blur(oe, G, ee, ke, Ne, $e, vt, Lt, Pn) {
                this._blurMaterial.uniforms.tLast.value = ee,
                this._blurMaterial.uniforms.tBlur.value = ke,
                this._blurMaterial.uniforms.uWeight.value = Ne,
                this._blurMaterial.uniforms.uLod.value = $e,
                this._blurMaterial.uniforms.uFace.value = vt,
                this._blurMaterial.uniforms.uExposure.value = this.exposure,
                (0,
                po.NB)(oe, G, this._blurMaterial, Lt, Pn)
            }
        }
        var Va = function(ve, oe, G, ee) {
            var ke = arguments.length, Ne = ke < 3 ? oe : ee === null ? ee = Object.getOwnPropertyDescriptor(oe, G) : ee, $e;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                Ne = Reflect.decorate(ve, oe, G, ee);
            else
                for (var vt = ve.length - 1; vt >= 0; vt--)
                    ($e = ve[vt]) && (Ne = (ke < 3 ? $e(Ne) : ke > 3 ? $e(oe, G, Ne) : $e(oe, G)) || Ne);
            return ke > 3 && Ne && Object.defineProperty(oe, G, Ne),
            Ne
        };
        class eo extends ce.w {
            constructor(G) {
                super();
                B(this, "_scene");
                B(this, "_cubeRenderTarget");
                B(this, "_cubeCamera");
                B(this, "_mipBlurPass");
                B(this, "_cubeTexture", {
                    value: null
                });
                this._scene = G.scene,
                this.onLoad = ()=>{
                    this._cubeRenderTarget = this.viewer.createCubeRenderTarget(G.resolution || 256, !1, !1, 0, !0),
                    this._cubeTexture.value = this._cubeRenderTarget.texture,
                    this._cubeCamera = new l._am(G.near || 1,G.far || 100,this._cubeRenderTarget),
                    this._cubeCamera.layers.set(G.layer || 0),
                    this._mipBlurPass = new Co(this.viewer,this._cubeRenderTarget)
                }
            }
            get cubeTexture() {
                return this._cubeTexture
            }
            get blurTexture() {
                return this._mipBlurPass.blurTexture
            }
            get blurIntensity() {
                return this._mipBlurPass.blurIntensity
            }
            set blurIntensity(G) {
                this._mipBlurPass.blurIntensity = G
            }
            get exposure() {
                return this._mipBlurPass.exposure
            }
            set exposure(G) {
                this._mipBlurPass.exposure = G
            }
            onDestroy() {
                this._cubeRenderTarget.dispose(),
                this._mipBlurPass.dispose()
            }
            update(G) {
                const ee = this.viewer.renderer;
                this._cubeCamera.update(ee, this._scene),
                this._mipBlurPass.update()
            }
        }
        Va([(0,
        q.Cb)({
            min: 0,
            max: 10,
            step: .01
        })], eo.prototype, "blurIntensity", null),
        Va([(0,
        q.Cb)({
            min: 1,
            max: 20,
            step: .01
        })], eo.prototype, "exposure", null);
        var ns = r(678);
        const Po = {
            NORMAL: 0,
            ADD: 1,
            SUB: 2,
            MUL: 3
        };
        let ya = 0;
        class Yo {
            constructor(oe="", G="", ee=Po.NORMAL, ke=[], Ne={}, $e={}) {
                B(this, "frag");
                B(this, "name");
                B(this, "blend");
                B(this, "keywords");
                B(this, "uniforms");
                B(this, "defines");
                B(this, "id", "" + ya++);
                this.frag = oe,
                this.name = G,
                this.blend = ee,
                this.keywords = ke,
                this.uniforms = Ne,
                this.defines = $e
            }
            compile(oe, G) {
                this.prepare && this.prepare();
                let ee = {};
                for (let Lt in this.defines)
                    ee[Lt + this.id] = this.defines[Lt];
                this.defines = ee;
                let ke = {};
                for (let Lt in this.uniforms)
                    ke[Lt + this.id] = this.uniforms[Lt];
                let Ne = this.frag
                  , $e = this.keywords.concat(["mainImage", "mainUv"]);
                for (let Lt of $e)
                    Ne = Ne.replaceAll(Lt, Lt + this.id);
                let vt = [/mainUv/.test(this.frag) ? this._mainUv() : "", /mainImage/.test(this.frag) ? this._mainImage(oe, G) : "", this._blendLayer(oe, G)].join(`
`);
                return {
                    defines: ee,
                    uniforms: ke,
                    partChunk: Ne,
                    mainChunk: vt
                }
            }
            _mainUv() {
                return `mainUv${this.id}(uv);`
            }
            _mainImage(oe, G) {
                return `mainImage${this.id}(${oe}, uv, ${G});`
            }
            _blendLayer(oe, G) {
                switch (this.blend) {
                case Po.NORMAL:
                    return `blendNormal(${oe}, ${G});`;
                case Po.ADD:
                    return `blendAdd(${oe}, ${G});`;
                case Po.SUB:
                    return `blendSub(${oe}, ${G});`;
                case Po.MUL:
                    return `blendMul(${oe}, ${G});`;
                default:
                    return `blendNormal(${oe}, ${G});`
                }
            }
        }
        const mo = `
uniform vec3    uColor;
uniform float   uOpacity;

void mainImage(in vec4 inputColor, in vec2 uv, out vec4 outputColor) {
    outputColor = vec4(uColor, uOpacity);
}
`;
        class ws extends Yo {
            constructor({color: oe, mode: G}) {
                super(mo, "LayerColor", G, ["uColor", "uOpacity"], {
                    color: oe
                })
            }
        }
        const Gs = ve=>`
uniform vec3 uOrigin;
uniform vec3 uColorA;
uniform vec3 uColorB;
uniform vec4 uDepthParams;

#define uOpacity    uDepthParams.x
#define uNear       uDepthParams.y
#define uFar        uDepthParams.z

void mainImage(in vec4 inputColor, in vec2 uv, out vec4 outputColor) {
    float fDist = ${ve};
    float fDepth = (fDist - uNear) / (uFar - uNear);
    vec3  fDepthColor =  mix(uColorB, uColorA, 1.0 - clamp(fDepth, 0., 1.));
    outputColor = vec4(fDepthColor, uOpacity);
}
`
          , S = {
            VECTOR: 0,
            WORLD: 1,
            CAMERA: 2
        };
        class p extends Yo {
            constructor({blend: G, mapping: ee, colorA: ke, colorB: Ne, near: $e, far: vt}) {
                super("", "LayerDepth", G, ["uOrigin", "uColorA", "uColorB", "uDepthParams", "uOpacity", "uNear", "uFar"], {
                    colorA: ke,
                    colorB: Ne,
                    near: $e,
                    far: vt
                });
                B(this, "mapping", S.VECTOR)
            }
            prepare() {
                this.frag = Gs(this._depthDistance(this.mapping))
            }
            _depthDistance(G) {
                switch (G) {
                case S.CAMERA:
                    return "length(vWorldPosition - cameraPosition);";
                case S.WORLD:
                    return `length(vWorldPosition - uOrigin${this.id});`;
                case S.VECTOR:
                    return "length(vPosition);"
                }
            }
        }
        const C = `
varying vec2 vUv;
varying vec3 vPosition;
varying vec3 vWorldPosition;

void main() {
    vec4 worldPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * worldPosition;
    vWorldPosition = worldPosition.xyz;
    vUv = uv;
}
`
          , V = (ve,oe)=>`
varying vec2 vUv;
varying vec3 vPosition;
varying vec3 vWorldPosition;

void blendNormal(in vec4 inputColor, inout vec4 outputColor) {
    outputColor.rgb = inputColor.rgb * inputColor.a + outputColor.rgb * (1. - inputColor.a);
    outputColor.a   = inputColor.a + outputColor.a * (1. - inputColor.a);
}

void blendAdd(in vec4 inputColor, inout vec4 outputColor) {
    outputColor.rgb = inputColor.rgb * inputColor.a + outputColor.rgb;
    outputColor.a   = inputColor.a + outputColor.a;
}

void blendSub(in vec4 inputColor, inout vec4 outputColor) {
    outputColor.rgb = outputColor.rgb * (1. - inputColor.rgb);
    outputColor.a   = outputColor.a * (1. - inputColor.a);
}

void blendMul(in vec4 inputColor, inout vec4 outputColor) {
    outputColor.rgb = inputColor.rgb * outputColor.rgb;
    outputColor.a   = inputColor.a * outputColor.a;
}

${ve}

void main() {
vec2 uv = vUv;
vec4 color0 = vec4(0.,0.,0.,0.);
vec4 color1 = vec4(0.,0.,0.,1.);
${oe}
}
`;
        class se extends l.jyz {
            constructor(G=[new ws({
                color: "#444",
                opacity: 1
            }), new p({
                colorA: "blue",
                colorB: "black",
                opacity: .5
            }), new ws({
                color: "#444",
                opacity: 1
            })]) {
                super({
                    vertexShader: C
                });
                B(this, "layers");
                this.layers = G
            }
            onBeforeCompile(G, ee) {
                let ke = {}
                  , Ne = {}
                  , $e = []
                  , vt = []
                  , Lt = "color0"
                  , Pn = "color1"
                  , un = "";
                for (let vn of this.layers) {
                    let _n = vn.compile(Lt, Pn);
                    Object.assign(ke, _n.uniforms),
                    Object.assign(Ne, _n.defines),
                    $e.push(_n.partChunk),
                    vt.push(_n.mainChunk),
                    un = Lt,
                    Lt = Pn,
                    Pn = un
                }
                vt.push(`gl_FragColor=${Lt};`),
                G.fragmentShader = V($e.join(`
`), vt.join(`
`)),
                console.log(G.fragmentShader)
            }
        }
        class ye extends l.Wid {
            constructor({specularGlossMap: G, ...ee}={}) {
                super(ee);
                B(this, "envMapIntensity", .45);
                B(this, "specularGlossMap", null);
                this.specularGlossMap = G
            }
            onBeforeCompile(G, ee) {
                G.fragmentShader = G.fragmentShader.replace("#include <map_pars_fragment>", `
            uniform sampler2D specularGlossMap;
            #include <map_pars_fragment>
            `).replace("#include <lights_physical_fragment>", `
            #include <lights_physical_fragment>
            vec4 specGloss = texture2D(specularGlossMap, vUv);
            material.specularColor = specGloss.rgb;
            material.diffuseColor = diffuseColor.rgb * (1. - specGloss.rgb);
            material.roughness = specGloss.a;
        `),
                G.uniforms.specularGlossMap = {
                    value: this.specularGlossMap
                }
            }
        }
        var ue = r(741)
          , Ce = r(353)
          , mt = r(481);
        const nn = "SYSTEM_UPDATE"
          , cn = "PARTICLE_CREATED"
          , ni = "PARTICLE_UPDATE"
          , ae = "PARTICLE_DEAD"
          , y = "EMITTER_ADDED"
          , b = "EMITTER_REMOVED"
          , E = "SYSTEM_UPDATE_AFTER"
          , T = "EULER";
        function L(ve, oe, G) {
            ve.sleep || (ve.mass !== 1 && ve.acceleration.multiplyScalar(1 / ve.mass),
            ve.velocity.add(ve.acceleration.multiplyScalar(oe)),
            ve.position.add(ve.velocity.multiplyScalar(oe)),
            ve.acceleration.set(0, 0, 0))
        }
        function F(ve, oe, G, ee=T) {
            switch (ee) {
            case T:
                L(ve, oe);
                break;
            default:
                L(ve, oe)
            }
        }
        function j(ve, oe, G) {
            if (ve === oe)
                return G ? ve >> 0 : ve;
            {
                let ee = ve + Math.random() * (oe - ve);
                return G ? ee >> 0 : ee
            }
        }
        class W {
            constructor(oe, G) {
                B(this, "a");
                B(this, "b");
                B(this, "arr");
                Array.isArray(oe) ? this.arr = oe : (this.a = oe ?? 0,
                this.b = G ?? this.a)
            }
            getValue(oe=!1) {
                return this.arr ? this.arr[this.arr.length * Math.random() >> 0] : j(this.a, this.b, oe)
            }
        }
        class re {
            constructor(oe=1, G=0, ee=1) {
                B(this, "_countSpan", null);
                B(this, "_intervalSpan", null);
                B(this, "_elapse", 0);
                B(this, "_inteval", 0);
                B(this, "_lastTime", 0);
                B(this, "_repeat", 1);
                B(this, "_repeatCount", 1);
                this._countSpan = Array.isArray(oe) ? new W(oe[0],oe[1]) : new W(oe),
                this._intervalSpan = Array.isArray(G) ? new W(G[0],G[1]) : new W(G),
                this._inteval = this._intervalSpan.getValue(),
                this._repeatCount = this._repeat = ee
            }
            reset() {
                this._elapse = 0,
                this._lastTime = 0,
                this._inteval = this._intervalSpan.getValue(),
                this._repeatCount = this._repeat
            }
            getVaue(oe) {
                return (this._repeatCount > 0 || this._repeat < 0) && (this._elapse += oe,
                this._elapse - this._lastTime >= this._inteval) ? (this._lastTime += this._inteval,
                this._inteval = this._intervalSpan.getValue(),
                this._repeatCount--,
                this._countSpan.getValue(!0)) : 0
            }
        }
        const {PI: fe} = Math
          , te = {
            easeLinear: function(ve) {
                return ve
            },
            easeInQuad: function(ve) {
                return Math.pow(ve, 2)
            },
            easeOutQuad: function(ve) {
                return -(Math.pow(ve - 1, 2) - 1)
            },
            easeInOutQuad: function(ve) {
                return (ve /= .5) < 1 ? .5 * Math.pow(ve, 2) : -.5 * ((ve -= 2) * ve - 2)
            },
            easeInCubic: function(ve) {
                return Math.pow(ve, 3)
            },
            easeOutCubic: function(ve) {
                return Math.pow(ve - 1, 3) + 1
            },
            easeInOutCubic: function(ve) {
                return (ve /= .5) < 1 ? .5 * Math.pow(ve, 3) : .5 * (Math.pow(ve - 2, 3) + 2)
            },
            easeInQuart: function(ve) {
                return Math.pow(ve, 4)
            },
            easeOutQuart: function(ve) {
                return -(Math.pow(ve - 1, 4) - 1)
            },
            easeInOutQuart: function(ve) {
                return (ve /= .5) < 1 ? .5 * Math.pow(ve, 4) : -.5 * ((ve -= 2) * Math.pow(ve, 3) - 2)
            },
            easeInSine: function(ve) {
                return -Math.cos(ve * (fe / 2)) + 1
            },
            easeOutSine: function(ve) {
                return Math.sin(ve * (fe / 2))
            },
            easeInOutSine: function(ve) {
                return -.5 * (Math.cos(fe * ve) - 1)
            },
            easeInExpo: function(ve) {
                return ve === 0 ? 0 : Math.pow(2, 10 * (ve - 1))
            },
            easeOutExpo: function(ve) {
                return ve === 1 ? 1 : -Math.pow(2, -10 * ve) + 1
            },
            easeInOutExpo: function(ve) {
                return ve === 0 ? 0 : ve === 1 ? 1 : (ve /= .5) < 1 ? .5 * Math.pow(2, 10 * (ve - 1)) : .5 * (-Math.pow(2, -10 * --ve) + 2)
            },
            easeInCirc: function(ve) {
                return -(Math.sqrt(1 - ve * ve) - 1)
            },
            easeOutCirc: function(ve) {
                return Math.sqrt(1 - Math.pow(ve - 1, 2))
            },
            easeInOutCirc: function(ve) {
                return (ve /= .5) < 1 ? -.5 * (Math.sqrt(1 - ve * ve) - 1) : .5 * (Math.sqrt(1 - (ve -= 2) * ve) + 1)
            },
            easeInBack: function(ve) {
                var oe = 1.70158;
                return ve * ve * ((oe + 1) * ve - oe)
            },
            easeOutBack: function(ve) {
                var oe = 1.70158;
                return (ve = ve - 1) * ve * ((oe + 1) * ve + oe) + 1
            },
            easeInOutBack: function(ve) {
                var oe = 1.70158;
                return (ve /= .5) < 1 ? .5 * (ve * ve * (((oe *= 1.525) + 1) * ve - oe)) : .5 * ((ve -= 2) * ve * (((oe *= 1.525) + 1) * ve + oe) + 2)
            }
        };
        function Te(ve) {
            return ve.constructor.type === "Span" ? ve.getValue() : ve
        }
        function Ge(ve, oe, G) {
            for (var ee in oe)
                ve.hasOwnProperty(ee) && (G ? G.indexOf(ee) < 0 && (ve[ee] = Te(oe[ee])) : ve[ee] = Te(oe[ee]));
            return ve
        }
        function St(ve, oe) {
            for (let G in oe)
                if (ve.hasOwnProperty(G)) {
                    let ee = ve[G];
                    ee && ee.copy ? ee.copy(oe[G]) : ve[G] = oe[G]
                }
            return ve
        }
        const {clamp: kt, clamp01: Vt} = l.MathUtils;
        class gt {
            constructor(oe) {
                B(this, "index", 0);
                B(this, "age", 0);
                B(this, "life", 1 / 0);
                B(this, "energy", 1);
                B(this, "progress", 0);
                B(this, "dead", !1);
                B(this, "sleep", !1);
                B(this, "delay", 0);
                B(this, "acceleration", new l.Pa4);
                B(this, "scale", new l.Pa4(1,1,1));
                B(this, "position", new l.Pa4);
                B(this, "velocity", new l.Pa4);
                B(this, "rotation", new l.USm);
                B(this, "behaviours", []);
                B(this, "parent", null);
                B(this, "color", new l.Ilk);
                B(this, "alpha", 1);
                B(this, "mass", 1);
                B(this, "easing", te.easeLinear);
                B(this, "transform", {});
                B(this, "rand", new l.Pa4);
                Ge(this, oe)
            }
            reset() {
                return this.age = 0,
                this.life = 1 / 0,
                this.energy = 1,
                this.progress = 0,
                this.dead = !1,
                this.sleep = !1,
                this.delay = 0,
                this.acceleration.set(0, 0, 0),
                this.scale.set(1, 1, 1),
                this.position.set(0, 0, 0),
                this.velocity.set(0, 0, 0),
                this.rotation.set(0, 0, 0),
                this.parent = null,
                this.color.setRGB(1, 1, 1),
                this.alpha = 1,
                this.mass = 1,
                this.easing = te.easeLinear,
                this.rand.set(0, 0, 0),
                this.removeAllBehaviours(),
                this
            }
            destroy() {
                return this.dead = !0,
                this.parent = null,
                this
            }
            update(oe) {
                if (this.sleep || this.dead)
                    return !1;
                if (this.delay > 0)
                    return this.delay -= oe,
                    !1;
                if (this.age += oe,
                this.age > this.life)
                    if (this.energy > 0)
                        this.energy = 0,
                        this.progress = 1;
                    else
                        return this.destroy(),
                        !1;
                else
                    this.progress = this.easing(Vt(this.age / this.life)),
                    this.energy = 1 - this.progress;
                for (let G = this.behaviours.length; G--; )
                    this.behaviours[G].applyBehaviour(this, oe, this.progress);
                return !0
            }
            addBehaviour(...oe) {
                for (let G of oe)
                    this.behaviours.push(G),
                    G.initialize(this)
            }
            removeBehaviour(oe) {
                let G = this.behaviours.indexOf(oe);
                G > -1 && this.behaviours.splice(G, 1)
            }
            removeAllBehaviours() {
                this.behaviours.length = 0
            }
        }
        var xt = r(282);
        const Xe = new xt.X(null,new l.Ltg,new l.Ltg);
        class ut {
            constructor(oe={}) {
                B(this, "spriteFrame", Xe);
                B(this, "count", 1);
                B(this, "interval", 0);
                B(this, "repeat", 1);
                B(this, "billboard", !0);
                B(this, "behaviours", []);
                Ge(this, oe)
            }
        }
        const {clamp: dn} = l.MathUtils
          , qt = {
            count: 1
        };
        class ln extends gt {
            constructor(G) {
                super();
                B(this, "rate", new re(1,.1));
                B(this, "playing", !1);
                B(this, "particles", []);
                B(this, "damping", .006);
                B(this, "controller", new ut);
                Ge(this, G),
                this.initialize(this.controller)
            }
            initialize({count: G, interval: ee, repeat: ke, behaviours: Ne}) {
                this.rate = new re(G,ee,ke),
                this.behaviours = Ne
            }
            update(G) {
                return this.sleep || this.dead ? !1 : (this.age += G,
                this.age > this.life && this.particles.length == 0 && this.destroy(),
                this.playing && this.generate(G),
                this.particles.length > 0 && this.integrate(G),
                !0)
            }
            integrate(G) {
                var Ne, $e, vt;
                1 - this.damping;
                let ee, ke = dn(G * 60, .5, 1.5);
                for (let Lt = this.particles.length; Lt--; )
                    ee = this.particles[Lt],
                    ee.update(G) && ((Ne = this.parent) == null || Ne.emit(ni, ee),
                    this.controller.onParticleUpdate && this.controller.onParticleUpdate(ee),
                    F(ee, ke)),
                    ee.dead && (this.particles.splice(Lt, 1),
                    ($e = this.parent) == null || $e.pool.expire(ee),
                    (vt = this.parent) == null || vt.emit(ae, ee))
            }
            createParticle(G) {
                var ke;
                let ee = this.parent.pool.get(gt);
                ee.reset(),
                ee.addBehaviour(...this.behaviours),
                ee.parent = this,
                ee.index = this.particles.length,
                this.particles.push(ee),
                (ke = this.parent) == null || ke.emit(cn, ee),
                this.controller.onParticleCreate && this.controller.onParticleCreate(ee, G)
            }
            generate(G) {
                for (let ee = qt.count = this.rate.getVaue(G); ee--; )
                    this.createParticle(qt)
            }
            emit(G) {
                for (let ee = G.count = Math.max(1, G.count); ee--; )
                    this.createParticle(G)
            }
            play() {
                this.playing = !0,
                this.rate.reset()
            }
            stop() {
                this.playing = !1
            }
        }
        class Tn {
            constructor() {
                B(this, "list", [])
            }
            get(oe) {
                return this.list.length > 0 ? this.list.pop() : new oe
            }
            expire(oe) {
                this.list.push(oe)
            }
        }
        var fn = function(ve, oe, G, ee) {
            var ke = arguments.length, Ne = ke < 3 ? oe : ee === null ? ee = Object.getOwnPropertyDescriptor(oe, G) : ee, $e;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                Ne = Reflect.decorate(ve, oe, G, ee);
            else
                for (var vt = ve.length - 1; vt >= 0; vt--)
                    ($e = ve[vt]) && (Ne = (ke < 3 ? $e(Ne) : ke > 3 ? $e(oe, G, Ne) : $e(oe, G)) || Ne);
            return ke > 3 && Ne && Object.defineProperty(oe, G, Ne),
            Ne
        };
        class Hn extends ce.w {
            constructor() {
                super(...arguments);
                B(this, "name", "ParticleSystem-" + this.uuid);
                B(this, "playing", !1);
                B(this, "pool", new Tn);
                B(this, "emitters", []);
                B(this, "renderers", [])
            }
            addEmitter(G) {
                return G.parent = this,
                this.emitters.push(G),
                this.emit(y, G),
                this
            }
            removeEmitter(G) {
                return G.parent !== this ? this : (G.parent = null,
                this.emitters.splice(this.emitters.indexOf(G), 1),
                this.emit(b, G),
                this)
            }
            addRenderer(G) {
                return this.renderers.push(G.init(this)),
                this
            }
            removeRenderer(G) {
                return this.renderers.splice(this.renderers.indexOf(G.reset()), 1),
                this
            }
            play() {
                for (let G = this.emitters.length; G--; )
                    this.emitters[G].play();
                return this.playing = !0,
                this
            }
            stop() {
                return this.playing = !1,
                this
            }
            update(G) {
                if (!this.playing)
                    return;
                let ee;
                for (let ke = this.emitters.length; ke--; )
                    ee = this.emitters[ke],
                    ee.update(G),
                    ee.particles.length && this.emit(nn, this);
                this.emit(E, this)
            }
            getCount() {
                let G = 0;
                for (let ee = this.emitters.length; ee--; )
                    G += this.emitters[ee].particles.length;
                return G
            }
            onDestroy() {
                for (let G = this.emitters.length; G--; )
                    this.emitters[G].destroy();
                for (let G = this.renderers.length; G--; )
                    this.renderers[G].destroy();
                this.emitters.length = 0,
                this.renderers.length = 0
            }
        }
        fn([(0,
        q.Cb)()], Hn.prototype, "play", null),
        fn([(0,
        q.Cb)()], Hn.prototype, "stop", null);
        class En {
            constructor(oe=!0) {
                B(this, "enabled");
                this.enabled = oe
            }
            applyBehaviour(oe, G, ee) {
                this.enabled && this.mutate(oe, G, ee)
            }
            initialize(oe) {}
            mutate(oe, G, ee) {}
        }
        class Ei extends En {
            constructor(G=1, ee, ke=te.easeLinear, Ne) {
                super(Ne);
                B(this, "alphaA");
                B(this, "alphaB");
                B(this, "easing");
                this.alphaA = G,
                this.alphaB = ee,
                this.easing = ke
            }
            initialize(G) {
                G.transform.alphaA = this.alphaA,
                G.transform.alphaB = this.alphaB
            }
            mutate(G, ee, ke) {
                G.alpha = G.transform.alphaB !== void 0 ? l.MathUtils.lerp(G.transform.alphaA, G.transform.alphaB, this.easing(ke)) : G.transform.alphaA
            }
        }
        class ar extends En {
            constructor(G=new l.Ilk, ee, ke=te.easeLinear, Ne) {
                super(Ne);
                B(this, "colorA");
                B(this, "colorB");
                B(this, "easing");
                this.colorA = G,
                this.colorB = ee,
                this.easing = ke
            }
            initialize(G) {
                var ee;
                G.transform.colorA = this.colorA.clone(),
                G.transform.colorB = (ee = this.colorB) == null ? void 0 : ee.clone()
            }
            mutate(G, ee, ke) {
                G.color.copy(G.transform.colorA),
                G.transform.colorB && G.color.lerp(G.transform.colorB, this.easing(ke))
            }
        }
        class fr extends En {
            constructor(G=new l.Pa4, ee) {
                super(ee);
                B(this, "force");
                this.force = G,
                this.force.multiplyScalar(100)
            }
            initialize(G) {
                G.transform.force = this.force.clone()
            }
            mutate(G, ee, ke) {
                G.acceleration.add(G.transform.force)
            }
        }
        class lr extends fr {
            constructor(G=10, ee) {
                super(new l.Pa4(0,-G,0), ee);
                B(this, "gravity");
                this.gravity = G
            }
        }
        class is extends En {
            constructor(G=new l.Pa4, ee, ke=te.easeLinear, Ne) {
                super(Ne);
                B(this, "scaleA");
                B(this, "scaleB");
                B(this, "easing");
                this.scaleA = G,
                this.scaleB = ee,
                this.easing = ke
            }
            initialize(G) {
                var ee;
                G.transform.scaleA = this.scaleA.clone(),
                G.transform.scaleB = (ee = this.scaleB) == null ? void 0 : ee.clone()
            }
            mutate(G, ee, ke) {
                G.scale.copy(G.transform.scaleA),
                G.transform.scaleB && G.scale.lerp(G.transform.scaleB, this.easing(ke))
            }
        }
        class Tr extends l.Kj0 {
            constructor() {
                super(...arguments);
                B(this, "system")
            }
            init(G) {
                return this.system = G,
                this.system.node.add(this),
                this.system.on(nn, this.onSystemUpdate, this),
                this.system.on(E, this.onSystemUpdateAfter, this),
                this
            }
            reset() {
                return this.system && (this.system.targetOff(this),
                this.system.node.remove(this),
                this.system = void 0),
                this
            }
            destroy() {}
            onSystemUpdate(G) {}
            onSystemUpdateAfter(G) {}
        }
        const Er = `
precision highp float;
attribute vec4 texCoords;
attribute vec4 meshCoords;
attribute vec3 spritePos;
attribute vec4 spriteQuat;
attribute vec4 spriteColor;
attribute vec2 decorators;

varying vec2 vUv;
varying vec4 vColor;

#include <xv_matrix>

mat2 makeRotateMatrix(in float rad) {
    float c = cos(rad);
    float s = sin(rad);
    return mat2(c,-s,s,c);
}

void main() {
    vColor = spriteColor;
    vUv = uv * texCoords.zw + texCoords.xy;
    vUv.y = 1. - vUv.y;

    mat4 instanceMatrix = getInstanceMatrix(spritePos, spriteQuat, vec3(1.));
    mat4 mvMatrix = modelViewMatrix * instanceMatrix;

    vec4 transformed = vec4(position,1.);
    transformed.xy = transformed.xy * meshCoords.zw + meshCoords.xy;

    vec4 mvPosition = mvMatrix * transformed;
    vec4 bbPosition = mvMatrix * vec4(0.,0.,0.,1.);
    vec2 scale = vec2(length(mvMatrix[0].xyz), length(mvMatrix[1].xyz));
    bbPosition.xy += makeRotateMatrix(spriteQuat.x) * transformed.xy * scale;
    mvPosition = mix(mvPosition, bbPosition, decorators.x);

    gl_Position = projectionMatrix * mvPosition;
}
`
          , Kr = `
precision highp float;
uniform sampler2D map;
varying vec2 vUv;
varying vec4 vColor;

float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }

void main() {
    vec4 color = texture2D(map, vUv);
    float shape = color.r;

#ifdef USE_ALPHA_SDF
#ifdef IS_ADDITIVE_BLENDING
    float l = vColor.a * luma(vColor.rgb);
    shape = max(smoothstep(0.48, 0.52, shape), shape * l);
#else
    shape = smoothstep(0.48, 0.52, shape);
#endif
#endif

    float alpha = color.a * vColor.a;
    vec3 col = vColor.rgb * vColor.a * shape;
    gl_FragColor = vec4(col, alpha * shape);
}
`
          , Vi = {
            blending: l.WMw,
            depthTest: !0,
            depthWrite: !1,
            transparent: !0,
            maxParticles: 200
        }
          , me = new l._12;
        let _r = new l._fP;
        class Qo extends Tr {
            constructor(G=Vi) {
                super();
                B(this, "stride", 21);
                B(this, "buffer");
                B(this, "interleavedBuffer");
                B(this, "geometry", new l.L5s);
                B(this, "renderMode", 0);
                const {blending: ee, useAlphaSDF: ke, depthTest: Ne, depthWrite: $e, transparent: vt, maxParticles: Lt, map: Pn, frustumCulled: un, ...vn} = {
                    ...Vi,
                    ...G
                }
                  , _n = new l.jyz({
                    uniforms: {
                        map: {
                            value: Pn
                        }
                    },
                    defines: {
                        USE_ALPHA_SDF: !!ke,
                        IS_ADDITIVE_BLENDING: ee === l.WMw
                    },
                    vertexShader: Er,
                    fragmentShader: Kr,
                    blending: ee,
                    depthTest: Ne,
                    depthWrite: $e,
                    transparent: vt
                });
                let qn = new Float32Array(Lt * this.stride)
                  , ii = new l.$TI(qn,this.stride)
                  , Mi = new l.L5s;
                Mi.index = me.index,
                Mi.attributes.position = me.attributes.position,
                Mi.attributes.uv = me.attributes.uv,
                Mi.setAttribute("texCoords", new l.kB5(ii,4,0,!1)),
                Mi.setAttribute("meshCoords", new l.kB5(ii,4,4,!1)),
                Mi.setAttribute("spritePos", new l.kB5(ii,3,8,!1)),
                Mi.setAttribute("decorators", new l.kB5(ii,2,11,!1)),
                Mi.setAttribute("spriteQuat", new l.kB5(ii,4,13,!1)),
                Mi.setAttribute("spriteColor", new l.kB5(ii,4,17,!1)),
                this.buffer = qn,
                this.interleavedBuffer = ii,
                this.interleavedBuffer.setUsage(l.dj0),
                this.geometry = Mi,
                this.material = _n,
                this.frustumCulled = un ?? !1,
                (0,
                ne.$p)(this, vn)
            }
            onSystemUpdateAfter(G) {
                let ee = 0
                  , ke = G.emitters;
                for (let Ne = ke.length; Ne--; ) {
                    let $e = ke[Ne].particles;
                    for (let vt = $e.length; vt--; )
                        this.commitInstanceBuffer($e[vt], ee++ * this.stride)
                }
                this.interleavedBuffer.needsUpdate = !0,
                this.geometry.instanceCount = ee,
                this.visible = ee > 0
            }
            commitInstanceBuffer(G, ee=0) {
                let {position: ke, rotation: Ne, scale: $e, color: vt} = G
                  , {billboard: Lt, spriteFrame: Pn} = G.parent.controller
                  , {texCoords: un, meshCoords: vn} = Pn;
                Lt ? _r.x = Ne.x : _r.setFromEuler(Ne);
                let _n = this.buffer;
                _n[ee++] = un.x,
                _n[ee++] = un.y,
                _n[ee++] = un.z,
                _n[ee++] = un.w,
                _n[ee++] = vn.x * $e.x,
                _n[ee++] = vn.y * $e.y,
                _n[ee++] = vn.z * $e.x,
                _n[ee++] = vn.w * $e.y,
                _n[ee++] = ke.x,
                _n[ee++] = ke.y,
                _n[ee++] = ke.z,
                _n[ee++] = Lt ? 1 : 0,
                _n[ee++] = 0,
                _n[ee++] = _r.x,
                _n[ee++] = _r.y,
                _n[ee++] = _r.z,
                _n[ee++] = _r.w,
                _n[ee++] = vt.r,
                _n[ee++] = vt.g,
                _n[ee++] = vt.b,
                _n[ee++] = G.alpha
            }
        }
        var Ji = r(427)
          , xa = r(992);
        function wi(ve) {
            return ve > 1e3 ? Math.floor(ve * .001) + "k" : ve > 1e6 ? Math.floor(ve * 1e-6) + "m" : ve
        }
        var Mr = function(ve, oe, G) {
            var ee = 1 / 0
              , ke = 0
              , Ne = Math.round
              , $e = Ne(window.devicePixelRatio || 1)
              , vt = 80 * $e
              , Lt = 48 * $e
              , Pn = 3 * $e
              , un = 2 * $e
              , vn = 3 * $e
              , _n = 15 * $e
              , qn = 74 * $e
              , ii = 30 * $e
              , Mi = document.createElement("canvas");
            Mi.width = vt,
            Mi.height = Lt,
            Mi.style.cssText = "width:80px;height:48px";
            var Jn = Mi.getContext("2d");
            return Jn.font = "bold " + 9 * $e + "px Helvetica,Arial,sans-serif",
            Jn.textBaseline = "top",
            Jn.fillStyle = G,
            Jn.fillRect(0, 0, vt, Lt),
            Jn.fillStyle = oe,
            Jn.fillText(ve, Pn, un),
            Jn.fillRect(vn, _n, qn, ii),
            Jn.fillStyle = G,
            Jn.globalAlpha = .9,
            Jn.fillRect(vn, _n, qn, ii),
            {
                dom: Mi,
                update: function(cr, ur) {
                    ee = Math.min(ee, cr),
                    ke = Math.max(ke, cr),
                    Jn.fillStyle = G,
                    Jn.globalAlpha = 1,
                    Jn.fillRect(0, 0, vt, _n),
                    Jn.fillStyle = oe,
                    Jn.fillText(wi(Ne(cr)) + " " + ve + " (" + wi(Ne(ee)) + "-" + wi(Ne(ke)) + ")", Pn, un),
                    console.error('drawImage:', Mi),
                    Jn.drawImage(Mi, vn + $e, _n, qn - $e, ii, vn, _n, qn - $e, ii),
                    Jn.fillRect(vn + qn - $e, _n, $e, ii),
                    Jn.fillStyle = G,
                    Jn.globalAlpha = .9,
                    Jn.fillRect(vn + qn - $e, _n, $e, Ne((1 - cr / ur) * ii))
                }
            }
        }
          , yr = function() {
            var ve = 0
              , oe = document.createElement("div");
            oe.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",
            oe.addEventListener("click", function(un) {
                un.preventDefault(),
                ee(++ve % oe.children.length)
            }, !1);
            function G(un) {
                return oe.appendChild(un.dom),
                un
            }
            function ee(un) {
                for (var vn = 0; vn < oe.children.length; vn++)
                    oe.children[vn].style.display = vn === un ? "block" : "none";
                ve = un
            }
            var ke = (performance || Date).now()
              , Ne = ke
              , $e = 0
              , vt = G(new Mr("FPS","#0ff","#002"))
              , Lt = G(new Mr("MS","#0f0","#020"));
            if (self.performance && self.performance.memory)
                var Pn = G(new Mr("MB","#f08","#201"));
            return ee(0),
            {
                REVISION: 16,
                dom: oe,
                addPanel: G,
                showPanel: ee,
                begin: function() {
                    ke = (performance || Date).now()
                },
                end: function() {
                    $e++;
                    var un = (performance || Date).now();
                    if (Lt.update(un - ke, 200),
                    un >= Ne + 1e3 && (vt.update($e * 1e3 / (un - Ne), 100),
                    Ne = un,
                    $e = 0,
                    Pn)) {
                        var vn = performance.memory;
                        Pn.update(vn.usedJSHeapSize / 1048576, vn.jsHeapSizeLimit / 1048576)
                    }
                    return un
                },
                update: function() {
                    ke = this.end()
                },
                domElement: oe,
                setMode: ee
            }
        };
        class Wi extends xa.S {
            constructor() {
                super(...arguments);
                B(this, "_stats", new yr);
                B(this, "_dcPanel", new Mr("DC","#ff8","#221"));
                B(this, "_triPanel", new Mr("TRI","#ff8","#221"));
                B(this, "_texPanel", new Mr("TEX","#ff8","#221"));
                B(this, "_prgPanel", new Mr("PRG","#ff8","#221"))
            }
            onLoad() {
                this._stats.addPanel(this._dcPanel),
                this._stats.addPanel(this._texPanel),
                this._stats.addPanel(this._triPanel),
                this._stats.addPanel(this._prgPanel),
                this._stats.showPanel(0),
                document.body.appendChild(this._stats.dom)
            }
            update(G) {
                let ee = this.viewer.renderer.info;
                this._dcPanel.update(ee.render.calls, 300),
                this._triPanel.update(ee.render.triangles, 5e5),
                this._texPanel.update(ee.memory.textures, 200),
                this._prgPanel.update(ee.programs.length, 50),
                this._stats.update()
            }
        }
    }
    ,
    745: (t,n,r)=>{
        r.d(n, {
            g: ()=>s
        });
        class s {
            constructor(l) {
                B(this, "viewer");
                B(this, "name", "");
                this.viewer = l
            }
        }
    }
    ,
    353: (t,n,r)=>{
        r.d(n, {
            gO: ()=>s.g,
            f0: ()=>g,
            GP: ()=>A,
            q7: ()=>pt,
            Ae: ()=>us,
            uo: ()=>ye,
            k7: ()=>Ce,
            KC: ()=>ni,
            Zt: ()=>mt,
            YQ: ()=>nn
        });
        var s = r(745)
          , h = r(811)
          , l = r(427);
        class g extends s.g {
            constructor() {
                super(...arguments);
                B(this, "extensions", ["atlas"])
            }
            load({url: b, file: E, onLoad: T, onProgress: L, onError: F, texSettings: j}) {
                (async()=>{
                    try {
                        let W = await this.viewer.loadAsset({
                            url: b,
                            selExt: "json"
                        })
                          , re = await this.viewer.loadAsset({
                            url: `${(0,
                            l.I_)(b)}/${W.meta.image}`,
                            onProgress: L
                        });
                        T(new h.Y(W,Object.assign(re, j)))
                    } catch (W) {
                        F(W)
                    }
                }
                )()
            }
        }
        var _ = r(25);
        class A extends s.g {
            constructor() {
                super(...arguments);
                B(this, "extensions", ["mp3", "wav", "ogg"])
            }
            load({url: b, file: E, onLoad: T, onProgress: L, onError: F}) {
                new _.mTL(this.viewer.loadingManager).load(b, T, L, F, E)
            }
        }
        var m = r(477)
          , D = function(ae) {
            return URL.createObjectURL(new Blob([ae],{
                type: "text/javascript"
            }))
        };
        try {
            URL.revokeObjectURL(D(""))
        } catch {
            D = function(y) {
                return "data:application/javascript;charset=UTF-8," + encodeURI(y)
            }
        }
        var U = Uint8Array
          , R = Uint16Array
          , ne = Uint32Array
          , ce = new U([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
          , xe = new U([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
          , Se = new U([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
          , $ = function(ae, y) {
            for (var b = new R(31), E = 0; E < 31; ++E)
                b[E] = y += 1 << ae[E - 1];
            for (var T = new ne(b[30]), E = 1; E < 30; ++E)
                for (var L = b[E]; L < b[E + 1]; ++L)
                    T[L] = L - b[E] << 5 | E;
            return [b, T]
        }
          , q = $(ce, 2)
          , N = q[0]
          , ie = q[1];
        N[28] = 258,
        ie[258] = 28;
        for (var _e = $(xe, 0), Pe = _e[0], Be = new R(32768), Re = 0; Re < 32768; ++Re) {
            var ct = (Re & 43690) >>> 1 | (Re & 21845) << 1;
            ct = (ct & 52428) >>> 2 | (ct & 13107) << 2,
            ct = (ct & 61680) >>> 4 | (ct & 3855) << 4,
            Be[Re] = ((ct & 65280) >>> 8 | (ct & 255) << 8) >>> 1
        }
        for (var et = function(ae, y, b) {
            for (var E = ae.length, T = 0, L = new R(y); T < E; ++T)
                ++L[ae[T] - 1];
            var F = new R(y);
            for (T = 0; T < y; ++T)
                F[T] = F[T - 1] + L[T - 1] << 1;
            var j;
            if (b) {
                j = new R(1 << y);
                var W = 15 - y;
                for (T = 0; T < E; ++T)
                    if (ae[T])
                        for (var re = T << 4 | ae[T], fe = y - ae[T], te = F[ae[T] - 1]++ << fe, Te = te | (1 << fe) - 1; te <= Te; ++te)
                            j[Be[te] >>> W] = re
            } else
                for (j = new R(E),
                T = 0; T < E; ++T)
                    ae[T] && (j[T] = Be[F[ae[T] - 1]++] >>> 15 - ae[T]);
            return j
        }, Ze = new U(288), Re = 0; Re < 144; ++Re)
            Ze[Re] = 8;
        for (var Re = 144; Re < 256; ++Re)
            Ze[Re] = 9;
        for (var Re = 256; Re < 280; ++Re)
            Ze[Re] = 7;
        for (var Re = 280; Re < 288; ++Re)
            Ze[Re] = 8;
        for (var Nt = new U(32), Re = 0; Re < 32; ++Re)
            Nt[Re] = 5;
        var Bt = et(Ze, 9, 1)
          , en = et(Nt, 5, 1)
          , li = function(ae) {
            for (var y = ae[0], b = 1; b < ae.length; ++b)
                ae[b] > y && (y = ae[b]);
            return y
        }
          , di = function(ae, y, b) {
            var E = y / 8 | 0;
            return (ae[E] | ae[E + 1] << 8) >> (y & 7) & b
        }
          , xi = function(ae, y) {
            var b = y / 8 | 0;
            return (ae[b] | ae[b + 1] << 8 | ae[b + 2] << 16) >> (y & 7)
        }
          , zt = function(ae) {
            return (ae / 8 | 0) + (ae & 7 && 1)
        }
          , Sn = function(ae, y, b) {
            (y == null || y < 0) && (y = 0),
            (b == null || b > ae.length) && (b = ae.length);
            var E = new (ae instanceof R ? R : ae instanceof ne ? ne : U)(b - y);
            return E.set(ae.subarray(y, b)),
            E
        }
          , rn = function(ae, y, b) {
            var E = ae.length;
            if (!E || b && !b.l && E < 5)
                return y || new U(0);
            var T = !y || b
              , L = !b || b.i;
            b || (b = {}),
            y || (y = new U(E * 3));
            var F = function(wi) {
                var Mr = y.length;
                if (wi > Mr) {
                    var yr = new U(Math.max(Mr * 2, wi));
                    yr.set(y),
                    y = yr
                }
            }
              , j = b.f || 0
              , W = b.p || 0
              , re = b.b || 0
              , fe = b.l
              , te = b.d
              , Te = b.m
              , Ge = b.n
              , St = E * 8;
            do {
                if (!fe) {
                    b.f = j = di(ae, W, 1);
                    var kt = di(ae, W + 1, 3);
                    if (W += 3,
                    kt)
                        if (kt == 1)
                            fe = Bt,
                            te = en,
                            Te = 9,
                            Ge = 5;
                        else if (kt == 2) {
                            var Xe = di(ae, W, 31) + 257
                              , ut = di(ae, W + 10, 15) + 4
                              , dn = Xe + di(ae, W + 5, 31) + 1;
                            W += 14;
                            for (var qt = new U(dn), ln = new U(19), Tn = 0; Tn < ut; ++Tn)
                                ln[Se[Tn]] = di(ae, W + Tn * 3, 7);
                            W += ut * 3;
                            for (var fn = li(ln), Hn = (1 << fn) - 1, En = et(ln, fn, 1), Tn = 0; Tn < dn; ) {
                                var Ei = En[di(ae, W, Hn)];
                                W += Ei & 15;
                                var Vt = Ei >>> 4;
                                if (Vt < 16)
                                    qt[Tn++] = Vt;
                                else {
                                    var ar = 0
                                      , fr = 0;
                                    for (Vt == 16 ? (fr = 3 + di(ae, W, 3),
                                    W += 2,
                                    ar = qt[Tn - 1]) : Vt == 17 ? (fr = 3 + di(ae, W, 7),
                                    W += 3) : Vt == 18 && (fr = 11 + di(ae, W, 127),
                                    W += 7); fr--; )
                                        qt[Tn++] = ar
                                }
                            }
                            var lr = qt.subarray(0, Xe)
                              , is = qt.subarray(Xe);
                            Te = li(lr),
                            Ge = li(is),
                            fe = et(lr, Te, 1),
                            te = et(is, Ge, 1)
                        } else
                            throw "invalid block type";
                    else {
                        var Vt = zt(W) + 4
                          , gt = ae[Vt - 4] | ae[Vt - 3] << 8
                          , xt = Vt + gt;
                        if (xt > E) {
                            if (L)
                                throw "unexpected EOF";
                            break
                        }
                        T && F(re + gt),
                        y.set(ae.subarray(Vt, xt), re),
                        b.b = re += gt,
                        b.p = W = xt * 8;
                        continue
                    }
                    if (W > St) {
                        if (L)
                            throw "unexpected EOF";
                        break
                    }
                }
                T && F(re + 131072);
                for (var Tr = (1 << Te) - 1, Er = (1 << Ge) - 1, Kr = W; ; Kr = W) {
                    var ar = fe[xi(ae, W) & Tr]
                      , Vi = ar >>> 4;
                    if (W += ar & 15,
                    W > St) {
                        if (L)
                            throw "unexpected EOF";
                        break
                    }
                    if (!ar)
                        throw "invalid length/literal";
                    if (Vi < 256)
                        y[re++] = Vi;
                    else if (Vi == 256) {
                        Kr = W,
                        fe = null;
                        break
                    } else {
                        var me = Vi - 254;
                        if (Vi > 264) {
                            var Tn = Vi - 257
                              , _r = ce[Tn];
                            me = di(ae, W, (1 << _r) - 1) + N[Tn],
                            W += _r
                        }
                        var Qo = te[xi(ae, W) & Er]
                          , Ji = Qo >>> 4;
                        if (!Qo)
                            throw "invalid distance";
                        W += Qo & 15;
                        var is = Pe[Ji];
                        if (Ji > 3) {
                            var _r = xe[Ji];
                            is += xi(ae, W) & (1 << _r) - 1,
                            W += _r
                        }
                        if (W > St) {
                            if (L)
                                throw "unexpected EOF";
                            break
                        }
                        T && F(re + 131072);
                        for (var xa = re + me; re < xa; re += 4)
                            y[re] = y[re - is],
                            y[re + 1] = y[re + 1 - is],
                            y[re + 2] = y[re + 2 - is],
                            y[re + 3] = y[re + 3 - is];
                        re = xa
                    }
                }
                b.l = fe,
                b.p = Kr,
                b.b = re,
                fe && (j = 1,
                b.m = Te,
                b.d = te,
                b.n = Ge)
            } while (!j);
            return re == y.length ? y : Sn(y, 0, re)
        }
          , Ft = new U(0)
          , jt = function(ae) {
            if ((ae[0] & 15) != 8 || ae[0] >>> 4 > 7 || (ae[0] << 8 | ae[1]) % 31)
                throw "invalid zlib data";
            if (ae[1] & 32)
                throw "invalid zlib data: preset dictionaries not supported"
        };
        function Xt(ae, y) {
            return rn((jt(ae),
            ae.subarray(2, -4)), y)
        }
        var Rt = typeof TextDecoder < "u" && new TextDecoder
          , Wn = 0;
        try {
            Rt.decode(Ft, {
                stream: !0
            }),
            Wn = 1
        } catch {}
        class He extends m.yxD {
            constructor(y) {
                super(y),
                this.type = m.cLu
            }
            parse(y) {
                const fn = Math.pow(2.7182818, 2.2);
                function Hn(Y, le) {
                    let Ee = 0;
                    for (let at = 0; at < 65536; ++at)
                        (at == 0 || Y[at >> 3] & 1 << (at & 7)) && (le[Ee++] = at);
                    const Ve = Ee - 1;
                    for (; Ee < 65536; )
                        le[Ee++] = 0;
                    return Ve
                }
                function En(Y) {
                    for (let le = 0; le < 16384; le++)
                        Y[le] = {},
                        Y[le].len = 0,
                        Y[le].lit = 0,
                        Y[le].p = null
                }
                const Ei = {
                    l: 0,
                    c: 0,
                    lc: 0
                };
                function ar(Y, le, Ee, Ve, at) {
                    for (; Ee < Y; )
                        le = le << 8 | Bc(Ve, at),
                        Ee += 8;
                    Ee -= Y,
                    Ei.l = le >> Ee & (1 << Y) - 1,
                    Ei.c = le,
                    Ei.lc = Ee
                }
                const fr = new Array(59);
                function lr(Y) {
                    for (let Ee = 0; Ee <= 58; ++Ee)
                        fr[Ee] = 0;
                    for (let Ee = 0; Ee < 65537; ++Ee)
                        fr[Y[Ee]] += 1;
                    let le = 0;
                    for (let Ee = 58; Ee > 0; --Ee) {
                        const Ve = le + fr[Ee] >> 1;
                        fr[Ee] = le,
                        le = Ve
                    }
                    for (let Ee = 0; Ee < 65537; ++Ee) {
                        const Ve = Y[Ee];
                        Ve > 0 && (Y[Ee] = Ve | fr[Ve]++ << 6)
                    }
                }
                function is(Y, le, Ee, Ve, at, Qe) {
                    const Et = le;
                    let Ut = 0
                      , Yt = 0;
                    for (; Ve <= at; Ve++) {
                        if (Et.value - le.value > Ee)
                            return !1;
                        ar(6, Ut, Yt, Y, Et);
                        const At = Ei.l;
                        if (Ut = Ei.c,
                        Yt = Ei.lc,
                        Qe[Ve] = At,
                        At == 63) {
                            if (Et.value - le.value > Ee)
                                throw new Error("Something wrong with hufUnpackEncTable");
                            ar(8, Ut, Yt, Y, Et);
                            let bt = Ei.l + 6;
                            if (Ut = Ei.c,
                            Yt = Ei.lc,
                            Ve + bt > at + 1)
                                throw new Error("Something wrong with hufUnpackEncTable");
                            for (; bt--; )
                                Qe[Ve++] = 0;
                            Ve--
                        } else if (At >= 59) {
                            let bt = At - 59 + 2;
                            if (Ve + bt > at + 1)
                                throw new Error("Something wrong with hufUnpackEncTable");
                            for (; bt--; )
                                Qe[Ve++] = 0;
                            Ve--
                        }
                    }
                    lr(Qe)
                }
                function Tr(Y) {
                    return Y & 63
                }
                function Er(Y) {
                    return Y >> 6
                }
                function Kr(Y, le, Ee, Ve) {
                    for (; le <= Ee; le++) {
                        const at = Er(Y[le])
                          , Qe = Tr(Y[le]);
                        if (at >> Qe)
                            throw new Error("Invalid table entry");
                        if (Qe > 14) {
                            const Et = Ve[at >> Qe - 14];
                            if (Et.len)
                                throw new Error("Invalid table entry");
                            if (Et.lit++,
                            Et.p) {
                                const Ut = Et.p;
                                Et.p = new Array(Et.lit);
                                for (let Yt = 0; Yt < Et.lit - 1; ++Yt)
                                    Et.p[Yt] = Ut[Yt]
                            } else
                                Et.p = new Array(1);
                            Et.p[Et.lit - 1] = le
                        } else if (Qe) {
                            let Et = 0;
                            for (let Ut = 1 << 14 - Qe; Ut > 0; Ut--) {
                                const Yt = Ve[(at << 14 - Qe) + Et];
                                if (Yt.len || Yt.p)
                                    throw new Error("Invalid table entry");
                                Yt.len = Qe,
                                Yt.lit = le,
                                Et++
                            }
                        }
                    }
                    return !0
                }
                const Vi = {
                    c: 0,
                    lc: 0
                };
                function me(Y, le, Ee, Ve) {
                    Y = Y << 8 | Bc(Ee, Ve),
                    le += 8,
                    Vi.c = Y,
                    Vi.lc = le
                }
                const _r = {
                    c: 0,
                    lc: 0
                };
                function Qo(Y, le, Ee, Ve, at, Qe, Et, Ut, Yt) {
                    if (Y == le) {
                        Ve < 8 && (me(Ee, Ve, at, Qe),
                        Ee = Vi.c,
                        Ve = Vi.lc),
                        Ve -= 8;
                        let At = Ee >> Ve;
                        if (At = new Uint8Array([At])[0],
                        Ut.value + At > Yt)
                            return !1;
                        const bt = Et[Ut.value - 1];
                        for (; At-- > 0; )
                            Et[Ut.value++] = bt
                    } else if (Ut.value < Yt)
                        Et[Ut.value++] = Y;
                    else
                        return !1;
                    _r.c = Ee,
                    _r.lc = Ve
                }
                function Ji(Y) {
                    return Y & 65535
                }
                function xa(Y) {
                    const le = Ji(Y);
                    return le > 32767 ? le - 65536 : le
                }
                const wi = {
                    a: 0,
                    b: 0
                };
                function Mr(Y, le) {
                    const Ee = xa(Y)
                      , at = xa(le)
                      , Qe = Ee + (at & 1) + (at >> 1)
                      , Et = Qe
                      , Ut = Qe - at;
                    wi.a = Et,
                    wi.b = Ut
                }
                function yr(Y, le) {
                    const Ee = Ji(Y)
                      , Ve = Ji(le)
                      , at = Ee - (Ve >> 1) & 65535
                      , Qe = Ve + at - 32768 & 65535;
                    wi.a = Qe,
                    wi.b = at
                }
                function Wi(Y, le, Ee, Ve, at, Qe, Et) {
                    const Ut = Et < 16384
                      , Yt = Ee > at ? at : Ee;
                    let At = 1, bt, pn;
                    for (; At <= Yt; )
                        At <<= 1;
                    for (At >>= 1,
                    bt = At,
                    At >>= 1; At >= 1; ) {
                        pn = 0;
                        const yn = pn + Qe * (at - bt)
                          , Nn = Qe * At
                          , ci = Qe * bt
                          , Dn = Ve * At
                          , $t = Ve * bt;
                        let mn, ki, pr, to;
                        for (; pn <= yn; pn += ci) {
                            let ir = pn;
                            const Bi = pn + Ve * (Ee - bt);
                            for (; ir <= Bi; ir += $t) {
                                const Hr = ir + Dn
                                  , Zr = ir + Nn
                                  , or = Zr + Dn;
                                Ut ? (Mr(Y[ir + le], Y[Zr + le]),
                                mn = wi.a,
                                pr = wi.b,
                                Mr(Y[Hr + le], Y[or + le]),
                                ki = wi.a,
                                to = wi.b,
                                Mr(mn, ki),
                                Y[ir + le] = wi.a,
                                Y[Hr + le] = wi.b,
                                Mr(pr, to),
                                Y[Zr + le] = wi.a,
                                Y[or + le] = wi.b) : (yr(Y[ir + le], Y[Zr + le]),
                                mn = wi.a,
                                pr = wi.b,
                                yr(Y[Hr + le], Y[or + le]),
                                ki = wi.a,
                                to = wi.b,
                                yr(mn, ki),
                                Y[ir + le] = wi.a,
                                Y[Hr + le] = wi.b,
                                yr(pr, to),
                                Y[Zr + le] = wi.a,
                                Y[or + le] = wi.b)
                            }
                            if (Ee & At) {
                                const Hr = ir + Nn;
                                Ut ? Mr(Y[ir + le], Y[Hr + le]) : yr(Y[ir + le], Y[Hr + le]),
                                mn = wi.a,
                                Y[Hr + le] = wi.b,
                                Y[ir + le] = mn
                            }
                        }
                        if (at & At) {
                            let ir = pn;
                            const Bi = pn + Ve * (Ee - bt);
                            for (; ir <= Bi; ir += $t) {
                                const Hr = ir + Dn;
                                Ut ? Mr(Y[ir + le], Y[Hr + le]) : yr(Y[ir + le], Y[Hr + le]),
                                mn = wi.a,
                                Y[Hr + le] = wi.b,
                                Y[ir + le] = mn
                            }
                        }
                        bt = At,
                        At >>= 1
                    }
                    return pn
                }
                function Ko(Y, le, Ee, Ve, at, Qe, Et, Ut, Yt) {
                    let At = 0
                      , bt = 0;
                    const pn = Et
                      , yn = Math.trunc(Ve.value + (at + 7) / 8);
                    for (; Ve.value < yn; )
                        for (me(At, bt, Ee, Ve),
                        At = Vi.c,
                        bt = Vi.lc; bt >= 14; ) {
                            const ci = At >> bt - 14 & 16383
                              , Dn = le[ci];
                            if (Dn.len)
                                bt -= Dn.len,
                                Qo(Dn.lit, Qe, At, bt, Ee, Ve, Ut, Yt, pn),
                                At = _r.c,
                                bt = _r.lc;
                            else {
                                if (!Dn.p)
                                    throw new Error("hufDecode issues");
                                let $t;
                                for ($t = 0; $t < Dn.lit; $t++) {
                                    const mn = Tr(Y[Dn.p[$t]]);
                                    for (; bt < mn && Ve.value < yn; )
                                        me(At, bt, Ee, Ve),
                                        At = Vi.c,
                                        bt = Vi.lc;
                                    if (bt >= mn && Er(Y[Dn.p[$t]]) == (At >> bt - mn & (1 << mn) - 1)) {
                                        bt -= mn,
                                        Qo(Dn.p[$t], Qe, At, bt, Ee, Ve, Ut, Yt, pn),
                                        At = _r.c,
                                        bt = _r.lc;
                                        break
                                    }
                                }
                                if ($t == Dn.lit)
                                    throw new Error("hufDecode issues")
                            }
                        }
                    const Nn = 8 - at & 7;
                    for (At >>= Nn,
                    bt -= Nn; bt > 0; ) {
                        const ci = le[At << 14 - bt & 16383];
                        if (ci.len)
                            bt -= ci.len,
                            Qo(ci.lit, Qe, At, bt, Ee, Ve, Ut, Yt, pn),
                            At = _r.c,
                            bt = _r.lc;
                        else
                            throw new Error("hufDecode issues")
                    }
                    return !0
                }
                function ve(Y, le, Ee, Ve, at, Qe) {
                    const Et = {
                        value: 0
                    }
                      , Ut = Ee.value
                      , Yt = vi(le, Ee)
                      , At = vi(le, Ee);
                    Ee.value += 4;
                    const bt = vi(le, Ee);
                    if (Ee.value += 4,
                    Yt < 0 || Yt >= 65537 || At < 0 || At >= 65537)
                        throw new Error("Something wrong with HUF_ENCSIZE");
                    const pn = new Array(65537)
                      , yn = new Array(16384);
                    En(yn);
                    const Nn = Ve - (Ee.value - Ut);
                    if (is(Y, Ee, Nn, Yt, At, pn),
                    bt > 8 * (Ve - (Ee.value - Ut)))
                        throw new Error("Something wrong with hufUncompress");
                    Kr(pn, Yt, At, yn),
                    Ko(pn, yn, Y, Ee, bt, At, Qe, at, Et)
                }
                function oe(Y, le, Ee) {
                    for (let Ve = 0; Ve < Ee; ++Ve)
                        le[Ve] = Y[le[Ve]]
                }
                function G(Y) {
                    for (let le = 1; le < Y.length; le++) {
                        const Ee = Y[le - 1] + Y[le] - 128;
                        Y[le] = Ee
                    }
                }
                function ee(Y, le) {
                    let Ee = 0
                      , Ve = Math.floor((Y.length + 1) / 2)
                      , at = 0;
                    const Qe = Y.length - 1;
                    for (; !(at > Qe || (le[at++] = Y[Ee++],
                    at > Qe)); )
                        le[at++] = Y[Ve++]
                }
                function ke(Y) {
                    let le = Y.byteLength;
                    const Ee = new Array;
                    let Ve = 0;
                    const at = new DataView(Y);
                    for (; le > 0; ) {
                        const Qe = at.getInt8(Ve++);
                        if (Qe < 0) {
                            const Et = -Qe;
                            le -= Et + 1;
                            for (let Ut = 0; Ut < Et; Ut++)
                                Ee.push(at.getUint8(Ve++))
                        } else {
                            const Et = Qe;
                            le -= 2;
                            const Ut = at.getUint8(Ve++);
                            for (let Yt = 0; Yt < Et + 1; Yt++)
                                Ee.push(Ut)
                        }
                    }
                    return Ee
                }
                function Ne(Y, le, Ee, Ve, at, Qe) {
                    let Et = new DataView(Qe.buffer);
                    const Ut = Ee[Y.idx[0]].width
                      , Yt = Ee[Y.idx[0]].height
                      , At = 3
                      , bt = Math.floor(Ut / 8)
                      , pn = Math.ceil(Ut / 8)
                      , yn = Math.ceil(Yt / 8)
                      , Nn = Ut - (pn - 1) * 8
                      , ci = Yt - (yn - 1) * 8
                      , Dn = {
                        value: 0
                    }
                      , $t = new Array(At)
                      , mn = new Array(At)
                      , ki = new Array(At)
                      , pr = new Array(At)
                      , to = new Array(At);
                    for (let Bi = 0; Bi < At; ++Bi)
                        to[Bi] = le[Y.idx[Bi]],
                        $t[Bi] = Bi < 1 ? 0 : $t[Bi - 1] + pn * yn,
                        mn[Bi] = new Float32Array(64),
                        ki[Bi] = new Uint16Array(64),
                        pr[Bi] = new Uint16Array(pn * 64);
                    for (let Bi = 0; Bi < yn; ++Bi) {
                        let Hr = 8;
                        Bi == yn - 1 && (Hr = ci);
                        let Zr = 8;
                        for (let Ri = 0; Ri < pn; ++Ri) {
                            Ri == pn - 1 && (Zr = Nn);
                            for (let er = 0; er < At; ++er)
                                ki[er].fill(0),
                                ki[er][0] = at[$t[er]++],
                                $e(Dn, Ve, ki[er]),
                                vt(ki[er], mn[er]),
                                Lt(mn[er]);
                            Pn(mn);
                            for (let er = 0; er < At; ++er)
                                un(mn[er], pr[er], Ri * 64)
                        }
                        let or = 0;
                        for (let Ri = 0; Ri < At; ++Ri) {
                            const er = Ee[Y.idx[Ri]].type;
                            for (let Hs = 8 * Bi; Hs < 8 * Bi + Hr; ++Hs) {
                                or = to[Ri][Hs];
                                for (let Zo = 0; Zo < bt; ++Zo) {
                                    const Ts = Zo * 64 + (Hs & 7) * 8;
                                    Et.setUint16(or + 0 * 2 * er, pr[Ri][Ts + 0], !0),
                                    Et.setUint16(or + 1 * 2 * er, pr[Ri][Ts + 1], !0),
                                    Et.setUint16(or + 2 * 2 * er, pr[Ri][Ts + 2], !0),
                                    Et.setUint16(or + 3 * 2 * er, pr[Ri][Ts + 3], !0),
                                    Et.setUint16(or + 4 * 2 * er, pr[Ri][Ts + 4], !0),
                                    Et.setUint16(or + 5 * 2 * er, pr[Ri][Ts + 5], !0),
                                    Et.setUint16(or + 6 * 2 * er, pr[Ri][Ts + 6], !0),
                                    Et.setUint16(or + 7 * 2 * er, pr[Ri][Ts + 7], !0),
                                    or += 8 * 2 * er
                                }
                            }
                            if (bt != pn)
                                for (let Hs = 8 * Bi; Hs < 8 * Bi + Hr; ++Hs) {
                                    const Zo = to[Ri][Hs] + 8 * bt * 2 * er
                                      , Ts = bt * 64 + (Hs & 7) * 8;
                                    for (let Do = 0; Do < Zr; ++Do)
                                        Et.setUint16(Zo + Do * 2 * er, pr[Ri][Ts + Do], !0)
                                }
                        }
                    }
                    const ir = new Uint16Array(Ut);
                    Et = new DataView(Qe.buffer);
                    for (let Bi = 0; Bi < At; ++Bi) {
                        Ee[Y.idx[Bi]].decoded = !0;
                        const Hr = Ee[Y.idx[Bi]].type;
                        if (Ee[Bi].type == 2)
                            for (let Zr = 0; Zr < Yt; ++Zr) {
                                const or = to[Bi][Zr];
                                for (let Ri = 0; Ri < Ut; ++Ri)
                                    ir[Ri] = Et.getUint16(or + Ri * 2 * Hr, !0);
                                for (let Ri = 0; Ri < Ut; ++Ri)
                                    Et.setFloat32(or + Ri * 2 * Hr, hn(ir[Ri]), !0)
                            }
                    }
                }
                function $e(Y, le, Ee) {
                    let Ve, at = 1;
                    for (; at < 64; )
                        Ve = le[Y.value],
                        Ve == 65280 ? at = 64 : Ve >> 8 == 255 ? at += Ve & 255 : (Ee[at] = Ve,
                        at++),
                        Y.value++
                }
                function vt(Y, le) {
                    le[0] = hn(Y[0]),
                    le[1] = hn(Y[1]),
                    le[2] = hn(Y[5]),
                    le[3] = hn(Y[6]),
                    le[4] = hn(Y[14]),
                    le[5] = hn(Y[15]),
                    le[6] = hn(Y[27]),
                    le[7] = hn(Y[28]),
                    le[8] = hn(Y[2]),
                    le[9] = hn(Y[4]),
                    le[10] = hn(Y[7]),
                    le[11] = hn(Y[13]),
                    le[12] = hn(Y[16]),
                    le[13] = hn(Y[26]),
                    le[14] = hn(Y[29]),
                    le[15] = hn(Y[42]),
                    le[16] = hn(Y[3]),
                    le[17] = hn(Y[8]),
                    le[18] = hn(Y[12]),
                    le[19] = hn(Y[17]),
                    le[20] = hn(Y[25]),
                    le[21] = hn(Y[30]),
                    le[22] = hn(Y[41]),
                    le[23] = hn(Y[43]),
                    le[24] = hn(Y[9]),
                    le[25] = hn(Y[11]),
                    le[26] = hn(Y[18]),
                    le[27] = hn(Y[24]),
                    le[28] = hn(Y[31]),
                    le[29] = hn(Y[40]),
                    le[30] = hn(Y[44]),
                    le[31] = hn(Y[53]),
                    le[32] = hn(Y[10]),
                    le[33] = hn(Y[19]),
                    le[34] = hn(Y[23]),
                    le[35] = hn(Y[32]),
                    le[36] = hn(Y[39]),
                    le[37] = hn(Y[45]),
                    le[38] = hn(Y[52]),
                    le[39] = hn(Y[54]),
                    le[40] = hn(Y[20]),
                    le[41] = hn(Y[22]),
                    le[42] = hn(Y[33]),
                    le[43] = hn(Y[38]),
                    le[44] = hn(Y[46]),
                    le[45] = hn(Y[51]),
                    le[46] = hn(Y[55]),
                    le[47] = hn(Y[60]),
                    le[48] = hn(Y[21]),
                    le[49] = hn(Y[34]),
                    le[50] = hn(Y[37]),
                    le[51] = hn(Y[47]),
                    le[52] = hn(Y[50]),
                    le[53] = hn(Y[56]),
                    le[54] = hn(Y[59]),
                    le[55] = hn(Y[61]),
                    le[56] = hn(Y[35]),
                    le[57] = hn(Y[36]),
                    le[58] = hn(Y[48]),
                    le[59] = hn(Y[49]),
                    le[60] = hn(Y[57]),
                    le[61] = hn(Y[58]),
                    le[62] = hn(Y[62]),
                    le[63] = hn(Y[63])
                }
                function Lt(Y) {
                    const le = .5 * Math.cos(.7853975)
                      , Ee = .5 * Math.cos(3.14159 / 16)
                      , Ve = .5 * Math.cos(3.14159 / 8)
                      , at = .5 * Math.cos(3 * 3.14159 / 16)
                      , Qe = .5 * Math.cos(5 * 3.14159 / 16)
                      , Et = .5 * Math.cos(3 * 3.14159 / 8)
                      , Ut = .5 * Math.cos(7 * 3.14159 / 16)
                      , Yt = new Array(4)
                      , At = new Array(4)
                      , bt = new Array(4)
                      , pn = new Array(4);
                    for (let yn = 0; yn < 8; ++yn) {
                        const Nn = yn * 8;
                        Yt[0] = Ve * Y[Nn + 2],
                        Yt[1] = Et * Y[Nn + 2],
                        Yt[2] = Ve * Y[Nn + 6],
                        Yt[3] = Et * Y[Nn + 6],
                        At[0] = Ee * Y[Nn + 1] + at * Y[Nn + 3] + Qe * Y[Nn + 5] + Ut * Y[Nn + 7],
                        At[1] = at * Y[Nn + 1] - Ut * Y[Nn + 3] - Ee * Y[Nn + 5] - Qe * Y[Nn + 7],
                        At[2] = Qe * Y[Nn + 1] - Ee * Y[Nn + 3] + Ut * Y[Nn + 5] + at * Y[Nn + 7],
                        At[3] = Ut * Y[Nn + 1] - Qe * Y[Nn + 3] + at * Y[Nn + 5] - Ee * Y[Nn + 7],
                        bt[0] = le * (Y[Nn + 0] + Y[Nn + 4]),
                        bt[3] = le * (Y[Nn + 0] - Y[Nn + 4]),
                        bt[1] = Yt[0] + Yt[3],
                        bt[2] = Yt[1] - Yt[2],
                        pn[0] = bt[0] + bt[1],
                        pn[1] = bt[3] + bt[2],
                        pn[2] = bt[3] - bt[2],
                        pn[3] = bt[0] - bt[1],
                        Y[Nn + 0] = pn[0] + At[0],
                        Y[Nn + 1] = pn[1] + At[1],
                        Y[Nn + 2] = pn[2] + At[2],
                        Y[Nn + 3] = pn[3] + At[3],
                        Y[Nn + 4] = pn[3] - At[3],
                        Y[Nn + 5] = pn[2] - At[2],
                        Y[Nn + 6] = pn[1] - At[1],
                        Y[Nn + 7] = pn[0] - At[0]
                    }
                    for (let yn = 0; yn < 8; ++yn)
                        Yt[0] = Ve * Y[16 + yn],
                        Yt[1] = Et * Y[16 + yn],
                        Yt[2] = Ve * Y[48 + yn],
                        Yt[3] = Et * Y[48 + yn],
                        At[0] = Ee * Y[8 + yn] + at * Y[24 + yn] + Qe * Y[40 + yn] + Ut * Y[56 + yn],
                        At[1] = at * Y[8 + yn] - Ut * Y[24 + yn] - Ee * Y[40 + yn] - Qe * Y[56 + yn],
                        At[2] = Qe * Y[8 + yn] - Ee * Y[24 + yn] + Ut * Y[40 + yn] + at * Y[56 + yn],
                        At[3] = Ut * Y[8 + yn] - Qe * Y[24 + yn] + at * Y[40 + yn] - Ee * Y[56 + yn],
                        bt[0] = le * (Y[yn] + Y[32 + yn]),
                        bt[3] = le * (Y[yn] - Y[32 + yn]),
                        bt[1] = Yt[0] + Yt[3],
                        bt[2] = Yt[1] - Yt[2],
                        pn[0] = bt[0] + bt[1],
                        pn[1] = bt[3] + bt[2],
                        pn[2] = bt[3] - bt[2],
                        pn[3] = bt[0] - bt[1],
                        Y[0 + yn] = pn[0] + At[0],
                        Y[8 + yn] = pn[1] + At[1],
                        Y[16 + yn] = pn[2] + At[2],
                        Y[24 + yn] = pn[3] + At[3],
                        Y[32 + yn] = pn[3] - At[3],
                        Y[40 + yn] = pn[2] - At[2],
                        Y[48 + yn] = pn[1] - At[1],
                        Y[56 + yn] = pn[0] - At[0]
                }
                function Pn(Y) {
                    for (let le = 0; le < 64; ++le) {
                        const Ee = Y[0][le]
                          , Ve = Y[1][le]
                          , at = Y[2][le];
                        Y[0][le] = Ee + 1.5747 * at,
                        Y[1][le] = Ee - .1873 * Ve - .4682 * at,
                        Y[2][le] = Ee + 1.8556 * Ve
                    }
                }
                function un(Y, le, Ee) {
                    for (let Ve = 0; Ve < 64; ++Ve)
                        le[Ee + Ve] = m.A5E.toHalfFloat(vn(Y[Ve]))
                }
                function vn(Y) {
                    return Y <= 1 ? Math.sign(Y) * Math.pow(Math.abs(Y), 2.2) : Math.sign(Y) * Math.pow(fn, Math.abs(Y) - 1)
                }
                function _n(Y) {
                    return new DataView(Y.array.buffer,Y.offset.value,Y.size)
                }
                function qn(Y) {
                    const le = Y.viewer.buffer.slice(Y.offset.value, Y.offset.value + Y.size)
                      , Ee = new Uint8Array(ke(le))
                      , Ve = new Uint8Array(Ee.length);
                    return G(Ee),
                    ee(Ee, Ve),
                    new DataView(Ve.buffer)
                }
                function ii(Y) {
                    const le = Y.array.slice(Y.offset.value, Y.offset.value + Y.size)
                      , Ee = Xt(le)
                      , Ve = new Uint8Array(Ee.length);
                    return G(Ee),
                    ee(Ee, Ve),
                    new DataView(Ve.buffer)
                }
                function Mi(Y) {
                    const le = Y.viewer
                      , Ee = {
                        value: Y.offset.value
                    }
                      , Ve = new Uint16Array(Y.width * Y.scanlineBlockSize * (Y.channels * Y.type))
                      , at = new Uint8Array(8192);
                    let Qe = 0;
                    const Et = new Array(Y.channels);
                    for (let ci = 0; ci < Y.channels; ci++)
                        Et[ci] = {},
                        Et[ci].start = Qe,
                        Et[ci].end = Et[ci].start,
                        Et[ci].nx = Y.width,
                        Et[ci].ny = Y.lines,
                        Et[ci].size = Y.type,
                        Qe += Et[ci].nx * Et[ci].ny * Et[ci].size;
                    const Ut = Fc(le, Ee)
                      , Yt = Fc(le, Ee);
                    if (Yt >= 8192)
                        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
                    if (Ut <= Yt)
                        for (let ci = 0; ci < Yt - Ut + 1; ci++)
                            at[ci + Ut] = Ro(le, Ee);
                    const At = new Uint16Array(65536)
                      , bt = Hn(at, At)
                      , pn = vi(le, Ee);
                    ve(Y.array, le, Ee, pn, Ve, Qe);
                    for (let ci = 0; ci < Y.channels; ++ci) {
                        const Dn = Et[ci];
                        for (let $t = 0; $t < Et[ci].size; ++$t)
                            Wi(Ve, Dn.start + $t, Dn.nx, Dn.size, Dn.ny, Dn.nx * Dn.size, bt)
                    }
                    oe(At, Ve, Qe);
                    let yn = 0;
                    const Nn = new Uint8Array(Ve.buffer.byteLength);
                    for (let ci = 0; ci < Y.lines; ci++)
                        for (let Dn = 0; Dn < Y.channels; Dn++) {
                            const $t = Et[Dn]
                              , mn = $t.nx * $t.size
                              , ki = new Uint8Array(Ve.buffer,$t.end * 2,mn * 2);
                            Nn.set(ki, yn),
                            yn += mn * 2,
                            $t.end += mn
                        }
                    return new DataView(Nn.buffer)
                }
                function Jn(Y) {
                    const le = Y.array.slice(Y.offset.value, Y.offset.value + Y.size)
                      , Ee = Xt(le)
                      , Ve = Y.lines * Y.channels * Y.width
                      , at = Y.type == 1 ? new Uint16Array(Ve) : new Uint32Array(Ve);
                    let Qe = 0
                      , Et = 0;
                    const Ut = new Array(4);
                    for (let Yt = 0; Yt < Y.lines; Yt++)
                        for (let At = 0; At < Y.channels; At++) {
                            let bt = 0;
                            switch (Y.type) {
                            case 1:
                                Ut[0] = Qe,
                                Ut[1] = Ut[0] + Y.width,
                                Qe = Ut[1] + Y.width;
                                for (let pn = 0; pn < Y.width; ++pn) {
                                    const yn = Ee[Ut[0]++] << 8 | Ee[Ut[1]++];
                                    bt += yn,
                                    at[Et] = bt,
                                    Et++
                                }
                                break;
                            case 2:
                                Ut[0] = Qe,
                                Ut[1] = Ut[0] + Y.width,
                                Ut[2] = Ut[1] + Y.width,
                                Qe = Ut[2] + Y.width;
                                for (let pn = 0; pn < Y.width; ++pn) {
                                    const yn = Ee[Ut[0]++] << 24 | Ee[Ut[1]++] << 16 | Ee[Ut[2]++] << 8;
                                    bt += yn,
                                    at[Et] = bt,
                                    Et++
                                }
                                break
                            }
                        }
                    return new DataView(at.buffer)
                }
                function cr(Y) {
                    const le = Y.viewer
                      , Ee = {
                        value: Y.offset.value
                    }
                      , Ve = new Uint8Array(Y.width * Y.lines * (Y.channels * Y.type * 2))
                      , at = {
                        version: Ss(le, Ee),
                        unknownUncompressedSize: Ss(le, Ee),
                        unknownCompressedSize: Ss(le, Ee),
                        acCompressedSize: Ss(le, Ee),
                        dcCompressedSize: Ss(le, Ee),
                        rleCompressedSize: Ss(le, Ee),
                        rleUncompressedSize: Ss(le, Ee),
                        rleRawSize: Ss(le, Ee),
                        totalAcUncompressedCount: Ss(le, Ee),
                        totalDcUncompressedCount: Ss(le, Ee),
                        acCompression: Ss(le, Ee)
                    };
                    if (at.version < 2)
                        throw new Error("EXRLoader.parse: " + gl.compression + " version " + at.version + " is unsupported");
                    const Qe = new Array;
                    let Et = Fc(le, Ee) - 2;
                    for (; Et > 0; ) {
                        const Dn = ur(le.buffer, Ee)
                          , $t = Ro(le, Ee)
                          , mn = $t >> 2 & 3
                          , ki = ($t >> 4) - 1
                          , pr = new Int8Array([ki])[0]
                          , to = Ro(le, Ee);
                        Qe.push({
                            name: Dn,
                            index: pr,
                            type: to,
                            compression: mn
                        }),
                        Et -= Dn.length + 3
                    }
                    const Ut = gl.channels
                      , Yt = new Array(Y.channels);
                    for (let Dn = 0; Dn < Y.channels; ++Dn) {
                        const $t = Yt[Dn] = {}
                          , mn = Ut[Dn];
                        $t.name = mn.name,
                        $t.compression = 0,
                        $t.decoded = !1,
                        $t.type = mn.pixelType,
                        $t.pLinear = mn.pLinear,
                        $t.width = Y.width,
                        $t.height = Y.lines
                    }
                    const At = {
                        idx: new Array(3)
                    };
                    for (let Dn = 0; Dn < Y.channels; ++Dn) {
                        const $t = Yt[Dn];
                        for (let mn = 0; mn < Qe.length; ++mn) {
                            const ki = Qe[mn];
                            $t.name == ki.name && ($t.compression = ki.compression,
                            ki.index >= 0 && (At.idx[ki.index] = Dn),
                            $t.offset = Dn)
                        }
                    }
                    let bt, pn, yn;
                    if (at.acCompressedSize > 0)
                        switch (at.acCompression) {
                        case 0:
                            bt = new Uint16Array(at.totalAcUncompressedCount),
                            ve(Y.array, le, Ee, at.acCompressedSize, bt, at.totalAcUncompressedCount);
                            break;
                        case 1:
                            const Dn = Y.array.slice(Ee.value, Ee.value + at.totalAcUncompressedCount)
                              , $t = Xt(Dn);
                            bt = new Uint16Array($t.buffer),
                            Ee.value += at.totalAcUncompressedCount;
                            break
                        }
                    if (at.dcCompressedSize > 0) {
                        const Dn = {
                            array: Y.array,
                            offset: Ee,
                            size: at.dcCompressedSize
                        };
                        pn = new Uint16Array(ii(Dn).buffer),
                        Ee.value += at.dcCompressedSize
                    }
                    if (at.rleRawSize > 0) {
                        const Dn = Y.array.slice(Ee.value, Ee.value + at.rleCompressedSize)
                          , $t = Xt(Dn);
                        yn = ke($t.buffer),
                        Ee.value += at.rleCompressedSize
                    }
                    let Nn = 0;
                    const ci = new Array(Yt.length);
                    for (let Dn = 0; Dn < ci.length; ++Dn)
                        ci[Dn] = new Array;
                    for (let Dn = 0; Dn < Y.lines; ++Dn)
                        for (let $t = 0; $t < Yt.length; ++$t)
                            ci[$t].push(Nn),
                            Nn += Yt[$t].width * Y.type * 2;
                    Ne(At, ci, Yt, bt, pn, Ve);
                    for (let Dn = 0; Dn < Yt.length; ++Dn) {
                        const $t = Yt[Dn];
                        if (!$t.decoded)
                            switch ($t.compression) {
                            case 2:
                                let mn = 0
                                  , ki = 0;
                                for (let pr = 0; pr < Y.lines; ++pr) {
                                    let to = ci[Dn][mn];
                                    for (let ir = 0; ir < $t.width; ++ir) {
                                        for (let Bi = 0; Bi < 2 * $t.type; ++Bi)
                                            Ve[to++] = yn[ki + Bi * $t.width * $t.height];
                                        ki++
                                    }
                                    mn++
                                }
                                break;
                            case 1:
                            default:
                                throw new Error("EXRLoader.parse: unsupported channel compression")
                            }
                    }
                    return new DataView(Ve.buffer)
                }
                function ur(Y, le) {
                    const Ee = new Uint8Array(Y);
                    let Ve = 0;
                    for (; Ee[le.value + Ve] != 0; )
                        Ve += 1;
                    const at = new TextDecoder().decode(Ee.slice(le.value, le.value + Ve));
                    return le.value = le.value + Ve + 1,
                    at
                }
                function fi(Y, le, Ee) {
                    const Ve = new TextDecoder().decode(new Uint8Array(Y).slice(le.value, le.value + Ee));
                    return le.value = le.value + Ee,
                    Ve
                }
                function As(Y, le) {
                    const Ee = hr(Y, le)
                      , Ve = vi(Y, le);
                    return [Ee, Ve]
                }
                function kr(Y, le) {
                    const Ee = vi(Y, le)
                      , Ve = vi(Y, le);
                    return [Ee, Ve]
                }
                function hr(Y, le) {
                    const Ee = Y.getInt32(le.value, !0);
                    return le.value = le.value + 4,
                    Ee
                }
                function vi(Y, le) {
                    const Ee = Y.getUint32(le.value, !0);
                    return le.value = le.value + 4,
                    Ee
                }
                function Bc(Y, le) {
                    const Ee = Y[le.value];
                    return le.value = le.value + 1,
                    Ee
                }
                function Ro(Y, le) {
                    const Ee = Y.getUint8(le.value);
                    return le.value = le.value + 1,
                    Ee
                }
                const Ss = function(Y, le) {
                    let Ee;
                    return "getBigInt64"in DataView.prototype ? Ee = Number(Y.getBigInt64(le.value, !0)) : Ee = Y.getUint32(le.value + 4, !0) + Number(Y.getUint32(le.value, !0) << 32),
                    le.value += 8,
                    Ee
                };
                function xr(Y, le) {
                    const Ee = Y.getFloat32(le.value, !0);
                    return le.value += 4,
                    Ee
                }
                function ml(Y, le) {
                    return m.A5E.toHalfFloat(xr(Y, le))
                }
                function hn(Y) {
                    const le = (Y & 31744) >> 10
                      , Ee = Y & 1023;
                    return (Y >> 15 ? -1 : 1) * (le ? le === 31 ? Ee ? NaN : 1 / 0 : Math.pow(2, le - 15) * (1 + Ee / 1024) : 6103515625e-14 * (Ee / 1024))
                }
                function Fc(Y, le) {
                    const Ee = Y.getUint16(le.value, !0);
                    return le.value += 2,
                    Ee
                }
                function Dg(Y, le) {
                    return hn(Fc(Y, le))
                }
                function Lg(Y, le, Ee, Ve) {
                    const at = Ee.value
                      , Qe = [];
                    for (; Ee.value < at + Ve - 1; ) {
                        const Et = ur(le, Ee)
                          , Ut = hr(Y, Ee)
                          , Yt = Ro(Y, Ee);
                        Ee.value += 3;
                        const At = hr(Y, Ee)
                          , bt = hr(Y, Ee);
                        Qe.push({
                            name: Et,
                            pixelType: Ut,
                            pLinear: Yt,
                            xSampling: At,
                            ySampling: bt
                        })
                    }
                    return Ee.value += 1,
                    Qe
                }
                function Uf(Y, le) {
                    const Ee = xr(Y, le)
                      , Ve = xr(Y, le)
                      , at = xr(Y, le)
                      , Qe = xr(Y, le)
                      , Et = xr(Y, le)
                      , Ut = xr(Y, le)
                      , Yt = xr(Y, le)
                      , At = xr(Y, le);
                    return {
                        redX: Ee,
                        redY: Ve,
                        greenX: at,
                        greenY: Qe,
                        blueX: Et,
                        blueY: Ut,
                        whiteX: Yt,
                        whiteY: At
                    }
                }
                function Ig(Y, le) {
                    const Ee = ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"]
                      , Ve = Ro(Y, le);
                    return Ee[Ve]
                }
                function Og(Y, le) {
                    const Ee = vi(Y, le)
                      , Ve = vi(Y, le)
                      , at = vi(Y, le)
                      , Qe = vi(Y, le);
                    return {
                        xMin: Ee,
                        yMin: Ve,
                        xMax: at,
                        yMax: Qe
                    }
                }
                function zh(Y, le) {
                    const Ee = ["INCREASING_Y"]
                      , Ve = Ro(Y, le);
                    return Ee[Ve]
                }
                function Nf(Y, le) {
                    const Ee = xr(Y, le)
                      , Ve = xr(Y, le);
                    return [Ee, Ve]
                }
                function Bg(Y, le) {
                    const Ee = xr(Y, le)
                      , Ve = xr(Y, le)
                      , at = xr(Y, le);
                    return [Ee, Ve, at]
                }
                function Fg(Y, le, Ee, Ve, at) {
                    if (Ve === "string" || Ve === "stringvector" || Ve === "iccProfile")
                        return fi(le, Ee, at);
                    if (Ve === "chlist")
                        return Lg(Y, le, Ee, at);
                    if (Ve === "chromaticities")
                        return Uf(Y, Ee);
                    if (Ve === "compression")
                        return Ig(Y, Ee);
                    if (Ve === "box2i")
                        return Og(Y, Ee);
                    if (Ve === "lineOrder")
                        return zh(Y, Ee);
                    if (Ve === "float")
                        return xr(Y, Ee);
                    if (Ve === "v2f")
                        return Nf(Y, Ee);
                    if (Ve === "v3f")
                        return Bg(Y, Ee);
                    if (Ve === "int")
                        return hr(Y, Ee);
                    if (Ve === "rational")
                        return As(Y, Ee);
                    if (Ve === "timecode")
                        return kr(Y, Ee);
                    if (Ve === "preview")
                        return Ee.value += at,
                        "skipped";
                    Ee.value += at
                }
                function kg(Y, le, Ee) {
                    const Ve = {};
                    if (Y.getUint32(0, !0) != 20000630)
                        throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");
                    Ve.version = Y.getUint8(4);
                    const at = Y.getUint8(5);
                    Ve.spec = {
                        singleTile: !!(at & 2),
                        longName: !!(at & 4),
                        deepFormat: !!(at & 8),
                        multiPart: !!(at & 16)
                    },
                    Ee.value = 8;
                    let Qe = !0;
                    for (; Qe; ) {
                        const Et = ur(le, Ee);
                        if (Et == 0)
                            Qe = !1;
                        else {
                            const Ut = ur(le, Ee)
                              , Yt = vi(Y, Ee)
                              , At = Fg(Y, le, Ee, Ut, Yt);
                            At === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${Ut}'.`) : Ve[Et] = At
                        }
                    }
                    if (at & -5)
                        throw console.error("EXRHeader:", Ve),
                        new Error("THREE.EXRLoader: provided file is currently unsupported.");
                    return Ve
                }
                function Ug(Y, le, Ee, Ve, at) {
                    const Qe = {
                        size: 0,
                        viewer: le,
                        array: Ee,
                        offset: Ve,
                        width: Y.dataWindow.xMax - Y.dataWindow.xMin + 1,
                        height: Y.dataWindow.yMax - Y.dataWindow.yMin + 1,
                        channels: Y.channels.length,
                        bytesPerLine: null,
                        lines: null,
                        inputSize: null,
                        type: Y.channels[0].pixelType,
                        uncompress: null,
                        getter: null,
                        format: null,
                        encoding: null
                    };
                    switch (Y.compression) {
                    case "NO_COMPRESSION":
                        Qe.lines = 1,
                        Qe.uncompress = _n;
                        break;
                    case "RLE_COMPRESSION":
                        Qe.lines = 1,
                        Qe.uncompress = qn;
                        break;
                    case "ZIPS_COMPRESSION":
                        Qe.lines = 1,
                        Qe.uncompress = ii;
                        break;
                    case "ZIP_COMPRESSION":
                        Qe.lines = 16,
                        Qe.uncompress = ii;
                        break;
                    case "PIZ_COMPRESSION":
                        Qe.lines = 32,
                        Qe.uncompress = Mi;
                        break;
                    case "PXR24_COMPRESSION":
                        Qe.lines = 16,
                        Qe.uncompress = Jn;
                        break;
                    case "DWAA_COMPRESSION":
                        Qe.lines = 32,
                        Qe.uncompress = cr;
                        break;
                    case "DWAB_COMPRESSION":
                        Qe.lines = 256,
                        Qe.uncompress = cr;
                        break;
                    default:
                        throw new Error("EXRLoader.parse: " + Y.compression + " is unsupported")
                    }
                    if (Qe.scanlineBlockSize = Qe.lines,
                    Qe.type == 1)
                        switch (at) {
                        case m.VzW:
                            Qe.getter = Dg,
                            Qe.inputSize = 2;
                            break;
                        case m.cLu:
                            Qe.getter = Fc,
                            Qe.inputSize = 2;
                            break
                        }
                    else if (Qe.type == 2)
                        switch (at) {
                        case m.VzW:
                            Qe.getter = xr,
                            Qe.inputSize = 4;
                            break;
                        case m.cLu:
                            Qe.getter = ml,
                            Qe.inputSize = 4
                        }
                    else
                        throw new Error("EXRLoader.parse: unsupported pixelType " + Qe.type + " for " + Y.compression + ".");
                    Qe.blockCount = (Y.dataWindow.yMax + 1) / Qe.scanlineBlockSize;
                    for (let Ut = 0; Ut < Qe.blockCount; Ut++)
                        Ss(le, Ve);
                    Qe.outputChannels = Qe.channels == 3 ? 4 : Qe.channels;
                    const Et = Qe.width * Qe.height * Qe.outputChannels;
                    switch (at) {
                    case m.VzW:
                        Qe.byteArray = new Float32Array(Et),
                        Qe.channels < Qe.outputChannels && Qe.byteArray.fill(1, 0, Et);
                        break;
                    case m.cLu:
                        Qe.byteArray = new Uint16Array(Et),
                        Qe.channels < Qe.outputChannels && Qe.byteArray.fill(15360, 0, Et);
                        break;
                    default:
                        console.error("THREE.EXRLoader: unsupported type: ", at);
                        break
                    }
                    return Qe.bytesPerLine = Qe.width * Qe.inputSize * Qe.channels,
                    Qe.outputChannels == 4 ? (Qe.format = m.wk1,
                    Qe.encoding = m.rnI) : (Qe.format = m.hEm,
                    Qe.encoding = m.rnI),
                    Qe
                }
                const Tu = new DataView(y)
                  , _t = new Uint8Array(y)
                  , Cr = {
                    value: 0
                }
                  , gl = kg(Tu, y, Cr)
                  , Ci = Ug(gl, Tu, _t, Cr, this.type)
                  , zf = {
                    value: 0
                }
                  , Yl = {
                    R: 0,
                    G: 1,
                    B: 2,
                    A: 3,
                    Y: 0
                };
                for (let Y = 0; Y < Ci.height / Ci.scanlineBlockSize; Y++) {
                    const le = vi(Tu, Cr);
                    Ci.size = vi(Tu, Cr),
                    Ci.lines = le + Ci.scanlineBlockSize > Ci.height ? Ci.height - le : Ci.scanlineBlockSize;
                    const Ve = Ci.size < Ci.lines * Ci.bytesPerLine ? Ci.uncompress(Ci) : _n(Ci);
                    Cr.value += Ci.size;
                    for (let at = 0; at < Ci.scanlineBlockSize; at++) {
                        const Qe = at + Y * Ci.scanlineBlockSize;
                        if (Qe >= Ci.height)
                            break;
                        for (let Et = 0; Et < Ci.channels; Et++) {
                            const Ut = Yl[gl.channels[Et].name];
                            for (let Yt = 0; Yt < Ci.width; Yt++) {
                                zf.value = (at * (Ci.channels * Ci.width) + Et * Ci.width + Yt) * Ci.inputSize;
                                const At = (Ci.height - 1 - Qe) * (Ci.width * Ci.outputChannels) + Yt * Ci.outputChannels + Ut;
                                Ci.byteArray[At] = Ci.getter(Ve, zf)
                            }
                        }
                    }
                }
                return {
                    header: gl,
                    width: Ci.width,
                    height: Ci.height,
                    data: Ci.byteArray,
                    format: Ci.format,
                    encoding: Ci.encoding,
                    type: this.type
                }
            }
            setDataType(y) {
                return this.type = y,
                this
            }
            load(y, b, E, T) {
                function L(F, j) {
                    F.encoding = j.encoding,
                    F.minFilter = m.wem,
                    F.magFilter = m.wem,
                    F.generateMipmaps = !1,
                    F.flipY = !1,
                    b && b(F, j)
                }
                return super.load(y, L, E, T)
            }
        }
        class pt extends s.g {
            constructor() {
                super(...arguments);
                B(this, "extensions", ["exr"])
            }
            load({url: b, file: E, onLoad: T, onProgress: L, onError: F, texSettings: j}) {
                new He(this.viewer.loadingManager).load(b, W=>T(Object.assign(W, j)), L, F, E)
            }
        }
        function Fe(ae, y, b) {
            const E = b.length - ae - 1;
            if (y >= b[E])
                return E - 1;
            if (y <= b[ae])
                return ae;
            let T = ae
              , L = E
              , F = Math.floor((T + L) / 2);
            for (; y < b[F] || y >= b[F + 1]; )
                y < b[F] ? L = F : T = F,
                F = Math.floor((T + L) / 2);
            return F
        }
        function qe(ae, y, b, E) {
            const T = []
              , L = []
              , F = [];
            T[0] = 1;
            for (let j = 1; j <= b; ++j) {
                L[j] = y - E[ae + 1 - j],
                F[j] = E[ae + j] - y;
                let W = 0;
                for (let re = 0; re < j; ++re) {
                    const fe = F[re + 1]
                      , te = L[j - re]
                      , Te = T[re] / (fe + te);
                    T[re] = W + fe * Te,
                    W = te * Te
                }
                T[j] = W
            }
            return T
        }
        function wt(ae, y, b, E) {
            const T = Fe(ae, E, y)
              , L = qe(T, E, ae, y)
              , F = new m.Ltg(0,0,0,0);
            for (let j = 0; j <= ae; ++j) {
                const W = b[T - ae + j]
                  , re = L[j]
                  , fe = W.w * re;
                F.x += W.x * fe,
                F.y += W.y * fe,
                F.z += W.z * fe,
                F.w += W.w * re
            }
            return F
        }
        function An(ae, y, b, E, T) {
            const L = [];
            for (let te = 0; te <= b; ++te)
                L[te] = 0;
            const F = [];
            for (let te = 0; te <= E; ++te)
                F[te] = L.slice(0);
            const j = [];
            for (let te = 0; te <= b; ++te)
                j[te] = L.slice(0);
            j[0][0] = 1;
            const W = L.slice(0)
              , re = L.slice(0);
            for (let te = 1; te <= b; ++te) {
                W[te] = y - T[ae + 1 - te],
                re[te] = T[ae + te] - y;
                let Te = 0;
                for (let Ge = 0; Ge < te; ++Ge) {
                    const St = re[Ge + 1]
                      , kt = W[te - Ge];
                    j[te][Ge] = St + kt;
                    const Vt = j[Ge][te - 1] / j[te][Ge];
                    j[Ge][te] = Te + St * Vt,
                    Te = kt * Vt
                }
                j[te][te] = Te
            }
            for (let te = 0; te <= b; ++te)
                F[0][te] = j[te][b];
            for (let te = 0; te <= b; ++te) {
                let Te = 0
                  , Ge = 1;
                const St = [];
                for (let kt = 0; kt <= b; ++kt)
                    St[kt] = L.slice(0);
                St[0][0] = 1;
                for (let kt = 1; kt <= E; ++kt) {
                    let Vt = 0;
                    const gt = te - kt
                      , xt = b - kt;
                    te >= kt && (St[Ge][0] = St[Te][0] / j[xt + 1][gt],
                    Vt = St[Ge][0] * j[gt][xt]);
                    const Xe = gt >= -1 ? 1 : -gt
                      , ut = te - 1 <= xt ? kt - 1 : b - te;
                    for (let qt = Xe; qt <= ut; ++qt)
                        St[Ge][qt] = (St[Te][qt] - St[Te][qt - 1]) / j[xt + 1][gt + qt],
                        Vt += St[Ge][qt] * j[gt + qt][xt];
                    te <= xt && (St[Ge][kt] = -St[Te][kt - 1] / j[xt + 1][te],
                    Vt += St[Ge][kt] * j[te][xt]),
                    F[kt][te] = Vt;
                    const dn = Te;
                    Te = Ge,
                    Ge = dn
                }
            }
            let fe = b;
            for (let te = 1; te <= E; ++te) {
                for (let Te = 0; Te <= b; ++Te)
                    F[te][Te] *= fe;
                fe *= b - te
            }
            return F
        }
        function Qt(ae, y, b, E, T) {
            const L = T < ae ? T : ae
              , F = []
              , j = Fe(ae, E, y)
              , W = An(j, E, ae, L, y)
              , re = [];
            for (let fe = 0; fe < b.length; ++fe) {
                const te = b[fe].clone()
                  , Te = te.w;
                te.x *= Te,
                te.y *= Te,
                te.z *= Te,
                re[fe] = te
            }
            for (let fe = 0; fe <= L; ++fe) {
                const te = re[j - ae].clone().multiplyScalar(W[fe][0]);
                for (let Te = 1; Te <= ae; ++Te)
                    te.add(re[j - ae + Te].clone().multiplyScalar(W[fe][Te]));
                F[fe] = te
            }
            for (let fe = L + 1; fe <= T + 1; ++fe)
                F[fe] = new m.Ltg(0,0,0);
            return F
        }
        function Pi(ae, y) {
            let b = 1;
            for (let T = 2; T <= ae; ++T)
                b *= T;
            let E = 1;
            for (let T = 2; T <= y; ++T)
                E *= T;
            for (let T = 2; T <= ae - y; ++T)
                E *= T;
            return b / E
        }
        function ui(ae) {
            const y = ae.length
              , b = []
              , E = [];
            for (let L = 0; L < y; ++L) {
                const F = ae[L];
                b[L] = new m.Pa4(F.x,F.y,F.z),
                E[L] = F.w
            }
            const T = [];
            for (let L = 0; L < y; ++L) {
                const F = b[L].clone();
                for (let j = 1; j <= L; ++j)
                    F.sub(T[L - j].clone().multiplyScalar(Pi(L, j) * E[j]));
                T[L] = F.divideScalar(E[0])
            }
            return T
        }
        function mi(ae, y, b, E, T) {
            const L = Qt(ae, y, b, E, T);
            return ui(L)
        }
        class Si extends m.Hyl {
            constructor(y, b, E, T, L) {
                super(),
                this.degree = y,
                this.knots = b,
                this.controlPoints = [],
                this.startKnot = T || 0,
                this.endKnot = L || this.knots.length - 1;
                for (let F = 0; F < E.length; ++F) {
                    const j = E[F];
                    this.controlPoints[F] = new m.Ltg(j.x,j.y,j.z,j.w)
                }
            }
            getPoint(y, b=new m.Pa4) {
                const E = b
                  , T = this.knots[this.startKnot] + y * (this.knots[this.endKnot] - this.knots[this.startKnot])
                  , L = wt(this.degree, this.knots, this.controlPoints, T);
                return L.w !== 1 && L.divideScalar(L.w),
                E.set(L.x, L.y, L.z)
            }
            getTangent(y, b=new m.Pa4) {
                const E = b
                  , T = this.knots[0] + y * (this.knots[this.knots.length - 1] - this.knots[0])
                  , L = mi(this.degree, this.knots, this.controlPoints, T, 1);
                return E.copy(L[1]).normalize(),
                E
            }
        }
        let Gt, On, kn;
        class bi extends m.aNw {
            constructor(y) {
                super(y)
            }
            load(y, b, E, T, L) {
                const F = this
                  , j = F.path === "" ? m.Zp0.extractUrlBase(y) : F.path
                  , W = new m.hH6(this.manager);
                W.setPath(F.path),
                W.setResponseType("arraybuffer"),
                W.setRequestHeader(F.requestHeader),
                W.setWithCredentials(F.withCredentials),
                W.load(y, function(re) {
                    try {
                        b(F.parse(re, j))
                    } catch (fe) {
                        T ? T(fe) : console.error(fe),
                        F.manager.itemError(y)
                    }
                }, E, T, L == null ? void 0 : L.mainFile)
            }
            parse(y, b) {
                if (ys(y))
                    Gt = new Oi().parse(y);
                else {
                    const T = Ba(y);
                    if (!xs(T))
                        throw new Error("THREE.FBXLoader: Unknown format.");
                    if (hi(T) < 7e3)
                        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + hi(T));
                    Gt = new vr().parse(T)
                }
                const E = new m.dpR(this.manager).setPath(this.resourcePath || b).setCrossOrigin(this.crossOrigin);
                return new $i(E,this.manager).parse(Gt)
            }
        }
        class $i {
            constructor(y, b) {
                this.textureLoader = y,
                this.manager = b
            }
            parse() {
                On = this.parseConnections();
                const y = this.parseImages()
                  , b = this.parseTextures(y)
                  , E = this.parseMaterials(b)
                  , T = this.parseDeformers()
                  , L = new zr().parse(T);
                return this.parseScene(T, L, E),
                kn
            }
            parseConnections() {
                const y = new Map;
                return "Connections"in Gt && Gt.Connections.connections.forEach(function(E) {
                    const T = E[0]
                      , L = E[1]
                      , F = E[2];
                    y.has(T) || y.set(T, {
                        parents: [],
                        children: []
                    });
                    const j = {
                        ID: L,
                        relationship: F
                    };
                    y.get(T).parents.push(j),
                    y.has(L) || y.set(L, {
                        parents: [],
                        children: []
                    });
                    const W = {
                        ID: T,
                        relationship: F
                    };
                    y.get(L).children.push(W)
                }),
                y
            }
            parseImages() {
                const y = {}
                  , b = {};
                if ("Video"in Gt.Objects) {
                    const E = Gt.Objects.Video;
                    for (const T in E) {
                        const L = E[T]
                          , F = parseInt(T);
                        if (y[F] = L.RelativeFilename || L.Filename,
                        "Content"in L) {
                            const j = L.Content instanceof ArrayBuffer && L.Content.byteLength > 0
                              , W = typeof L.Content == "string" && L.Content !== "";
                            if (j || W) {
                                const re = this.parseImage(E[T]);
                                b[L.RelativeFilename || L.Filename] = re
                            }
                        }
                    }
                }
                for (const E in y) {
                    const T = y[E];
                    b[T] !== void 0 ? y[E] = b[T] : y[E] = y[E].split("\\").pop()
                }
                return y
            }
            parseImage(y) {
                const b = y.Content
                  , E = y.RelativeFilename || y.Filename
                  , T = E.slice(E.lastIndexOf(".") + 1).toLowerCase();
                let L;
                switch (T) {
                case "bmp":
                    L = "image/bmp";
                    break;
                case "jpg":
                case "jpeg":
                    L = "image/jpeg";
                    break;
                case "png":
                    L = "image/png";
                    break;
                case "tif":
                    L = "image/tiff";
                    break;
                case "tga":
                    this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", E),
                    L = "image/tga";
                    break;
                default:
                    console.warn('FBXLoader: Image type "' + T + '" is not supported.');
                    return
                }
                if (typeof b == "string")
                    return "data:" + L + ";base64," + b;
                {
                    const F = new Uint8Array(b);
                    return window.URL.createObjectURL(new Blob([F],{
                        type: L
                    }))
                }
            }
            parseTextures(y) {
                const b = new Map;
                if ("Texture"in Gt.Objects) {
                    const E = Gt.Objects.Texture;
                    for (const T in E) {
                        const L = this.parseTexture(E[T], y);
                        b.set(parseInt(T), L)
                    }
                }
                return b
            }
            parseTexture(y, b) {
                const E = this.loadTexture(y, b);
                E.ID = y.id,
                E.name = y.attrName;
                const T = y.WrapModeU
                  , L = y.WrapModeV
                  , F = T !== void 0 ? T.value : 0
                  , j = L !== void 0 ? L.value : 0;
                if (E.wrapS = F === 0 ? m.rpg : m.uWy,
                E.wrapT = j === 0 ? m.rpg : m.uWy,
                "Scaling"in y) {
                    const W = y.Scaling.value;
                    E.repeat.x = W[0],
                    E.repeat.y = W[1]
                }
                if ("Translation"in y) {
                    const W = y.Translation.value;
                    E.offset.x = W[0],
                    E.offset.y = W[1]
                }
                return E
            }
            loadTexture(y, b) {
                let E;
                const T = this.textureLoader.path
                  , L = On.get(y.id).children;
                L !== void 0 && L.length > 0 && b[L[0].ID] !== void 0 && (E = b[L[0].ID],
                (E.indexOf("blob:") === 0 || E.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
                let F;
                const j = y.FileName.slice(-3).toLowerCase();
                if (j === "tga") {
                    const W = this.manager.getHandler(".tga");
                    W === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", y.RelativeFilename),
                    F = new m.xEZ) : (W.setPath(this.textureLoader.path),
                    F = W.load(E))
                } else
                    j === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", y.RelativeFilename),
                    F = new m.xEZ) : F = this.textureLoader.load(E);
                return this.textureLoader.setPath(T),
                F
            }
            parseMaterials(y) {
                const b = new Map;
                if ("Material"in Gt.Objects) {
                    const E = Gt.Objects.Material;
                    for (const T in E) {
                        const L = this.parseMaterial(E[T], y);
                        L !== null && b.set(parseInt(T), L)
                    }
                }
                return b
            }
            parseMaterial(y, b) {
                const E = y.id
                  , T = y.attrName;
                let L = y.ShadingModel;
                if (typeof L == "object" && (L = L.value),
                !On.has(E))
                    return null;
                const F = this.parseParameters(y, b, E);
                let j;
                switch (L.toLowerCase()) {
                case "phong":
                    j = new m.xoR;
                    break;
                case "lambert":
                    j = new m.YBo;
                    break;
                default:
                    console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', L),
                    j = new m.xoR;
                    break
                }
                return j.setValues(F),
                j.name = T,
                j
            }
            parseParameters(y, b, E) {
                const T = {};
                y.BumpFactor && (T.bumpScale = y.BumpFactor.value),
                y.Diffuse ? T.color = new m.Ilk().fromArray(y.Diffuse.value) : y.DiffuseColor && (y.DiffuseColor.type === "Color" || y.DiffuseColor.type === "ColorRGB") && (T.color = new m.Ilk().fromArray(y.DiffuseColor.value)),
                y.DisplacementFactor && (T.displacementScale = y.DisplacementFactor.value),
                y.Emissive ? T.emissive = new m.Ilk().fromArray(y.Emissive.value) : y.EmissiveColor && (y.EmissiveColor.type === "Color" || y.EmissiveColor.type === "ColorRGB") && (T.emissive = new m.Ilk().fromArray(y.EmissiveColor.value)),
                y.EmissiveFactor && (T.emissiveIntensity = parseFloat(y.EmissiveFactor.value)),
                y.Opacity && (T.opacity = parseFloat(y.Opacity.value)),
                T.opacity < 1 && (T.transparent = !0),
                y.ReflectionFactor && (T.reflectivity = y.ReflectionFactor.value),
                y.Shininess && (T.shininess = y.Shininess.value),
                y.Specular ? T.specular = new m.Ilk().fromArray(y.Specular.value) : y.SpecularColor && y.SpecularColor.type === "Color" && (T.specular = new m.Ilk().fromArray(y.SpecularColor.value));
                const L = this;
                return On.get(E).children.forEach(function(F) {
                    const j = F.relationship;
                    switch (j) {
                    case "Bump":
                        T.bumpMap = L.getTexture(b, F.ID);
                        break;
                    case "Maya|TEX_ao_map":
                        T.aoMap = L.getTexture(b, F.ID);
                        break;
                    case "DiffuseColor":
                    case "Maya|TEX_color_map":
                        T.map = L.getTexture(b, F.ID),
                        T.map !== void 0 && (T.map.encoding = m.knz);
                        break;
                    case "DisplacementColor":
                        T.displacementMap = L.getTexture(b, F.ID);
                        break;
                    case "EmissiveColor":
                        T.emissiveMap = L.getTexture(b, F.ID),
                        T.emissiveMap !== void 0 && (T.emissiveMap.encoding = m.knz);
                        break;
                    case "NormalMap":
                    case "Maya|TEX_normal_map":
                        T.normalMap = L.getTexture(b, F.ID);
                        break;
                    case "ReflectionColor":
                        T.envMap = L.getTexture(b, F.ID),
                        T.envMap !== void 0 && (T.envMap.mapping = m.dSO,
                        T.envMap.encoding = m.knz);
                        break;
                    case "SpecularColor":
                        T.specularMap = L.getTexture(b, F.ID),
                        T.specularMap !== void 0 && (T.specularMap.encoding = m.knz);
                        break;
                    case "TransparentColor":
                    case "TransparencyFactor":
                        T.alphaMap = L.getTexture(b, F.ID),
                        T.transparent = !0;
                        break;
                    case "AmbientColor":
                    case "ShininessExponent":
                    case "SpecularFactor":
                    case "VectorDisplacementColor":
                    default:
                        console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", j);
                        break
                    }
                }),
                T
            }
            getTexture(y, b) {
                return "LayeredTexture"in Gt.Objects && b in Gt.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),
                b = On.get(b).children[0].ID),
                y.get(b)
            }
            parseDeformers() {
                const y = {}
                  , b = {};
                if ("Deformer"in Gt.Objects) {
                    const E = Gt.Objects.Deformer;
                    for (const T in E) {
                        const L = E[T]
                          , F = On.get(parseInt(T));
                        if (L.attrType === "Skin") {
                            const j = this.parseSkeleton(F, E);
                            j.ID = T,
                            F.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),
                            j.geometryID = F.parents[0].ID,
                            y[T] = j
                        } else if (L.attrType === "BlendShape") {
                            const j = {
                                id: T
                            };
                            j.rawTargets = this.parseMorphTargets(F, E),
                            j.id = T,
                            F.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),
                            b[T] = j
                        }
                    }
                }
                return {
                    skeletons: y,
                    morphTargets: b
                }
            }
            parseSkeleton(y, b) {
                const E = [];
                return y.children.forEach(function(T) {
                    const L = b[T.ID];
                    if (L.attrType !== "Cluster")
                        return;
                    const F = {
                        ID: T.ID,
                        indices: [],
                        weights: [],
                        transformLink: new m.yGw().fromArray(L.TransformLink.a)
                    };
                    "Indexes"in L && (F.indices = L.Indexes.a,
                    F.weights = L.Weights.a),
                    E.push(F)
                }),
                {
                    rawBones: E,
                    bones: []
                }
            }
            parseMorphTargets(y, b) {
                const E = [];
                for (let T = 0; T < y.children.length; T++) {
                    const L = y.children[T]
                      , F = b[L.ID]
                      , j = {
                        name: F.attrName,
                        initialWeight: F.DeformPercent,
                        id: F.id,
                        fullWeights: F.FullWeights.a
                    };
                    if (F.attrType !== "BlendShapeChannel")
                        return;
                    j.geoID = On.get(parseInt(L.ID)).children.filter(function(W) {
                        return W.relationship === void 0
                    })[0].ID,
                    E.push(j)
                }
                return E
            }
            parseScene(y, b, E) {
                kn = new m.ZAu;
                const T = this.parseModels(y.skeletons, b, E)
                  , L = Gt.Objects.Model
                  , F = this;
                T.forEach(function(W) {
                    const re = L[W.ID];
                    F.setLookAtProperties(W, re),
                    On.get(W.ID).parents.forEach(function(te) {
                        const Te = T.get(te.ID);
                        Te !== void 0 && Te.add(W)
                    }),
                    W.parent === null && kn.add(W)
                }),
                this.bindSkeleton(y.skeletons, b, T),
                this.createAmbientLight(),
                kn.traverse(function(W) {
                    if (W.userData.transformData) {
                        W.parent && (W.userData.transformData.parentMatrix = W.parent.matrix,
                        W.userData.transformData.parentMatrixWorld = W.parent.matrixWorld);
                        const re = Ao(W.userData.transformData);
                        W.applyMatrix4(re),
                        W.updateWorldMatrix()
                    }
                });
                const j = new Fi().parse();
                kn.children.length === 1 && kn.children[0].isGroup && (kn.children[0].animations = j,
                kn = kn.children[0]),
                kn.animations = j
            }
            parseModels(y, b, E) {
                const T = new Map
                  , L = Gt.Objects.Model;
                for (const F in L) {
                    const j = parseInt(F)
                      , W = L[F]
                      , re = On.get(j);
                    let fe = this.buildSkeleton(re, y, j, W.attrName);
                    if (!fe) {
                        switch (W.attrType) {
                        case "Camera":
                            fe = this.createCamera(re);
                            break;
                        case "Light":
                            fe = this.createLight(re);
                            break;
                        case "Mesh":
                            fe = this.createMesh(re, b, E);
                            break;
                        case "NurbsCurve":
                            fe = this.createCurve(re, b);
                            break;
                        case "LimbNode":
                        case "Root":
                            fe = new m.N$j;
                            break;
                        case "Null":
                        default:
                            fe = new m.ZAu;
                            break
                        }
                        fe.name = W.attrName ? m.iUV.sanitizeNodeName(W.attrName) : "",
                        fe.ID = j
                    }
                    this.getTransformData(fe, W),
                    T.set(j, fe)
                }
                return T
            }
            buildSkeleton(y, b, E, T) {
                let L = null;
                return y.parents.forEach(function(F) {
                    for (const j in b) {
                        const W = b[j];
                        W.rawBones.forEach(function(re, fe) {
                            if (re.ID === F.ID) {
                                const te = L;
                                L = new m.N$j,
                                L.matrixWorld.copy(re.transformLink),
                                L.name = T ? m.iUV.sanitizeNodeName(T) : "",
                                L.ID = E,
                                W.bones[fe] = L,
                                te !== null && L.add(te)
                            }
                        })
                    }
                }),
                L
            }
            createCamera(y) {
                let b, E;
                if (y.children.forEach(function(T) {
                    const L = Gt.Objects.NodeAttribute[T.ID];
                    L !== void 0 && (E = L)
                }),
                E === void 0)
                    b = new m.Tme;
                else {
                    let T = 0;
                    E.CameraProjectionType !== void 0 && E.CameraProjectionType.value === 1 && (T = 1);
                    let L = 1;
                    E.NearPlane !== void 0 && (L = E.NearPlane.value / 1e3);
                    let F = 1e3;
                    E.FarPlane !== void 0 && (F = E.FarPlane.value / 1e3);
                    let j = window.innerWidth
                      , W = window.innerHeight;
                    E.AspectWidth !== void 0 && E.AspectHeight !== void 0 && (j = E.AspectWidth.value,
                    W = E.AspectHeight.value);
                    const re = j / W;
                    let fe = 45;
                    E.FieldOfView !== void 0 && (fe = E.FieldOfView.value);
                    const te = E.FocalLength ? E.FocalLength.value : null;
                    switch (T) {
                    case 0:
                        b = new m.cPb(fe,re,L,F),
                        te !== null && b.setFocalLength(te);
                        break;
                    case 1:
                        b = new m.iKG(-j / 2,j / 2,W / 2,-W / 2,L,F);
                        break;
                    default:
                        console.warn("THREE.FBXLoader: Unknown camera type " + T + "."),
                        b = new m.Tme;
                        break
                    }
                }
                return b
            }
            createLight(y) {
                let b, E;
                if (y.children.forEach(function(T) {
                    const L = Gt.Objects.NodeAttribute[T.ID];
                    L !== void 0 && (E = L)
                }),
                E === void 0)
                    b = new m.Tme;
                else {
                    let T;
                    E.LightType === void 0 ? T = 0 : T = E.LightType.value;
                    let L = 16777215;
                    E.Color !== void 0 && (L = new m.Ilk().fromArray(E.Color.value));
                    let F = E.Intensity === void 0 ? 1 : E.Intensity.value / 100;
                    E.CastLightOnObject !== void 0 && E.CastLightOnObject.value === 0 && (F = 0);
                    let j = 0;
                    E.FarAttenuationEnd !== void 0 && (E.EnableFarAttenuation !== void 0 && E.EnableFarAttenuation.value === 0 ? j = 0 : j = E.FarAttenuationEnd.value);
                    const W = 1;
                    switch (T) {
                    case 0:
                        b = new m.cek(L,F,j,W);
                        break;
                    case 1:
                        b = new m.Ox3(L,F);
                        break;
                    case 2:
                        let re = Math.PI / 3;
                        E.InnerAngle !== void 0 && (re = m.M8C.degToRad(E.InnerAngle.value));
                        let fe = 0;
                        E.OuterAngle !== void 0 && (fe = m.M8C.degToRad(E.OuterAngle.value),
                        fe = Math.max(fe, 1)),
                        b = new m.PMe(L,F,j,re,fe,W);
                        break;
                    default:
                        console.warn("THREE.FBXLoader: Unknown light type " + E.LightType.value + ", defaulting to a PointLight."),
                        b = new m.cek(L,F);
                        break
                    }
                    E.CastShadows !== void 0 && E.CastShadows.value === 1 && (b.castShadow = !0)
                }
                return b
            }
            createMesh(y, b, E) {
                let T, L = null, F = null;
                const j = [];
                return y.children.forEach(function(W) {
                    b.has(W.ID) && (L = b.get(W.ID)),
                    E.has(W.ID) && j.push(E.get(W.ID))
                }),
                j.length > 1 ? F = j : j.length > 0 ? F = j[0] : (F = new m.xoR({
                    color: 13421772
                }),
                j.push(F)),
                "color"in L.attributes && j.forEach(function(W) {
                    W.vertexColors = !0
                }),
                L.FBX_Deformer ? (T = new m.TUv(L,F),
                T.normalizeSkinWeights()) : T = new m.Kj0(L,F),
                T
            }
            createCurve(y, b) {
                const E = y.children.reduce(function(L, F) {
                    return b.has(F.ID) && (L = b.get(F.ID)),
                    L
                }, null)
                  , T = new m.nls({
                    color: 3342591,
                    linewidth: 1
                });
                return new m.x12(E,T)
            }
            getTransformData(y, b) {
                const E = {};
                "InheritType"in b && (E.inheritType = parseInt(b.InheritType.value)),
                "RotationOrder"in b ? E.eulerOrder = Hi(b.RotationOrder.value) : E.eulerOrder = "ZYX",
                "Lcl_Translation"in b && (E.translation = b.Lcl_Translation.value),
                "PreRotation"in b && (E.preRotation = b.PreRotation.value),
                "Lcl_Rotation"in b && (E.rotation = b.Lcl_Rotation.value),
                "PostRotation"in b && (E.postRotation = b.PostRotation.value),
                "Lcl_Scaling"in b && (E.scale = b.Lcl_Scaling.value),
                "ScalingOffset"in b && (E.scalingOffset = b.ScalingOffset.value),
                "ScalingPivot"in b && (E.scalingPivot = b.ScalingPivot.value),
                "RotationOffset"in b && (E.rotationOffset = b.RotationOffset.value),
                "RotationPivot"in b && (E.rotationPivot = b.RotationPivot.value),
                y.userData.transformData = E
            }
            setLookAtProperties(y, b) {
                "LookAtProperty"in b && On.get(y.ID).children.forEach(function(T) {
                    if (T.relationship === "LookAtProperty") {
                        const L = Gt.Objects.Model[T.ID];
                        if ("Lcl_Translation"in L) {
                            const F = L.Lcl_Translation.value;
                            y.target !== void 0 ? (y.target.position.fromArray(F),
                            kn.add(y.target)) : y.lookAt(new m.Pa4().fromArray(F))
                        }
                    }
                })
            }
            bindSkeleton(y, b, E) {
                const T = this.parsePoseNodes();
                for (const L in y) {
                    const F = y[L];
                    On.get(parseInt(F.ID)).parents.forEach(function(W) {
                        if (b.has(W.ID)) {
                            const re = W.ID;
                            On.get(re).parents.forEach(function(te) {
                                E.has(te.ID) && E.get(te.ID).bind(new m.OdW(F.bones), T[te.ID])
                            })
                        }
                    })
                }
            }
            parsePoseNodes() {
                const y = {};
                if ("Pose"in Gt.Objects) {
                    const b = Gt.Objects.Pose;
                    for (const E in b)
                        if (b[E].attrType === "BindPose" && b[E].NbPoseNodes > 0) {
                            const T = b[E].PoseNode;
                            Array.isArray(T) ? T.forEach(function(L) {
                                y[L.Node] = new m.yGw().fromArray(L.Matrix.a)
                            }) : y[T.Node] = new m.yGw().fromArray(T.Matrix.a)
                        }
                }
                return y
            }
            createAmbientLight() {
                if ("GlobalSettings"in Gt && "AmbientColor"in Gt.GlobalSettings) {
                    const y = Gt.GlobalSettings.AmbientColor.value
                      , b = y[0]
                      , E = y[1]
                      , T = y[2];
                    if (b !== 0 || E !== 0 || T !== 0) {
                        const L = new m.Ilk(b,E,T);
                        kn.add(new m.Mig(L,1))
                    }
                }
            }
        }
        class zr {
            constructor() {
                this.negativeMaterialIndices = !1
            }
            parse(y) {
                const b = new Map;
                if ("Geometry"in Gt.Objects) {
                    const E = Gt.Objects.Geometry;
                    for (const T in E) {
                        const L = On.get(parseInt(T))
                          , F = this.parseGeometry(L, E[T], y);
                        b.set(parseInt(T), F)
                    }
                }
                return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),
                b
            }
            parseGeometry(y, b, E) {
                switch (b.attrType) {
                case "Mesh":
                    return this.parseMeshGeometry(y, b, E);
                case "NurbsCurve":
                    return this.parseNurbsGeometry(b)
                }
            }
            parseMeshGeometry(y, b, E) {
                const T = E.skeletons
                  , L = []
                  , F = y.parents.map(function(te) {
                    return Gt.Objects.Model[te.ID]
                });
                if (F.length === 0)
                    return;
                const j = y.children.reduce(function(te, Te) {
                    return T[Te.ID] !== void 0 && (te = T[Te.ID]),
                    te
                }, null);
                y.children.forEach(function(te) {
                    E.morphTargets[te.ID] !== void 0 && L.push(E.morphTargets[te.ID])
                });
                const W = F[0]
                  , re = {};
                "RotationOrder"in W && (re.eulerOrder = Hi(W.RotationOrder.value)),
                "InheritType"in W && (re.inheritType = parseInt(W.InheritType.value)),
                "GeometricTranslation"in W && (re.translation = W.GeometricTranslation.value),
                "GeometricRotation"in W && (re.rotation = W.GeometricRotation.value),
                "GeometricScaling"in W && (re.scale = W.GeometricScaling.value);
                const fe = Ao(re);
                return this.genGeometry(b, j, L, fe)
            }
            genGeometry(y, b, E, T) {
                const L = new m.u9r;
                y.attrName && (L.name = y.attrName);
                const F = this.parseGeoNode(y, b)
                  , j = this.genBuffers(F)
                  , W = new m.a$l(j.vertex,3);
                if (W.applyMatrix4(T),
                L.setAttribute("position", W),
                j.colors.length > 0 && L.setAttribute("color", new m.a$l(j.colors,3)),
                b && (L.setAttribute("skinIndex", new m.qlB(j.weightsIndices,4)),
                L.setAttribute("skinWeight", new m.a$l(j.vertexWeights,4)),
                L.FBX_Deformer = b),
                j.normal.length > 0) {
                    const re = new m.Vkp().getNormalMatrix(T)
                      , fe = new m.a$l(j.normal,3);
                    fe.applyNormalMatrix(re),
                    L.setAttribute("normal", fe)
                }
                if (j.uvs.forEach(function(re, fe) {
                    let te = "uv" + (fe + 1).toString();
                    fe === 0 && (te = "uv"),
                    L.setAttribute(te, new m.a$l(j.uvs[fe],2))
                }),
                F.material && F.material.mappingType !== "AllSame") {
                    let re = j.materialIndex[0]
                      , fe = 0;
                    if (j.materialIndex.forEach(function(te, Te) {
                        te !== re && (L.addGroup(fe, Te - fe, re),
                        re = te,
                        fe = Te)
                    }),
                    L.groups.length > 0) {
                        const te = L.groups[L.groups.length - 1]
                          , Te = te.start + te.count;
                        Te !== j.materialIndex.length && L.addGroup(Te, j.materialIndex.length - Te, re)
                    }
                    L.groups.length === 0 && L.addGroup(0, j.materialIndex.length, j.materialIndex[0])
                }
                return this.addMorphTargets(L, y, E, T),
                L
            }
            parseGeoNode(y, b) {
                const E = {};
                if (E.vertexPositions = y.Vertices !== void 0 ? y.Vertices.a : [],
                E.vertexIndices = y.PolygonVertexIndex !== void 0 ? y.PolygonVertexIndex.a : [],
                y.LayerElementColor && (E.color = this.parseVertexColors(y.LayerElementColor[0])),
                y.LayerElementMaterial && (E.material = this.parseMaterialIndices(y.LayerElementMaterial[0])),
                y.LayerElementNormal && (E.normal = this.parseNormals(y.LayerElementNormal[0])),
                y.LayerElementUV) {
                    E.uv = [];
                    let T = 0;
                    for (; y.LayerElementUV[T]; )
                        y.LayerElementUV[T].UV && E.uv.push(this.parseUVs(y.LayerElementUV[T])),
                        T++
                }
                return E.weightTable = {},
                b !== null && (E.skeleton = b,
                b.rawBones.forEach(function(T, L) {
                    T.indices.forEach(function(F, j) {
                        E.weightTable[F] === void 0 && (E.weightTable[F] = []),
                        E.weightTable[F].push({
                            id: L,
                            weight: T.weights[j]
                        })
                    })
                })),
                E
            }
            genBuffers(y) {
                const b = {
                    vertex: [],
                    normal: [],
                    colors: [],
                    uvs: [],
                    materialIndex: [],
                    vertexWeights: [],
                    weightsIndices: []
                };
                let E = 0
                  , T = 0
                  , L = !1
                  , F = []
                  , j = []
                  , W = []
                  , re = []
                  , fe = []
                  , te = [];
                const Te = this;
                return y.vertexIndices.forEach(function(Ge, St) {
                    let kt, Vt = !1;
                    Ge < 0 && (Ge = Ge ^ -1,
                    Vt = !0);
                    let gt = []
                      , xt = [];
                    if (F.push(Ge * 3, Ge * 3 + 1, Ge * 3 + 2),
                    y.color) {
                        const Xe = qi(St, E, Ge, y.color);
                        W.push(Xe[0], Xe[1], Xe[2])
                    }
                    if (y.skeleton) {
                        if (y.weightTable[Ge] !== void 0 && y.weightTable[Ge].forEach(function(Xe) {
                            xt.push(Xe.weight),
                            gt.push(Xe.id)
                        }),
                        xt.length > 4) {
                            L || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),
                            L = !0);
                            const Xe = [0, 0, 0, 0]
                              , ut = [0, 0, 0, 0];
                            xt.forEach(function(dn, qt) {
                                let ln = dn
                                  , Tn = gt[qt];
                                ut.forEach(function(fn, Hn, En) {
                                    if (ln > fn) {
                                        En[Hn] = ln,
                                        ln = fn;
                                        const Ei = Xe[Hn];
                                        Xe[Hn] = Tn,
                                        Tn = Ei
                                    }
                                })
                            }),
                            gt = Xe,
                            xt = ut
                        }
                        for (; xt.length < 4; )
                            xt.push(0),
                            gt.push(0);
                        for (let Xe = 0; Xe < 4; ++Xe)
                            fe.push(xt[Xe]),
                            te.push(gt[Xe])
                    }
                    if (y.normal) {
                        const Xe = qi(St, E, Ge, y.normal);
                        j.push(Xe[0], Xe[1], Xe[2])
                    }
                    y.material && y.material.mappingType !== "AllSame" && (kt = qi(St, E, Ge, y.material)[0],
                    kt < 0 && (Te.negativeMaterialIndices = !0,
                    kt = 0)),
                    y.uv && y.uv.forEach(function(Xe, ut) {
                        const dn = qi(St, E, Ge, Xe);
                        re[ut] === void 0 && (re[ut] = []),
                        re[ut].push(dn[0]),
                        re[ut].push(dn[1])
                    }),
                    T++,
                    Vt && (T > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."),
                    Te.genFace(b, y, F, kt, j, W, re, fe, te, T),
                    E++,
                    T = 0,
                    F = [],
                    j = [],
                    W = [],
                    re = [],
                    fe = [],
                    te = [])
                }),
                b
            }
            genFace(y, b, E, T, L, F, j, W, re, fe) {
                for (let te = 2; te < fe; te++)
                    y.vertex.push(b.vertexPositions[E[0]]),
                    y.vertex.push(b.vertexPositions[E[1]]),
                    y.vertex.push(b.vertexPositions[E[2]]),
                    y.vertex.push(b.vertexPositions[E[(te - 1) * 3]]),
                    y.vertex.push(b.vertexPositions[E[(te - 1) * 3 + 1]]),
                    y.vertex.push(b.vertexPositions[E[(te - 1) * 3 + 2]]),
                    y.vertex.push(b.vertexPositions[E[te * 3]]),
                    y.vertex.push(b.vertexPositions[E[te * 3 + 1]]),
                    y.vertex.push(b.vertexPositions[E[te * 3 + 2]]),
                    b.skeleton && (y.vertexWeights.push(W[0]),
                    y.vertexWeights.push(W[1]),
                    y.vertexWeights.push(W[2]),
                    y.vertexWeights.push(W[3]),
                    y.vertexWeights.push(W[(te - 1) * 4]),
                    y.vertexWeights.push(W[(te - 1) * 4 + 1]),
                    y.vertexWeights.push(W[(te - 1) * 4 + 2]),
                    y.vertexWeights.push(W[(te - 1) * 4 + 3]),
                    y.vertexWeights.push(W[te * 4]),
                    y.vertexWeights.push(W[te * 4 + 1]),
                    y.vertexWeights.push(W[te * 4 + 2]),
                    y.vertexWeights.push(W[te * 4 + 3]),
                    y.weightsIndices.push(re[0]),
                    y.weightsIndices.push(re[1]),
                    y.weightsIndices.push(re[2]),
                    y.weightsIndices.push(re[3]),
                    y.weightsIndices.push(re[(te - 1) * 4]),
                    y.weightsIndices.push(re[(te - 1) * 4 + 1]),
                    y.weightsIndices.push(re[(te - 1) * 4 + 2]),
                    y.weightsIndices.push(re[(te - 1) * 4 + 3]),
                    y.weightsIndices.push(re[te * 4]),
                    y.weightsIndices.push(re[te * 4 + 1]),
                    y.weightsIndices.push(re[te * 4 + 2]),
                    y.weightsIndices.push(re[te * 4 + 3])),
                    b.color && (y.colors.push(F[0]),
                    y.colors.push(F[1]),
                    y.colors.push(F[2]),
                    y.colors.push(F[(te - 1) * 3]),
                    y.colors.push(F[(te - 1) * 3 + 1]),
                    y.colors.push(F[(te - 1) * 3 + 2]),
                    y.colors.push(F[te * 3]),
                    y.colors.push(F[te * 3 + 1]),
                    y.colors.push(F[te * 3 + 2])),
                    b.material && b.material.mappingType !== "AllSame" && (y.materialIndex.push(T),
                    y.materialIndex.push(T),
                    y.materialIndex.push(T)),
                    b.normal && (y.normal.push(L[0]),
                    y.normal.push(L[1]),
                    y.normal.push(L[2]),
                    y.normal.push(L[(te - 1) * 3]),
                    y.normal.push(L[(te - 1) * 3 + 1]),
                    y.normal.push(L[(te - 1) * 3 + 2]),
                    y.normal.push(L[te * 3]),
                    y.normal.push(L[te * 3 + 1]),
                    y.normal.push(L[te * 3 + 2])),
                    b.uv && b.uv.forEach(function(Te, Ge) {
                        y.uvs[Ge] === void 0 && (y.uvs[Ge] = []),
                        y.uvs[Ge].push(j[Ge][0]),
                        y.uvs[Ge].push(j[Ge][1]),
                        y.uvs[Ge].push(j[Ge][(te - 1) * 2]),
                        y.uvs[Ge].push(j[Ge][(te - 1) * 2 + 1]),
                        y.uvs[Ge].push(j[Ge][te * 2]),
                        y.uvs[Ge].push(j[Ge][te * 2 + 1])
                    })
            }
            addMorphTargets(y, b, E, T) {
                if (E.length === 0)
                    return;
                y.morphTargetsRelative = !0,
                y.morphAttributes.position = [];
                const L = this;
                E.forEach(function(F) {
                    F.rawTargets.forEach(function(j) {
                        const W = Gt.Objects.Geometry[j.geoID];
                        W !== void 0 && L.genMorphGeometry(y, b, W, T, j.name)
                    })
                })
            }
            genMorphGeometry(y, b, E, T, L) {
                const F = b.PolygonVertexIndex !== void 0 ? b.PolygonVertexIndex.a : []
                  , j = E.Vertices !== void 0 ? E.Vertices.a : []
                  , W = E.Indexes !== void 0 ? E.Indexes.a : []
                  , re = y.attributes.position.count * 3
                  , fe = new Float32Array(re);
                for (let St = 0; St < W.length; St++) {
                    const kt = W[St] * 3;
                    fe[kt] = j[St * 3],
                    fe[kt + 1] = j[St * 3 + 1],
                    fe[kt + 2] = j[St * 3 + 2]
                }
                const te = {
                    vertexIndices: F,
                    vertexPositions: fe
                }
                  , Te = this.genBuffers(te)
                  , Ge = new m.a$l(Te.vertex,3);
                Ge.name = L || E.attrName,
                Ge.applyMatrix4(T),
                y.morphAttributes.position.push(Ge)
            }
            parseNormals(y) {
                const b = y.MappingInformationType
                  , E = y.ReferenceInformationType
                  , T = y.Normals.a;
                let L = [];
                return E === "IndexToDirect" && ("NormalIndex"in y ? L = y.NormalIndex.a : "NormalsIndex"in y && (L = y.NormalsIndex.a)),
                {
                    dataSize: 3,
                    buffer: T,
                    indices: L,
                    mappingType: b,
                    referenceType: E
                }
            }
            parseUVs(y) {
                const b = y.MappingInformationType
                  , E = y.ReferenceInformationType
                  , T = y.UV.a;
                let L = [];
                return E === "IndexToDirect" && (L = y.UVIndex.a),
                {
                    dataSize: 2,
                    buffer: T,
                    indices: L,
                    mappingType: b,
                    referenceType: E
                }
            }
            parseVertexColors(y) {
                const b = y.MappingInformationType
                  , E = y.ReferenceInformationType
                  , T = y.Colors.a;
                let L = [];
                return E === "IndexToDirect" && (L = y.ColorIndex.a),
                {
                    dataSize: 4,
                    buffer: T,
                    indices: L,
                    mappingType: b,
                    referenceType: E
                }
            }
            parseMaterialIndices(y) {
                const b = y.MappingInformationType
                  , E = y.ReferenceInformationType;
                if (b === "NoMappingInformation")
                    return {
                        dataSize: 1,
                        buffer: [0],
                        indices: [0],
                        mappingType: "AllSame",
                        referenceType: E
                    };
                const T = y.Materials.a
                  , L = [];
                for (let F = 0; F < T.length; ++F)
                    L.push(F);
                return {
                    dataSize: 1,
                    buffer: T,
                    indices: L,
                    mappingType: b,
                    referenceType: E
                }
            }
            parseNurbsGeometry(y) {
                const b = parseInt(y.Order);
                if (isNaN(b))
                    return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", y.Order, y.id),
                    new m.u9r;
                const E = b - 1
                  , T = y.KnotVector.a
                  , L = []
                  , F = y.Points.a;
                for (let te = 0, Te = F.length; te < Te; te += 4)
                    L.push(new m.Ltg().fromArray(F, te));
                let j, W;
                if (y.Form === "Closed")
                    L.push(L[0]);
                else if (y.Form === "Periodic") {
                    j = E,
                    W = T.length - 1 - j;
                    for (let te = 0; te < E; ++te)
                        L.push(L[te])
                }
                const fe = new Si(E,T,L,j,W).getPoints(L.length * 12);
                return new m.u9r().setFromPoints(fe)
            }
        }
        class Fi {
            parse() {
                const y = []
                  , b = this.parseClips();
                if (b !== void 0)
                    for (const E in b) {
                        const T = b[E]
                          , L = this.addClip(T);
                        y.push(L)
                    }
                return y
            }
            parseClips() {
                if (Gt.Objects.AnimationCurve === void 0)
                    return;
                const y = this.parseAnimationCurveNodes();
                this.parseAnimationCurves(y);
                const b = this.parseAnimationLayers(y);
                return this.parseAnimStacks(b)
            }
            parseAnimationCurveNodes() {
                const y = Gt.Objects.AnimationCurveNode
                  , b = new Map;
                for (const E in y) {
                    const T = y[E];
                    if (T.attrName.match(/S|R|T|DeformPercent/) !== null) {
                        const L = {
                            id: T.id,
                            attr: T.attrName,
                            curves: {}
                        };
                        b.set(L.id, L)
                    }
                }
                return b
            }
            parseAnimationCurves(y) {
                const b = Gt.Objects.AnimationCurve;
                for (const E in b) {
                    const T = {
                        id: b[E].id,
                        times: b[E].KeyTime.a.map(Ti),
                        values: b[E].KeyValueFloat.a
                    }
                      , L = On.get(T.id);
                    if (L !== void 0) {
                        const F = L.parents[0].ID
                          , j = L.parents[0].relationship;
                        j.match(/X/) ? y.get(F).curves.x = T : j.match(/Y/) ? y.get(F).curves.y = T : j.match(/Z/) ? y.get(F).curves.z = T : j.match(/d|DeformPercent/) && y.has(F) && (y.get(F).curves.morph = T)
                    }
                }
            }
            parseAnimationLayers(y) {
                const b = Gt.Objects.AnimationLayer
                  , E = new Map;
                for (const T in b) {
                    const L = []
                      , F = On.get(parseInt(T));
                    F !== void 0 && (F.children.forEach(function(W, re) {
                        if (y.has(W.ID)) {
                            const fe = y.get(W.ID);
                            if (fe.curves.x !== void 0 || fe.curves.y !== void 0 || fe.curves.z !== void 0) {
                                if (L[re] === void 0) {
                                    const te = On.get(W.ID).parents.filter(function(Te) {
                                        return Te.relationship !== void 0
                                    })[0].ID;
                                    if (te !== void 0) {
                                        const Te = Gt.Objects.Model[te.toString()];
                                        if (Te === void 0) {
                                            console.warn("THREE.FBXLoader: Encountered a unused curve.", W);
                                            return
                                        }
                                        const Ge = {
                                            modelName: Te.attrName ? m.iUV.sanitizeNodeName(Te.attrName) : "",
                                            ID: Te.id,
                                            initialPosition: [0, 0, 0],
                                            initialRotation: [0, 0, 0],
                                            initialScale: [1, 1, 1]
                                        };
                                        kn.traverse(function(St) {
                                            St.ID === Te.id && (Ge.transform = St.matrix,
                                            St.userData.transformData && (Ge.eulerOrder = St.userData.transformData.eulerOrder))
                                        }),
                                        Ge.transform || (Ge.transform = new m.yGw),
                                        "PreRotation"in Te && (Ge.preRotation = Te.PreRotation.value),
                                        "PostRotation"in Te && (Ge.postRotation = Te.PostRotation.value),
                                        L[re] = Ge
                                    }
                                }
                                L[re] && (L[re][fe.attr] = fe)
                            } else if (fe.curves.morph !== void 0) {
                                if (L[re] === void 0) {
                                    const te = On.get(W.ID).parents.filter(function(gt) {
                                        return gt.relationship !== void 0
                                    })[0].ID
                                      , Te = On.get(te).parents[0].ID
                                      , Ge = On.get(Te).parents[0].ID
                                      , St = On.get(Ge).parents[0].ID
                                      , kt = Gt.Objects.Model[St]
                                      , Vt = {
                                        modelName: kt.attrName ? m.iUV.sanitizeNodeName(kt.attrName) : "",
                                        morphName: Gt.Objects.Deformer[te].attrName
                                    };
                                    L[re] = Vt
                                }
                                L[re][fe.attr] = fe
                            }
                        }
                    }),
                    E.set(parseInt(T), L))
                }
                return E
            }
            parseAnimStacks(y) {
                const b = Gt.Objects.AnimationStack
                  , E = {};
                for (const T in b) {
                    const L = On.get(parseInt(T)).children;
                    L.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                    const F = y.get(L[0].ID);
                    E[T] = {
                        name: b[T].attrName,
                        layer: F
                    }
                }
                return E
            }
            addClip(y) {
                let b = [];
                const E = this;
                return y.layer.forEach(function(T) {
                    b = b.concat(E.generateTracks(T))
                }),
                new m.m7l(y.name,-1,b)
            }
            generateTracks(y) {
                const b = [];
                let E = new m.Pa4
                  , T = new m._fP
                  , L = new m.Pa4;
                if (y.transform && y.transform.decompose(E, T, L),
                E = E.toArray(),
                T = new m.USm().setFromQuaternion(T, y.eulerOrder).toArray(),
                L = L.toArray(),
                y.T !== void 0 && Object.keys(y.T.curves).length > 0) {
                    const F = this.generateVectorTrack(y.modelName, y.T.curves, E, "position");
                    F !== void 0 && b.push(F)
                }
                if (y.R !== void 0 && Object.keys(y.R.curves).length > 0) {
                    const F = this.generateRotationTrack(y.modelName, y.R.curves, T, y.preRotation, y.postRotation, y.eulerOrder);
                    F !== void 0 && b.push(F)
                }
                if (y.S !== void 0 && Object.keys(y.S.curves).length > 0) {
                    const F = this.generateVectorTrack(y.modelName, y.S.curves, L, "scale");
                    F !== void 0 && b.push(F)
                }
                if (y.DeformPercent !== void 0) {
                    const F = this.generateMorphTrack(y);
                    F !== void 0 && b.push(F)
                }
                return b
            }
            generateVectorTrack(y, b, E, T) {
                const L = this.getTimesForAllAxes(b)
                  , F = this.getKeyframeTrackValues(L, b, E);
                return new m.yC1(y + "." + T,L,F)
            }
            generateRotationTrack(y, b, E, T, L, F) {
                b.x !== void 0 && (this.interpolateRotations(b.x),
                b.x.values = b.x.values.map(m.M8C.degToRad)),
                b.y !== void 0 && (this.interpolateRotations(b.y),
                b.y.values = b.y.values.map(m.M8C.degToRad)),
                b.z !== void 0 && (this.interpolateRotations(b.z),
                b.z.values = b.z.values.map(m.M8C.degToRad));
                const j = this.getTimesForAllAxes(b)
                  , W = this.getKeyframeTrackValues(j, b, E);
                T !== void 0 && (T = T.map(m.M8C.degToRad),
                T.push(F),
                T = new m.USm().fromArray(T),
                T = new m._fP().setFromEuler(T)),
                L !== void 0 && (L = L.map(m.M8C.degToRad),
                L.push(F),
                L = new m.USm().fromArray(L),
                L = new m._fP().setFromEuler(L).invert());
                const re = new m._fP
                  , fe = new m.USm
                  , te = [];
                for (let Te = 0; Te < W.length; Te += 3)
                    fe.set(W[Te], W[Te + 1], W[Te + 2], F),
                    re.setFromEuler(fe),
                    T !== void 0 && re.premultiply(T),
                    L !== void 0 && re.multiply(L),
                    re.toArray(te, Te / 3 * 4);
                return new m.iLg(y + ".quaternion",j,te)
            }
            generateMorphTrack(y) {
                const b = y.DeformPercent.curves.morph
                  , E = b.values.map(function(L) {
                    return L / 100
                })
                  , T = kn.getObjectByName(y.modelName).morphTargetDictionary[y.morphName];
                return new m.dUE(y.modelName + ".morphTargetInfluences[" + T + "]",b.times,E)
            }
            getTimesForAllAxes(y) {
                let b = [];
                if (y.x !== void 0 && (b = b.concat(y.x.times)),
                y.y !== void 0 && (b = b.concat(y.y.times)),
                y.z !== void 0 && (b = b.concat(y.z.times)),
                b = b.sort(function(E, T) {
                    return E - T
                }),
                b.length > 1) {
                    let E = 1
                      , T = b[0];
                    for (let L = 1; L < b.length; L++) {
                        const F = b[L];
                        F !== T && (b[E] = F,
                        T = F,
                        E++)
                    }
                    b = b.slice(0, E)
                }
                return b
            }
            getKeyframeTrackValues(y, b, E) {
                const T = E
                  , L = [];
                let F = -1
                  , j = -1
                  , W = -1;
                return y.forEach(function(re) {
                    if (b.x && (F = b.x.times.indexOf(re)),
                    b.y && (j = b.y.times.indexOf(re)),
                    b.z && (W = b.z.times.indexOf(re)),
                    F !== -1) {
                        const fe = b.x.values[F];
                        L.push(fe),
                        T[0] = fe
                    } else
                        L.push(T[0]);
                    if (j !== -1) {
                        const fe = b.y.values[j];
                        L.push(fe),
                        T[1] = fe
                    } else
                        L.push(T[1]);
                    if (W !== -1) {
                        const fe = b.z.values[W];
                        L.push(fe),
                        T[2] = fe
                    } else
                        L.push(T[2])
                }),
                L
            }
            interpolateRotations(y) {
                for (let b = 1; b < y.values.length; b++) {
                    const E = y.values[b - 1]
                      , T = y.values[b] - E
                      , L = Math.abs(T);
                    if (L >= 180) {
                        const F = L / 180
                          , j = T / F;
                        let W = E + j;
                        const re = y.times[b - 1]
                          , te = (y.times[b] - re) / F;
                        let Te = re + te;
                        const Ge = []
                          , St = [];
                        for (; Te < y.times[b]; )
                            Ge.push(Te),
                            Te += te,
                            St.push(W),
                            W += j;
                        y.times = bs(y.times, b, Ge),
                        y.values = bs(y.values, b, St)
                    }
                }
            }
        }
        class vr {
            getPrevNode() {
                return this.nodeStack[this.currentIndent - 2]
            }
            getCurrentNode() {
                return this.nodeStack[this.currentIndent - 1]
            }
            getCurrentProp() {
                return this.currentProp
            }
            pushStack(y) {
                this.nodeStack.push(y),
                this.currentIndent += 1
            }
            popStack() {
                this.nodeStack.pop(),
                this.currentIndent -= 1
            }
            setCurrentProp(y, b) {
                this.currentProp = y,
                this.currentPropName = b
            }
            parse(y) {
                this.currentIndent = 0,
                this.allNodes = new Gr,
                this.nodeStack = [],
                this.currentProp = [],
                this.currentPropName = "";
                const b = this
                  , E = y.split(/[\r\n]+/);
                return E.forEach(function(T, L) {
                    const F = T.match(/^[\s\t]*;/)
                      , j = T.match(/^[\s\t]*$/);
                    if (F || j)
                        return;
                    const W = T.match("^\\t{" + b.currentIndent + "}(\\w+):(.*){", "")
                      , re = T.match("^\\t{" + b.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)")
                      , fe = T.match("^\\t{" + (b.currentIndent - 1) + "}}");
                    W ? b.parseNodeBegin(T, W) : re ? b.parseNodeProperty(T, re, E[++L]) : fe ? b.popStack() : T.match(/^[^\s\t}]/) && b.parseNodePropertyContinued(T)
                }),
                this.allNodes
            }
            parseNodeBegin(y, b) {
                const E = b[1].trim().replace(/^"/, "").replace(/"$/, "")
                  , T = b[2].split(",").map(function(W) {
                    return W.trim().replace(/^"/, "").replace(/"$/, "")
                })
                  , L = {
                    name: E
                }
                  , F = this.parseNodeAttr(T)
                  , j = this.getCurrentNode();
                this.currentIndent === 0 ? this.allNodes.add(E, L) : E in j ? (E === "PoseNode" ? j.PoseNode.push(L) : j[E].id !== void 0 && (j[E] = {},
                j[E][j[E].id] = j[E]),
                F.id !== "" && (j[E][F.id] = L)) : typeof F.id == "number" ? (j[E] = {},
                j[E][F.id] = L) : E !== "Properties70" && (E === "PoseNode" ? j[E] = [L] : j[E] = L),
                typeof F.id == "number" && (L.id = F.id),
                F.name !== "" && (L.attrName = F.name),
                F.type !== "" && (L.attrType = F.type),
                this.pushStack(L)
            }
            parseNodeAttr(y) {
                let b = y[0];
                y[0] !== "" && (b = parseInt(y[0]),
                isNaN(b) && (b = y[0]));
                let E = ""
                  , T = "";
                return y.length > 1 && (E = y[1].replace(/^(\w+)::/, ""),
                T = y[2]),
                {
                    id: b,
                    name: E,
                    type: T
                }
            }
            parseNodeProperty(y, b, E) {
                let T = b[1].replace(/^"/, "").replace(/"$/, "").trim()
                  , L = b[2].replace(/^"/, "").replace(/"$/, "").trim();
                T === "Content" && L === "," && (L = E.replace(/"/g, "").replace(/,$/, "").trim());
                const F = this.getCurrentNode();
                if (F.name === "Properties70") {
                    this.parseNodeSpecialProperty(y, T, L);
                    return
                }
                if (T === "C") {
                    const W = L.split(",").slice(1)
                      , re = parseInt(W[0])
                      , fe = parseInt(W[1]);
                    let te = L.split(",").slice(3);
                    te = te.map(function(Te) {
                        return Te.trim().replace(/^"/, "")
                    }),
                    T = "connections",
                    L = [re, fe],
                    Fr(L, te),
                    F[T] === void 0 && (F[T] = [])
                }
                T === "Node" && (F.id = L),
                T in F && Array.isArray(F[T]) ? F[T].push(L) : T !== "a" ? F[T] = L : F.a = L,
                this.setCurrentProp(F, T),
                T === "a" && L.slice(-1) !== "," && (F.a = Us(L))
            }
            parseNodePropertyContinued(y) {
                const b = this.getCurrentNode();
                b.a += y,
                y.slice(-1) !== "," && (b.a = Us(b.a))
            }
            parseNodeSpecialProperty(y, b, E) {
                const T = E.split('",').map(function(fe) {
                    return fe.trim().replace(/^\"/, "").replace(/\s/, "_")
                })
                  , L = T[0]
                  , F = T[1]
                  , j = T[2]
                  , W = T[3];
                let re = T[4];
                switch (F) {
                case "int":
                case "enum":
                case "bool":
                case "ULongLong":
                case "double":
                case "Number":
                case "FieldOfView":
                    re = parseFloat(re);
                    break;
                case "Color":
                case "ColorRGB":
                case "Vector3D":
                case "Lcl_Translation":
                case "Lcl_Rotation":
                case "Lcl_Scaling":
                    re = Us(re);
                    break
                }
                this.getPrevNode()[L] = {
                    type: F,
                    type2: j,
                    flag: W,
                    value: re
                },
                this.setCurrentProp(this.getPrevNode(), L)
            }
        }
        class Oi {
            parse(y) {
                const b = new ts(y);
                b.skip(23);
                const E = b.getUint32();
                if (E < 6400)
                    throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + E);
                const T = new Gr;
                for (; !this.endOfContent(b); ) {
                    const L = this.parseNode(b, E);
                    L !== null && T.add(L.name, L)
                }
                return T
            }
            endOfContent(y) {
                return y.size() % 16 === 0 ? (y.getOffset() + 160 + 16 & -16) >= y.size() : y.getOffset() + 160 + 16 >= y.size()
            }
            parseNode(y, b) {
                const E = {}
                  , T = b >= 7500 ? y.getUint64() : y.getUint32()
                  , L = b >= 7500 ? y.getUint64() : y.getUint32();
                b >= 7500 ? y.getUint64() : y.getUint32();
                const F = y.getUint8()
                  , j = y.getString(F);
                if (T === 0)
                    return null;
                const W = [];
                for (let Te = 0; Te < L; Te++)
                    W.push(this.parseProperty(y));
                const re = W.length > 0 ? W[0] : ""
                  , fe = W.length > 1 ? W[1] : ""
                  , te = W.length > 2 ? W[2] : "";
                for (E.singleProperty = L === 1 && y.getOffset() === T; T > y.getOffset(); ) {
                    const Te = this.parseNode(y, b);
                    Te !== null && this.parseSubNode(j, E, Te)
                }
                return E.propertyList = W,
                typeof re == "number" && (E.id = re),
                fe !== "" && (E.attrName = fe),
                te !== "" && (E.attrType = te),
                j !== "" && (E.name = j),
                E
            }
            parseSubNode(y, b, E) {
                if (E.singleProperty === !0) {
                    const T = E.propertyList[0];
                    Array.isArray(T) ? (b[E.name] = E,
                    E.a = T) : b[E.name] = T
                } else if (y === "Connections" && E.name === "C") {
                    const T = [];
                    E.propertyList.forEach(function(L, F) {
                        F !== 0 && T.push(L)
                    }),
                    b.connections === void 0 && (b.connections = []),
                    b.connections.push(T)
                } else if (E.name === "Properties70")
                    Object.keys(E).forEach(function(L) {
                        b[L] = E[L]
                    });
                else if (y === "Properties70" && E.name === "P") {
                    let T = E.propertyList[0]
                      , L = E.propertyList[1];
                    const F = E.propertyList[2]
                      , j = E.propertyList[3];
                    let W;
                    T.indexOf("Lcl ") === 0 && (T = T.replace("Lcl ", "Lcl_")),
                    L.indexOf("Lcl ") === 0 && (L = L.replace("Lcl ", "Lcl_")),
                    L === "Color" || L === "ColorRGB" || L === "Vector" || L === "Vector3D" || L.indexOf("Lcl_") === 0 ? W = [E.propertyList[4], E.propertyList[5], E.propertyList[6]] : W = E.propertyList[4],
                    b[T] = {
                        type: L,
                        type2: F,
                        flag: j,
                        value: W
                    }
                } else
                    b[E.name] === void 0 ? typeof E.id == "number" ? (b[E.name] = {},
                    b[E.name][E.id] = E) : b[E.name] = E : E.name === "PoseNode" ? (Array.isArray(b[E.name]) || (b[E.name] = [b[E.name]]),
                    b[E.name].push(E)) : b[E.name][E.id] === void 0 && (b[E.name][E.id] = E)
            }
            parseProperty(y) {
                const b = y.getString(1);
                let E;
                switch (b) {
                case "C":
                    return y.getBoolean();
                case "D":
                    return y.getFloat64();
                case "F":
                    return y.getFloat32();
                case "I":
                    return y.getInt32();
                case "L":
                    return y.getInt64();
                case "R":
                    return E = y.getUint32(),
                    y.getArrayBuffer(E);
                case "S":
                    return E = y.getUint32(),
                    y.getString(E);
                case "Y":
                    return y.getInt16();
                case "b":
                case "c":
                case "d":
                case "f":
                case "i":
                case "l":
                    const T = y.getUint32()
                      , L = y.getUint32()
                      , F = y.getUint32();
                    if (L === 0)
                        switch (b) {
                        case "b":
                        case "c":
                            return y.getBooleanArray(T);
                        case "d":
                            return y.getFloat64Array(T);
                        case "f":
                            return y.getFloat32Array(T);
                        case "i":
                            return y.getInt32Array(T);
                        case "l":
                            return y.getInt64Array(T)
                        }
                    const j = Xt(new Uint8Array(y.getArrayBuffer(F)))
                      , W = new ts(j.buffer);
                    switch (b) {
                    case "b":
                    case "c":
                        return W.getBooleanArray(T);
                    case "d":
                        return W.getFloat64Array(T);
                    case "f":
                        return W.getFloat32Array(T);
                    case "i":
                        return W.getInt32Array(T);
                    case "l":
                        return W.getInt64Array(T)
                    }
                    break;
                default:
                    throw new Error("THREE.FBXLoader: Unknown property type " + b)
                }
            }
        }
        class ts {
            constructor(y, b) {
                this.dv = new DataView(y),
                this.offset = 0,
                this.littleEndian = b !== void 0 ? b : !0,
                this._textDecoder = new TextDecoder
            }
            getOffset() {
                return this.offset
            }
            size() {
                return this.dv.buffer.byteLength
            }
            skip(y) {
                this.offset += y
            }
            getBoolean() {
                return (this.getUint8() & 1) === 1
            }
            getBooleanArray(y) {
                const b = [];
                for (let E = 0; E < y; E++)
                    b.push(this.getBoolean());
                return b
            }
            getUint8() {
                const y = this.dv.getUint8(this.offset);
                return this.offset += 1,
                y
            }
            getInt16() {
                const y = this.dv.getInt16(this.offset, this.littleEndian);
                return this.offset += 2,
                y
            }
            getInt32() {
                const y = this.dv.getInt32(this.offset, this.littleEndian);
                return this.offset += 4,
                y
            }
            getInt32Array(y) {
                const b = [];
                for (let E = 0; E < y; E++)
                    b.push(this.getInt32());
                return b
            }
            getUint32() {
                const y = this.dv.getUint32(this.offset, this.littleEndian);
                return this.offset += 4,
                y
            }
            getInt64() {
                let y, b;
                return this.littleEndian ? (y = this.getUint32(),
                b = this.getUint32()) : (b = this.getUint32(),
                y = this.getUint32()),
                b & 2147483648 ? (b = ~b & 4294967295,
                y = ~y & 4294967295,
                y === 4294967295 && (b = b + 1 & 4294967295),
                y = y + 1 & 4294967295,
                -(b * 4294967296 + y)) : b * 4294967296 + y
            }
            getInt64Array(y) {
                const b = [];
                for (let E = 0; E < y; E++)
                    b.push(this.getInt64());
                return b
            }
            getUint64() {
                let y, b;
                return this.littleEndian ? (y = this.getUint32(),
                b = this.getUint32()) : (b = this.getUint32(),
                y = this.getUint32()),
                b * 4294967296 + y
            }
            getFloat32() {
                const y = this.dv.getFloat32(this.offset, this.littleEndian);
                return this.offset += 4,
                y
            }
            getFloat32Array(y) {
                const b = [];
                for (let E = 0; E < y; E++)
                    b.push(this.getFloat32());
                return b
            }
            getFloat64() {
                const y = this.dv.getFloat64(this.offset, this.littleEndian);
                return this.offset += 8,
                y
            }
            getFloat64Array(y) {
                const b = [];
                for (let E = 0; E < y; E++)
                    b.push(this.getFloat64());
                return b
            }
            getArrayBuffer(y) {
                const b = this.dv.buffer.slice(this.offset, this.offset + y);
                return this.offset += y,
                b
            }
            getString(y) {
                const b = this.offset;
                let E = new Uint8Array(this.dv.buffer,b,y);
                this.skip(y);
                const T = E.indexOf(0);
                return T >= 0 && (E = new Uint8Array(this.dv.buffer,b,T)),
                this._textDecoder.decode(E)
            }
        }
        class Gr {
            add(y, b) {
                this[y] = b
            }
        }
        function ys(ae) {
            const y = "Kaydara FBX Binary  \0";
            return ae.byteLength >= y.length && y === Ba(ae, 0, y.length)
        }
        function xs(ae) {
            const y = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
            let b = 0;
            function E(T) {
                const L = ae[T - 1];
                return ae = ae.slice(b + T),
                b++,
                L
            }
            for (let T = 0; T < y.length; ++T)
                if (E(1) === y[T])
                    return !1;
            return !0
        }
        function hi(ae) {
            const y = /FBXVersion: (\d+)/
              , b = ae.match(y);
            if (b)
                return parseInt(b[1]);
            throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
        }
        function Ti(ae) {
            return ae / 46186158e3
        }
        const gi = [];
        function qi(ae, y, b, E) {
            let T;
            switch (E.mappingType) {
            case "ByPolygonVertex":
                T = ae;
                break;
            case "ByPolygon":
                T = y;
                break;
            case "ByVertice":
                T = b;
                break;
            case "AllSame":
                T = E.indices[0];
                break;
            default:
                console.warn("THREE.FBXLoader: unknown attribute mapping type " + E.mappingType)
            }
            E.referenceType === "IndexToDirect" && (T = E.indices[T]);
            const L = T * E.dataSize
              , F = L + E.dataSize;
            return Ns(gi, E.buffer, L, F)
        }
        const ks = new m.USm
          , Gi = new m.Pa4;
        function Ao(ae) {
            const y = new m.yGw
              , b = new m.yGw
              , E = new m.yGw
              , T = new m.yGw
              , L = new m.yGw
              , F = new m.yGw
              , j = new m.yGw
              , W = new m.yGw
              , re = new m.yGw
              , fe = new m.yGw
              , te = new m.yGw
              , Te = new m.yGw
              , Ge = ae.inheritType ? ae.inheritType : 0;
            if (ae.translation && y.setPosition(Gi.fromArray(ae.translation)),
            ae.preRotation) {
                const Hn = ae.preRotation.map(m.M8C.degToRad);
                Hn.push(ae.eulerOrder || m.USm.DEFAULT_ORDER),
                b.makeRotationFromEuler(ks.fromArray(Hn))
            }
            if (ae.rotation) {
                const Hn = ae.rotation.map(m.M8C.degToRad);
                Hn.push(ae.eulerOrder || m.USm.DEFAULT_ORDER),
                E.makeRotationFromEuler(ks.fromArray(Hn))
            }
            if (ae.postRotation) {
                const Hn = ae.postRotation.map(m.M8C.degToRad);
                Hn.push(ae.eulerOrder || m.USm.DEFAULT_ORDER),
                T.makeRotationFromEuler(ks.fromArray(Hn)),
                T.invert()
            }
            ae.scale && L.scale(Gi.fromArray(ae.scale)),
            ae.scalingOffset && j.setPosition(Gi.fromArray(ae.scalingOffset)),
            ae.scalingPivot && F.setPosition(Gi.fromArray(ae.scalingPivot)),
            ae.rotationOffset && W.setPosition(Gi.fromArray(ae.rotationOffset)),
            ae.rotationPivot && re.setPosition(Gi.fromArray(ae.rotationPivot)),
            ae.parentMatrixWorld && (te.copy(ae.parentMatrix),
            fe.copy(ae.parentMatrixWorld));
            const St = b.clone().multiply(E).multiply(T)
              , kt = new m.yGw;
            kt.extractRotation(fe);
            const Vt = new m.yGw;
            Vt.copyPosition(fe);
            const gt = Vt.clone().invert().multiply(fe)
              , xt = kt.clone().invert().multiply(gt)
              , Xe = L
              , ut = new m.yGw;
            if (Ge === 0)
                ut.copy(kt).multiply(St).multiply(xt).multiply(Xe);
            else if (Ge === 1)
                ut.copy(kt).multiply(xt).multiply(St).multiply(Xe);
            else {
                const En = new m.yGw().scale(new m.Pa4().setFromMatrixScale(te)).clone().invert()
                  , Ei = xt.clone().multiply(En);
                ut.copy(kt).multiply(St).multiply(Ei).multiply(Xe)
            }
            const dn = re.clone().invert()
              , qt = F.clone().invert();
            let ln = y.clone().multiply(W).multiply(re).multiply(b).multiply(E).multiply(T).multiply(dn).multiply(j).multiply(F).multiply(L).multiply(qt);
            const Tn = new m.yGw().copyPosition(ln)
              , fn = fe.clone().multiply(Tn);
            return Te.copyPosition(fn),
            ln = Te.clone().multiply(ut),
            ln.premultiply(fe.invert()),
            ln
        }
        function Hi(ae) {
            ae = ae || 0;
            const y = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
            return ae === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),
            y[0]) : y[ae]
        }
        function Us(ae) {
            return ae.split(",").map(function(b) {
                return parseFloat(b)
            })
        }
        function Ba(ae, y, b) {
            return y === void 0 && (y = 0),
            b === void 0 && (b = ae.byteLength),
            new TextDecoder().decode(new Uint8Array(ae,y,b))
        }
        function Fr(ae, y) {
            for (let b = 0, E = ae.length, T = y.length; b < T; b++,
            E++)
                ae[E] = y[b]
        }
        function Ns(ae, y, b, E) {
            for (let T = b, L = 0; T < E; T++,
            L++)
                ae[L] = y[T];
            return ae
        }
        function bs(ae, y, b) {
            return ae.slice(0, y).concat(b).concat(ae.slice(y))
        }
        var jo = r(774);
        class us extends s.g {
            constructor() {
                super(...arguments);
                B(this, "extensions", ["fbx"])
            }
            load({url: b, file: E, onLoad: T, onProgress: L, onError: F}) {
                const j = W=>{
                    Object.assign(W.meshData, (0,
                    jo.tQ)(W)),
                    T(W)
                }
                ;
                new bi(this.viewer.loadingManager).load(b, j, L, F, E)
            }
        }
        const ha = new WeakMap;
        class da extends m.aNw {
            constructor(y) {
                super(y),
                this.decoderPath = "",
                this.decoderConfig = {},
                this.decoderBinary = null,
                this.decoderPending = null,
                this.workerLimit = 4,
                this.workerPool = [],
                this.workerNextTaskID = 1,
                this.workerSourceURL = "",
                this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                },
                this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(y) {
                return this.decoderPath = y,
                this
            }
            setDecoderConfig(y) {
                return this.decoderConfig = y,
                this
            }
            setWorkerLimit(y) {
                return this.workerLimit = y,
                this
            }
            load(y, b, E, T) {
                const L = new m.hH6(this.manager);
                L.setPath(this.path),
                L.setResponseType("arraybuffer"),
                L.setRequestHeader(this.requestHeader),
                L.setWithCredentials(this.withCredentials),
                L.load(y, F=>{
                    this.parse(F, b, T)
                }
                , E, T)
            }
            parse(y, b, E) {
                this.decodeDracoFile(y, b, null, null, m.KI_).catch(E)
            }
            decodeDracoFile(y, b, E, T, L=m.GUF) {
                const F = {
                    attributeIDs: E || this.defaultAttributeIDs,
                    attributeTypes: T || this.defaultAttributeTypes,
                    useUniqueIDs: !!E,
                    vertexColorSpace: L
                };
                return this.decodeGeometry(y, F).then(b)
            }
            decodeGeometry(y, b) {
                const E = JSON.stringify(b);
                if (ha.has(y)) {
                    const W = ha.get(y);
                    if (W.key === E)
                        return W.promise;
                    if (y.byteLength === 0)
                        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let T;
                const L = this.workerNextTaskID++
                  , F = y.byteLength
                  , j = this._getWorker(L, F).then(W=>(T = W,
                new Promise((re,fe)=>{
                    T._callbacks[L] = {
                        resolve: re,
                        reject: fe
                    },
                    T.postMessage({
                        type: "decode",
                        id: L,
                        taskConfig: b,
                        buffer: y
                    }, [y])
                }
                ))).then(W=>this._createGeometry(W.geometry));
                return j.catch(()=>!0).then(()=>{
                    T && L && this._releaseTask(T, L)
                }
                ),
                ha.set(y, {
                    key: E,
                    promise: j
                }),
                j
            }
            _createGeometry(y) {
                const b = new m.u9r;
                y.index && b.setIndex(new m.TlE(y.index.array,1));
                for (let E = 0; E < y.attributes.length; E++) {
                    const T = y.attributes[E]
                      , L = T.name
                      , F = T.array
                      , j = T.itemSize
                      , W = new m.TlE(F,j);
                    L === "color" && this._assignVertexColorSpace(W, T.vertexColorSpace),
                    b.setAttribute(L, W)
                }
                return b
            }
            _assignVertexColorSpace(y, b) {
                if (b !== m.KI_)
                    return;
                const E = new m.Ilk;
                for (let T = 0, L = y.count; T < L; T++)
                    E.fromBufferAttribute(y, T).convertSRGBToLinear(),
                    y.setXYZ(T, E.r, E.g, E.b)
            }
            _loadLibrary(y, b) {
                const E = new m.hH6(this.manager);
                return E.setPath(this.decoderPath),
                E.setResponseType(b),
                E.setWithCredentials(this.withCredentials),
                new Promise((T,L)=>{
                    E.load(y, T, void 0, L)
                }
                )
            }
            preload() {
                return this._initDecoder(),
                this
            }
            _initDecoder() {
                if (this.decoderPending)
                    return this.decoderPending;
                const y = typeof WebAssembly != "object" || this.decoderConfig.type === "js"
                  , b = [];
                return y ? b.push(this._loadLibrary("draco_decoder.js", "text")) : (b.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                b.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                this.decoderPending = Promise.all(b).then(E=>{
                    const T = E[0];
                    y || (this.decoderConfig.wasmBinary = E[1]);
                    const L = uo.toString()
                      , F = ["/* draco decoder */", T, "", "/* worker */", L.substring(L.indexOf("{") + 1, L.lastIndexOf("}"))].join(`
`);
                    this.workerSourceURL = URL.createObjectURL(new Blob([F]))
                }
                ),
                this.decoderPending
            }
            _getWorker(y, b) {
                return this._initDecoder().then(()=>{
                    if (this.workerPool.length < this.workerLimit) {
                        const T = new Worker(this.workerSourceURL);
                        T._callbacks = {},
                        T._taskCosts = {},
                        T._taskLoad = 0,
                        T.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }),
                        T.onmessage = function(L) {
                            const F = L.data;
                            switch (F.type) {
                            case "decode":
                                T._callbacks[F.id].resolve(F);
                                break;
                            case "error":
                                T._callbacks[F.id].reject(F);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + F.type + '"')
                            }
                        }
                        ,
                        this.workerPool.push(T)
                    } else
                        this.workerPool.sort(function(T, L) {
                            return T._taskLoad > L._taskLoad ? -1 : 1
                        });
                    const E = this.workerPool[this.workerPool.length - 1];
                    return E._taskCosts[y] = b,
                    E._taskLoad += b,
                    E
                }
                )
            }
            _releaseTask(y, b) {
                y._taskLoad -= y._taskCosts[b],
                delete y._callbacks[b],
                delete y._taskCosts[b]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map(y=>y._taskLoad))
            }
            dispose() {
                for (let y = 0; y < this.workerPool.length; ++y)
                    this.workerPool[y].terminate();
                return this.workerPool.length = 0,
                this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL),
                this
            }
        }
        function uo() {
            let ae, y;
            onmessage = function(F) {
                const j = F.data;
                switch (j.type) {
                case "init":
                    ae = j.decoderConfig,
                    y = new Promise(function(fe) {
                        ae.onModuleLoaded = function(te) {
                            fe({
                                draco: te
                            })
                        }
                        ,
                        DracoDecoderModule(ae)
                    }
                    );
                    break;
                case "decode":
                    const W = j.buffer
                      , re = j.taskConfig;
                    y.then(fe=>{
                        const te = fe.draco
                          , Te = new te.Decoder;
                        try {
                            const Ge = b(te, Te, new Int8Array(W), re)
                              , St = Ge.attributes.map(kt=>kt.array.buffer);
                            Ge.index && St.push(Ge.index.array.buffer),
                            self.postMessage({
                                type: "decode",
                                id: j.id,
                                geometry: Ge
                            }, St)
                        } catch (Ge) {
                            console.error(Ge),
                            self.postMessage({
                                type: "error",
                                id: j.id,
                                error: Ge.message
                            })
                        } finally {
                            te.destroy(Te)
                        }
                    }
                    );
                    break
                }
            }
            ;
            function b(F, j, W, re) {
                const fe = re.attributeIDs
                  , te = re.attributeTypes;
                let Te, Ge;
                const St = j.GetEncodedGeometryType(W);
                if (St === F.TRIANGULAR_MESH)
                    Te = new F.Mesh,
                    Ge = j.DecodeArrayToMesh(W, W.byteLength, Te);
                else if (St === F.POINT_CLOUD)
                    Te = new F.PointCloud,
                    Ge = j.DecodeArrayToPointCloud(W, W.byteLength, Te);
                else
                    throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                if (!Ge.ok() || Te.ptr === 0)
                    throw new Error("THREE.DRACOLoader: Decoding failed: " + Ge.error_msg());
                const kt = {
                    index: null,
                    attributes: []
                };
                for (const Vt in fe) {
                    const gt = self[te[Vt]];
                    let xt, Xe;
                    if (re.useUniqueIDs)
                        Xe = fe[Vt],
                        xt = j.GetAttributeByUniqueId(Te, Xe);
                    else {
                        if (Xe = j.GetAttributeId(Te, F[fe[Vt]]),
                        Xe === -1)
                            continue;
                        xt = j.GetAttribute(Te, Xe)
                    }
                    const ut = T(F, j, Te, Vt, gt, xt);
                    Vt === "color" && (ut.vertexColorSpace = re.vertexColorSpace),
                    kt.attributes.push(ut)
                }
                return St === F.TRIANGULAR_MESH && (kt.index = E(F, j, Te)),
                F.destroy(Te),
                kt
            }
            function E(F, j, W) {
                const fe = W.num_faces() * 3
                  , te = fe * 4
                  , Te = F._malloc(te);
                j.GetTrianglesUInt32Array(W, te, Te);
                const Ge = new Uint32Array(F.HEAPF32.buffer,Te,fe).slice();
                return F._free(Te),
                {
                    array: Ge,
                    itemSize: 1
                }
            }
            function T(F, j, W, re, fe, te) {
                const Te = te.num_components()
                  , St = W.num_points() * Te
                  , kt = St * fe.BYTES_PER_ELEMENT
                  , Vt = L(F, fe)
                  , gt = F._malloc(kt);
                j.GetAttributeDataArrayForAllPoints(W, te, Vt, kt, gt);
                const xt = new fe(F.HEAPF32.buffer,gt,St).slice();
                return F._free(gt),
                {
                    name: re,
                    array: xt,
                    itemSize: Te
                }
            }
            function L(F, j) {
                switch (j) {
                case Float32Array:
                    return F.DT_FLOAT32;
                case Int8Array:
                    return F.DT_INT8;
                case Int16Array:
                    return F.DT_INT16;
                case Int32Array:
                    return F.DT_INT32;
                case Uint8Array:
                    return F.DT_UINT8;
                case Uint16Array:
                    return F.DT_UINT16;
                case Uint32Array:
                    return F.DT_UINT32
                }
            }
        }
        var Js = r(980);
        function So(ae, y) {
            if (y === m.WwZ)
                return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
                ae;
            if (y === m.z$h || y === m.UlW) {
                let b = ae.getIndex();
                if (b === null) {
                    const F = []
                      , j = ae.getAttribute("position");
                    if (j !== void 0) {
                        for (let W = 0; W < j.count; W++)
                            F.push(W);
                        ae.setIndex(F),
                        b = ae.getIndex()
                    } else
                        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                        ae
                }
                const E = b.count - 2
                  , T = [];
                if (y === m.z$h)
                    for (let F = 1; F <= E; F++)
                        T.push(b.getX(0)),
                        T.push(b.getX(F)),
                        T.push(b.getX(F + 1));
                else
                    for (let F = 0; F < E; F++)
                        F % 2 === 0 ? (T.push(b.getX(F)),
                        T.push(b.getX(F + 1)),
                        T.push(b.getX(F + 2))) : (T.push(b.getX(F + 2)),
                        T.push(b.getX(F + 1)),
                        T.push(b.getX(F)));
                T.length / 3 !== E && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const L = ae.clone();
                return L.setIndex(T),
                L.clearGroups(),
                L
            } else
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", y),
                ae
        }
        class Fa extends m.aNw {
            constructor(y) {
                super(y),
                this.dracoLoader = null,
                this.ktx2Loader = null,
                this.meshoptDecoder = null,
                this.pluginCallbacks = [],
                this.register(function(b) {
                    return new al(b)
                }),
                this.register(function(b) {
                    return new ul(b)
                }),
                this.register(function(b) {
                    return new ka(b)
                }),
                this.register(function(b) {
                    return new Ua(b)
                }),
                this.register(function(b) {
                    return new ho(b)
                }),
                this.register(function(b) {
                    return new Xl(b)
                }),
                this.register(function(b) {
                    return new ll(b)
                }),
                this.register(function(b) {
                    return new cl(b)
                }),
                this.register(function(b) {
                    return new ol(b)
                }),
                this.register(function(b) {
                    return new fa(b)
                }),
                this.register(function(b) {
                    return new $s(b)
                }),
                this.register(function(b) {
                    return new jl(b)
                }),
                this.register(function(b) {
                    return new Na(b)
                }),
                this.register(function(b) {
                    return new pa(b)
                })
            }
            load(y, b, E, T, L) {
                const F = this;
                let j;
                this.resourcePath !== "" ? j = this.resourcePath : this.path !== "" ? j = this.path : j = m.Zp0.extractUrlBase(y),
                this.manager.itemStart(y);
                const W = function(fe) {
                    T ? T(fe) : console.error(fe),
                    F.manager.itemError(y),
                    F.manager.itemEnd(y)
                }
                  , re = new m.hH6(this.manager);
                re.setPath(this.path),
                re.setResponseType("arraybuffer"),
                re.setRequestHeader(this.requestHeader),
                re.setWithCredentials(this.withCredentials),
                re.load(y, function(fe) {
                    try {
                        F.parse(fe, j, function(te) {
                            b(te),
                            F.manager.itemEnd(y)
                        }, W, L == null ? void 0 : L.additionalFiles)
                    } catch (te) {
                        W(te)
                    }
                }, E, W, L == null ? void 0 : L.mainFile)
            }
            setDRACOLoader(y) {
                return this.dracoLoader = y,
                this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(y) {
                return this.ktx2Loader = y,
                this
            }
            setMeshoptDecoder(y) {
                return this.meshoptDecoder = y,
                this
            }
            register(y) {
                return this.pluginCallbacks.indexOf(y) === -1 && this.pluginCallbacks.push(y),
                this
            }
            unregister(y) {
                return this.pluginCallbacks.indexOf(y) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(y), 1),
                this
            }
            parse(y, b, E, T, L) {
                let F;
                const j = {}
                  , W = {}
                  , re = new TextDecoder;
                if (typeof y == "string")
                    F = JSON.parse(y);
                else if (y instanceof ArrayBuffer) {
                    const te = new Uint8Array(y,0,4).join("");
                    if (te === ma || te === nr) {
                        try {
                            j[ti.KHR_BINARY_GLTF] = new dl(y)
                        } catch (Te) {
                            T && T(Te);
                            return
                        }
                        F = JSON.parse(j[ti.KHR_BINARY_GLTF].content)
                    } else
                        F = JSON.parse(re.decode(y))
                } else
                    F = y;
                if (F.asset === void 0 || F.asset.version[0] < 2) {
                    T && T(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                    return
                }
                const fe = new p(F,{
                    path: b || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                fe.fileLoader.setRequestHeader(this.requestHeader);
                for (let te = 0; te < this.pluginCallbacks.length; te++) {
                    const Te = this.pluginCallbacks[te](fe);
                    W[Te.name] = Te,
                    j[Te.name] = !0
                }
                if (F.extensionsUsed)
                    for (let te = 0; te < F.extensionsUsed.length; ++te) {
                        const Te = F.extensionsUsed[te]
                          , Ge = F.extensionsRequired || [];
                        switch (Te) {
                        case ti.KHR_MATERIALS_UNLIT:
                            j[Te] = new Xr;
                            break;
                        case ti.KHR_DRACO_MESH_COMPRESSION:
                            j[Te] = new fl(F,this.dracoLoader);
                            break;
                        case ti.KHR_TEXTURE_TRANSFORM:
                            j[Te] = new pl;
                            break;
                        case ti.KHR_MESH_QUANTIZATION:
                            j[Te] = new ga;
                            break;
                        default:
                            Ge.indexOf(Te) >= 0 && W[Te] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + Te + '".')
                        }
                    }
                F.additionalFiles = L,
                fe.setExtensions(j),
                fe.setPlugins(W),
                fe.parse(E, T)
            }
            parseAsync(y, b) {
                const E = this;
                return new Promise(function(T, L) {
                    E.parse(y, b, T, L)
                }
                )
            }
        }
        function Wl() {
            let ae = {};
            return {
                get: function(y) {
                    return ae[y]
                },
                add: function(y, b) {
                    ae[y] = b
                },
                remove: function(y) {
                    delete ae[y]
                },
                removeAll: function() {
                    ae = {}
                }
            }
        }
        const ti = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class jl {
            constructor(y) {
                this.parser = y,
                this.name = ti.KHR_LIGHTS_PUNCTUAL,
                this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const y = this.parser
                  , b = this.parser.json.nodes || [];
                for (let E = 0, T = b.length; E < T; E++) {
                    const L = b[E];
                    L.extensions && L.extensions[this.name] && L.extensions[this.name].light !== void 0 && y._addNodeRef(this.cache, L.extensions[this.name].light)
                }
            }
            _loadLight(y) {
                const b = this.parser
                  , E = "light:" + y;
                let T = b.cache.get(E);
                if (T)
                    return T;
                const L = b.json
                  , W = ((L.extensions && L.extensions[this.name] || {}).lights || [])[y];
                let re;
                const fe = new m.Ilk(16777215);
                W.color !== void 0 && fe.fromArray(W.color);
                const te = W.range !== void 0 ? W.range : 0;
                switch (W.type) {
                case "directional":
                    re = new m.Ox3(fe),
                    re.target.position.set(0, 0, -1),
                    re.add(re.target);
                    break;
                case "point":
                    re = new m.cek(fe),
                    re.distance = te;
                    break;
                case "spot":
                    re = new m.PMe(fe),
                    re.distance = te,
                    W.spot = W.spot || {},
                    W.spot.innerConeAngle = W.spot.innerConeAngle !== void 0 ? W.spot.innerConeAngle : 0,
                    W.spot.outerConeAngle = W.spot.outerConeAngle !== void 0 ? W.spot.outerConeAngle : Math.PI / 4,
                    re.angle = W.spot.outerConeAngle,
                    re.penumbra = 1 - W.spot.innerConeAngle / W.spot.outerConeAngle,
                    re.target.position.set(0, 0, -1),
                    re.add(re.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + W.type)
                }
                return re.position.set(0, 0, 0),
                re.decay = 2,
                ns(re, W),
                W.intensity !== void 0 && (re.intensity = W.intensity),
                re.name = b.createUniqueName(W.name || "light_" + y),
                T = Promise.resolve(re),
                b.cache.add(E, T),
                T
            }
            getDependency(y, b) {
                if (y === "light")
                    return this._loadLight(b)
            }
            createNodeAttachment(y) {
                const b = this
                  , E = this.parser
                  , L = E.json.nodes[y]
                  , j = (L.extensions && L.extensions[this.name] || {}).light;
                return j === void 0 ? null : this._loadLight(j).then(function(W) {
                    return E._getNodeRef(b.cache, j, W)
                })
            }
        }
        class Xr {
            constructor() {
                this.name = ti.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return m.vBJ
            }
            extendParams(y, b, E) {
                const T = [];
                y.color = new m.Ilk(1,1,1),
                y.opacity = 1;
                const L = b.pbrMetallicRoughness;
                if (L) {
                    if (Array.isArray(L.baseColorFactor)) {
                        const F = L.baseColorFactor;
                        y.color.fromArray(F),
                        y.opacity = F[3]
                    }
                    L.baseColorTexture !== void 0 && T.push(E.assignTexture(y, "map", L.baseColorTexture, m.knz))
                }
                return Promise.all(T)
            }
        }
        class ol {
            constructor(y) {
                this.parser = y,
                this.name = ti.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(y, b) {
                const T = this.parser.json.materials[y];
                if (!T.extensions || !T.extensions[this.name])
                    return Promise.resolve();
                const L = T.extensions[this.name].emissiveStrength;
                return L !== void 0 && (b.emissiveIntensity = L),
                Promise.resolve()
            }
        }
        class al {
            constructor(y) {
                this.parser = y,
                this.name = ti.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(y) {
                const E = this.parser.json.materials[y];
                return !E.extensions || !E.extensions[this.name] ? null : m.EJi
            }
            extendMaterialParams(y, b) {
                const E = this.parser
                  , T = E.json.materials[y];
                if (!T.extensions || !T.extensions[this.name])
                    return Promise.resolve();
                const L = []
                  , F = T.extensions[this.name];
                if (F.clearcoatFactor !== void 0 && (b.clearcoat = F.clearcoatFactor),
                F.clearcoatTexture !== void 0 && L.push(E.assignTexture(b, "clearcoatMap", F.clearcoatTexture)),
                F.clearcoatRoughnessFactor !== void 0 && (b.clearcoatRoughness = F.clearcoatRoughnessFactor),
                F.clearcoatRoughnessTexture !== void 0 && L.push(E.assignTexture(b, "clearcoatRoughnessMap", F.clearcoatRoughnessTexture)),
                F.clearcoatNormalTexture !== void 0 && (L.push(E.assignTexture(b, "clearcoatNormalMap", F.clearcoatNormalTexture)),
                F.clearcoatNormalTexture.scale !== void 0)) {
                    const j = F.clearcoatNormalTexture.scale;
                    b.clearcoatNormalScale = new m.FM8(j,j)
                }
                return Promise.all(L)
            }
        }
        class $s {
            constructor(y) {
                this.parser = y,
                this.name = ti.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(y) {
                const E = this.parser.json.materials[y];
                return !E.extensions || !E.extensions[this.name] ? null : m.EJi
            }
            extendMaterialParams(y, b) {
                const E = this.parser
                  , T = E.json.materials[y];
                if (!T.extensions || !T.extensions[this.name])
                    return Promise.resolve();
                const L = []
                  , F = T.extensions[this.name];
                return F.iridescenceFactor !== void 0 && (b.iridescence = F.iridescenceFactor),
                F.iridescenceTexture !== void 0 && L.push(E.assignTexture(b, "iridescenceMap", F.iridescenceTexture)),
                F.iridescenceIor !== void 0 && (b.iridescenceIOR = F.iridescenceIor),
                b.iridescenceThicknessRange === void 0 && (b.iridescenceThicknessRange = [100, 400]),
                F.iridescenceThicknessMinimum !== void 0 && (b.iridescenceThicknessRange[0] = F.iridescenceThicknessMinimum),
                F.iridescenceThicknessMaximum !== void 0 && (b.iridescenceThicknessRange[1] = F.iridescenceThicknessMaximum),
                F.iridescenceThicknessTexture !== void 0 && L.push(E.assignTexture(b, "iridescenceThicknessMap", F.iridescenceThicknessTexture)),
                Promise.all(L)
            }
        }
        class ho {
            constructor(y) {
                this.parser = y,
                this.name = ti.KHR_MATERIALS_SHEEN
            }
            getMaterialType(y) {
                const E = this.parser.json.materials[y];
                return !E.extensions || !E.extensions[this.name] ? null : m.EJi
            }
            extendMaterialParams(y, b) {
                const E = this.parser
                  , T = E.json.materials[y];
                if (!T.extensions || !T.extensions[this.name])
                    return Promise.resolve();
                const L = [];
                b.sheenColor = new m.Ilk(0,0,0),
                b.sheenRoughness = 0,
                b.sheen = 1;
                const F = T.extensions[this.name];
                return F.sheenColorFactor !== void 0 && b.sheenColor.fromArray(F.sheenColorFactor),
                F.sheenRoughnessFactor !== void 0 && (b.sheenRoughness = F.sheenRoughnessFactor),
                F.sheenColorTexture !== void 0 && L.push(E.assignTexture(b, "sheenColorMap", F.sheenColorTexture, m.knz)),
                F.sheenRoughnessTexture !== void 0 && L.push(E.assignTexture(b, "sheenRoughnessMap", F.sheenRoughnessTexture)),
                Promise.all(L)
            }
        }
        class Xl {
            constructor(y) {
                this.parser = y,
                this.name = ti.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(y) {
                const E = this.parser.json.materials[y];
                return !E.extensions || !E.extensions[this.name] ? null : m.EJi
            }
            extendMaterialParams(y, b) {
                const E = this.parser
                  , T = E.json.materials[y];
                if (!T.extensions || !T.extensions[this.name])
                    return Promise.resolve();
                const L = []
                  , F = T.extensions[this.name];
                return F.transmissionFactor !== void 0 && (b.transmission = F.transmissionFactor),
                F.transmissionTexture !== void 0 && L.push(E.assignTexture(b, "transmissionMap", F.transmissionTexture)),
                Promise.all(L)
            }
        }
        class ll {
            constructor(y) {
                this.parser = y,
                this.name = ti.KHR_MATERIALS_VOLUME
            }
            getMaterialType(y) {
                const E = this.parser.json.materials[y];
                return !E.extensions || !E.extensions[this.name] ? null : m.EJi
            }
            extendMaterialParams(y, b) {
                const E = this.parser
                  , T = E.json.materials[y];
                if (!T.extensions || !T.extensions[this.name])
                    return Promise.resolve();
                const L = []
                  , F = T.extensions[this.name];
                b.thickness = F.thicknessFactor !== void 0 ? F.thicknessFactor : 0,
                F.thicknessTexture !== void 0 && L.push(E.assignTexture(b, "thicknessMap", F.thicknessTexture)),
                b.attenuationDistance = F.attenuationDistance || 1 / 0;
                const j = F.attenuationColor || [1, 1, 1];
                return b.attenuationColor = new m.Ilk(j[0],j[1],j[2]),
                Promise.all(L)
            }
        }
        class cl {
            constructor(y) {
                this.parser = y,
                this.name = ti.KHR_MATERIALS_IOR
            }
            getMaterialType(y) {
                const E = this.parser.json.materials[y];
                return !E.extensions || !E.extensions[this.name] ? null : m.EJi
            }
            extendMaterialParams(y, b) {
                const T = this.parser.json.materials[y];
                if (!T.extensions || !T.extensions[this.name])
                    return Promise.resolve();
                const L = T.extensions[this.name];
                return b.ior = L.ior !== void 0 ? L.ior : 1.5,
                Promise.resolve()
            }
        }
        class fa {
            constructor(y) {
                this.parser = y,
                this.name = ti.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(y) {
                const E = this.parser.json.materials[y];
                return !E.extensions || !E.extensions[this.name] ? null : m.EJi
            }
            extendMaterialParams(y, b) {
                const E = this.parser
                  , T = E.json.materials[y];
                if (!T.extensions || !T.extensions[this.name])
                    return Promise.resolve();
                const L = []
                  , F = T.extensions[this.name];
                b.specularIntensity = F.specularFactor !== void 0 ? F.specularFactor : 1,
                F.specularTexture !== void 0 && L.push(E.assignTexture(b, "specularIntensityMap", F.specularTexture));
                const j = F.specularColorFactor || [1, 1, 1];
                return b.specularColor = new m.Ilk(j[0],j[1],j[2]),
                F.specularColorTexture !== void 0 && L.push(E.assignTexture(b, "specularColorMap", F.specularColorTexture, m.knz)),
                Promise.all(L)
            }
        }
        class ul {
            constructor(y) {
                this.parser = y,
                this.name = ti.KHR_TEXTURE_BASISU
            }
            loadTexture(y) {
                const b = this.parser
                  , E = b.json
                  , T = E.textures[y];
                if (!T.extensions || !T.extensions[this.name])
                    return null;
                const L = T.extensions[this.name]
                  , F = b.options.ktx2Loader;
                if (!F) {
                    if (E.extensionsRequired && E.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return b.loadTextureImage(y, L.source, F)
            }
        }
        class ka {
            constructor(y) {
                this.parser = y,
                this.name = ti.EXT_TEXTURE_WEBP,
                this.isSupported = null
            }
            loadTexture(y) {
                const b = this.name
                  , E = this.parser
                  , T = E.json
                  , L = T.textures[y];
                if (!L.extensions || !L.extensions[b])
                    return null;
                const F = L.extensions[b]
                  , j = T.images[F.source];
                let W = E.textureLoader;
                if (j.uri) {
                    const re = E.options.manager.getHandler(j.uri);
                    re !== null && (W = re)
                }
                return this.detectSupport().then(function(re) {
                    if (re)
                        return E.loadTextureImage(y, F.source, W);
                    if (T.extensionsRequired && T.extensionsRequired.indexOf(b) >= 0)
                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return E.loadTexture(y)
                })
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise(function(y) {
                    const b = new Image;
                    b.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                    b.onload = b.onerror = function() {
                        y(b.height === 1)
                    }
                }
                )),
                this.isSupported
            }
        }
        class Ua {
            constructor(y) {
                this.parser = y,
                this.name = ti.EXT_TEXTURE_AVIF,
                this.isSupported = null
            }
            loadTexture(y) {
                const b = this.name
                  , E = this.parser
                  , T = E.json
                  , L = T.textures[y];
                if (!L.extensions || !L.extensions[b])
                    return null;
                const F = L.extensions[b]
                  , j = T.images[F.source];
                let W = E.textureLoader;
                if (j.uri) {
                    const re = E.options.manager.getHandler(j.uri);
                    re !== null && (W = re)
                }
                return this.detectSupport().then(function(re) {
                    if (re)
                        return E.loadTextureImage(y, F.source, W);
                    if (T.extensionsRequired && T.extensionsRequired.indexOf(b) >= 0)
                        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return E.loadTexture(y)
                })
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise(function(y) {
                    const b = new Image;
                    b.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
                    b.onload = b.onerror = function() {
                        y(b.height === 1)
                    }
                }
                )),
                this.isSupported
            }
        }
        class Na {
            constructor(y) {
                this.name = ti.EXT_MESHOPT_COMPRESSION,
                this.parser = y
            }
            loadBufferView(y) {
                const b = this.parser.json
                  , E = b.bufferViews[y];
                if (E.extensions && E.extensions[this.name]) {
                    const T = E.extensions[this.name]
                      , L = this.parser.getDependency("buffer", T.buffer)
                      , F = this.parser.options.meshoptDecoder;
                    if (!F || !F.supported) {
                        if (b.extensionsRequired && b.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return L.then(function(j) {
                        const W = T.byteOffset || 0
                          , re = T.byteLength || 0
                          , fe = T.count
                          , te = T.byteStride
                          , Te = new Uint8Array(j,W,re);
                        return F.decodeGltfBufferAsync ? F.decodeGltfBufferAsync(fe, te, Te, T.mode, T.filter).then(function(Ge) {
                            return Ge.buffer
                        }) : F.ready.then(function() {
                            const Ge = new ArrayBuffer(fe * te);
                            return F.decodeGltfBuffer(new Uint8Array(Ge), fe, te, Te, T.mode, T.filter),
                            Ge
                        })
                    })
                } else
                    return null
            }
        }
        class pa {
            constructor(y) {
                this.name = ti.EXT_MESH_GPU_INSTANCING,
                this.parser = y
            }
            createNodeMesh(y) {
                const b = this.parser.json
                  , E = b.nodes[y];
                if (!E.extensions || !E.extensions[this.name] || E.mesh === void 0)
                    return null;
                const T = b.meshes[E.mesh];
                for (const re of T.primitives)
                    if (re.mode !== Yr.TRIANGLES && re.mode !== Yr.TRIANGLE_STRIP && re.mode !== Yr.TRIANGLE_FAN && re.mode !== void 0)
                        return null;
                const F = E.extensions[this.name].attributes
                  , j = []
                  , W = {};
                for (const re in F)
                    j.push(this.parser.getDependency("accessor", F[re]).then(fe=>(W[re] = fe,
                    W[re])));
                return j.length < 1 ? null : (j.push(this.parser.createNodeMesh(y)),
                Promise.all(j).then(re=>{
                    const fe = re.pop()
                      , te = fe.isGroup ? fe.children : [fe]
                      , Te = re[0].count
                      , Ge = [];
                    for (const St of te) {
                        const kt = new m.yGw
                          , Vt = new m.Pa4
                          , gt = new m._fP
                          , xt = new m.Pa4(1,1,1)
                          , Xe = new m.SPe(St.geometry,St.material,Te);
                        for (let ut = 0; ut < Te; ut++)
                            W.TRANSLATION && Vt.fromBufferAttribute(W.TRANSLATION, ut),
                            W.ROTATION && gt.fromBufferAttribute(W.ROTATION, ut),
                            W.SCALE && xt.fromBufferAttribute(W.SCALE, ut),
                            Xe.setMatrixAt(ut, kt.compose(Vt, gt, xt));
                        for (const ut in W)
                            ut !== "TRANSLATION" && ut !== "ROTATION" && ut !== "SCALE" && St.geometry.setAttribute(ut, W[ut]);
                        m.Tme.prototype.copy.call(Xe, St),
                        Xe.frustumCulled = !1,
                        this.parser.assignFinalMaterial(Xe),
                        Ge.push(Xe)
                    }
                    return fe.isGroup ? (fe.clear(),
                    fe.add(...Ge),
                    fe) : Ge[0]
                }
                ))
            }
        }
        function hl(ae, y=255) {
            for (let b = 0, E = ae.length; b < E; b++)
                ae[b] ^= y;
            return ae
        }
        const za = "glTF"
          , ma = "1031088470"
          , nr = "152147171185"
          , fo = 12
          , Ga = {
            JSON: 1313821514,
            BIN: 5130562
        };
        class dl {
            constructor(y) {
                this.name = ti.KHR_BINARY_GLTF,
                this.content = null,
                this.body = null;
                const b = new DataView(y,0,fo)
                  , E = new TextDecoder
                  , L = new Uint8Array(y,0,4).join("") === nr;
                if (this.header = {
                    magic: za,
                    version: b.getUint32(4, !0),
                    length: b.getUint32(8, !0)
                },
                this.header.magic !== za)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const F = this.header.length - fo
                  , j = new DataView(y,fo);
                let W = 0;
                for (; W < F; ) {
                    const re = j.getUint32(W, !0);
                    W += 4,
                    L && hl(new Uint8Array(y,fo + W,re + 4));
                    const fe = j.getUint32(W, !0);
                    if (W += 4,
                    fe === Ga.JSON) {
                        const te = new Uint8Array(y,fo + W,re);
                        this.content = E.decode(te)
                    } else if (fe === Ga.BIN) {
                        const te = fo + W;
                        this.body = y.slice(te, te + re)
                    }
                    W += re
                }
                if (this.content === null)
                    throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class fl {
            constructor(y, b) {
                if (!b)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = ti.KHR_DRACO_MESH_COMPRESSION,
                this.json = y,
                this.dracoLoader = b,
                this.dracoLoader.preload()
            }
            decodePrimitive(y, b) {
                const E = this.json
                  , T = this.dracoLoader
                  , L = y.extensions[this.name].bufferView
                  , F = y.extensions[this.name].attributes
                  , j = {}
                  , W = {}
                  , re = {};
                for (const fe in F) {
                    const te = Xo[fe] || fe.toLowerCase();
                    j[te] = F[fe]
                }
                for (const fe in y.attributes) {
                    const te = Xo[fe] || fe.toLowerCase();
                    if (F[fe] !== void 0) {
                        const Te = E.accessors[y.attributes[fe]]
                          , Ge = Qr[Te.componentType];
                        re[te] = Ge.name,
                        W[te] = Te.normalized === !0
                    }
                }
                return b.getDependency("bufferView", L).then(function(fe) {
                    return new Promise(function(te) {
                        T.decodeDracoFile(fe, function(Te) {
                            for (const Ge in Te.attributes) {
                                const St = Te.attributes[Ge]
                                  , kt = W[Ge];
                                kt !== void 0 && (St.normalized = kt)
                            }
                            te(Te)
                        }, j, re)
                    }
                    )
                })
            }
        }
        class pl {
            constructor() {
                this.name = ti.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(y, b) {
                return b.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
                b.offset === void 0 && b.rotation === void 0 && b.scale === void 0 || (y = y.clone(),
                b.offset !== void 0 && y.offset.fromArray(b.offset),
                b.rotation !== void 0 && (y.rotation = b.rotation),
                b.scale !== void 0 && y.repeat.fromArray(b.scale),
                y.needsUpdate = !0),
                y
            }
        }
        class ga {
            constructor() {
                this.name = ti.KHR_MESH_QUANTIZATION
            }
        }
        class Ha extends m._C8 {
            constructor(y, b, E, T) {
                super(y, b, E, T)
            }
            copySampleValue_(y) {
                const b = this.resultBuffer
                  , E = this.sampleValues
                  , T = this.valueSize
                  , L = y * T * 3 + T;
                for (let F = 0; F !== T; F++)
                    b[F] = E[L + F];
                return b
            }
            interpolate_(y, b, E, T) {
                const L = this.resultBuffer
                  , F = this.sampleValues
                  , j = this.valueSize
                  , W = j * 2
                  , re = j * 3
                  , fe = T - b
                  , te = (E - b) / fe
                  , Te = te * te
                  , Ge = Te * te
                  , St = y * re
                  , kt = St - re
                  , Vt = -2 * Ge + 3 * Te
                  , gt = Ge - Te
                  , xt = 1 - Vt
                  , Xe = gt - Te + te;
                for (let ut = 0; ut !== j; ut++) {
                    const dn = F[kt + ut + j]
                      , qt = F[kt + ut + W] * fe
                      , ln = F[St + ut + j]
                      , Tn = F[St + ut] * fe;
                    L[ut] = xt * dn + Xe * qt + Vt * ln + gt * Tn
                }
                return L
            }
        }
        const To = new m._fP;
        class Eo extends Ha {
            interpolate_(y, b, E, T) {
                const L = super.interpolate_(y, b, E, T);
                return To.fromArray(L).normalize().toArray(L),
                L
            }
        }
        const Yr = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        }
          , Qr = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }
          , va = {
            9728: m.TyD,
            9729: m.wem,
            9984: m.YLQ,
            9985: m.qyh,
            9986: m.aH4,
            9987: m.D1R
        }
          , po = {
            33071: m.uWy,
            33648: m.OoA,
            10497: m.rpg
        }
          , Mo = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        }
          , Xo = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }
          , zs = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        }
          , _a = {
            CUBICSPLINE: void 0,
            LINEAR: m.NMF,
            STEP: m.Syv
        }
          , Co = {
            OPAQUE: "OPAQUE",
            MASK: "MASK",
            BLEND: "BLEND"
        };
        function Va(ae) {
            return ae.DefaultMaterial === void 0 && (ae.DefaultMaterial = new m.Wid({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: m.Wl3
            })),
            ae.DefaultMaterial
        }
        function eo(ae, y, b) {
            for (const E in b.extensions)
                ae[E] === void 0 && (y.userData.gltfExtensions = y.userData.gltfExtensions || {},
                y.userData.gltfExtensions[E] = b.extensions[E])
        }
        function ns(ae, y) {
            y.extras !== void 0 && (typeof y.extras == "object" ? Object.assign(ae.userData, y.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + y.extras))
        }
        function Po(ae, y, b) {
            let E = !1
              , T = !1
              , L = !1;
            for (let re = 0, fe = y.length; re < fe; re++) {
                const te = y[re];
                if (te.POSITION !== void 0 && (E = !0),
                te.NORMAL !== void 0 && (T = !0),
                te.COLOR_0 !== void 0 && (L = !0),
                E && T && L)
                    break
            }
            if (!E && !T && !L)
                return Promise.resolve(ae);
            const F = []
              , j = []
              , W = [];
            for (let re = 0, fe = y.length; re < fe; re++) {
                const te = y[re];
                if (E) {
                    const Te = te.POSITION !== void 0 ? b.getDependency("accessor", te.POSITION) : ae.attributes.position;
                    F.push(Te)
                }
                if (T) {
                    const Te = te.NORMAL !== void 0 ? b.getDependency("accessor", te.NORMAL) : ae.attributes.normal;
                    j.push(Te)
                }
                if (L) {
                    const Te = te.COLOR_0 !== void 0 ? b.getDependency("accessor", te.COLOR_0) : ae.attributes.color;
                    W.push(Te)
                }
            }
            return Promise.all([Promise.all(F), Promise.all(j), Promise.all(W)]).then(function(re) {
                const fe = re[0]
                  , te = re[1]
                  , Te = re[2];
                return E && (ae.morphAttributes.position = fe),
                T && (ae.morphAttributes.normal = te),
                L && (ae.morphAttributes.color = Te),
                ae.morphTargetsRelative = !0,
                ae
            })
        }
        function ya(ae, y) {
            if (ae.updateMorphTargets(),
            y.weights !== void 0)
                for (let b = 0, E = y.weights.length; b < E; b++)
                    ae.morphTargetInfluences[b] = y.weights[b];
            if (y.extras && Array.isArray(y.extras.targetNames)) {
                const b = y.extras.targetNames;
                if (ae.morphTargetInfluences.length === b.length) {
                    ae.morphTargetDictionary = {};
                    for (let E = 0, T = b.length; E < T; E++)
                        ae.morphTargetDictionary[b[E]] = E
                } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }
        function Yo(ae) {
            const y = ae.extensions && ae.extensions[ti.KHR_DRACO_MESH_COMPRESSION];
            let b;
            return y ? b = "draco:" + y.bufferView + ":" + y.indices + ":" + mo(y.attributes) : b = ae.indices + ":" + mo(ae.attributes) + ":" + ae.mode,
            b
        }
        function mo(ae) {
            let y = "";
            const b = Object.keys(ae).sort();
            for (let E = 0, T = b.length; E < T; E++)
                y += b[E] + ":" + ae[b[E]] + ";";
            return y
        }
        function ws(ae) {
            switch (ae) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        function Gs(ae) {
            return ae.search(/\.jpe?g($|\?)/i) > 0 || ae.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : ae.search(/\.webp($|\?)/i) > 0 || ae.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
        }
        const S = new m.yGw;
        class p {
            constructor(y={}, b={}) {
                this.json = y,
                this.extensions = {},
                this.plugins = {},
                this.options = b,
                this.cache = new Wl,
                this.associations = new Map,
                this.primitiveCache = {},
                this.nodeCache = {},
                this.meshCache = {
                    refs: {},
                    uses: {}
                },
                this.cameraCache = {
                    refs: {},
                    uses: {}
                },
                this.lightCache = {
                    refs: {},
                    uses: {}
                },
                this.sourceCache = {},
                this.textureCache = {},
                this.nodeNamesUsed = {};
                let E = !1
                  , T = !1
                  , L = -1;
                typeof navigator < "u" && (E = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
                T = navigator.userAgent.indexOf("Firefox") > -1,
                L = T ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1),
                typeof createImageBitmap > "u" || E || T && L < 98 ? this.textureLoader = new m.dpR(this.options.manager) : this.textureLoader = new m.QRU(this.options.manager),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                this.fileLoader = new m.hH6(this.options.manager),
                this.fileLoader.setResponseType("arraybuffer"),
                this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(y) {
                this.extensions = y
            }
            setPlugins(y) {
                this.plugins = y
            }
            parse(y, b) {
                const E = this
                  , T = this.json
                  , L = this.extensions;
                this.cache.removeAll(),
                this.nodeCache = {},
                this._invokeAll(function(F) {
                    return F._markDefs && F._markDefs()
                }),
                Promise.all(this._invokeAll(function(F) {
                    return F.beforeRoot && F.beforeRoot()
                })).then(function() {
                    return Promise.all([E.getDependencies("scene"), E.getDependencies("animation"), E.getDependencies("camera")])
                }).then(function(F) {
                    const j = {
                        scene: F[0][T.scene || 0],
                        scenes: F[0],
                        animations: F[1],
                        cameras: F[2],
                        asset: T.asset,
                        parser: E,
                        userData: {}
                    };
                    eo(L, j, T),
                    ns(j, T),
                    Promise.all(E._invokeAll(function(W) {
                        return W.afterRoot && W.afterRoot(j)
                    })).then(function() {
                        y(j)
                    })
                }).catch(b)
            }
            _markDefs() {
                const y = this.json.nodes || []
                  , b = this.json.skins || []
                  , E = this.json.meshes || [];
                for (let T = 0, L = b.length; T < L; T++) {
                    const F = b[T].joints;
                    for (let j = 0, W = F.length; j < W; j++)
                        y[F[j]].isBone = !0
                }
                for (let T = 0, L = y.length; T < L; T++) {
                    const F = y[T];
                    F.mesh !== void 0 && (this._addNodeRef(this.meshCache, F.mesh),
                    F.skin !== void 0 && (E[F.mesh].isSkinnedMesh = !0)),
                    F.camera !== void 0 && this._addNodeRef(this.cameraCache, F.camera)
                }
            }
            _addNodeRef(y, b) {
                b !== void 0 && (y.refs[b] === void 0 && (y.refs[b] = y.uses[b] = 0),
                y.refs[b]++)
            }
            _getNodeRef(y, b, E) {
                if (y.refs[b] <= 1)
                    return E;
                const T = E.clone()
                  , L = (F,j)=>{
                    const W = this.associations.get(F);
                    W != null && this.associations.set(j, W);
                    for (const [re,fe] of F.children.entries())
                        L(fe, j.children[re])
                }
                ;
                return L(E, T),
                T.name += "_instance_" + y.uses[b]++,
                T
            }
            _invokeOne(y) {
                const b = Object.values(this.plugins);
                b.push(this);
                for (let E = 0; E < b.length; E++) {
                    const T = y(b[E]);
                    if (T)
                        return T
                }
                return null
            }
            _invokeAll(y) {
                const b = Object.values(this.plugins);
                b.unshift(this);
                const E = [];
                for (let T = 0; T < b.length; T++) {
                    const L = y(b[T]);
                    L && E.push(L)
                }
                return E
            }
            getDependency(y, b) {
                const E = y + ":" + b;
                let T = this.cache.get(E);
                if (!T) {
                    switch (y) {
                    case "scene":
                        T = this.loadScene(b);
                        break;
                    case "node":
                        T = this._invokeOne(function(L) {
                            return L.loadNode && L.loadNode(b)
                        });
                        break;
                    case "mesh":
                        T = this._invokeOne(function(L) {
                            return L.loadMesh && L.loadMesh(b)
                        });
                        break;
                    case "accessor":
                        T = this.loadAccessor(b);
                        break;
                    case "bufferView":
                        T = this._invokeOne(function(L) {
                            return L.loadBufferView && L.loadBufferView(b)
                        });
                        break;
                    case "buffer":
                        T = this.loadBuffer(b);
                        break;
                    case "material":
                        T = this._invokeOne(function(L) {
                            return L.loadMaterial && L.loadMaterial(b)
                        });
                        break;
                    case "texture":
                        T = this._invokeOne(function(L) {
                            return L.loadTexture && L.loadTexture(b)
                        });
                        break;
                    case "skin":
                        T = this.loadSkin(b);
                        break;
                    case "animation":
                        T = this._invokeOne(function(L) {
                            return L.loadAnimation && L.loadAnimation(b)
                        });
                        break;
                    case "camera":
                        T = this.loadCamera(b);
                        break;
                    default:
                        if (T = this._invokeOne(function(L) {
                            return L != this && L.getDependency && L.getDependency(y, b)
                        }),
                        !T)
                            throw new Error("Unknown type: " + y);
                        break
                    }
                    this.cache.add(E, T)
                }
                return T
            }
            getDependencies(y) {
                let b = this.cache.get(y);
                if (!b) {
                    const E = this
                      , T = this.json[y + (y === "mesh" ? "es" : "s")] || [];
                    b = Promise.all(T.map(function(L, F) {
                        return E.getDependency(y, F)
                    })),
                    this.cache.add(y, b)
                }
                return b
            }
            loadBuffer(y) {
                const b = this.json.buffers[y]
                  , E = this.fileLoader;
                if (b.type && b.type !== "arraybuffer")
                    throw new Error("THREE.GLTFLoader: " + b.type + " buffer type is not supported.");
                if (b.uri === void 0 && y === 0)
                    return Promise.resolve(this.extensions[ti.KHR_BINARY_GLTF].body);
                let T = this.json.additionalFiles
                  , L = T ? T.find(j=>j.name === b.uri) : null;
                const F = this.options;
                return new Promise(function(j, W) {
                    E.load(m.Zp0.resolveURL(b.uri, F.path), j, void 0, function() {
                        W(new Error('THREE.GLTFLoader: Failed to load buffer "' + b.uri + '".'))
                    }, L)
                }
                )
            }
            loadBufferView(y) {
                const b = this.json.bufferViews[y];
                return this.getDependency("buffer", b.buffer).then(function(E) {
                    const T = b.byteLength || 0
                      , L = b.byteOffset || 0;
                    return E.slice(L, L + T)
                })
            }
            loadAccessor(y) {
                const b = this
                  , E = this.json
                  , T = this.json.accessors[y];
                if (T.bufferView === void 0 && T.sparse === void 0) {
                    const F = Mo[T.type]
                      , j = Qr[T.componentType]
                      , W = T.normalized === !0
                      , re = new j(T.count * F);
                    return Promise.resolve(new m.TlE(re,F,W))
                }
                const L = [];
                return T.bufferView !== void 0 ? L.push(this.getDependency("bufferView", T.bufferView)) : L.push(null),
                T.sparse !== void 0 && (L.push(this.getDependency("bufferView", T.sparse.indices.bufferView)),
                L.push(this.getDependency("bufferView", T.sparse.values.bufferView))),
                Promise.all(L).then(function(F) {
                    const j = F[0]
                      , W = Mo[T.type]
                      , re = Qr[T.componentType]
                      , fe = re.BYTES_PER_ELEMENT
                      , te = fe * W
                      , Te = T.byteOffset || 0
                      , Ge = T.bufferView !== void 0 ? E.bufferViews[T.bufferView].byteStride : void 0
                      , St = T.normalized === !0;
                    let kt, Vt;
                    if (Ge && Ge !== te) {
                        const gt = Math.floor(Te / Ge)
                          , xt = "InterleavedBuffer:" + T.bufferView + ":" + T.componentType + ":" + gt + ":" + T.count;
                        let Xe = b.cache.get(xt);
                        Xe || (kt = new re(j,gt * Ge,T.count * Ge / fe),
                        Xe = new m.vpT(kt,Ge / fe),
                        b.cache.add(xt, Xe)),
                        Vt = new m.kB5(Xe,W,Te % Ge / fe,St)
                    } else
                        j === null ? kt = new re(T.count * W) : kt = new re(j,Te,T.count * W),
                        Vt = new m.TlE(kt,W,St);
                    if (T.sparse !== void 0) {
                        const gt = Mo.SCALAR
                          , xt = Qr[T.sparse.indices.componentType]
                          , Xe = T.sparse.indices.byteOffset || 0
                          , ut = T.sparse.values.byteOffset || 0
                          , dn = new xt(F[1],Xe,T.sparse.count * gt)
                          , qt = new re(F[2],ut,T.sparse.count * W);
                        j !== null && (Vt = new m.TlE(Vt.array.slice(),Vt.itemSize,Vt.normalized));
                        for (let ln = 0, Tn = dn.length; ln < Tn; ln++) {
                            const fn = dn[ln];
                            if (Vt.setX(fn, qt[ln * W]),
                            W >= 2 && Vt.setY(fn, qt[ln * W + 1]),
                            W >= 3 && Vt.setZ(fn, qt[ln * W + 2]),
                            W >= 4 && Vt.setW(fn, qt[ln * W + 3]),
                            W >= 5)
                                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return Vt
                })
            }
            loadTexture(y) {
                const b = this.json
                  , E = this.options
                  , L = b.textures[y].source
                  , F = b.images[L];
                let j = this.textureLoader;
                if (F.uri) {
                    const W = E.manager.getHandler(F.uri);
                    W !== null && (j = W)
                }
                return this.loadTextureImage(y, L, j)
            }
            loadTextureImage(y, b, E) {
                const T = this
                  , L = this.json
                  , F = L.textures[y]
                  , j = L.images[b]
                  , W = (j.uri || j.bufferView) + ":" + F.sampler;
                if (this.textureCache[W])
                    return this.textureCache[W];
                const re = this.loadImageSource(b, E).then(function(fe) {
                    fe.flipY = !1,
                    fe.name = F.name || j.name || "";
                    const Te = (L.samplers || {})[F.sampler] || {};
                    return fe.magFilter = va[Te.magFilter] || m.wem,
                    fe.minFilter = va[Te.minFilter] || m.D1R,
                    fe.wrapS = po[Te.wrapS] || m.rpg,
                    fe.wrapT = po[Te.wrapT] || m.rpg,
                    T.associations.set(fe, {
                        textures: y
                    }),
                    fe
                }).catch(function() {
                    return null
                });
                return this.textureCache[W] = re,
                re
            }
            loadImageSource(y, b) {
                const E = this
                  , T = this.json
                  , L = this.options;
                if (this.sourceCache[y] !== void 0)
                    return this.sourceCache[y].then(te=>te.clone());
                const F = T.images[y]
                  , j = self.URL || self.webkitURL;
                let W = F.uri || ""
                  , re = !1;
                if (F.bufferView !== void 0)
                    W = E.getDependency("bufferView", F.bufferView).then(function(te) {
                        re = !0;
                        const Te = new Blob([te],{
                            type: F.mimeType
                        });
                        return W = j.createObjectURL(Te),
                        W
                    });
                else {
                    if (F.uri === void 0)
                        throw new Error("THREE.GLTFLoader: Image " + y + " is missing URI and bufferView");
                    if (T.additionalFiles) {
                        let te = W.split("\\").pop().split("/").pop()
                          , Te = T.additionalFiles.find(Ge=>te === Ge.name);
                        Te && (W = (0,
                        Js.hR)(Te))
                    }
                }
                const fe = Promise.resolve(W).then(function(te) {
                    return new Promise(function(Te, Ge) {
                        let St = Te;
                        b.isImageBitmapLoader === !0 && (St = function(kt) {
                            const Vt = new m.xEZ(kt);
                            Vt.needsUpdate = !0,
                            Te(Vt)
                        }
                        ),
                        b.load(m.Zp0.resolveURL(te, L.path), St, void 0, Ge)
                    }
                    )
                }).then(function(te) {
                    return re === !0 && j.revokeObjectURL(W),
                    te.userData.mimeType = F.mimeType || Gs(F.uri),
                    te
                }).catch(function(te) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", W),
                    te
                });
                return this.sourceCache[y] = fe,
                fe
            }
            assignTexture(y, b, E, T) {
                const L = this;
                return this.getDependency("texture", E.index).then(function(F) {
                    if (!F)
                        return null;
                    if (E.texCoord !== void 0 && E.texCoord != 0 && !(b === "aoMap" && E.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + E.texCoord + " for texture " + b + " not yet supported."),
                    L.extensions[ti.KHR_TEXTURE_TRANSFORM]) {
                        const j = E.extensions !== void 0 ? E.extensions[ti.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (j) {
                            const W = L.associations.get(F);
                            F = L.extensions[ti.KHR_TEXTURE_TRANSFORM].extendTexture(F, j),
                            L.associations.set(F, W)
                        }
                    }
                    return T !== void 0 && (F.encoding = T),
                    y[b] = F,
                    F
                })
            }
            assignFinalMaterial(y) {
                const b = y.geometry;
                let E = y.material;
                const T = b.attributes.tangent === void 0
                  , L = b.attributes.color !== void 0
                  , F = b.attributes.normal === void 0;
                if (y.isPoints) {
                    const j = "PointsMaterial:" + E.uuid;
                    let W = this.cache.get(j);
                    W || (W = new m.UY4,
                    m.F5T.prototype.copy.call(W, E),
                    W.color.copy(E.color),
                    W.map = E.map,
                    W.sizeAttenuation = !1,
                    this.cache.add(j, W)),
                    E = W
                } else if (y.isLine) {
                    const j = "LineBasicMaterial:" + E.uuid;
                    let W = this.cache.get(j);
                    W || (W = new m.nls,
                    m.F5T.prototype.copy.call(W, E),
                    W.color.copy(E.color),
                    this.cache.add(j, W)),
                    E = W
                }
                if (T || L || F) {
                    let j = "ClonedMaterial:" + E.uuid + ":";
                    T && (j += "derivative-tangents:"),
                    L && (j += "vertex-colors:"),
                    F && (j += "flat-shading:");
                    let W = this.cache.get(j);
                    W || (W = E.clone(),
                    L && (W.vertexColors = !0),
                    F && (W.flatShading = !0),
                    T && (W.normalScale && (W.normalScale.y *= -1),
                    W.clearcoatNormalScale && (W.clearcoatNormalScale.y *= -1)),
                    this.cache.add(j, W),
                    this.associations.set(W, this.associations.get(E))),
                    E = W
                }
                E.aoMap && b.attributes.uv2 === void 0 && b.attributes.uv !== void 0 && b.setAttribute("uv2", b.attributes.uv),
                y.material = E
            }
            getMaterialType() {
                return m.Wid
            }
            loadMaterial(y) {
                const b = this
                  , E = this.json
                  , T = this.extensions
                  , L = E.materials[y];
                let F;
                const j = {}
                  , W = L.extensions || {}
                  , re = [];
                if (W[ti.KHR_MATERIALS_UNLIT]) {
                    const te = T[ti.KHR_MATERIALS_UNLIT];
                    F = te.getMaterialType(),
                    re.push(te.extendParams(j, L, b))
                } else {
                    const te = L.pbrMetallicRoughness || {};
                    if (j.color = new m.Ilk(1,1,1),
                    j.opacity = 1,
                    Array.isArray(te.baseColorFactor)) {
                        const Te = te.baseColorFactor;
                        j.color.fromArray(Te),
                        j.opacity = Te[3]
                    }
                    te.baseColorTexture !== void 0 && re.push(b.assignTexture(j, "map", te.baseColorTexture, m.knz)),
                    j.metalness = te.metallicFactor !== void 0 ? te.metallicFactor : 1,
                    j.roughness = te.roughnessFactor !== void 0 ? te.roughnessFactor : 1,
                    te.metallicRoughnessTexture !== void 0 && (re.push(b.assignTexture(j, "metalnessMap", te.metallicRoughnessTexture)),
                    re.push(b.assignTexture(j, "roughnessMap", te.metallicRoughnessTexture))),
                    F = this._invokeOne(function(Te) {
                        return Te.getMaterialType && Te.getMaterialType(y)
                    }),
                    re.push(Promise.all(this._invokeAll(function(Te) {
                        return Te.extendMaterialParams && Te.extendMaterialParams(y, j)
                    })))
                }
                L.doubleSided === !0 && (j.side = m.ehD);
                const fe = L.alphaMode || Co.OPAQUE;
                if (fe === Co.BLEND ? (j.transparent = !0,
                j.depthWrite = !1) : (j.transparent = !1,
                fe === Co.MASK && (j.alphaTest = L.alphaCutoff !== void 0 ? L.alphaCutoff : .5)),
                L.normalTexture !== void 0 && F !== m.vBJ && (re.push(b.assignTexture(j, "normalMap", L.normalTexture)),
                j.normalScale = new m.FM8(1,1),
                L.normalTexture.scale !== void 0)) {
                    const te = L.normalTexture.scale;
                    j.normalScale.set(te, te)
                }
                return L.occlusionTexture !== void 0 && F !== m.vBJ && (re.push(b.assignTexture(j, "aoMap", L.occlusionTexture)),
                L.occlusionTexture.strength !== void 0 && (j.aoMapIntensity = L.occlusionTexture.strength)),
                L.emissiveFactor !== void 0 && F !== m.vBJ && (j.emissive = new m.Ilk().fromArray(L.emissiveFactor)),
                L.emissiveTexture !== void 0 && F !== m.vBJ && re.push(b.assignTexture(j, "emissiveMap", L.emissiveTexture, m.knz)),
                Promise.all(re).then(function() {
                    const te = new F(j);
                    return L.name && (te.name = L.name),
                    ns(te, L),
                    b.associations.set(te, {
                        materials: y
                    }),
                    L.extensions && eo(T, te, L),
                    te
                })
            }
            createUniqueName(y) {
                const b = m.iUV.sanitizeNodeName(y || "");
                let E = b;
                for (let T = 1; this.nodeNamesUsed[E]; ++T)
                    E = b + "_" + T;
                return this.nodeNamesUsed[E] = !0,
                E
            }
            loadGeometries(y) {
                const b = this
                  , E = this.extensions
                  , T = this.primitiveCache;
                function L(j) {
                    return E[ti.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(j, b).then(function(W) {
                        return V(W, j, b)
                    })
                }
                const F = [];
                for (let j = 0, W = y.length; j < W; j++) {
                    const re = y[j]
                      , fe = Yo(re)
                      , te = T[fe];
                    if (te)
                        F.push(te.promise);
                    else {
                        let Te;
                        re.extensions && re.extensions[ti.KHR_DRACO_MESH_COMPRESSION] ? Te = L(re) : Te = V(new m.u9r, re, b),
                        T[fe] = {
                            primitive: re,
                            promise: Te
                        },
                        F.push(Te)
                    }
                }
                return Promise.all(F)
            }
            loadMesh(y) {
                const b = this
                  , E = this.json
                  , T = this.extensions
                  , L = E.meshes[y]
                  , F = L.primitives
                  , j = [];
                for (let W = 0, re = F.length; W < re; W++) {
                    const fe = F[W].material === void 0 ? Va(this.cache) : this.getDependency("material", F[W].material);
                    j.push(fe)
                }
                return j.push(b.loadGeometries(F)),
                Promise.all(j).then(function(W) {
                    const re = W.slice(0, W.length - 1)
                      , fe = W[W.length - 1]
                      , te = [];
                    for (let Ge = 0, St = fe.length; Ge < St; Ge++) {
                        const kt = fe[Ge]
                          , Vt = F[Ge];
                        let gt;
                        const xt = re[Ge];
                        if (Vt.mode === Yr.TRIANGLES || Vt.mode === Yr.TRIANGLE_STRIP || Vt.mode === Yr.TRIANGLE_FAN || Vt.mode === void 0)
                            gt = L.isSkinnedMesh === !0 ? new m.TUv(kt,xt) : new m.Kj0(kt,xt),
                            gt.isSkinnedMesh === !0 && gt.normalizeSkinWeights(),
                            Vt.mode === Yr.TRIANGLE_STRIP ? gt.geometry = So(gt.geometry, m.UlW) : Vt.mode === Yr.TRIANGLE_FAN && (gt.geometry = So(gt.geometry, m.z$h));
                        else if (Vt.mode === Yr.LINES)
                            gt = new m.ejS(kt,xt);
                        else if (Vt.mode === Yr.LINE_STRIP)
                            gt = new m.x12(kt,xt);
                        else if (Vt.mode === Yr.LINE_LOOP)
                            gt = new m.blk(kt,xt);
                        else if (Vt.mode === Yr.POINTS)
                            gt = new m.woe(kt,xt);
                        else
                            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + Vt.mode);
                        Object.keys(gt.geometry.morphAttributes).length > 0 && ya(gt, L),
                        gt.name = b.createUniqueName(L.name || "mesh_" + y),
                        ns(gt, L),
                        Vt.extensions && eo(T, gt, Vt),
                        b.assignFinalMaterial(gt),
                        te.push(gt)
                    }
                    for (let Ge = 0, St = te.length; Ge < St; Ge++)
                        b.associations.set(te[Ge], {
                            meshes: y,
                            primitives: Ge
                        });
                    if (te.length === 1)
                        return te[0];
                    const Te = new m.ZAu;
                    b.associations.set(Te, {
                        meshes: y
                    });
                    for (let Ge = 0, St = te.length; Ge < St; Ge++)
                        Te.add(te[Ge]);
                    return Te
                })
            }
            loadCamera(y) {
                let b;
                const E = this.json.cameras[y]
                  , T = E[E.type];
                if (!T) {
                    console.warn("THREE.GLTFLoader: Missing camera parameters.");
                    return
                }
                return E.type === "perspective" ? b = new m.cPb(m.M8C.radToDeg(T.yfov),T.aspectRatio || 1,T.znear || 1,T.zfar || 2e6) : E.type === "orthographic" && (b = new m.iKG(-T.xmag,T.xmag,T.ymag,-T.ymag,T.znear,T.zfar)),
                E.name && (b.name = this.createUniqueName(E.name)),
                ns(b, E),
                Promise.resolve(b)
            }
            loadSkin(y) {
                const b = this.json.skins[y]
                  , E = [];
                for (let T = 0, L = b.joints.length; T < L; T++)
                    E.push(this._loadNodeShallow(b.joints[T]));
                return b.inverseBindMatrices !== void 0 ? E.push(this.getDependency("accessor", b.inverseBindMatrices)) : E.push(null),
                Promise.all(E).then(function(T) {
                    const L = T.pop()
                      , F = T
                      , j = []
                      , W = [];
                    for (let re = 0, fe = F.length; re < fe; re++) {
                        const te = F[re];
                        if (te) {
                            j.push(te);
                            const Te = new m.yGw;
                            L !== null && Te.fromArray(L.array, re * 16),
                            W.push(Te)
                        } else
                            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', b.joints[re])
                    }
                    return new m.OdW(j,W)
                })
            }
            loadAnimation(y) {
                const E = this.json.animations[y]
                  , T = []
                  , L = []
                  , F = []
                  , j = []
                  , W = [];
                for (let re = 0, fe = E.channels.length; re < fe; re++) {
                    const te = E.channels[re]
                      , Te = E.samplers[te.sampler]
                      , Ge = te.target
                      , St = Ge.node
                      , kt = E.parameters !== void 0 ? E.parameters[Te.input] : Te.input
                      , Vt = E.parameters !== void 0 ? E.parameters[Te.output] : Te.output;
                    T.push(this.getDependency("node", St)),
                    L.push(this.getDependency("accessor", kt)),
                    F.push(this.getDependency("accessor", Vt)),
                    j.push(Te),
                    W.push(Ge)
                }
                return Promise.all([Promise.all(T), Promise.all(L), Promise.all(F), Promise.all(j), Promise.all(W)]).then(function(re) {
                    const fe = re[0]
                      , te = re[1]
                      , Te = re[2]
                      , Ge = re[3]
                      , St = re[4]
                      , kt = [];
                    for (let gt = 0, xt = fe.length; gt < xt; gt++) {
                        const Xe = fe[gt]
                          , ut = te[gt]
                          , dn = Te[gt]
                          , qt = Ge[gt]
                          , ln = St[gt];
                        if (Xe === void 0)
                            continue;
                        Xe.updateMatrix();
                        let Tn;
                        switch (zs[ln.path]) {
                        case zs.weights:
                            Tn = m.dUE;
                            break;
                        case zs.rotation:
                            Tn = m.iLg;
                            break;
                        case zs.position:
                        case zs.scale:
                        default:
                            Tn = m.yC1;
                            break
                        }
                        const fn = Xe.name ? Xe.name : Xe.uuid
                          , Hn = qt.interpolation !== void 0 ? _a[qt.interpolation] : m.NMF
                          , En = [];
                        zs[ln.path] === zs.weights ? Xe.traverse(function(ar) {
                            ar.morphTargetInfluences && En.push(ar.name ? ar.name : ar.uuid)
                        }) : En.push(fn);
                        let Ei = dn.array;
                        if (dn.normalized) {
                            const ar = ws(Ei.constructor)
                              , fr = new Float32Array(Ei.length);
                            for (let lr = 0, is = Ei.length; lr < is; lr++)
                                fr[lr] = Ei[lr] * ar;
                            Ei = fr
                        }
                        for (let ar = 0, fr = En.length; ar < fr; ar++) {
                            const lr = new Tn(En[ar] + "." + zs[ln.path],ut.array,Ei,Hn);
                            qt.interpolation === "CUBICSPLINE" && (lr.createInterpolant = function(Tr) {
                                const Er = this instanceof m.iLg ? Eo : Ha;
                                return new Er(this.times,this.values,this.getValueSize() / 3,Tr)
                            }
                            ,
                            lr.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                            kt.push(lr)
                        }
                    }
                    const Vt = E.name ? E.name : "animation_" + y;
                    return new m.m7l(Vt,void 0,kt)
                })
            }
            createNodeMesh(y) {
                const b = this.json
                  , E = this
                  , T = b.nodes[y];
                return T.mesh === void 0 ? null : E.getDependency("mesh", T.mesh).then(function(L) {
                    const F = E._getNodeRef(E.meshCache, T.mesh, L);
                    return T.weights !== void 0 && F.traverse(function(j) {
                        if (j.isMesh)
                            for (let W = 0, re = T.weights.length; W < re; W++)
                                j.morphTargetInfluences[W] = T.weights[W]
                    }),
                    F
                })
            }
            loadNode(y) {
                const b = this.json
                  , E = this
                  , T = b.nodes[y]
                  , L = E._loadNodeShallow(y)
                  , F = []
                  , j = T.children || [];
                for (let re = 0, fe = j.length; re < fe; re++)
                    F.push(E.getDependency("node", j[re]));
                const W = T.skin === void 0 ? Promise.resolve(null) : E.getDependency("skin", T.skin);
                return Promise.all([L, Promise.all(F), W]).then(function(re) {
                    const fe = re[0]
                      , te = re[1]
                      , Te = re[2];
                    Te !== null && fe.traverse(function(Ge) {
                        Ge.isSkinnedMesh && Ge.bind(Te, S)
                    });
                    for (let Ge = 0, St = te.length; Ge < St; Ge++)
                        fe.add(te[Ge]);
                    return fe
                })
            }
            _loadNodeShallow(y) {
                const b = this.json
                  , E = this.extensions
                  , T = this;
                if (this.nodeCache[y] !== void 0)
                    return this.nodeCache[y];
                const L = b.nodes[y]
                  , F = L.name ? T.createUniqueName(L.name) : ""
                  , j = []
                  , W = T._invokeOne(function(re) {
                    return re.createNodeMesh && re.createNodeMesh(y)
                });
                return W && j.push(W),
                L.camera !== void 0 && j.push(T.getDependency("camera", L.camera).then(function(re) {
                    return T._getNodeRef(T.cameraCache, L.camera, re)
                })),
                T._invokeAll(function(re) {
                    return re.createNodeAttachment && re.createNodeAttachment(y)
                }).forEach(function(re) {
                    j.push(re)
                }),
                this.nodeCache[y] = Promise.all(j).then(function(re) {
                    let fe;
                    if (L.isBone === !0 ? fe = new m.N$j : re.length > 1 ? fe = new m.ZAu : re.length === 1 ? fe = re[0] : fe = new m.Tme,
                    fe !== re[0])
                        for (let te = 0, Te = re.length; te < Te; te++)
                            fe.add(re[te]);
                    if (L.name && (fe.userData.name = L.name,
                    fe.name = F),
                    ns(fe, L),
                    L.extensions && eo(E, fe, L),
                    L.matrix !== void 0) {
                        const te = new m.yGw;
                        te.fromArray(L.matrix),
                        fe.applyMatrix4(te)
                    } else
                        L.translation !== void 0 && fe.position.fromArray(L.translation),
                        L.rotation !== void 0 && fe.quaternion.fromArray(L.rotation),
                        L.scale !== void 0 && fe.scale.fromArray(L.scale);
                    return T.associations.has(fe) || T.associations.set(fe, {}),
                    T.associations.get(fe).nodes = y,
                    fe
                }),
                this.nodeCache[y]
            }
            loadScene(y) {
                const b = this.extensions
                  , E = this.json.scenes[y]
                  , T = this
                  , L = new m.ZAu;
                E.name && (L.name = T.createUniqueName(E.name)),
                ns(L, E),
                E.extensions && eo(b, L, E);
                const F = E.nodes || []
                  , j = [];
                for (let W = 0, re = F.length; W < re; W++)
                    j.push(T.getDependency("node", F[W]));
                return Promise.all(j).then(function(W) {
                    for (let fe = 0, te = W.length; fe < te; fe++)
                        L.add(W[fe]);
                    const re = fe=>{
                        const te = new Map;
                        for (const [Te,Ge] of T.associations)
                            (Te instanceof m.F5T || Te instanceof m.xEZ) && te.set(Te, Ge);
                        return fe.traverse(Te=>{
                            const Ge = T.associations.get(Te);
                            Ge != null && te.set(Te, Ge)
                        }
                        ),
                        te
                    }
                    ;
                    return T.associations = re(L),
                    L
                })
            }
        }
        function C(ae, y, b) {
            const E = y.attributes
              , T = new m.ZzF;
            if (E.POSITION !== void 0) {
                const j = b.json.accessors[E.POSITION]
                  , W = j.min
                  , re = j.max;
                if (W !== void 0 && re !== void 0) {
                    if (T.set(new m.Pa4(W[0],W[1],W[2]), new m.Pa4(re[0],re[1],re[2])),
                    j.normalized) {
                        const fe = ws(Qr[j.componentType]);
                        T.min.multiplyScalar(fe),
                        T.max.multiplyScalar(fe)
                    }
                } else {
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    return
                }
            } else
                return;
            const L = y.targets;
            if (L !== void 0) {
                const j = new m.Pa4
                  , W = new m.Pa4;
                for (let re = 0, fe = L.length; re < fe; re++) {
                    const te = L[re];
                    if (te.POSITION !== void 0) {
                        const Te = b.json.accessors[te.POSITION]
                          , Ge = Te.min
                          , St = Te.max;
                        if (Ge !== void 0 && St !== void 0) {
                            if (W.setX(Math.max(Math.abs(Ge[0]), Math.abs(St[0]))),
                            W.setY(Math.max(Math.abs(Ge[1]), Math.abs(St[1]))),
                            W.setZ(Math.max(Math.abs(Ge[2]), Math.abs(St[2]))),
                            Te.normalized) {
                                const kt = ws(Qr[Te.componentType]);
                                W.multiplyScalar(kt)
                            }
                            j.max(W)
                        } else
                            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                    }
                }
                T.expandByVector(j)
            }
            ae.boundingBox = T;
            const F = new m.aLr;
            T.getCenter(F.center),
            F.radius = T.min.distanceTo(T.max) / 2,
            ae.boundingSphere = F
        }
        function V(ae, y, b) {
            const E = y.attributes
              , T = [];
            function L(F, j) {
                return b.getDependency("accessor", F).then(function(W) {
                    ae.setAttribute(j, W)
                })
            }
            for (const F in E) {
                const j = Xo[F] || F.toLowerCase();
                j in ae.attributes || T.push(L(E[F], j))
            }
            if (y.indices !== void 0 && !ae.index) {
                const F = b.getDependency("accessor", y.indices).then(function(j) {
                    ae.setIndex(j)
                });
                T.push(F)
            }
            return ns(ae, y),
            C(ae, y, b),
            Promise.all(T).then(function() {
                return y.targets !== void 0 ? Po(ae, y.targets, b) : ae
            })
        }
        var se = function() {
            var ae = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb"
              , y = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb"
              , b = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11])
              , E = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
            if (typeof WebAssembly != "object")
                return {
                    supported: !1
                };
            var T = WebAssembly.validate(b) ? y : ae, L, F = WebAssembly.instantiate(j(T), {}).then(function(gt) {
                L = gt.instance,
                L.exports.__wasm_call_ctors()
            });
            function j(gt) {
                for (var xt = new Uint8Array(gt.length), Xe = 0; Xe < gt.length; ++Xe) {
                    var ut = gt.charCodeAt(Xe);
                    xt[Xe] = ut > 96 ? ut - 97 : ut > 64 ? ut - 39 : ut + 4
                }
                for (var dn = 0, Xe = 0; Xe < gt.length; ++Xe)
                    xt[dn++] = xt[Xe] < 60 ? E[xt[Xe]] : (xt[Xe] - 60) * 64 + xt[++Xe];
                return xt.buffer.slice(0, dn)
            }
            function W(gt, xt, Xe, ut, dn, qt) {
                var ln = L.exports.sbrk
                  , Tn = Xe + 3 & -4
                  , fn = ln(Tn * ut)
                  , Hn = ln(dn.length)
                  , En = new Uint8Array(L.exports.memory.buffer);
                En.set(dn, Hn);
                var Ei = gt(fn, Xe, ut, Hn, dn.length);
                if (Ei == 0 && qt && qt(fn, Tn, ut),
                xt.set(En.subarray(fn, fn + Xe * ut)),
                ln(fn - ln(0)),
                Ei != 0)
                    throw new Error("Malformed buffer data: " + Ei)
            }
            var re = {
                NONE: "",
                OCTAHEDRAL: "meshopt_decodeFilterOct",
                QUATERNION: "meshopt_decodeFilterQuat",
                EXPONENTIAL: "meshopt_decodeFilterExp"
            }
              , fe = {
                ATTRIBUTES: "meshopt_decodeVertexBuffer",
                TRIANGLES: "meshopt_decodeIndexBuffer",
                INDICES: "meshopt_decodeIndexSequence"
            }
              , te = []
              , Te = 0;
            function Ge(gt) {
                var xt = {
                    object: new Worker(gt),
                    pending: 0,
                    requests: {}
                };
                return xt.object.onmessage = function(Xe) {
                    var ut = Xe.data;
                    xt.pending -= ut.count,
                    xt.requests[ut.id][ut.action](ut.value),
                    delete xt.requests[ut.id]
                }
                ,
                xt
            }
            function St(gt) {
                for (var xt = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(j(T)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + W.toString() + Vt.toString(), Xe = new Blob([xt],{
                    type: "text/javascript"
                }), ut = URL.createObjectURL(Xe), dn = 0; dn < gt; ++dn)
                    te[dn] = Ge(ut);
                URL.revokeObjectURL(ut)
            }
            function kt(gt, xt, Xe, ut, dn) {
                for (var qt = te[0], ln = 1; ln < te.length; ++ln)
                    te[ln].pending < qt.pending && (qt = te[ln]);
                return new Promise(function(Tn, fn) {
                    var Hn = new Uint8Array(Xe)
                      , En = Te++;
                    qt.pending += gt,
                    qt.requests[En] = {
                        resolve: Tn,
                        reject: fn
                    },
                    qt.object.postMessage({
                        id: En,
                        count: gt,
                        size: xt,
                        source: Hn,
                        mode: ut,
                        filter: dn
                    }, [Hn.buffer])
                }
                )
            }
            function Vt(gt) {
                F.then(function() {
                    var xt = gt.data;
                    try {
                        var Xe = new Uint8Array(xt.count * xt.size);
                        W(L.exports[xt.mode], Xe, xt.count, xt.size, xt.source, L.exports[xt.filter]),
                        self.postMessage({
                            id: xt.id,
                            count: xt.count,
                            action: "resolve",
                            value: Xe
                        }, [Xe.buffer])
                    } catch (ut) {
                        self.postMessage({
                            id: xt.id,
                            count: xt.count,
                            action: "reject",
                            value: ut
                        })
                    }
                })
            }
            return {
                ready: F,
                supported: !0,
                useWorkers: function(gt) {
                    St(gt)
                },
                decodeVertexBuffer: function(gt, xt, Xe, ut, dn) {
                    W(L.exports.meshopt_decodeVertexBuffer, gt, xt, Xe, ut, L.exports[re[dn]])
                },
                decodeIndexBuffer: function(gt, xt, Xe, ut) {
                    W(L.exports.meshopt_decodeIndexBuffer, gt, xt, Xe, ut)
                },
                decodeIndexSequence: function(gt, xt, Xe, ut) {
                    W(L.exports.meshopt_decodeIndexSequence, gt, xt, Xe, ut)
                },
                decodeGltfBuffer: function(gt, xt, Xe, ut, dn, qt) {
                    W(L.exports[fe[dn]], gt, xt, Xe, ut, L.exports[re[qt]])
                },
                decodeGltfBufferAsync: function(gt, xt, Xe, ut, dn) {
                    return te.length > 0 ? kt(gt, xt, Xe, fe[ut], re[dn]) : F.then(function() {
                        var qt = new Uint8Array(gt * xt);
                        return W(L.exports[fe[ut]], qt, gt, xt, Xe, L.exports[re[dn]]),
                        qt
                    })
                }
            }
        }();
        class ye extends s.g {
            constructor() {
                super(...arguments);
                B(this, "extensions", ["gltf", "glb", "bin"])
            }
            load({url: b, file: E, onLoad: T, onProgress: L, onError: F}) {
                const j = fe=>{
                    const te = fe.scene;
                    Object.assign(te, {
                        animations: fe.animations
                    }),
                    Object.assign(te.meshData, (0,
                    jo.tQ)(te)),
                    T(te)
                }
                ;
                let W = new Fa(this.viewer.loadingManager)
                  , re = new da(this.viewer.loadingManager);
                re.setDecoderPath(this.viewer.dracoPath),
                W.setDRACOLoader(re),
                W.setMeshoptDecoder(se),
                W.load(b, j, L, F, E)
            }
        }
        class ue extends m.yxD {
            constructor(y) {
                super(y),
                this.type = m.cLu
            }
            parse(y) {
                const j = function(Xe, ut) {
                    switch (Xe) {
                    case 1:
                        console.error("THREE.RGBELoader Read Error: " + (ut || ""));
                        break;
                    case 2:
                        console.error("THREE.RGBELoader Write Error: " + (ut || ""));
                        break;
                    case 3:
                        console.error("THREE.RGBELoader Bad File Format: " + (ut || ""));
                        break;
                    default:
                    case 4:
                        console.error("THREE.RGBELoader: Error: " + (ut || ""))
                    }
                    return -1
                }
                  , te = `
`
                  , Te = function(Xe, ut, dn) {
                    ut = ut || 1024;
                    let ln = Xe.pos
                      , Tn = -1
                      , fn = 0
                      , Hn = ""
                      , En = String.fromCharCode.apply(null, new Uint16Array(Xe.subarray(ln, ln + 128)));
                    for (; 0 > (Tn = En.indexOf(te)) && fn < ut && ln < Xe.byteLength; )
                        Hn += En,
                        fn += En.length,
                        ln += 128,
                        En += String.fromCharCode.apply(null, new Uint16Array(Xe.subarray(ln, ln + 128)));
                    return -1 < Tn ? (dn !== !1 && (Xe.pos += fn + Tn + 1),
                    Hn + En.slice(0, Tn)) : !1
                }
                  , Ge = function(Xe) {
                    const ut = /^#\?(\S+)/
                      , dn = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
                      , qt = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
                      , ln = /^\s*FORMAT=(\S+)\s*$/
                      , Tn = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
                      , fn = {
                        valid: 0,
                        string: "",
                        comments: "",
                        programtype: "RGBE",
                        format: "",
                        gamma: 1,
                        exposure: 1,
                        width: 0,
                        height: 0
                    };
                    let Hn, En;
                    if (Xe.pos >= Xe.byteLength || !(Hn = Te(Xe)))
                        return j(1, "no header found");
                    if (!(En = Hn.match(ut)))
                        return j(3, "bad initial token");
                    for (fn.valid |= 1,
                    fn.programtype = En[1],
                    fn.string += Hn + `
`; Hn = Te(Xe),
                    Hn !== !1; ) {
                        if (fn.string += Hn + `
`,
                        Hn.charAt(0) === "#") {
                            fn.comments += Hn + `
`;
                            continue
                        }
                        if ((En = Hn.match(dn)) && (fn.gamma = parseFloat(En[1])),
                        (En = Hn.match(qt)) && (fn.exposure = parseFloat(En[1])),
                        (En = Hn.match(ln)) && (fn.valid |= 2,
                        fn.format = En[1]),
                        (En = Hn.match(Tn)) && (fn.valid |= 4,
                        fn.height = parseInt(En[1], 10),
                        fn.width = parseInt(En[2], 10)),
                        fn.valid & 2 && fn.valid & 4)
                            break
                    }
                    return fn.valid & 2 ? fn.valid & 4 ? fn : j(3, "missing image size specifier") : j(3, "missing format specifier")
                }
                  , St = function(Xe, ut, dn) {
                    const qt = ut;
                    if (qt < 8 || qt > 32767 || Xe[0] !== 2 || Xe[1] !== 2 || Xe[2] & 128)
                        return new Uint8Array(Xe);
                    if (qt !== (Xe[2] << 8 | Xe[3]))
                        return j(3, "wrong scanline width");
                    const ln = new Uint8Array(4 * ut * dn);
                    if (!ln.length)
                        return j(4, "unable to allocate buffer space");
                    let Tn = 0
                      , fn = 0;
                    const Hn = 4 * qt
                      , En = new Uint8Array(4)
                      , Ei = new Uint8Array(Hn);
                    let ar = dn;
                    for (; ar > 0 && fn < Xe.byteLength; ) {
                        if (fn + 4 > Xe.byteLength)
                            return j(1);
                        if (En[0] = Xe[fn++],
                        En[1] = Xe[fn++],
                        En[2] = Xe[fn++],
                        En[3] = Xe[fn++],
                        En[0] != 2 || En[1] != 2 || (En[2] << 8 | En[3]) != qt)
                            return j(3, "bad rgbe scanline format");
                        let fr = 0, lr;
                        for (; fr < Hn && fn < Xe.byteLength; ) {
                            lr = Xe[fn++];
                            const Tr = lr > 128;
                            if (Tr && (lr -= 128),
                            lr === 0 || fr + lr > Hn)
                                return j(3, "bad scanline data");
                            if (Tr) {
                                const Er = Xe[fn++];
                                for (let Kr = 0; Kr < lr; Kr++)
                                    Ei[fr++] = Er
                            } else
                                Ei.set(Xe.subarray(fn, fn + lr), fr),
                                fr += lr,
                                fn += lr
                        }
                        const is = qt;
                        for (let Tr = 0; Tr < is; Tr++) {
                            let Er = 0;
                            ln[Tn] = Ei[Tr + Er],
                            Er += qt,
                            ln[Tn + 1] = Ei[Tr + Er],
                            Er += qt,
                            ln[Tn + 2] = Ei[Tr + Er],
                            Er += qt,
                            ln[Tn + 3] = Ei[Tr + Er],
                            Tn += 4
                        }
                        ar--
                    }
                    return ln
                }
                  , kt = function(Xe, ut, dn, qt) {
                    const ln = Xe[ut + 3]
                      , Tn = Math.pow(2, ln - 128) / 255;
                    dn[qt + 0] = Xe[ut + 0] * Tn,
                    dn[qt + 1] = Xe[ut + 1] * Tn,
                    dn[qt + 2] = Xe[ut + 2] * Tn,
                    dn[qt + 3] = 1
                }
                  , Vt = function(Xe, ut, dn, qt) {
                    const ln = Xe[ut + 3]
                      , Tn = Math.pow(2, ln - 128) / 255;
                    dn[qt + 0] = m.A5E.toHalfFloat(Math.min(Xe[ut + 0] * Tn, 65504)),
                    dn[qt + 1] = m.A5E.toHalfFloat(Math.min(Xe[ut + 1] * Tn, 65504)),
                    dn[qt + 2] = m.A5E.toHalfFloat(Math.min(Xe[ut + 2] * Tn, 65504)),
                    dn[qt + 3] = m.A5E.toHalfFloat(1)
                }
                  , gt = new Uint8Array(y);
                gt.pos = 0;
                const xt = Ge(gt);
                if (xt !== -1) {
                    const Xe = xt.width
                      , ut = xt.height
                      , dn = St(gt.subarray(gt.pos), Xe, ut);
                    if (dn !== -1) {
                        let qt, ln, Tn;
                        switch (this.type) {
                        case m.VzW:
                            Tn = dn.length / 4;
                            const fn = new Float32Array(Tn * 4);
                            for (let En = 0; En < Tn; En++)
                                kt(dn, En * 4, fn, En * 4);
                            qt = fn,
                            ln = m.VzW;
                            break;
                        case m.cLu:
                            Tn = dn.length / 4;
                            const Hn = new Uint16Array(Tn * 4);
                            for (let En = 0; En < Tn; En++)
                                Vt(dn, En * 4, Hn, En * 4);
                            qt = Hn,
                            ln = m.cLu;
                            break;
                        default:
                            console.error("THREE.RGBELoader: unsupported type: ", this.type);
                            break
                        }
                        return {
                            width: Xe,
                            height: ut,
                            data: qt,
                            header: xt.string,
                            gamma: xt.gamma,
                            exposure: xt.exposure,
                            type: ln
                        }
                    }
                }
                return null
            }
            setDataType(y) {
                return this.type = y,
                this
            }
            load(y, b, E, T, L) {
                function F(j, W) {
                    switch (j.type) {
                    case m.VzW:
                    case m.cLu:
                        j.encoding = m.rnI,
                        j.minFilter = m.wem,
                        j.magFilter = m.wem,
                        j.generateMipmaps = !1,
                        j.flipY = !0;
                        break
                    }
                    b && b(j, W)
                }
                return super.load(y, F, E, T, L)
            }
        }
        class Ce extends s.g {
            constructor() {
                super(...arguments);
                B(this, "extensions", ["hdr"])
            }
            load({url: b, file: E, onLoad: T, onProgress: L, onError: F, texSettings: j}) {
                new ue(this.viewer.loadingManager).load(b, W=>T(Object.assign(W, j)), L, F, E)
            }
        }
        class mt extends s.g {
            constructor() {
                super(...arguments);
                B(this, "extensions", ["json"])
            }
            load({url: b, file: E, onLoad: T, onProgress: L, onError: F}) {
                new _.hH6(this.viewer.loadingManager).load(b, j=>T(JSON.parse(j)), L, F, E)
            }
        }
        class nn extends s.g {
            constructor() {
                super(...arguments);
                B(this, "extensions", ["png", "jpg", "webp", "avif"])
            }
            load({url: b, file: E, onLoad: T, onProgress: L, onError: F, texSettings: j}) {
                const W = this.viewer.renderer.outputEncoding;
                new _.dpR(this.viewer.loadingManager).load(b, re=>T(Object.assign(re, Object.assign({
                    encoding: W
                }, j))), L, F, E)
            }
        }
        var cn = r(400);
        class ni extends s.g {
            constructor() {
                super(...arguments);
                B(this, "extensions", ["img"])
            }
            load({url: b, file: E, onLoad: T, onProgress: L, onError: F}) {
                this.viewer.renderer.outputEncoding,
                new cn.S3k(this.viewer.loadingManager).load(b, T, L, F, E)
            }
        }
    }
    ,
    741: (t,n,r)=>{
        r.d(n, {
            B: ()=>m
        });
        var s = r(861)
          , h = r(41)
          , l = r(25)
          , g = function(D, U, R, ne) {
            var ce = arguments.length, xe = ce < 3 ? U : ne === null ? ne = Object.getOwnPropertyDescriptor(U, R) : ne, Se;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                xe = Reflect.decorate(D, U, R, ne);
            else
                for (var $ = D.length - 1; $ >= 0; $--)
                    (Se = D[$]) && (xe = (ce < 3 ? Se(xe) : ce > 3 ? Se(U, R, xe) : Se(U, R)) || xe);
            return ce > 3 && xe && Object.defineProperty(U, R, xe),
            xe
        };
        const _ = `
varying vec2 vUv;

void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`
          , A = `
uniform sampler2D texFont;
varying vec2 vUv;

uniform vec4  diffuse;
uniform vec4  stroke;
uniform vec4  shadow;
uniform vec2  shadowOffset;
uniform float weight;

float median(in float r, in float g, in float b) {
    return max(min(r, g), min(max(r, g), b));
}

float signedDistance(in vec2 uv) {
    vec4 texel = texture2D(texFont, uv);
    return median(texel.r, texel.g, texel.b) - 0.5;
}

void main() {
    vec4 color = vec4(diffuse);
    float d = signedDistance(vUv) + weight;
    float w = fwidth(d);

    if (stroke.a > 0.0) {
        vec4 strokeColor = vec4(stroke.rgb, smoothstep(-w, w, d));
        color.a *= smoothstep(-w, w, d - stroke.a);
        color = mix(strokeColor, color, color.a);
    }
    else {
        color.a *= smoothstep(-w, w, d);
    }

    if (shadow.a > 0.0) {
        float dd = signedDistance(vUv + shadowOffset);
        vec4 shadowColor = vec4(shadow.rgb, smoothstep(-w - shadow.a, w + shadow.a, dd));
        color = mix(shadowColor, color, color.a);
    }

    gl_FragColor = color;
}
`;
        class m extends l.jyz {
            constructor() {
                super(...arguments);
                B(this, "vertexShader", _);
                B(this, "fragmentShader", A);
                B(this, "blending", l.bdR);
                B(this, "transparent", !0);
                B(this, "depthWrite", !1);
                B(this, "uniforms", {
                    texFont: {
                        value: null
                    },
                    diffuse: {
                        value: (0,
                        s.bd)(1)
                    },
                    stroke: {
                        value: (0,
                        s.bd)(0)
                    },
                    shadow: {
                        value: (0,
                        s.bd)(0)
                    },
                    shadowOffset: {
                        value: (0,
                        s.i5)(-.001, .001)
                    },
                    weight: {
                        value: .2
                    }
                });
                B(this, "_strokeColor", (0,
                s.$c)());
                B(this, "_shadowColor", (0,
                s.$c)())
            }
            get color() {
                return this.uniforms.diffuse.value
            }
            set color(R) {
                this.uniforms.diffuse.value = R
            }
            get weight() {
                return this.uniforms.weight.value
            }
            set weight(R) {
                this.uniforms.weight.value = R
            }
            get strokeColor() {
                return (0,
                s.OE)(this.uniforms.stroke.value, this._strokeColor)
            }
            set strokeColor(R) {
                (0,
                s.eC)(R, this.uniforms.stroke.value)
            }
            get strokeWidth() {
                return this.uniforms.stroke.value.w
            }
            set strokeWidth(R) {
                this.uniforms.stroke.value.w = R
            }
            get shadowBlur() {
                return this.uniforms.shadow.value.w
            }
            set shadowBlur(R) {
                this.uniforms.shadow.value.w = R
            }
            get shadowColor() {
                return (0,
                s.OE)(this.uniforms.shadow.value, this._shadowColor)
            }
            set shadowColor(R) {
                (0,
                s.eC)(R, this.uniforms.shadow.value)
            }
            get shadowOffset() {
                return this.uniforms.shadowOffset.value
            }
            set shadowOffset(R) {
                this.uniforms.shadowOffset.value = R
            }
            get texFont() {
                return this.uniforms.texFont.value
            }
        }
        g([(0,
        h.Cb)({
            type: "Color"
        })], m.prototype, "color", null),
        g([(0,
        h.Cb)({
            min: 0,
            max: 1,
            step: .01
        })], m.prototype, "weight", null),
        g([(0,
        h.Cb)({
            dir: "stroke"
        })], m.prototype, "strokeColor", null),
        g([(0,
        h.Cb)({
            min: 0,
            max: 1,
            step: .01,
            dir: "stroke"
        })], m.prototype, "strokeWidth", null),
        g([(0,
        h.Cb)({
            min: 0,
            max: 1,
            step: .01,
            dir: "shadow"
        })], m.prototype, "shadowBlur", null),
        g([(0,
        h.Cb)({
            dir: "shadow"
        })], m.prototype, "shadowColor", null),
        g([(0,
        h.Cb)({
            dir: "shadow"
        })], m.prototype, "shadowOffset", null),
        g([(0,
        h.Cb)()], m.prototype, "texFont", null)
    }
    ,
    678: (t,n,r)=>{
        r.d(n, {
            w: ()=>l
        });
        var s = r(25)
          , h = r(616);
        const l = {
            vertexShader: h.n,
            blending: s.jFi,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1
        }
    }
    ,
    28: (t,n,r)=>{
        r.d(n, {
            U: ()=>h
        });
        var s = r(25);
        function h(l, g) {
            let _ = l * l
              , A = 2 * Math.PI * _
              , m = Math.pow(16, g) * 1.386294361
              , D = A * (Math.pow(4, g) + A);
            return s.MathUtils.clamp01(m / D)
        }
    }
    ,
    616: (t,n,r)=>{
        r.d(n, {
            n: ()=>s
        });
        const s = `
varying vec2 vUv;
void main() {
    vUv = position.xy * 0.5 + 0.5;
    gl_Position = vec4(position.xy, 1.0, 1.0);
}
`
    }
    ,
    465: (t,n,r)=>{
        r.d(n, {
            S: ()=>_,
            v: ()=>A
        });
        var s = r(25);
        const {lerp: h, clamp01: l} = s.MathUtils;
        function g(m, D, U, R, ne) {
            const ce = (R - D) * .5
              , xe = (ne - U) * .5
              , Se = m * m
              , $ = m * Se;
            return (2 * U - 2 * R + ce + xe) * $ + (-3 * U + 3 * R - 2 * ce - xe) * Se + ce * m + U
        }
        class _ {
            constructor(D=0, U=0, R=0) {
                B(this, "x");
                B(this, "y");
                B(this, "mode", 0);
                this.set(D, U),
                this.mode = R
            }
            set(D, U) {
                return this.x = D,
                this.y = U,
                this
            }
            lerp(D, U, R=this) {
                return R.x = h(this.x, D.x, U),
                R.y = h(this.y, D.y, U),
                R
            }
        }
        class A {
            constructor(D="", U=[new _(0,0), new _(1,1)]) {
                B(this, "name");
                B(this, "points");
                B(this, "isAnimationCurve", !0);
                B(this, "needsUpdate", !0);
                B(this, "_samples", 100);
                B(this, "_interpolant", new s.lfu(new Float32Array(100),new Float32Array(100),1,new Float32Array(100)));
                this.name = D,
                this.points = U
            }
            _getInterpolant(D) {
                return this._samples !== D && (this._samples = D,
                this._interpolant = new s.lfu(new Float32Array(D),new Float32Array(D),1,new Float32Array(D))),
                this._interpolant
            }
            resample(D=100) {
                const U = 1 / (D - 1)
                  , R = this._getInterpolant(D)
                  , ne = R.parameterPositions
                  , ce = R.sampleValues
                  , xe = new _;
                for (let Se = 0; Se < D; Se++)
                    this.getPoint(Se * U, xe),
                    ne[Se] = xe.x,
                    ce[Se] = xe.y
            }
            evaluate(D) {
                return this.needsUpdate && (this.needsUpdate = !1,
                this.resample()),
                this._interpolant.evaluate(D)[0]
            }
            getPoint(D, U) {
                const R = this.points;
                if (D <= 0)
                    return U.set(D, R[0].y);
                if (D >= 1)
                    return U.set(D, R[R.length - 1].y);
                const ne = (R.length - 1) * D
                  , ce = Math.floor(ne)
                  , xe = ne - ce
                  , Se = R[ce === 0 ? ce : ce - 1]
                  , $ = R[ce]
                  , q = R[ce > R.length - 2 ? R.length - 1 : ce + 1]
                  , N = R[ce > R.length - 3 ? R.length - 1 : ce + 2];
                return $.mode === 1 || Se === $ && q.mode === 1 ? $.lerp(q, xe, U) : U.set(l(g(xe, Se.x, $.x, q.x, N.x)), l(g(xe, Se.y, $.y, q.y, N.y)))
            }
        }
    }
    ,
    876: (t,n,r)=>{
        r.d(n, {
            H: ()=>h
        });
        const {floor: s} = Math
          , l = class l {
            static Noise(_, A, m) {
                let D = l._Fade
                  , U = l._Grad
                  , R = l._Lerp
                  , ne = l._Permutation;
                if (A !== void 0 && m !== void 0) {
                    let ce = s(_)
                      , xe = s(A)
                      , Se = s(m)
                      , $ = ce & 255
                      , q = xe & 255
                      , N = Se & 255;
                    _ -= ce,
                    A -= xe,
                    m -= Se;
                    let ie = D(_)
                      , _e = D(A)
                      , Pe = D(m)
                      , Be = ne[$] + q
                      , Re = ne[Be] + N
                      , ct = ne[Be + 1] + N
                      , et = ne[$ + 1] + q
                      , Ze = ne[et] + N
                      , Nt = ne[et + 1] + N;
                    return R(Pe, R(_e, R(ie, U(ne[Re], _, A, m), U(ne[Ze], _ - 1, A, m)), R(ie, U(ne[ct], _, A - 1, m), U(ne[Nt], _ - 1, A - 1, m))), R(_e, R(ie, U(ne[Re + 1], _, A, m - 1), U(ne[Ze + 1], _ - 1, A, m - 1)), R(ie, U(ne[ct + 1], _, A - 1, m - 1), U(ne[Nt + 1], _ - 1, A - 1, m - 1))))
                } else if (A !== void 0) {
                    let ce = s(_)
                      , xe = s(A)
                      , Se = ce & 255
                      , $ = xe & 255;
                    _ -= ce,
                    A -= xe;
                    let q = D(_)
                      , N = D(A)
                      , ie = ne[Se] + $ & 255
                      , _e = ne[Se + 1] + $ & 255;
                    return R(N, R(q, U(ne[ie], _, A), U(ne[_e], _ - 1, A)), R(q, U(ne[ie + 1], _, A - 1), U(ne[_e + 1], _ - 1, A - 1)))
                } else {
                    let ce = s(_)
                      , xe = ce & 255;
                    _ -= ce;
                    let Se = D(_);
                    return R(Se, U(ne[xe], _), U(ne[xe + 1], _ - 1))
                }
            }
            static Fbm(_, A, m, D) {
                let U = 0
                  , R = .5
                  , ne = l.Noise;
                if (m !== void 0 && D !== void 0)
                    for (let ce = 0; ce < _; ce++)
                        U += R * ne(A, m, D),
                        A *= 2,
                        m *= 2,
                        D *= 2,
                        R *= .5;
                else if (m !== void 0)
                    for (let ce = 0; ce < _; ce++)
                        U += R * ne(A, m),
                        A *= 2,
                        m *= 2,
                        R *= .5;
                else
                    for (let ce = 0; ce < _; ce++)
                        U += R * ne(A),
                        A *= 2,
                        R *= .5;
                return U
            }
            static _Fade(_) {
                return _ * _ * _ * (_ * (_ * 6 - 15) + 10)
            }
            static _Lerp(_, A, m) {
                return A + _ * (m - A)
            }
            static _Grad(_, A, m, D) {
                if (m !== void 0 && D !== void 0) {
                    let U = _ & 15
                      , R = U < 8 ? A : m
                      , ne = U < 4 ? m : U == 12 || U == 14 ? A : D;
                    return (U & 1 ? -R : R) + (U & 2 ? -ne : ne)
                } else
                    return m !== void 0 ? (_ & 1 ? -A : A) + (_ & 2 ? -m : m) : _ & 1 ? -A : A
            }
        }
        ;
        B(l, "_Permutation", [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180, 151]);
        let h = l
    }
    ,
    459: (t,n,r)=>{
        r.d(n, {
            H8: ()=>h.H,
            SV: ()=>s.S,
            vX: ()=>s.v
        });
        var s = r(465)
          , h = r(876);
        Array.prototype.remove = function(l) {
            let g = this.indexOf(l);
            g > -1 && this.splice(g, 1)
        }
    }
    ,
    992: (t,n,r)=>{
        r.d(n, {
            S: ()=>h
        });
        var s = r(591);
        class h extends s.w {
            constructor() {
                super(...arguments);
                B(this, "isPlugin", !0)
            }
        }
    }
    ,
    893: (t,n,r)=>{
        r.d(n, {
            k: ()=>A
        });
        var s = r(879)
          , h = r(585)
          , l = r(861)
          , g = r(25)
          , _ = r(992);
        class A extends _.S {
            constructor(U) {
                super();
                B(this, "name", "VirtualCameraPlugin");
                B(this, "_brain", null);
                B(this, "_freelookCamera", null);
                this.onLoad = ()=>{
                    const R = this.viewer.camera;
                    this._brain = this.viewer.addComponent(R, s.W),
                    this._freelookCamera = this.viewer.addNode(h.z, Object.assign({
                        fov: R.fov,
                        near: R.near,
                        far: R.far,
                        lookAt: new g.Tme,
                        position: (0,
                        l.nX)(0, 0, 4)
                    }, U))
                }
            }
            onEnable() {
                this._brain && (this._brain.enabled = !0),
                this._freelookCamera && (this._freelookCamera.enabled = !0)
            }
            onDisable() {
                this._brain && (this._brain.enabled = !1),
                this._freelookCamera && (this._freelookCamera.enabled = !1)
            }
        }
    }
    ,
    427: (t,n,r)=>{
        r.d(n, {
            BR: ()=>g,
            G: ()=>m,
            I_: ()=>h,
            J1: ()=>l,
            bk: ()=>_,
            oG: ()=>s
        });
        function s(D) {
            let U = D.split(".");
            return U.length > 1 ? U.pop() : ""
        }
        function h(D) {
            let U = D.lastIndexOf("/");
            return U !== -1 ? D.substring(0, U) : ""
        }
        function l(D, U) {
            let R = D.split("/").pop();
            return U ? R.replace("." + U, "") : R
        }
        function g(D) {
            let U = ""
              , R = null
              , ne = "";
            return typeof File < "u" && D instanceof File ? (U = D.name,
            ne = s(U),
            R = D) : typeof D == "object" ? (U = D.mainFile.name,
            ne = s(U),
            R = D) : (U += D,
            ne = s(U)),
            {
                url: U,
                file: R,
                ext: ne
            }
        }
        function _(D, U) {
            let R = [D];
            for (let ne in U)
                U[ne] !== void 0 && R.push(ne + "=" + U[ne]);
            return R.join(",")
        }
        const A = ["flipY", "mapping", "wrapS", "wrapT", "dataType", "magFilter", "minFilter", "format", "anisotropy", "encoding", "repeat"];
        function m(D) {
            let U = {};
            for (let R of A)
                D[R] !== void 0 && (R === "dataType" ? U.type = D[R] : U[R] = D[R]);
            return U
        }
    }
    ,
    371: (t,n,r)=>{
        r.d(n, {
            $S: ()=>l,
            EK: ()=>_,
            NB: ()=>h,
            Wr: ()=>g
        });
        var s = r(322);
        function h(A, m, D, U, R) {
            s.c.fullscreenMesh.material = D;
            const ne = A.getRenderTarget();
            A.setRenderTarget(m, R, U),
            A.render(s.c.fullscreenMesh, s.c.fullscreenCamera),
            A.setRenderTarget(ne)
        }
        function l(A, m) {
            if (Array.isArray(m))
                for (let D of m)
                    A.initTexture(D);
            else
                A.initTexture(m)
        }
        function g(A, m, D, U) {
            s.c.fullscreenMesh.material = U,
            A.compile(s.c.fullscreenMesh, D, m)
        }
        function _(A, m, D, U) {
            A.compile(U, D, m)
        }
    }
    ,
    774: (t,n,r)=>{
        r.d(n, {
            Oe: ()=>l,
            lD: ()=>g,
            lK: ()=>D,
            tQ: ()=>A
        });
        var s = r(25)
          , h = r(861);
        function l(U, R, ne) {
            let ce = {};
            U.traverse(q=>{
                var N;
                if (q.visible && q.isMesh && q.geometry) {
                    if (ne && ne(q))
                        return;
                    let ie = q.geometry.uuid + ((N = q.material) == null ? void 0 : N.name);
                    ce[ie] == null && (ce[ie] = {
                        geometry: q.geometry,
                        material: q.material,
                        group: []
                    }),
                    ce[ie].group.push(q)
                }
            }
            );
            let xe = 0
              , Se = 0
              , $ = new s.ZAu;
            for (let q in ce) {
                let N = ce[q]
                  , {geometry: ie, material: _e, group: Pe} = N
                  , Be = new s.SPe(ie,_e,Pe.length);
                for (let Re = Pe.length; Re--; )
                    Pe[Re].updateWorldMatrix(!0, !1),
                    Be.setMatrixAt(Re, Pe[Re].matrixWorld);
                (0,
                h.$p)(Be, R),
                $.add(Be),
                Se++,
                xe += Pe.length
            }
            return console.log("makeInstanced", "instance", Se, "count", xe),
            $
        }
        function g() {
            let U = new s.u9r;
            return U.setAttribute("position", new s.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
            U.setAttribute("uv", new s.a$l([0, 2, 0, 0, 2, 0],2)),
            U
        }
        const _ = ["alphaMap", "aoMap", "bumpMap", "displacementMap", "emissiveMap", "envMap", "lightMap", "metalnessMap", "normalMap", "roughnessMap", "specularMap"];
        function A(U, R={
            meshes: [],
            materials: {},
            textures: {}
        }) {
            return U.traverse(ne=>{
                if (ne instanceof s.Kj0) {
                    const ce = ne.material;
                    R.meshes.push(ne),
                    R.materials[ce.name] = ce;
                    let xe = null;
                    for (let Se of _)
                        xe = ce[Se],
                        xe && (R.textures[xe.uuid] = xe)
                }
            }
            ),
            R
        }
        const m = ["top", "bottom", "left", "right", "near", "far"];
        function D(U, R) {
            const ne = U.camera;
            for (let ce = 0; ce < R.length && ce < 6; ce++)
                ne[m[ce]] = R[ce];
            return R.length > 6 && (U.bias = R[6]),
            R.length > 8 && U.mapSize.set(R[7], R[8]),
            U
        }
    }
    ,
    150: (t,n,r)=>{
        r.d(n, {
            Ys: ()=>ne
        });
        var s = r(477);
        const h = new s.iMs
          , l = new s.Pa4
          , g = new s.Pa4
          , _ = new s._fP
          , A = {
            X: new s.Pa4(1,0,0),
            Y: new s.Pa4(0,1,0),
            Z: new s.Pa4(0,0,1)
        }
          , m = {
            type: "change"
        }
          , D = {
            type: "mouseDown"
        }
          , U = {
            type: "mouseUp",
            mode: null
        }
          , R = {
            type: "objectChange"
        };
        class ne extends s.Tme {
            constructor(Ft, jt) {
                super(),
                jt === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),
                jt = document),
                this.isTransformControls = !0,
                this.visible = !1,
                this.domElement = jt,
                this.domElement.style.touchAction = "none";
                const Xt = new zt;
                this._gizmo = Xt,
                this.add(Xt);
                const Rt = new Sn;
                this._plane = Rt,
                this.add(Rt);
                const Wn = this;
                function He(On, kn) {
                    let bi = kn;
                    Object.defineProperty(Wn, On, {
                        get: function() {
                            return bi !== void 0 ? bi : kn
                        },
                        set: function($i) {
                            bi !== $i && (bi = $i,
                            Rt[On] = $i,
                            Xt[On] = $i,
                            Wn.dispatchEvent({
                                type: On + "-changed",
                                value: $i
                            }),
                            Wn.dispatchEvent(m))
                        }
                    }),
                    Wn[On] = kn,
                    Rt[On] = kn,
                    Xt[On] = kn
                }
                He("camera", Ft),
                He("object", void 0),
                He("enabled", !0),
                He("axis", null),
                He("mode", "translate"),
                He("translationSnap", null),
                He("rotationSnap", null),
                He("scaleSnap", null),
                He("space", "world"),
                He("size", 1),
                He("dragging", !1),
                He("showX", !0),
                He("showY", !0),
                He("showZ", !0);
                const pt = new s.Pa4
                  , Fe = new s.Pa4
                  , qe = new s._fP
                  , wt = new s._fP
                  , An = new s.Pa4
                  , Qt = new s._fP
                  , Pi = new s.Pa4
                  , ui = new s.Pa4
                  , mi = new s.Pa4
                  , Si = 0
                  , Gt = new s.Pa4;
                He("worldPosition", pt),
                He("worldPositionStart", Fe),
                He("worldQuaternion", qe),
                He("worldQuaternionStart", wt),
                He("cameraPosition", An),
                He("cameraQuaternion", Qt),
                He("pointStart", Pi),
                He("pointEnd", ui),
                He("rotationAxis", mi),
                He("rotationAngle", Si),
                He("eye", Gt),
                this._offset = new s.Pa4,
                this._startNorm = new s.Pa4,
                this._endNorm = new s.Pa4,
                this._cameraScale = new s.Pa4,
                this._parentPosition = new s.Pa4,
                this._parentQuaternion = new s._fP,
                this._parentQuaternionInv = new s._fP,
                this._parentScale = new s.Pa4,
                this._worldScaleStart = new s.Pa4,
                this._worldQuaternionInv = new s._fP,
                this._worldScale = new s.Pa4,
                this._positionStart = new s.Pa4,
                this._quaternionStart = new s._fP,
                this._scaleStart = new s.Pa4,
                this._getPointer = ce.bind(this),
                this._onPointerDown = Se.bind(this),
                this._onPointerHover = xe.bind(this),
                this._onPointerMove = $.bind(this),
                this._onPointerUp = q.bind(this),
                this.domElement.addEventListener("pointerdown", this._onPointerDown),
                this.domElement.addEventListener("pointermove", this._onPointerHover),
                this.domElement.addEventListener("pointerup", this._onPointerUp)
            }
            updateMatrixWorld() {
                this.object !== void 0 && (this.object.updateMatrixWorld(),
                this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale),
                this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale),
                this._parentQuaternionInv.copy(this._parentQuaternion).invert(),
                this._worldQuaternionInv.copy(this.worldQuaternion).invert()),
                this.camera.updateMatrixWorld(),
                this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale),
                this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),
                super.updateMatrixWorld(this)
            }
            pointerHover(Ft) {
                if (this.object === void 0 || this.dragging === !0)
                    return;
                h.setFromCamera(Ft, this.camera);
                const jt = N(this._gizmo.picker[this.mode], h);
                jt ? this.axis = jt.object.name : this.axis = null
            }
            pointerDown(Ft) {
                if (!(this.object === void 0 || this.dragging === !0 || Ft.button !== 0) && this.axis !== null) {
                    h.setFromCamera(Ft, this.camera);
                    const jt = N(this._plane, h, !0);
                    jt && (this.object.updateMatrixWorld(),
                    this.object.parent.updateMatrixWorld(),
                    this._positionStart.copy(this.object.position),
                    this._quaternionStart.copy(this.object.quaternion),
                    this._scaleStart.copy(this.object.scale),
                    this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart),
                    this.pointStart.copy(jt.point).sub(this.worldPositionStart)),
                    this.dragging = !0,
                    D.mode = this.mode,
                    this.dispatchEvent(D)
                }
            }
            pointerMove(Ft) {
                const jt = this.axis
                  , Xt = this.mode
                  , Rt = this.object;
                let Wn = this.space;
                if (Xt === "scale" ? Wn = "local" : (jt === "E" || jt === "XYZE" || jt === "XYZ") && (Wn = "world"),
                Rt === void 0 || jt === null || this.dragging === !1 || Ft.button !== -1)
                    return;
                h.setFromCamera(Ft, this.camera);
                const He = N(this._plane, h, !0);
                if (He) {
                    if (this.pointEnd.copy(He.point).sub(this.worldPositionStart),
                    Xt === "translate")
                        this._offset.copy(this.pointEnd).sub(this.pointStart),
                        Wn === "local" && jt !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv),
                        jt.indexOf("X") === -1 && (this._offset.x = 0),
                        jt.indexOf("Y") === -1 && (this._offset.y = 0),
                        jt.indexOf("Z") === -1 && (this._offset.z = 0),
                        Wn === "local" && jt !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),
                        Rt.position.copy(this._offset).add(this._positionStart),
                        this.translationSnap && (Wn === "local" && (Rt.position.applyQuaternion(_.copy(this._quaternionStart).invert()),
                        jt.search("X") !== -1 && (Rt.position.x = Math.round(Rt.position.x / this.translationSnap) * this.translationSnap),
                        jt.search("Y") !== -1 && (Rt.position.y = Math.round(Rt.position.y / this.translationSnap) * this.translationSnap),
                        jt.search("Z") !== -1 && (Rt.position.z = Math.round(Rt.position.z / this.translationSnap) * this.translationSnap),
                        Rt.position.applyQuaternion(this._quaternionStart)),
                        Wn === "world" && (Rt.parent && Rt.position.add(l.setFromMatrixPosition(Rt.parent.matrixWorld)),
                        jt.search("X") !== -1 && (Rt.position.x = Math.round(Rt.position.x / this.translationSnap) * this.translationSnap),
                        jt.search("Y") !== -1 && (Rt.position.y = Math.round(Rt.position.y / this.translationSnap) * this.translationSnap),
                        jt.search("Z") !== -1 && (Rt.position.z = Math.round(Rt.position.z / this.translationSnap) * this.translationSnap),
                        Rt.parent && Rt.position.sub(l.setFromMatrixPosition(Rt.parent.matrixWorld))));
                    else if (Xt === "scale") {
                        if (jt.search("XYZ") !== -1) {
                            let pt = this.pointEnd.length() / this.pointStart.length();
                            this.pointEnd.dot(this.pointStart) < 0 && (pt *= -1),
                            g.set(pt, pt, pt)
                        } else
                            l.copy(this.pointStart),
                            g.copy(this.pointEnd),
                            l.applyQuaternion(this._worldQuaternionInv),
                            g.applyQuaternion(this._worldQuaternionInv),
                            g.divide(l),
                            jt.search("X") === -1 && (g.x = 1),
                            jt.search("Y") === -1 && (g.y = 1),
                            jt.search("Z") === -1 && (g.z = 1);
                        Rt.scale.copy(this._scaleStart).multiply(g),
                        this.scaleSnap && (jt.search("X") !== -1 && (Rt.scale.x = Math.round(Rt.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap),
                        jt.search("Y") !== -1 && (Rt.scale.y = Math.round(Rt.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap),
                        jt.search("Z") !== -1 && (Rt.scale.z = Math.round(Rt.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap))
                    } else if (Xt === "rotate") {
                        this._offset.copy(this.pointEnd).sub(this.pointStart);
                        const pt = 20 / this.worldPosition.distanceTo(l.setFromMatrixPosition(this.camera.matrixWorld));
                        jt === "E" ? (this.rotationAxis.copy(this.eye),
                        this.rotationAngle = this.pointEnd.angleTo(this.pointStart),
                        this._startNorm.copy(this.pointStart).normalize(),
                        this._endNorm.copy(this.pointEnd).normalize(),
                        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : jt === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),
                        this.rotationAngle = this._offset.dot(l.copy(this.rotationAxis).cross(this.eye)) * pt) : (jt === "X" || jt === "Y" || jt === "Z") && (this.rotationAxis.copy(A[jt]),
                        l.copy(A[jt]),
                        Wn === "local" && l.applyQuaternion(this.worldQuaternion),
                        this.rotationAngle = this._offset.dot(l.cross(this.eye).normalize()) * pt),
                        this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap),
                        Wn === "local" && jt !== "E" && jt !== "XYZE" ? (Rt.quaternion.copy(this._quaternionStart),
                        Rt.quaternion.multiply(_.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv),
                        Rt.quaternion.copy(_.setFromAxisAngle(this.rotationAxis, this.rotationAngle)),
                        Rt.quaternion.multiply(this._quaternionStart).normalize())
                    }
                    this.dispatchEvent(m),
                    this.dispatchEvent(R)
                }
            }
            pointerUp(Ft) {
                Ft.button === 0 && (this.dragging && this.axis !== null && (U.mode = this.mode,
                this.dispatchEvent(U)),
                this.dragging = !1,
                this.axis = null)
            }
            dispose() {
                this.domElement.removeEventListener("pointerdown", this._onPointerDown),
                this.domElement.removeEventListener("pointermove", this._onPointerHover),
                this.domElement.removeEventListener("pointermove", this._onPointerMove),
                this.domElement.removeEventListener("pointerup", this._onPointerUp),
                this.traverse(function(Ft) {
                    Ft.geometry && Ft.geometry.dispose(),
                    Ft.material && Ft.material.dispose()
                })
            }
            attach(Ft) {
                return this.object = Ft,
                this.visible = !0,
                this
            }
            detach() {
                return this.object = void 0,
                this.visible = !1,
                this.axis = null,
                this
            }
            reset() {
                this.enabled && this.dragging && (this.object.position.copy(this._positionStart),
                this.object.quaternion.copy(this._quaternionStart),
                this.object.scale.copy(this._scaleStart),
                this.dispatchEvent(m),
                this.dispatchEvent(R),
                this.pointStart.copy(this.pointEnd))
            }
            getRaycaster() {
                return h
            }
            getMode() {
                return this.mode
            }
            setMode(Ft) {
                this.mode = Ft
            }
            setTranslationSnap(Ft) {
                this.translationSnap = Ft
            }
            setRotationSnap(Ft) {
                this.rotationSnap = Ft
            }
            setScaleSnap(Ft) {
                this.scaleSnap = Ft
            }
            setSize(Ft) {
                this.size = Ft
            }
            setSpace(Ft) {
                this.space = Ft
            }
        }
        function ce(rn) {
            if (this.domElement.ownerDocument.pointerLockElement)
                return {
                    x: 0,
                    y: 0,
                    button: rn.button
                };
            {
                const Ft = this.domElement.getBoundingClientRect();
                return {
                    x: (rn.clientX - Ft.left) / Ft.width * 2 - 1,
                    y: -(rn.clientY - Ft.top) / Ft.height * 2 + 1,
                    button: rn.button
                }
            }
        }
        function xe(rn) {
            if (this.enabled)
                switch (rn.pointerType) {
                case "mouse":
                case "pen":
                    this.pointerHover(this._getPointer(rn));
                    break
                }
        }
        function Se(rn) {
            this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(rn.pointerId),
            this.domElement.addEventListener("pointermove", this._onPointerMove),
            this.pointerHover(this._getPointer(rn)),
            this.pointerDown(this._getPointer(rn)))
        }
        function $(rn) {
            this.enabled && this.pointerMove(this._getPointer(rn))
        }
        function q(rn) {
            this.enabled && (this.domElement.releasePointerCapture(rn.pointerId),
            this.domElement.removeEventListener("pointermove", this._onPointerMove),
            this.pointerUp(this._getPointer(rn)))
        }
        function N(rn, Ft, jt) {
            const Xt = Ft.intersectObject(rn, !0);
            for (let Rt = 0; Rt < Xt.length; Rt++)
                if (Xt[Rt].object.visible || jt)
                    return Xt[Rt];
            return !1
        }
        const ie = new s.USm
          , _e = new s.Pa4(0,1,0)
          , Pe = new s.Pa4(0,0,0)
          , Be = new s.yGw
          , Re = new s._fP
          , ct = new s._fP
          , et = new s.Pa4
          , Ze = new s.yGw
          , Nt = new s.Pa4(1,0,0)
          , Bt = new s.Pa4(0,1,0)
          , en = new s.Pa4(0,0,1)
          , li = new s.Pa4
          , di = new s.Pa4
          , xi = new s.Pa4;
        class zt extends s.Tme {
            constructor() {
                super(),
                this.isTransformControlsGizmo = !0,
                this.type = "TransformControlsGizmo";
                const Ft = new s.vBJ({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                    toneMapped: !1,
                    transparent: !0
                })
                  , jt = new s.nls({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                    toneMapped: !1,
                    transparent: !0
                })
                  , Xt = Ft.clone();
                Xt.opacity = .15;
                const Rt = jt.clone();
                Rt.opacity = .5;
                const Wn = Ft.clone();
                Wn.color.setHex(16711680);
                const He = Ft.clone();
                He.color.setHex(65280);
                const pt = Ft.clone();
                pt.color.setHex(255);
                const Fe = Ft.clone();
                Fe.color.setHex(16711680),
                Fe.opacity = .5;
                const qe = Ft.clone();
                qe.color.setHex(65280),
                qe.opacity = .5;
                const wt = Ft.clone();
                wt.color.setHex(255),
                wt.opacity = .5;
                const An = Ft.clone();
                An.opacity = .25;
                const Qt = Ft.clone();
                Qt.color.setHex(16776960),
                Qt.opacity = .25,
                Ft.clone().color.setHex(16776960);
                const ui = Ft.clone();
                ui.color.setHex(7895160);
                const mi = new s.fHI(0,.04,.1,12);
                mi.translate(0, .05, 0);
                const Si = new s.DvJ(.08,.08,.08);
                Si.translate(0, .04, 0);
                const Gt = new s.u9r;
                Gt.setAttribute("position", new s.a$l([0, 0, 0, 1, 0, 0],3));
                const On = new s.fHI(.0075,.0075,.5,3);
                On.translate(0, .25, 0);
                function kn(Ti, gi) {
                    const qi = new s.XvJ(Ti,.0075,3,64,gi * Math.PI * 2);
                    return qi.rotateY(Math.PI / 2),
                    qi.rotateX(Math.PI / 2),
                    qi
                }
                function bi() {
                    const Ti = new s.u9r;
                    return Ti.setAttribute("position", new s.a$l([0, 0, 0, 1, 1, 1],3)),
                    Ti
                }
                const $i = {
                    X: [[new s.Kj0(mi,Wn), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new s.Kj0(mi,Wn), [-.5, 0, 0], [0, 0, Math.PI / 2]], [new s.Kj0(On,Wn), [0, 0, 0], [0, 0, -Math.PI / 2]]],
                    Y: [[new s.Kj0(mi,He), [0, .5, 0]], [new s.Kj0(mi,He), [0, -.5, 0], [Math.PI, 0, 0]], [new s.Kj0(On,He)]],
                    Z: [[new s.Kj0(mi,pt), [0, 0, .5], [Math.PI / 2, 0, 0]], [new s.Kj0(mi,pt), [0, 0, -.5], [-Math.PI / 2, 0, 0]], [new s.Kj0(On,pt), null, [Math.PI / 2, 0, 0]]],
                    XYZ: [[new s.Kj0(new s.pQR(.1,0),An.clone()), [0, 0, 0]]],
                    XY: [[new s.Kj0(new s.DvJ(.15,.15,.01),wt.clone()), [.15, .15, 0]]],
                    YZ: [[new s.Kj0(new s.DvJ(.15,.15,.01),Fe.clone()), [0, .15, .15], [0, Math.PI / 2, 0]]],
                    XZ: [[new s.Kj0(new s.DvJ(.15,.15,.01),qe.clone()), [.15, 0, .15], [-Math.PI / 2, 0, 0]]]
                }
                  , zr = {
                    X: [[new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [-.3, 0, 0], [0, 0, Math.PI / 2]]],
                    Y: [[new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [0, .3, 0]], [new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [0, -.3, 0], [0, 0, Math.PI]]],
                    Z: [[new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [0, 0, .3], [Math.PI / 2, 0, 0]], [new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [0, 0, -.3], [-Math.PI / 2, 0, 0]]],
                    XYZ: [[new s.Kj0(new s.pQR(.2,0),Xt)]],
                    XY: [[new s.Kj0(new s.DvJ(.2,.2,.01),Xt), [.15, .15, 0]]],
                    YZ: [[new s.Kj0(new s.DvJ(.2,.2,.01),Xt), [0, .15, .15], [0, Math.PI / 2, 0]]],
                    XZ: [[new s.Kj0(new s.DvJ(.2,.2,.01),Xt), [.15, 0, .15], [-Math.PI / 2, 0, 0]]]
                }
                  , Fi = {
                    START: [[new s.Kj0(new s.pQR(.01,2),Rt), null, null, null, "helper"]],
                    END: [[new s.Kj0(new s.pQR(.01,2),Rt), null, null, null, "helper"]],
                    DELTA: [[new s.x12(bi(),Rt), null, null, null, "helper"]],
                    X: [[new s.x12(Gt,Rt.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
                    Y: [[new s.x12(Gt,Rt.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
                    Z: [[new s.x12(Gt,Rt.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
                }
                  , vr = {
                    XYZE: [[new s.Kj0(kn(.5, 1),ui), null, [0, Math.PI / 2, 0]]],
                    X: [[new s.Kj0(kn(.5, .5),Wn)]],
                    Y: [[new s.Kj0(kn(.5, .5),He), null, [0, 0, -Math.PI / 2]]],
                    Z: [[new s.Kj0(kn(.5, .5),pt), null, [0, Math.PI / 2, 0]]],
                    E: [[new s.Kj0(kn(.75, 1),Qt), null, [0, Math.PI / 2, 0]]]
                }
                  , Oi = {
                    AXIS: [[new s.x12(Gt,Rt.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
                }
                  , ts = {
                    XYZE: [[new s.Kj0(new s.xo$(.25,10,8),Xt)]],
                    X: [[new s.Kj0(new s.XvJ(.5,.1,4,24),Xt), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
                    Y: [[new s.Kj0(new s.XvJ(.5,.1,4,24),Xt), [0, 0, 0], [Math.PI / 2, 0, 0]]],
                    Z: [[new s.Kj0(new s.XvJ(.5,.1,4,24),Xt), [0, 0, 0], [0, 0, -Math.PI / 2]]],
                    E: [[new s.Kj0(new s.XvJ(.75,.1,2,24),Xt)]]
                }
                  , Gr = {
                    X: [[new s.Kj0(Si,Wn), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new s.Kj0(On,Wn), [0, 0, 0], [0, 0, -Math.PI / 2]], [new s.Kj0(Si,Wn), [-.5, 0, 0], [0, 0, Math.PI / 2]]],
                    Y: [[new s.Kj0(Si,He), [0, .5, 0]], [new s.Kj0(On,He)], [new s.Kj0(Si,He), [0, -.5, 0], [0, 0, Math.PI]]],
                    Z: [[new s.Kj0(Si,pt), [0, 0, .5], [Math.PI / 2, 0, 0]], [new s.Kj0(On,pt), [0, 0, 0], [Math.PI / 2, 0, 0]], [new s.Kj0(Si,pt), [0, 0, -.5], [-Math.PI / 2, 0, 0]]],
                    XY: [[new s.Kj0(new s.DvJ(.15,.15,.01),wt), [.15, .15, 0]]],
                    YZ: [[new s.Kj0(new s.DvJ(.15,.15,.01),Fe), [0, .15, .15], [0, Math.PI / 2, 0]]],
                    XZ: [[new s.Kj0(new s.DvJ(.15,.15,.01),qe), [.15, 0, .15], [-Math.PI / 2, 0, 0]]],
                    XYZ: [[new s.Kj0(new s.DvJ(.1,.1,.1),An.clone())]]
                }
                  , ys = {
                    X: [[new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [-.3, 0, 0], [0, 0, Math.PI / 2]]],
                    Y: [[new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [0, .3, 0]], [new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [0, -.3, 0], [0, 0, Math.PI]]],
                    Z: [[new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [0, 0, .3], [Math.PI / 2, 0, 0]], [new s.Kj0(new s.fHI(.2,0,.6,4),Xt), [0, 0, -.3], [-Math.PI / 2, 0, 0]]],
                    XY: [[new s.Kj0(new s.DvJ(.2,.2,.01),Xt), [.15, .15, 0]]],
                    YZ: [[new s.Kj0(new s.DvJ(.2,.2,.01),Xt), [0, .15, .15], [0, Math.PI / 2, 0]]],
                    XZ: [[new s.Kj0(new s.DvJ(.2,.2,.01),Xt), [.15, 0, .15], [-Math.PI / 2, 0, 0]]],
                    XYZ: [[new s.Kj0(new s.DvJ(.2,.2,.2),Xt), [0, 0, 0]]]
                }
                  , xs = {
                    X: [[new s.x12(Gt,Rt.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
                    Y: [[new s.x12(Gt,Rt.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
                    Z: [[new s.x12(Gt,Rt.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
                };
                function hi(Ti) {
                    const gi = new s.Tme;
                    for (const qi in Ti)
                        for (let ks = Ti[qi].length; ks--; ) {
                            const Gi = Ti[qi][ks][0].clone()
                              , Ao = Ti[qi][ks][1]
                              , Hi = Ti[qi][ks][2]
                              , Us = Ti[qi][ks][3]
                              , Ba = Ti[qi][ks][4];
                            Gi.name = qi,
                            Gi.tag = Ba,
                            Ao && Gi.position.set(Ao[0], Ao[1], Ao[2]),
                            Hi && Gi.rotation.set(Hi[0], Hi[1], Hi[2]),
                            Us && Gi.scale.set(Us[0], Us[1], Us[2]),
                            Gi.updateMatrix();
                            const Fr = Gi.geometry.clone();
                            Fr.applyMatrix4(Gi.matrix),
                            Gi.geometry = Fr,
                            Gi.renderOrder = 1 / 0,
                            Gi.position.set(0, 0, 0),
                            Gi.rotation.set(0, 0, 0),
                            Gi.scale.set(1, 1, 1),
                            Gi.isGizmo = !0,
                            gi.add(Gi)
                        }
                    return gi
                }
                this.gizmo = {},
                this.picker = {},
                this.helper = {},
                this.add(this.gizmo.translate = hi($i)),
                this.add(this.gizmo.rotate = hi(vr)),
                this.add(this.gizmo.scale = hi(Gr)),
                this.add(this.picker.translate = hi(zr)),
                this.add(this.picker.rotate = hi(ts)),
                this.add(this.picker.scale = hi(ys)),
                this.add(this.helper.translate = hi(Fi)),
                this.add(this.helper.rotate = hi(Oi)),
                this.add(this.helper.scale = hi(xs)),
                this.picker.translate.visible = !1,
                this.picker.rotate.visible = !1,
                this.picker.scale.visible = !1
            }
            updateMatrixWorld(Ft) {
                const Xt = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : ct;
                this.gizmo.translate.visible = this.mode === "translate",
                this.gizmo.rotate.visible = this.mode === "rotate",
                this.gizmo.scale.visible = this.mode === "scale",
                this.helper.translate.visible = this.mode === "translate",
                this.helper.rotate.visible = this.mode === "rotate",
                this.helper.scale.visible = this.mode === "scale";
                let Rt = [];
                Rt = Rt.concat(this.picker[this.mode].children),
                Rt = Rt.concat(this.gizmo[this.mode].children),
                Rt = Rt.concat(this.helper[this.mode].children);
                for (let Wn = 0; Wn < Rt.length; Wn++) {
                    const He = Rt[Wn];
                    He.visible = !0,
                    He.rotation.set(0, 0, 0),
                    He.position.copy(this.worldPosition);
                    let pt;
                    if (this.camera.isOrthographicCamera ? pt = (this.camera.top - this.camera.bottom) / this.camera.zoom : pt = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7),
                    He.scale.set(1, 1, 1).multiplyScalar(pt * this.size / 4),
                    He.tag === "helper") {
                        He.visible = !1,
                        He.name === "AXIS" ? (He.visible = !!this.axis,
                        this.axis === "X" && (_.setFromEuler(ie.set(0, 0, 0)),
                        He.quaternion.copy(Xt).multiply(_),
                        Math.abs(_e.copy(Nt).applyQuaternion(Xt).dot(this.eye)) > .9 && (He.visible = !1)),
                        this.axis === "Y" && (_.setFromEuler(ie.set(0, 0, Math.PI / 2)),
                        He.quaternion.copy(Xt).multiply(_),
                        Math.abs(_e.copy(Bt).applyQuaternion(Xt).dot(this.eye)) > .9 && (He.visible = !1)),
                        this.axis === "Z" && (_.setFromEuler(ie.set(0, Math.PI / 2, 0)),
                        He.quaternion.copy(Xt).multiply(_),
                        Math.abs(_e.copy(en).applyQuaternion(Xt).dot(this.eye)) > .9 && (He.visible = !1)),
                        this.axis === "XYZE" && (_.setFromEuler(ie.set(0, Math.PI / 2, 0)),
                        _e.copy(this.rotationAxis),
                        He.quaternion.setFromRotationMatrix(Be.lookAt(Pe, _e, Bt)),
                        He.quaternion.multiply(_),
                        He.visible = this.dragging),
                        this.axis === "E" && (He.visible = !1)) : He.name === "START" ? (He.position.copy(this.worldPositionStart),
                        He.visible = this.dragging) : He.name === "END" ? (He.position.copy(this.worldPosition),
                        He.visible = this.dragging) : He.name === "DELTA" ? (He.position.copy(this.worldPositionStart),
                        He.quaternion.copy(this.worldQuaternionStart),
                        l.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),
                        l.applyQuaternion(this.worldQuaternionStart.clone().invert()),
                        He.scale.copy(l),
                        He.visible = this.dragging) : (He.quaternion.copy(Xt),
                        this.dragging ? He.position.copy(this.worldPositionStart) : He.position.copy(this.worldPosition),
                        this.axis && (He.visible = this.axis.search(He.name) !== -1));
                        continue
                    }
                    He.quaternion.copy(Xt),
                    this.mode === "translate" || this.mode === "scale" ? (He.name === "X" && Math.abs(_e.copy(Nt).applyQuaternion(Xt).dot(this.eye)) > .99 && (He.scale.set(1e-10, 1e-10, 1e-10),
                    He.visible = !1),
                    He.name === "Y" && Math.abs(_e.copy(Bt).applyQuaternion(Xt).dot(this.eye)) > .99 && (He.scale.set(1e-10, 1e-10, 1e-10),
                    He.visible = !1),
                    He.name === "Z" && Math.abs(_e.copy(en).applyQuaternion(Xt).dot(this.eye)) > .99 && (He.scale.set(1e-10, 1e-10, 1e-10),
                    He.visible = !1),
                    He.name === "XY" && Math.abs(_e.copy(en).applyQuaternion(Xt).dot(this.eye)) < .2 && (He.scale.set(1e-10, 1e-10, 1e-10),
                    He.visible = !1),
                    He.name === "YZ" && Math.abs(_e.copy(Nt).applyQuaternion(Xt).dot(this.eye)) < .2 && (He.scale.set(1e-10, 1e-10, 1e-10),
                    He.visible = !1),
                    He.name === "XZ" && Math.abs(_e.copy(Bt).applyQuaternion(Xt).dot(this.eye)) < .2 && (He.scale.set(1e-10, 1e-10, 1e-10),
                    He.visible = !1)) : this.mode === "rotate" && (Re.copy(Xt),
                    _e.copy(this.eye).applyQuaternion(_.copy(Xt).invert()),
                    He.name.search("E") !== -1 && He.quaternion.setFromRotationMatrix(Be.lookAt(this.eye, Pe, Bt)),
                    He.name === "X" && (_.setFromAxisAngle(Nt, Math.atan2(-_e.y, _e.z)),
                    _.multiplyQuaternions(Re, _),
                    He.quaternion.copy(_)),
                    He.name === "Y" && (_.setFromAxisAngle(Bt, Math.atan2(_e.x, _e.z)),
                    _.multiplyQuaternions(Re, _),
                    He.quaternion.copy(_)),
                    He.name === "Z" && (_.setFromAxisAngle(en, Math.atan2(_e.y, _e.x)),
                    _.multiplyQuaternions(Re, _),
                    He.quaternion.copy(_))),
                    He.visible = He.visible && (He.name.indexOf("X") === -1 || this.showX),
                    He.visible = He.visible && (He.name.indexOf("Y") === -1 || this.showY),
                    He.visible = He.visible && (He.name.indexOf("Z") === -1 || this.showZ),
                    He.visible = He.visible && (He.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ),
                    He.material._color = He.material._color || He.material.color.clone(),
                    He.material._opacity = He.material._opacity || He.material.opacity,
                    He.material.color.copy(He.material._color),
                    He.material.opacity = He.material._opacity,
                    this.enabled && this.axis && (He.name === this.axis || this.axis.split("").some(function(Fe) {
                        return He.name === Fe
                    })) && (He.material.color.setHex(16776960),
                    He.material.opacity = 1)
                }
                super.updateMatrixWorld(Ft)
            }
        }
        class Sn extends s.Kj0 {
            constructor() {
                super(new s._12(1e5,1e5,2,2), new s.vBJ({
                    visible: !1,
                    wireframe: !0,
                    side: s.ehD,
                    transparent: !0,
                    opacity: .1,
                    toneMapped: !1
                })),
                this.isTransformControlsPlane = !0,
                this.type = "TransformControlsPlane"
            }
            updateMatrixWorld(Ft) {
                let jt = this.space;
                switch (this.position.copy(this.worldPosition),
                this.mode === "scale" && (jt = "local"),
                li.copy(Nt).applyQuaternion(jt === "local" ? this.worldQuaternion : ct),
                di.copy(Bt).applyQuaternion(jt === "local" ? this.worldQuaternion : ct),
                xi.copy(en).applyQuaternion(jt === "local" ? this.worldQuaternion : ct),
                _e.copy(di),
                this.mode) {
                case "translate":
                case "scale":
                    switch (this.axis) {
                    case "X":
                        _e.copy(this.eye).cross(li),
                        et.copy(li).cross(_e);
                        break;
                    case "Y":
                        _e.copy(this.eye).cross(di),
                        et.copy(di).cross(_e);
                        break;
                    case "Z":
                        _e.copy(this.eye).cross(xi),
                        et.copy(xi).cross(_e);
                        break;
                    case "XY":
                        et.copy(xi);
                        break;
                    case "YZ":
                        et.copy(li);
                        break;
                    case "XZ":
                        _e.copy(xi),
                        et.copy(di);
                        break;
                    case "XYZ":
                    case "E":
                        et.set(0, 0, 0);
                        break
                    }
                    break;
                case "rotate":
                default:
                    et.set(0, 0, 0)
                }
                et.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (Ze.lookAt(l.set(0, 0, 0), et, _e),
                this.quaternion.setFromRotationMatrix(Ze)),
                super.updateMatrixWorld(Ft)
            }
        }
    }
    ,
    477: (t,n,r)=>{
        r.d(n, {
            LY2: ()=>$i,
            bGH: ()=>et,
            NDo: ()=>Si,
            gSk: ()=>ye,
            WMw: ()=>Pe,
            OTo: ()=>jl,
            Se2: ()=>pt,
            cum: ()=>qt,
            Mig: ()=>Sb,
            i_9: ()=>tD,
            m7l: ()=>Ad,
            sYA: ()=>HR,
            Xcj: ()=>xD,
            mzJ: ()=>vD,
            ZZA: ()=>UR,
            T__: ()=>H1,
            HkE: ()=>p1,
            tGC: ()=>HD,
            BbS: ()=>Fb,
            kqm: ()=>aD,
            Hmr: ()=>G0,
            SJI: ()=>rD,
            mTL: ()=>$R,
            y8_: ()=>VD,
            _Li: ()=>$,
            z81: ()=>ni,
            _MY: ()=>R,
            N$j: ()=>f0,
            _YM: ()=>Yc,
            TUj: ()=>CD,
            ZzF: ()=>Zr,
            GQ: ()=>zD,
            nvb: ()=>KD,
            DvJ: ()=>Jl,
            fQA: ()=>ND,
            TlE: ()=>dr,
            u9r: ()=>Ai,
            s4_: ()=>Cb,
            T95: ()=>jo,
            CtF: ()=>tc,
            V1s: ()=>ip,
            Rki: ()=>UD,
            ROQ: ()=>lR,
            YN5: ()=>ZD,
            BVQ: ()=>sd,
            YT8: ()=>V1,
            YGz: ()=>bi,
            trn: ()=>qD,
            zf8: ()=>od,
            uWy: ()=>hi,
            SUY: ()=>Ib,
            Ilk: ()=>gn,
            R2R: ()=>O0,
            epp: ()=>bt,
            Z_g: ()=>aR,
            EB7: ()=>v0,
            DqL: ()=>VR,
            _3: ()=>JD,
            b_z: ()=>ad,
            _am: ()=>Nx,
            fY$: ()=>vr,
            vxC: ()=>Oi,
            BtG: ()=>Zh,
            cBK: ()=>WR,
            g8_: ()=>ys,
            AXT: ()=>w0,
            yj7: ()=>j1,
            dYG: ()=>fb,
            tm_: ()=>m,
            S2y: ()=>D,
            B02: ()=>U,
            PeU: ()=>A,
            Hyl: ()=>Ta,
            Wqd: ()=>Y1,
            Xaj: ()=>ct,
            dZ3: ()=>zr,
            m_w: ()=>$D,
            fHI: ()=>Vc,
            LBq: ()=>MD,
            JUT: ()=>ir,
            p3g: ()=>pr,
            IEO: ()=>Wu,
            yxD: ()=>jR,
            A5E: ()=>QD,
            jfJ: ()=>te,
            T_J: ()=>Ge,
            tEQ: ()=>gb,
            qkB: ()=>$s,
            brP: ()=>ho,
            $YQ: ()=>m1,
            Ox3: ()=>Ab,
            cBI: ()=>kD,
            cU9: ()=>pb,
            ntt: ()=>F,
            DT1: ()=>eL,
            Kgo: ()=>ld,
            ehD: ()=>q,
            fSK: ()=>Ft,
            Vdb: ()=>Xt,
            l8J: ()=>fr,
            dj0: ()=>Tn,
            QM0: ()=>En,
            TOt: ()=>Q1,
            Ny0: ()=>Ap,
            eD: ()=>wt,
            jwo: ()=>gt,
            dSO: ()=>ts,
            Bf4: ()=>Gr,
            USm: ()=>Wh,
            pBf: ()=>Kr,
            $Vf: ()=>tL,
            O7d: ()=>dd,
            hH6: ()=>Al,
            e62: ()=>JC,
            a$l: ()=>Rn,
            OM3: ()=>$C,
            VzW: ()=>Js,
            ybr: ()=>dp,
            yo9: ()=>hp,
            Wzm: ()=>oR,
            Wl3: ()=>Se,
            iWj: ()=>sp,
            ylh: ()=>SD,
            v9Y: ()=>is,
            LSk: ()=>Tr,
            w$m: ()=>Qt,
            ksN: ()=>An,
            j4z: ()=>dn,
            OAl: ()=>Xe,
            VLJ: ()=>BD,
            ZAu: ()=>Nu,
            cLu: ()=>So,
            vmT: ()=>vb,
            Qpg: ()=>OD,
            So8: ()=>eD,
            Wjw: ()=>nL,
            cJO: ()=>fd,
            QRU: ()=>JR,
            S3k: ()=>Sd,
            PpQ: ()=>yn,
            ZRs: ()=>fe,
            oqc: ()=>Te,
            lb7: ()=>ju,
            L5s: ()=>Mb,
            $TI: ()=>AD,
            SPe: ()=>L1,
            aVm: ()=>ZC,
            j87: ()=>qC,
            RNb: ()=>YC,
            Kz5: ()=>da,
            vpT: ()=>fp,
            kB5: ()=>Hc,
            _C8: ()=>xd,
            Syv: ()=>ws,
            NMF: ()=>Gs,
            pIN: ()=>S,
            eMJ: ()=>St,
            x5V: ()=>W,
            tUh: ()=>Ea,
            z8B: ()=>A1,
            GZb: ()=>iL,
            p7y: ()=>Xu,
            S9g: ()=>Xf,
            Zr5: ()=>Fe,
            vCF: ()=>qe,
            yt0: ()=>xt,
            uXU: ()=>Vt,
            _kC: ()=>nc,
            lk7: ()=>Lp,
            x12: ()=>ec,
            Zzh: ()=>PD,
            nls: ()=>ro,
            g_z: ()=>Tp,
            U7: ()=>X1,
            FT0: ()=>hb,
            blk: ()=>U1,
            ejS: ()=>Xa,
            rnI: ()=>nn,
            wem: ()=>Hi,
            lfu: ()=>I0,
            FDw: ()=>Ns,
            lRj: ()=>Ba,
            D1R: ()=>Fr,
            qyh: ()=>Us,
            GUF: ()=>L,
            EoG: ()=>On,
            aNw: ()=>Oo,
            Zp0: ()=>z0,
            lLk: ()=>B0,
            jAl: ()=>ya,
            uEv: ()=>mo,
            YKA: ()=>Yo,
            cRx: ()=>al,
            Y8D: ()=>ol,
            RsA: ()=>g,
            F5T: ()=>Vs,
            u7G: ()=>Ip,
            M8C: ()=>Tu,
            Vkp: ()=>Cr,
            yGw: ()=>pi,
            Sm8: ()=>en,
            Kj0: ()=>Es,
            vBJ: ()=>ql,
            lRF: ()=>a0,
            Lun: ()=>l0,
            YBo: ()=>cb,
            kaV: ()=>ub,
            RSm: ()=>lb,
            xoR: ()=>ob,
            EJi: ()=>sb,
            Wid: ()=>P0,
            IKL: ()=>ab,
            r_: ()=>Bt,
            OoA: ()=>Ti,
            qhX: ()=>mi,
            M5h: ()=>Re,
            Ns1: ()=>ui,
            TyD: ()=>gi,
            vZf: ()=>Ao,
            HTd: ()=>ks,
            aH4: ()=>Gi,
            YLQ: ()=>qi,
            BVF: ()=>He,
            MyG: ()=>kt,
            jFi: ()=>ie,
            aCh: ()=>E,
            uL9: ()=>Gt,
            IFH: ()=>se,
            bdR: ()=>_e,
            M6v: ()=>Pi,
            RvT: ()=>ut,
            dUE: ()=>bd,
            Tme: ()=>Qi,
            Gql: ()=>ZR,
            PA7: ()=>b,
            REq: ()=>rL,
            pQR: ()=>Qu,
            ghN: ()=>di,
            Hy8: ()=>jt,
            Wpd: ()=>Rt,
            LgZ: ()=>rn,
            iWC: ()=>zt,
            iKG: ()=>ap,
            _iA: ()=>ne,
            ntZ: ()=>ce,
            anP: ()=>i0,
            y$t: ()=>rd,
            cPb: ()=>Ms,
            JOQ: ()=>$l,
            BKK: ()=>sL,
            _12: ()=>Bu,
            tJx: ()=>GD,
            cek: ()=>wb,
            xG9: ()=>LD,
            woe: ()=>z1,
            UY4: ()=>m0,
            aq0: ()=>FD,
            ujx: ()=>oL,
            Uol: ()=>bl,
            VYz: ()=>oD,
            iUV: ()=>ji,
            tf: ()=>Ub,
            ZQ6: ()=>A0,
            mXe: ()=>S0,
            _fP: ()=>Vi,
            iLg: ()=>Zu,
            zbs: ()=>mb,
            ZTh: ()=>ns,
            HdW: ()=>Va,
            UZH: ()=>l,
            mSO: ()=>ae,
            wk1: ()=>Xr,
            E2K: ()=>ul,
            FUD: ()=>Xo,
            pKu: ()=>va,
            GG6: ()=>po,
            Gih: ()=>Mo,
            iiP: ()=>zs,
            SvJ: ()=>_a,
            ptH: ()=>fl,
            jZA: ()=>pl,
            y2t: ()=>ga,
            gi4: ()=>Ha,
            Djp: ()=>To,
            BG$: ()=>Eo,
            NYV: ()=>Yr,
            xJs: ()=>Qr,
            bsb: ()=>Co,
            ekQ: ()=>dl,
            CaW: ()=>nr,
            eaV: ()=>ma,
            BFQ: ()=>Ua,
            v3W: ()=>Na,
            ILR: ()=>pa,
            fto: ()=>fo,
            l0P: ()=>Ga,
            vCx: ()=>za,
            _AM: ()=>hl,
            wuA: ()=>ka,
            av9: ()=>cl,
            CtA: ()=>fa,
            FIo: ()=>rb,
            zHn: ()=>Vh,
            iMs: ()=>TD,
            T_f: ()=>Tb,
            hEm: ()=>Xl,
            D9w: ()=>ll,
            CdI: ()=>kn,
            rpg: ()=>xs,
            ce8: ()=>re,
            rOj: ()=>Nt,
            V4E: ()=>aL,
            o8S: ()=>pd,
            lGU: ()=>Po,
            vuL: ()=>eo,
            KI_: ()=>T,
            xsS: ()=>v1,
            WdD: ()=>yi,
            Vj0: ()=>Sa,
            jyz: ()=>ja,
            Tn7: ()=>ib,
            bnF: ()=>Wc,
            HW6: ()=>lL,
            oa8: ()=>md,
            T_1: ()=>WD,
            iDF: ()=>Ya,
            iAb: ()=>us,
            OdW: ()=>_p,
            _YX: ()=>DD,
            TUv: ()=>C1,
            Hw6: ()=>Nn,
            aLr: ()=>Nc,
            Aip: ()=>cL,
            xo$: ()=>Ku,
            $V: ()=>ED,
            lDi: ()=>Eb,
            gti: ()=>T0,
            PMe: ()=>xb,
            FvO: ()=>RD,
            jyi: ()=>b1,
            xeV: ()=>h0,
            k74: ()=>Sn,
            RlZ: ()=>Wn,
            KhW: ()=>xi,
            HgB: ()=>ar,
            W2J: ()=>ln,
            JWc: ()=>Hn,
            u37: ()=>nD,
            Z6B: ()=>lr,
            QZ1: ()=>fn,
            Ir4: ()=>Ei,
            NwF: ()=>Qc,
            Wbm: ()=>Ze,
            N4l: ()=>Be,
            QmN: ()=>_,
            IOt: ()=>y,
            L5g: ()=>uL,
            H$k: ()=>gd,
            xEZ: ()=>$t,
            dpR: ()=>XR,
            Cne: ()=>hL,
            XvJ: ()=>vd,
            XZw: ()=>dL,
            FE5: ()=>_d,
            CJI: ()=>qo,
            z$h: ()=>mt,
            UlW: ()=>Ce,
            WwZ: ()=>ue,
            Lcc: ()=>fL,
            WXh: ()=>yd,
            ub3: ()=>N,
            xfE: ()=>Fi,
            qlB: ()=>Kg,
            lCJ: ()=>Zg,
            WTc: ()=>QC,
            rAo: ()=>KC,
            xWb: ()=>W0,
            gH0: ()=>wD,
            rBU: ()=>Zt,
            rDY: ()=>Ux,
            ywz: ()=>bs,
            wJv: ()=>ti,
            JQ4: ()=>uo,
            k0A: ()=>Fa,
            irR: ()=>Wl,
            LsT: ()=>ha,
            dwk: ()=>xe,
            FM8: ()=>_t,
            Pa4: ()=>me,
            Ltg: ()=>mn,
            yC1: ()=>wd,
            fO1: ()=>sR,
            b5g: ()=>g1,
            Ywn: ()=>Bi,
            GVz: ()=>to,
            oAp: ()=>zx,
            kFz: ()=>Hr,
            dd2: ()=>ki,
            CP7: ()=>u0,
            fQK: ()=>f1,
            Uk6: ()=>tb,
            _sL: ()=>V,
            Pnf: ()=>p,
            c8b: ()=>li,
            _lf: ()=>C,
            ad5: ()=>j,
            L_r: ()=>Er,
            knz: ()=>cn
        });
        var s = {};
        r.r(s),
        r.d(s, {
            ArcCurve: ()=>H1,
            CatmullRomCurve3: ()=>V1,
            CubicBezierCurve: ()=>w0,
            CubicBezierCurve3: ()=>j1,
            EllipseCurve: ()=>Ap,
            LineCurve: ()=>Tp,
            LineCurve3: ()=>X1,
            QuadraticBezierCurve: ()=>A0,
            QuadraticBezierCurve3: ()=>S0,
            SplineCurve: ()=>T0
        });
        var h = {};
        r.r(h),
        r.d(h, {
            BoxGeometry: ()=>Jl,
            CapsuleGeometry: ()=>sd,
            CircleGeometry: ()=>od,
            ConeGeometry: ()=>ad,
            CylinderGeometry: ()=>Vc,
            DodecahedronGeometry: ()=>ld,
            EdgesGeometry: ()=>Q1,
            ExtrudeGeometry: ()=>dd,
            IcosahedronGeometry: ()=>fd,
            LatheGeometry: ()=>Xu,
            OctahedronGeometry: ()=>Qu,
            PlaneGeometry: ()=>Bu,
            PolyhedronGeometry: ()=>bl,
            RingGeometry: ()=>pd,
            ShapeGeometry: ()=>md,
            SphereGeometry: ()=>Ku,
            TetrahedronGeometry: ()=>gd,
            TorusGeometry: ()=>vd,
            TorusKnotGeometry: ()=>_d,
            TubeGeometry: ()=>yd,
            WireframeGeometry: ()=>tb
        });
        const l = "150"
          , g = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        }
          , _ = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        }
          , A = 0
          , m = 1
          , D = 2
          , U = 3
          , R = 0
          , ne = 1
          , ce = 2
          , xe = 3
          , Se = 0
          , $ = 1
          , q = 2
          , N = 2
          , ie = 0
          , _e = 1
          , Pe = 2
          , Be = 3
          , Re = 4
          , ct = 5
          , et = 100
          , Ze = 101
          , Nt = 102
          , Bt = 103
          , en = 104
          , li = 200
          , di = 201
          , xi = 202
          , zt = 203
          , Sn = 204
          , rn = 205
          , Ft = 206
          , jt = 207
          , Xt = 208
          , Rt = 209
          , Wn = 210
          , He = 0
          , pt = 1
          , Fe = 2
          , qe = 3
          , wt = 4
          , An = 5
          , Qt = 6
          , Pi = 7
          , ui = 0
          , mi = 1
          , Si = 2
          , Gt = 0
          , On = 1
          , kn = 2
          , bi = 3
          , $i = 4
          , zr = 5
          , Fi = 300
          , vr = 301
          , Oi = 302
          , ts = 303
          , Gr = 304
          , ys = 306
          , xs = 1e3
          , hi = 1001
          , Ti = 1002
          , gi = 1003
          , qi = 1004
          , ks = 1004
          , Gi = 1005
          , Ao = 1005
          , Hi = 1006
          , Us = 1007
          , Ba = 1007
          , Fr = 1008
          , Ns = 1008
          , bs = 1009
          , jo = 1010
          , us = 1011
          , ha = 1012
          , da = 1013
          , uo = 1014
          , Js = 1015
          , So = 1016
          , Fa = 1017
          , Wl = 1018
          , ti = 1020
          , jl = 1021
          , Xr = 1023
          , ol = 1024
          , al = 1025
          , $s = 1026
          , ho = 1027
          , Xl = 1028
          , ll = 1029
          , cl = 1030
          , fa = 1031
          , ul = 1033
          , ka = 33776
          , Ua = 33777
          , Na = 33778
          , pa = 33779
          , hl = 35840
          , za = 35841
          , ma = 35842
          , nr = 35843
          , fo = 36196
          , Ga = 37492
          , dl = 37496
          , fl = 37808
          , pl = 37809
          , ga = 37810
          , Ha = 37811
          , To = 37812
          , Eo = 37813
          , Yr = 37814
          , Qr = 37815
          , va = 37816
          , po = 37817
          , Mo = 37818
          , Xo = 37819
          , zs = 37820
          , _a = 37821
          , Co = 36492
          , Va = 36283
          , eo = 36284
          , ns = 36285
          , Po = 36286
          , ya = 2200
          , Yo = 2201
          , mo = 2202
          , ws = 2300
          , Gs = 2301
          , S = 2302
          , p = 2400
          , C = 2401
          , V = 2402
          , se = 2500
          , ye = 2501
          , ue = 0
          , Ce = 1
          , mt = 2
          , nn = 3e3
          , cn = 3001
          , ni = 3200
          , ae = 3201
          , y = 0
          , b = 1
          , E = ""
          , T = "srgb"
          , L = "srgb-linear"
          , F = "display-p3"
          , j = 0
          , W = 7680
          , re = 7681
          , fe = 7682
          , te = 7683
          , Te = 34055
          , Ge = 34056
          , St = 5386
          , kt = 512
          , Vt = 513
          , gt = 514
          , xt = 515
          , Xe = 516
          , ut = 517
          , dn = 518
          , qt = 519
          , ln = 35044
          , Tn = 35048
          , fn = 35040
          , Hn = 35045
          , En = 35049
          , Ei = 35041
          , ar = 35046
          , fr = 35050
          , lr = 35042
          , is = "100"
          , Tr = "300 es"
          , Er = 1035;
        class Kr {
            addEventListener(e, i) {
                this._listeners === void 0 && (this._listeners = {});
                const o = this._listeners;
                o[e] === void 0 && (o[e] = []),
                o[e].indexOf(i) === -1 && o[e].push(i)
            }
            hasEventListener(e, i) {
                if (this._listeners === void 0)
                    return !1;
                const o = this._listeners;
                return o[e] !== void 0 && o[e].indexOf(i) !== -1
            }
            removeEventListener(e, i) {
                if (this._listeners === void 0)
                    return;
                const a = this._listeners[e];
                if (a !== void 0) {
                    const c = a.indexOf(i);
                    c !== -1 && a.splice(c, 1)
                }
            }
            dispatchEvent(e) {
                if (this._listeners === void 0)
                    return;
                const o = this._listeners[e.type];
                if (o !== void 0) {
                    e.target = this;
                    const a = o.slice(0);
                    for (let c = 0, d = a.length; c < d; c++)
                        a[c].call(this, e);
                    e.target = null
                }
            }
        }
        class Vi {
            constructor(e=0, i=0, o=0, a=1) {
                this.isQuaternion = !0,
                this._x = e,
                this._y = i,
                this._z = o,
                this._w = a
            }
            static slerpFlat(e, i, o, a, c, d, f) {
                let v = o[a + 0]
                  , x = o[a + 1]
                  , w = o[a + 2]
                  , P = o[a + 3];
                const M = c[d + 0]
                  , I = c[d + 1]
                  , z = c[d + 2]
                  , O = c[d + 3];
                if (f === 0) {
                    e[i + 0] = v,
                    e[i + 1] = x,
                    e[i + 2] = w,
                    e[i + 3] = P;
                    return
                }
                if (f === 1) {
                    e[i + 0] = M,
                    e[i + 1] = I,
                    e[i + 2] = z,
                    e[i + 3] = O;
                    return
                }
                if (P !== O || v !== M || x !== I || w !== z) {
                    let k = 1 - f;
                    const Q = v * M + x * I + w * z + P * O
                      , Z = Q >= 0 ? 1 : -1
                      , X = 1 - Q * Q;
                    if (X > Number.EPSILON) {
                        const de = Math.sqrt(X)
                          , be = Math.atan2(de, Q * Z);
                        k = Math.sin(k * be) / de,
                        f = Math.sin(f * be) / de
                    }
                    const K = f * Z;
                    if (v = v * k + M * K,
                    x = x * k + I * K,
                    w = w * k + z * K,
                    P = P * k + O * K,
                    k === 1 - f) {
                        const de = 1 / Math.sqrt(v * v + x * x + w * w + P * P);
                        v *= de,
                        x *= de,
                        w *= de,
                        P *= de
                    }
                }
                e[i] = v,
                e[i + 1] = x,
                e[i + 2] = w,
                e[i + 3] = P
            }
            static multiplyQuaternionsFlat(e, i, o, a, c, d) {
                const f = o[a]
                  , v = o[a + 1]
                  , x = o[a + 2]
                  , w = o[a + 3]
                  , P = c[d]
                  , M = c[d + 1]
                  , I = c[d + 2]
                  , z = c[d + 3];
                return e[i] = f * z + w * P + v * I - x * M,
                e[i + 1] = v * z + w * M + x * P - f * I,
                e[i + 2] = x * z + w * I + f * M - v * P,
                e[i + 3] = w * z - f * P - v * M - x * I,
                e
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e,
                this._onChangeCallback()
            }
            set(e, i, o, a) {
                return this._x = e,
                this._y = i,
                this._z = o,
                this._w = a,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(e) {
                return this._x = e.x,
                this._y = e.y,
                this._z = e.z,
                this._w = e.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(e, i) {
                const o = e._x
                  , a = e._y
                  , c = e._z
                  , d = e._order
                  , f = Math.cos
                  , v = Math.sin
                  , x = f(o / 2)
                  , w = f(a / 2)
                  , P = f(c / 2)
                  , M = v(o / 2)
                  , I = v(a / 2)
                  , z = v(c / 2);
                switch (d) {
                case "XYZ":
                    this._x = M * w * P + x * I * z,
                    this._y = x * I * P - M * w * z,
                    this._z = x * w * z + M * I * P,
                    this._w = x * w * P - M * I * z;
                    break;
                case "YXZ":
                    this._x = M * w * P + x * I * z,
                    this._y = x * I * P - M * w * z,
                    this._z = x * w * z - M * I * P,
                    this._w = x * w * P + M * I * z;
                    break;
                case "ZXY":
                    this._x = M * w * P - x * I * z,
                    this._y = x * I * P + M * w * z,
                    this._z = x * w * z + M * I * P,
                    this._w = x * w * P - M * I * z;
                    break;
                case "ZYX":
                    this._x = M * w * P - x * I * z,
                    this._y = x * I * P + M * w * z,
                    this._z = x * w * z - M * I * P,
                    this._w = x * w * P + M * I * z;
                    break;
                case "YZX":
                    this._x = M * w * P + x * I * z,
                    this._y = x * I * P + M * w * z,
                    this._z = x * w * z - M * I * P,
                    this._w = x * w * P - M * I * z;
                    break;
                case "XZY":
                    this._x = M * w * P - x * I * z,
                    this._y = x * I * P - M * w * z,
                    this._z = x * w * z + M * I * P,
                    this._w = x * w * P + M * I * z;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + d)
                }
                return i !== !1 && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(e, i) {
                const o = i / 2
                  , a = Math.sin(o);
                return this._x = e.x * a,
                this._y = e.y * a,
                this._z = e.z * a,
                this._w = Math.cos(o),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(e) {
                const i = e.elements
                  , o = i[0]
                  , a = i[4]
                  , c = i[8]
                  , d = i[1]
                  , f = i[5]
                  , v = i[9]
                  , x = i[2]
                  , w = i[6]
                  , P = i[10]
                  , M = o + f + P;
                if (M > 0) {
                    const I = .5 / Math.sqrt(M + 1);
                    this._w = .25 / I,
                    this._x = (w - v) * I,
                    this._y = (c - x) * I,
                    this._z = (d - a) * I
                } else if (o > f && o > P) {
                    const I = 2 * Math.sqrt(1 + o - f - P);
                    this._w = (w - v) / I,
                    this._x = .25 * I,
                    this._y = (a + d) / I,
                    this._z = (c + x) / I
                } else if (f > P) {
                    const I = 2 * Math.sqrt(1 + f - o - P);
                    this._w = (c - x) / I,
                    this._x = (a + d) / I,
                    this._y = .25 * I,
                    this._z = (v + w) / I
                } else {
                    const I = 2 * Math.sqrt(1 + P - o - f);
                    this._w = (d - a) / I,
                    this._x = (c + x) / I,
                    this._y = (v + w) / I,
                    this._z = .25 * I
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(e, i) {
                let o = e.dot(i) + 1;
                return o < Number.EPSILON ? (o = 0,
                Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                this._y = e.x,
                this._z = 0,
                this._w = o) : (this._x = 0,
                this._y = -e.z,
                this._z = e.y,
                this._w = o)) : (this._x = e.y * i.z - e.z * i.y,
                this._y = e.z * i.x - e.x * i.z,
                this._z = e.x * i.y - e.y * i.x,
                this._w = o),
                this.normalize()
            }
            angleTo(e) {
                return 2 * Math.acos(Math.abs(Wi(this.dot(e), -1, 1)))
            }
            rotateTowards(e, i) {
                const o = this.angleTo(e);
                if (o === 0)
                    return this;
                const a = Math.min(1, i / o);
                return this.slerp(e, a),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let e = this.length();
                return e === 0 ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (e = 1 / e,
                this._x = this._x * e,
                this._y = this._y * e,
                this._z = this._z * e,
                this._w = this._w * e),
                this._onChangeCallback(),
                this
            }
            multiply(e) {
                return this.multiplyQuaternions(this, e)
            }
            premultiply(e) {
                return this.multiplyQuaternions(e, this)
            }
            multiplyQuaternions(e, i) {
                const o = e._x
                  , a = e._y
                  , c = e._z
                  , d = e._w
                  , f = i._x
                  , v = i._y
                  , x = i._z
                  , w = i._w;
                return this._x = o * w + d * f + a * x - c * v,
                this._y = a * w + d * v + c * f - o * x,
                this._z = c * w + d * x + o * v - a * f,
                this._w = d * w - o * f - a * v - c * x,
                this._onChangeCallback(),
                this
            }
            slerp(e, i) {
                if (i === 0)
                    return this;
                if (i === 1)
                    return this.copy(e);
                const o = this._x
                  , a = this._y
                  , c = this._z
                  , d = this._w;
                let f = d * e._w + o * e._x + a * e._y + c * e._z;
                if (f < 0 ? (this._w = -e._w,
                this._x = -e._x,
                this._y = -e._y,
                this._z = -e._z,
                f = -f) : this.copy(e),
                f >= 1)
                    return this._w = d,
                    this._x = o,
                    this._y = a,
                    this._z = c,
                    this;
                const v = 1 - f * f;
                if (v <= Number.EPSILON) {
                    const I = 1 - i;
                    return this._w = I * d + i * this._w,
                    this._x = I * o + i * this._x,
                    this._y = I * a + i * this._y,
                    this._z = I * c + i * this._z,
                    this.normalize(),
                    this._onChangeCallback(),
                    this
                }
                const x = Math.sqrt(v)
                  , w = Math.atan2(x, f)
                  , P = Math.sin((1 - i) * w) / x
                  , M = Math.sin(i * w) / x;
                return this._w = d * P + this._w * M,
                this._x = o * P + this._x * M,
                this._y = a * P + this._y * M,
                this._z = c * P + this._z * M,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(e, i, o) {
                return this.copy(e).slerp(i, o)
            }
            random() {
                const e = Math.random()
                  , i = Math.sqrt(1 - e)
                  , o = Math.sqrt(e)
                  , a = 2 * Math.PI * Math.random()
                  , c = 2 * Math.PI * Math.random();
                return this.set(i * Math.cos(a), o * Math.sin(c), o * Math.cos(c), i * Math.sin(a))
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            }
            fromArray(e, i=0) {
                return this._x = e[i],
                this._y = e[i + 1],
                this._z = e[i + 2],
                this._w = e[i + 3],
                this._onChangeCallback(),
                this
            }
            toArray(e=[], i=0) {
                return e[i] = this._x,
                e[i + 1] = this._y,
                e[i + 2] = this._z,
                e[i + 3] = this._w,
                e
            }
            fromBufferAttribute(e, i) {
                return this._x = e.getX(i),
                this._y = e.getY(i),
                this._z = e.getZ(i),
                this._w = e.getW(i),
                this
            }
            _onChange(e) {
                return this._onChangeCallback = e,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._w
            }
        }
        const os = class os {
            constructor(e=0, i=0, o=0) {
                os.prototype.isVector3 = !0,
                this.x = e,
                this.y = i,
                this.z = o
            }
            set(e, i, o) {
                return o === void 0 && (o = this.z),
                this.x = e,
                this.y = i,
                this.z = o,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this.z = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setZ(e) {
                return this.z = e,
                this
            }
            setComponent(e, i) {
                switch (e) {
                case 0:
                    this.x = i;
                    break;
                case 1:
                    this.y = i;
                    break;
                case 2:
                    this.z = i;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this.z += e,
                this
            }
            addVectors(e, i) {
                return this.x = e.x + i.x,
                this.y = e.y + i.y,
                this.z = e.z + i.z,
                this
            }
            addScaledVector(e, i) {
                return this.x += e.x * i,
                this.y += e.y * i,
                this.z += e.z * i,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this.z -= e,
                this
            }
            subVectors(e, i) {
                return this.x = e.x - i.x,
                this.y = e.y - i.y,
                this.z = e.z - i.z,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this
            }
            multiplyVectors(e, i) {
                return this.x = e.x * i.x,
                this.y = e.y * i.y,
                this.z = e.z * i.z,
                this
            }
            applyEuler(e) {
                return this.applyQuaternion(Qo.setFromEuler(e))
            }
            applyAxisAngle(e, i) {
                return this.applyQuaternion(Qo.setFromAxisAngle(e, i))
            }
            applyMatrix3(e) {
                const i = this.x
                  , o = this.y
                  , a = this.z
                  , c = e.elements;
                return this.x = c[0] * i + c[3] * o + c[6] * a,
                this.y = c[1] * i + c[4] * o + c[7] * a,
                this.z = c[2] * i + c[5] * o + c[8] * a,
                this
            }
            applyNormalMatrix(e) {
                return this.applyMatrix3(e).normalize()
            }
            applyMatrix4(e) {
                const i = this.x
                  , o = this.y
                  , a = this.z
                  , c = e.elements
                  , d = 1 / (c[3] * i + c[7] * o + c[11] * a + c[15]);
                return this.x = (c[0] * i + c[4] * o + c[8] * a + c[12]) * d,
                this.y = (c[1] * i + c[5] * o + c[9] * a + c[13]) * d,
                this.z = (c[2] * i + c[6] * o + c[10] * a + c[14]) * d,
                this
            }
            applyQuaternion(e) {
                const i = this.x
                  , o = this.y
                  , a = this.z
                  , c = e.x
                  , d = e.y
                  , f = e.z
                  , v = e.w
                  , x = v * i + d * a - f * o
                  , w = v * o + f * i - c * a
                  , P = v * a + c * o - d * i
                  , M = -c * i - d * o - f * a;
                return this.x = x * v + M * -c + w * -f - P * -d,
                this.y = w * v + M * -d + P * -c - x * -f,
                this.z = P * v + M * -f + x * -d - w * -c,
                this
            }
            project(e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            }
            unproject(e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            }
            transformDirection(e) {
                const i = this.x
                  , o = this.y
                  , a = this.z
                  , c = e.elements;
                return this.x = c[0] * i + c[4] * o + c[8] * a,
                this.y = c[1] * i + c[5] * o + c[9] * a,
                this.z = c[2] * i + c[6] * o + c[10] * a,
                this.normalize()
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this.z /= e.z,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this.z = Math.min(this.z, e.z),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this.z = Math.max(this.z, e.z),
                this
            }
            clamp(e, i) {
                return this.x = Math.max(e.x, Math.min(i.x, this.x)),
                this.y = Math.max(e.y, Math.min(i.y, this.y)),
                this.z = Math.max(e.z, Math.min(i.z, this.z)),
                this
            }
            clampScalar(e, i) {
                return this.x = Math.max(e, Math.min(i, this.x)),
                this.y = Math.max(e, Math.min(i, this.y)),
                this.z = Math.max(e, Math.min(i, this.z)),
                this
            }
            clampLength(e, i) {
                const o = this.length();
                return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(i, o)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, i) {
                return this.x += (e.x - this.x) * i,
                this.y += (e.y - this.y) * i,
                this.z += (e.z - this.z) * i,
                this
            }
            lerpVectors(e, i, o) {
                return this.x = e.x + (i.x - e.x) * o,
                this.y = e.y + (i.y - e.y) * o,
                this.z = e.z + (i.z - e.z) * o,
                this
            }
            cross(e) {
                return this.crossVectors(this, e)
            }
            crossVectors(e, i) {
                const o = e.x
                  , a = e.y
                  , c = e.z
                  , d = i.x
                  , f = i.y
                  , v = i.z;
                return this.x = a * v - c * f,
                this.y = c * d - o * v,
                this.z = o * f - a * d,
                this
            }
            projectOnVector(e) {
                const i = e.lengthSq();
                if (i === 0)
                    return this.set(0, 0, 0);
                const o = e.dot(this) / i;
                return this.copy(e).multiplyScalar(o)
            }
            projectOnPlane(e) {
                return _r.copy(this).projectOnVector(e),
                this.sub(_r)
            }
            reflect(e) {
                return this.sub(_r.copy(e).multiplyScalar(2 * this.dot(e)))
            }
            angleTo(e) {
                const i = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (i === 0)
                    return Math.PI / 2;
                const o = this.dot(e) / i;
                return Math.acos(Wi(o, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const i = this.x - e.x
                  , o = this.y - e.y
                  , a = this.z - e.z;
                return i * i + o * o + a * a
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            }
            setFromSpherical(e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            }
            setFromSphericalCoords(e, i, o) {
                const a = Math.sin(i) * e;
                return this.x = a * Math.sin(o),
                this.y = Math.cos(i) * e,
                this.z = a * Math.cos(o),
                this
            }
            setFromCylindrical(e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            }
            setFromCylindricalCoords(e, i, o) {
                return this.x = e * Math.sin(i),
                this.y = o,
                this.z = e * Math.cos(i),
                this
            }
            setFromMatrixPosition(e) {
                const i = e.elements;
                return this.x = i[12],
                this.y = i[13],
                this.z = i[14],
                this
            }
            setFromMatrixScale(e) {
                const i = this.setFromMatrixColumn(e, 0).length()
                  , o = this.setFromMatrixColumn(e, 1).length()
                  , a = this.setFromMatrixColumn(e, 2).length();
                return this.x = i,
                this.y = o,
                this.z = a,
                this
            }
            setFromMatrixColumn(e, i) {
                return this.fromArray(e.elements, i * 4)
            }
            setFromMatrix3Column(e, i) {
                return this.fromArray(e.elements, i * 3)
            }
            setFromEuler(e) {
                return this.x = e._x,
                this.y = e._y,
                this.z = e._z,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            }
            fromArray(e, i=0) {
                return this.x = e[i],
                this.y = e[i + 1],
                this.z = e[i + 2],
                this
            }
            toArray(e=[], i=0) {
                return e[i] = this.x,
                e[i + 1] = this.y,
                e[i + 2] = this.z,
                e
            }
            fromBufferAttribute(e, i) {
                return this.x = e.getX(i),
                this.y = e.getY(i),
                this.z = e.getZ(i),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
            randomDirection() {
                const e = (Math.random() - .5) * 2
                  , i = Math.random() * Math.PI * 2
                  , o = Math.sqrt(1 - e ** 2);
                return this.x = o * Math.cos(i),
                this.y = o * Math.sin(i),
                this.z = e,
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z
            }
        }
        ;
        B(os, "UNIT_X", Object.freeze(new os(1,0,0))),
        B(os, "UNIT_Y", Object.freeze(new os(0,1,0))),
        B(os, "UNIT_Z", Object.freeze(new os(0,0,1))),
        B(os, "RIGHT", Object.freeze(new os(1,0,0))),
        B(os, "UP", Object.freeze(new os(0,1,0))),
        B(os, "ZERO", Object.freeze(new os(0,0,0))),
        B(os, "ONE", Object.freeze(new os(1,1,1))),
        B(os, "NEG_ONE", Object.freeze(new os(-1,-1,-1)));
        let me = os;
        const _r = new me
          , Qo = new Vi
          , Ji = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let xa = 1234567;
        const wi = Math.PI / 180
          , Mr = 180 / Math.PI;
        function yr() {
            const u = Math.random() * 4294967295 | 0
              , e = Math.random() * 4294967295 | 0
              , i = Math.random() * 4294967295 | 0
              , o = Math.random() * 4294967295 | 0;
            return (Ji[u & 255] + Ji[u >> 8 & 255] + Ji[u >> 16 & 255] + Ji[u >> 24 & 255] + "-" + Ji[e & 255] + Ji[e >> 8 & 255] + "-" + Ji[e >> 16 & 15 | 64] + Ji[e >> 24 & 255] + "-" + Ji[i & 63 | 128] + Ji[i >> 8 & 255] + "-" + Ji[i >> 16 & 255] + Ji[i >> 24 & 255] + Ji[o & 255] + Ji[o >> 8 & 255] + Ji[o >> 16 & 255] + Ji[o >> 24 & 255]).toLowerCase()
        }
        function Wi(u, e, i) {
            return Math.max(e, Math.min(i, u))
        }
        function Ko(u) {
            return Wi(u, 0, 1)
        }
        function ve(u, e) {
            return (u % e + e) % e
        }
        function oe(u, e, i, o, a) {
            return o + (u - e) * (a - o) / (i - e)
        }
        function G(u, e, i) {
            return u !== e ? (i - u) / (e - u) : 0
        }
        function ee(u, e, i) {
            return (1 - i) * u + i * e
        }
        function ke(u, e, i, o) {
            return ee(u, e, 1 - Math.exp(-i * o))
        }
        function Ne(u, e=1) {
            return e - Math.abs(ve(u, e * 2) - e)
        }
        function $e(u, e, i) {
            return u <= e ? 0 : u >= i ? 1 : (u = (u - e) / (i - e),
            u * u * (3 - 2 * u))
        }
        function vt(u, e, i) {
            return u <= e ? 0 : u >= i ? 1 : (u = (u - e) / (i - e),
            u * u * u * (u * (u * 6 - 15) + 10))
        }
        function Lt(u, e) {
            return u + Math.random() * (e - u + 1) >> 0
        }
        function Pn(u, e) {
            return u + Math.random() * (e - u)
        }
        function un(u) {
            return u * (.5 - Math.random())
        }
        function vn(u) {
            u !== void 0 && (xa = u);
            let e = xa += 1831565813;
            return e = Math.imul(e ^ e >>> 15, e | 1),
            e ^= e + Math.imul(e ^ e >>> 7, e | 61),
            ((e ^ e >>> 14) >>> 0) / 4294967296
        }
        function _n(u) {
            return u * wi
        }
        function qn(u) {
            return u * Mr
        }
        function ii(u) {
            return (u & u - 1) === 0 && u !== 0
        }
        function Mi(u) {
            return Math.pow(2, Math.ceil(Math.log(u) / Math.LN2))
        }
        function Jn(u) {
            return Math.pow(2, Math.floor(Math.log(u) / Math.LN2))
        }
        function cr(u, e, i, o, a) {
            const c = Math.cos
              , d = Math.sin
              , f = c(i / 2)
              , v = d(i / 2)
              , x = c((e + o) / 2)
              , w = d((e + o) / 2)
              , P = c((e - o) / 2)
              , M = d((e - o) / 2)
              , I = c((o - e) / 2)
              , z = d((o - e) / 2);
            switch (a) {
            case "XYX":
                u.set(f * w, v * P, v * M, f * x);
                break;
            case "YZY":
                u.set(v * M, f * w, v * P, f * x);
                break;
            case "ZXZ":
                u.set(v * P, v * M, f * w, f * x);
                break;
            case "XZX":
                u.set(f * w, v * z, v * I, f * x);
                break;
            case "YXY":
                u.set(v * I, f * w, v * z, f * x);
                break;
            case "ZYZ":
                u.set(v * z, v * I, f * w, f * x);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + a)
            }
        }
        function ur(u, e) {
            switch (e.constructor) {
            case Float32Array:
                return u;
            case Uint16Array:
                return u / 65535;
            case Uint8Array:
                return u / 255;
            case Int16Array:
                return Math.max(u / 32767, -1);
            case Int8Array:
                return Math.max(u / 127, -1);
            default:
                throw new Error("Invalid component type.")
            }
        }
        function fi(u, e) {
            switch (e.constructor) {
            case Float32Array:
                return u;
            case Uint16Array:
                return Math.round(u * 65535);
            case Uint8Array:
                return Math.round(u * 255);
            case Int16Array:
                return Math.round(u * 32767);
            case Int8Array:
                return Math.round(u * 127);
            default:
                throw new Error("Invalid component type.")
            }
        }
        const {min: As, max: kr, abs: hr} = Math
          , vi = 1e-6
          , Ro = Math.log(.01);
        function Ss(u, e, i, o) {
            let a = -Ro / i;
            return u + (e - u) * (1 - exp(-a * o))
        }
        function xr(u, e, i, o) {
            let a = 1 - As(o, i) / i
              , c = a * a;
            return u + (e - u) * (1 - c * c)
        }
        function ml(u, e, i, o, a, c) {
            u._velocity === void 0 && (u._velocity = 0),
            o = kr(1e-4, o);
            let d = 2 / o
              , f = d * c
              , v = 1 / (1 + f + .48 * f * f + .235 * f * f * f)
              , x = e - i
              , w = i
              , P = a * o;
            x = Wi(x, -P, P),
            i = e - x;
            let M = (u._velocity + d * x) * c;
            u._velocity = (u._velocity - d * M) * v;
            let I = i + (x + M) * v;
            return w - e > 0 == I > w && (I = w,
            u._velocity = (I - w) / c),
            I
        }
        function hn(u, e, i, o, a=u) {
            return a.copy(u).slerp(e, Ss(0, 1, i, o))
        }
        function Fc(u, e, i, o, a=u) {
            return a.copy(u).slerp(e, xr(0, 1, i, o))
        }
        function Dg(u, e, i, o, a=u) {
            return a.copy(u).slerp(e, ml(a, 0, 1, i, 1 / 0, o))
        }
        function Lg(u, e, i, o, a=u) {
            return a.copy(u).lerp(e, ml(a, 0, 1, i, 1 / 0, o))
        }
        let Uf = new me;
        function Ig(u, e, i, o, a=u) {
            if (o <= 0)
                return a.copy(e);
            let c = Uf.copy(e).sub(u);
            return c.lengthSq() < vi ? a.copy(e) : a.copy(u).add(c.multiplyScalar(Wi(i * o, 0, 1)))
        }
        function Og(u, e, i, o, a=u) {
            let c = Uf.copy(e).sub(u)
              , d = c.length()
              , f = o * i;
            if (d > f)
                if (f > 0) {
                    let v = c.multiplyScalar(1 / d);
                    return a.copy(u).add(v)
                } else
                    return a.copy(u);
            return a.copy(e)
        }
        function zh(u, e, i=vi) {
            return hr(u.x - e.x) <= i * kr(1, hr(u.x), hr(e.x)) && hr(u.y - e.y) <= i * kr(1, hr(u.y), hr(e.y)) && hr(u.z - e.z) <= i * kr(1, hr(u.z), hr(e.z)) && hr(u.w - e.w) <= i * kr(1, hr(u.w), hr(e.w))
        }
        function Nf(u, e) {
            let i = u.x * e.x + u.y * e.y + u.z * e.z + u.w * e.w;
            return acos(2 * i * i - 1)
        }
        function Bg(u, e, i, o) {
            return o <= 0 || zh(u, e) ? e : u.slerp(e, Wi(o * i, 0, 1))
        }
        function Fg(u, e, i, o, a=u) {
            if (o <= 0 || zh(u, e))
                return a.copy(e);
            let c = Wi(o * i, 0, 1)
              , d = kr(Nf(u, e), vi);
            return a.copy(u).slerp(e, Wi(c / d, 0, 1))
        }
        function kg(u, e, i, o) {
            if (o <= 0)
                return e;
            let a = e - u;
            return hr(a) < vi ? e : u + a * Wi(o * i, 0, 1)
        }
        function Ug(u, e, i, o) {
            let a = e - u;
            if (hr(a) < vi)
                return e;
            let c = o * i;
            return u + Wi(a, -c, c)
        }
        const Tu = {
            DEG2RAD: wi,
            RAD2DEG: Mr,
            generateUUID: yr,
            clamp: Wi,
            clamp01: Ko,
            euclideanModulo: ve,
            mapLinear: oe,
            inverseLerp: G,
            lerp: ee,
            damp: ke,
            pingpong: Ne,
            smoothstep: $e,
            smootherstep: vt,
            randInt: Lt,
            randFloat: Pn,
            randFloatSpread: un,
            seededRandom: vn,
            degToRad: _n,
            radToDeg: qn,
            isPowerOfTwo: ii,
            ceilPowerOfTwo: Mi,
            floorPowerOfTwo: Jn,
            setQuaternionFromProperEuler: cr,
            normalize: fi,
            denormalize: ur,
            exponentialDamp: Ss,
            quarticDamp: xr,
            smoothDamp: ml,
            Quat_Equals: zh,
            Quat_AngularDistance: Nf,
            Quat_exponentialDamp: hn,
            Quat_quarticDamp: Fc,
            Quat_smoothDamp: Dg,
            Vec3_smoothDamp: Lg,
            VInterpTo: Ig,
            VInterpConstantTo: Og,
            QInterpTo: Bg,
            QInterpConstantTo: Fg,
            FInterpTo: kg,
            FInterpConstantTo: Ug
        };
        class _t {
            constructor(e=0, i=0) {
                _t.prototype.isVector2 = !0,
                this.x = e,
                this.y = i
            }
            get width() {
                return this.x
            }
            set width(e) {
                this.x = e
            }
            get height() {
                return this.y
            }
            set height(e) {
                this.y = e
            }
            set(e, i) {
                return this.x = e,
                this.y = i,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setComponent(e, i) {
                switch (e) {
                case 0:
                    this.x = i;
                    break;
                case 1:
                    this.y = i;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this
            }
            addVectors(e, i) {
                return this.x = e.x + i.x,
                this.y = e.y + i.y,
                this
            }
            addScaledVector(e, i) {
                return this.x += e.x * i,
                this.y += e.y * i,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this
            }
            subVectors(e, i) {
                return this.x = e.x - i.x,
                this.y = e.y - i.y,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            applyMatrix3(e) {
                const i = this.x
                  , o = this.y
                  , a = e.elements;
                return this.x = a[0] * i + a[3] * o + a[6],
                this.y = a[1] * i + a[4] * o + a[7],
                this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this
            }
            clamp(e, i) {
                return this.x = Math.max(e.x, Math.min(i.x, this.x)),
                this.y = Math.max(e.y, Math.min(i.y, this.y)),
                this
            }
            clampScalar(e, i) {
                return this.x = Math.max(e, Math.min(i, this.x)),
                this.y = Math.max(e, Math.min(i, this.y)),
                this
            }
            clampLength(e, i) {
                const o = this.length();
                return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(i, o)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            cross(e) {
                return this.x * e.y - this.y * e.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const i = this.x - e.x
                  , o = this.y - e.y;
                return i * i + o * o
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, i) {
                return this.x += (e.x - this.x) * i,
                this.y += (e.y - this.y) * i,
                this
            }
            lerpVectors(e, i, o) {
                return this.x = e.x + (i.x - e.x) * o,
                this.y = e.y + (i.y - e.y) * o,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y
            }
            fromArray(e, i=0) {
                return this.x = e[i],
                this.y = e[i + 1],
                this
            }
            toArray(e=[], i=0) {
                return e[i] = this.x,
                e[i + 1] = this.y,
                e
            }
            fromBufferAttribute(e, i) {
                return this.x = e.getX(i),
                this.y = e.getY(i),
                this
            }
            rotateAround(e, i) {
                const o = Math.cos(i)
                  , a = Math.sin(i)
                  , c = this.x - e.x
                  , d = this.y - e.y;
                return this.x = c * o - d * a + e.x,
                this.y = c * a + d * o + e.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y
            }
        }
        class Cr {
            constructor() {
                Cr.prototype.isMatrix3 = !0,
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
            }
            set(e, i, o, a, c, d, f, v, x) {
                const w = this.elements;
                return w[0] = e,
                w[1] = a,
                w[2] = f,
                w[3] = i,
                w[4] = c,
                w[5] = v,
                w[6] = o,
                w[7] = d,
                w[8] = x,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(e) {
                const i = this.elements
                  , o = e.elements;
                return i[0] = o[0],
                i[1] = o[1],
                i[2] = o[2],
                i[3] = o[3],
                i[4] = o[4],
                i[5] = o[5],
                i[6] = o[6],
                i[7] = o[7],
                i[8] = o[8],
                this
            }
            extractBasis(e, i, o) {
                return e.setFromMatrix3Column(this, 0),
                i.setFromMatrix3Column(this, 1),
                o.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(e) {
                const i = e.elements;
                return this.set(i[0], i[4], i[8], i[1], i[5], i[9], i[2], i[6], i[10]),
                this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, i) {
                const o = e.elements
                  , a = i.elements
                  , c = this.elements
                  , d = o[0]
                  , f = o[3]
                  , v = o[6]
                  , x = o[1]
                  , w = o[4]
                  , P = o[7]
                  , M = o[2]
                  , I = o[5]
                  , z = o[8]
                  , O = a[0]
                  , k = a[3]
                  , Q = a[6]
                  , Z = a[1]
                  , X = a[4]
                  , K = a[7]
                  , de = a[2]
                  , be = a[5]
                  , Me = a[8];
                return c[0] = d * O + f * Z + v * de,
                c[3] = d * k + f * X + v * be,
                c[6] = d * Q + f * K + v * Me,
                c[1] = x * O + w * Z + P * de,
                c[4] = x * k + w * X + P * be,
                c[7] = x * Q + w * K + P * Me,
                c[2] = M * O + I * Z + z * de,
                c[5] = M * k + I * X + z * be,
                c[8] = M * Q + I * K + z * Me,
                this
            }
            multiplyScalar(e) {
                const i = this.elements;
                return i[0] *= e,
                i[3] *= e,
                i[6] *= e,
                i[1] *= e,
                i[4] *= e,
                i[7] *= e,
                i[2] *= e,
                i[5] *= e,
                i[8] *= e,
                this
            }
            determinant() {
                const e = this.elements
                  , i = e[0]
                  , o = e[1]
                  , a = e[2]
                  , c = e[3]
                  , d = e[4]
                  , f = e[5]
                  , v = e[6]
                  , x = e[7]
                  , w = e[8];
                return i * d * w - i * f * x - o * c * w + o * f * v + a * c * x - a * d * v
            }
            invert() {
                const e = this.elements
                  , i = e[0]
                  , o = e[1]
                  , a = e[2]
                  , c = e[3]
                  , d = e[4]
                  , f = e[5]
                  , v = e[6]
                  , x = e[7]
                  , w = e[8]
                  , P = w * d - f * x
                  , M = f * v - w * c
                  , I = x * c - d * v
                  , z = i * P + o * M + a * I;
                if (z === 0)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const O = 1 / z;
                return e[0] = P * O,
                e[1] = (a * x - w * o) * O,
                e[2] = (f * o - a * d) * O,
                e[3] = M * O,
                e[4] = (w * i - a * v) * O,
                e[5] = (a * c - f * i) * O,
                e[6] = I * O,
                e[7] = (o * v - x * i) * O,
                e[8] = (d * i - o * c) * O,
                this
            }
            transpose() {
                let e;
                const i = this.elements;
                return e = i[1],
                i[1] = i[3],
                i[3] = e,
                e = i[2],
                i[2] = i[6],
                i[6] = e,
                e = i[5],
                i[5] = i[7],
                i[7] = e,
                this
            }
            getNormalMatrix(e) {
                return this.setFromMatrix4(e).invert().transpose()
            }
            transposeIntoArray(e) {
                const i = this.elements;
                return e[0] = i[0],
                e[1] = i[3],
                e[2] = i[6],
                e[3] = i[1],
                e[4] = i[4],
                e[5] = i[7],
                e[6] = i[2],
                e[7] = i[5],
                e[8] = i[8],
                this
            }
            setUvTransform(e, i, o, a, c, d, f) {
                const v = Math.cos(c)
                  , x = Math.sin(c);
                return this.set(o * v, o * x, -o * (v * d + x * f) + d + e, -a * x, a * v, -a * (-x * d + v * f) + f + i, 0, 0, 1),
                this
            }
            scale(e, i) {
                return this.premultiply(gl.makeScale(e, i)),
                this
            }
            rotate(e) {
                return this.premultiply(gl.makeRotation(-e)),
                this
            }
            translate(e, i) {
                return this.premultiply(gl.makeTranslation(e, i)),
                this
            }
            makeTranslation(e, i) {
                return this.set(1, 0, e, 0, 1, i, 0, 0, 1),
                this
            }
            makeRotation(e) {
                const i = Math.cos(e)
                  , o = Math.sin(e);
                return this.set(i, -o, 0, o, i, 0, 0, 0, 1),
                this
            }
            makeRotationY(e) {
                const i = Math.cos(e)
                  , o = Math.sin(e);
                return this.set(i, 0, o, 0, 1, 0, -o, 0, i, 0, 0, 1),
                this
            }
            makeScale(e, i) {
                return this.set(e, 0, 0, 0, i, 0, 0, 0, 1),
                this
            }
            equals(e) {
                const i = this.elements
                  , o = e.elements;
                for (let a = 0; a < 9; a++)
                    if (i[a] !== o[a])
                        return !1;
                return !0
            }
            fromArray(e, i=0) {
                for (let o = 0; o < 9; o++)
                    this.elements[o] = e[o + i];
                return this
            }
            toArray(e=[], i=0) {
                const o = this.elements;
                return e[i] = o[0],
                e[i + 1] = o[1],
                e[i + 2] = o[2],
                e[i + 3] = o[3],
                e[i + 4] = o[4],
                e[i + 5] = o[5],
                e[i + 6] = o[6],
                e[i + 7] = o[7],
                e[i + 8] = o[8],
                e
            }
            clone() {
                return new this.constructor().fromArray(this.elements)
            }
        }
        const gl = new Cr;
        function Ci(u) {
            for (let e = u.length - 1; e >= 0; --e)
                if (u[e] >= 65535)
                    return !0;
            return !1
        }
        const zf = {
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
        };
        function Yl(u, e) {
            return new zf[u](e)
        }
        function Y(u) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", u)
        }
        function le(u) {
            return u < .04045 ? u * .0773993808 : Math.pow(u * .9478672986 + .0521327014, 2.4)
        }
        function Ee(u) {
            return u < .0031308 ? u * 12.92 : 1.055 * Math.pow(u, .41666) - .055
        }
        const Ve = new Cr().fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199])
          , at = new Cr().fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735])
          , Qe = new me;
        function Et(u) {
            return u.convertSRGBToLinear(),
            Qe.set(u.r, u.g, u.b).applyMatrix3(at),
            u.setRGB(Qe.x, Qe.y, Qe.z)
        }
        function Ut(u) {
            return Qe.set(u.r, u.g, u.b).applyMatrix3(Ve),
            u.setRGB(Qe.x, Qe.y, Qe.z).convertLinearToSRGB()
        }
        const Yt = {
            [L]: u=>u,
            [T]: u=>u.convertSRGBToLinear(),
            [F]: Et
        }
          , At = {
            [L]: u=>u,
            [T]: u=>u.convertLinearToSRGB(),
            [F]: Ut
        }
          , bt = {
            enabled: !1,
            get legacyMode() {
                return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
                !this.enabled
            },
            set legacyMode(u) {
                console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
                this.enabled = !u
            },
            get workingColorSpace() {
                return L
            },
            set workingColorSpace(u) {
                console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
            },
            convert: function(u, e, i) {
                if (this.enabled === !1 || e === i || !e || !i)
                    return u;
                const o = Yt[e]
                  , a = At[i];
                if (o === void 0 || a === void 0)
                    throw new Error(`Unsupported color space conversion, "${e}" to "${i}".`);
                return a(o(u))
            },
            fromWorkingColorSpace: function(u, e) {
                return this.convert(u, this.workingColorSpace, e)
            },
            toWorkingColorSpace: function(u, e) {
                return this.convert(u, e, this.workingColorSpace)
            }
        };
        let pn;
        class yn {
            static getDataURL(e) {
                if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
                    return e.src;
                let i;
                if (e instanceof HTMLCanvasElement)
                    i = e;
                else {
                    pn === void 0 && (pn = Y("canvas")),
                    pn.width = e.width,
                    pn.height = e.height;
                    const o = pn.getContext("2d");
                    e instanceof ImageData ? o.putImageData(e, 0, 0) : o.drawImage(e, 0, 0, e.width, e.height),
                    i = pn
                }
                return i.width > 2048 || i.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
                i.toDataURL("image/jpeg", .6)) : i.toDataURL("image/png")
            }
            static sRGBToLinear(e) {
                if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
                    const i = Y("canvas");
                    i.width = e.width,
                    i.height = e.height;
                    const o = i.getContext("2d");
                    o.drawImage(e, 0, 0, e.width, e.height);
                    const a = o.getImageData(0, 0, e.width, e.height)
                      , c = a.data;
                    for (let d = 0; d < c.length; d++)
                        c[d] = le(c[d] / 255) * 255;
                    return o.putImageData(a, 0, 0),
                    i
                } else if (e.data) {
                    const i = e.data.slice(0);
                    for (let o = 0; o < i.length; o++)
                        i instanceof Uint8Array || i instanceof Uint8ClampedArray ? i[o] = Math.floor(le(i[o] / 255) * 255) : i[o] = le(i[o]);
                    return {
                        data: i,
                        width: e.width,
                        height: e.height
                    }
                } else
                    return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                    e
            }
        }
        class Nn {
            constructor(e=null) {
                this.isSource = !0,
                this.uuid = yr(),
                this.data = e,
                this.version = 0
            }
            set needsUpdate(e) {
                e === !0 && this.version++
            }
            toJSON(e) {
                const i = e === void 0 || typeof e == "string";
                if (!i && e.images[this.uuid] !== void 0)
                    return e.images[this.uuid];
                const o = {
                    uuid: this.uuid,
                    url: ""
                }
                  , a = this.data;
                if (a !== null) {
                    let c;
                    if (Array.isArray(a)) {
                        c = [];
                        for (let d = 0, f = a.length; d < f; d++)
                            a[d].isDataTexture ? c.push(ci(a[d].image)) : c.push(ci(a[d]))
                    } else
                        c = ci(a);
                    o.url = c
                }
                return i || (e.images[this.uuid] = o),
                o
            }
        }
        function ci(u) {
            return typeof HTMLImageElement < "u" && u instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && u instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && u instanceof ImageBitmap ? yn.getDataURL(u) : u.data ? {
                data: Array.from(u.data),
                width: u.width,
                height: u.height,
                type: u.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        let Dn = 0;
        class $t extends Kr {
            constructor(e=$t.DEFAULT_IMAGE, i=$t.DEFAULT_MAPPING, o=hi, a=hi, c=Hi, d=Fr, f=Xr, v=bs, x=$t.DEFAULT_ANISOTROPY, w=nn) {
                super(),
                this.isTexture = !0,
                Object.defineProperty(this, "id", {
                    value: Dn++
                }),
                this.uuid = yr(),
                this.name = "",
                this.source = new Nn(e),
                this.mipmaps = [],
                this.mapping = i,
                this.wrapS = o,
                this.wrapT = a,
                this.magFilter = c,
                this.minFilter = d,
                this.anisotropy = x,
                this.format = f,
                this.internalFormat = null,
                this.type = v,
                this.offset = new _t(0,0),
                this.repeat = new _t(1,1),
                this.center = new _t(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new Cr,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                this.encoding = w,
                this.userData = {},
                this.version = 0,
                this.onUpdate = null,
                this.fbo = null,
                this.isRenderTargetTexture = !1,
                this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(e=null) {
                this.source.data = e
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.name = e.name,
                this.source = e.source,
                this.mipmaps = e.mipmaps.slice(0),
                this.mapping = e.mapping,
                this.wrapS = e.wrapS,
                this.wrapT = e.wrapT,
                this.magFilter = e.magFilter,
                this.minFilter = e.minFilter,
                this.anisotropy = e.anisotropy,
                this.format = e.format,
                this.internalFormat = e.internalFormat,
                this.type = e.type,
                this.offset.copy(e.offset),
                this.repeat.copy(e.repeat),
                this.center.copy(e.center),
                this.rotation = e.rotation,
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this.matrix.copy(e.matrix),
                this.generateMipmaps = e.generateMipmaps,
                this.premultiplyAlpha = e.premultiplyAlpha,
                this.flipY = e.flipY,
                this.unpackAlignment = e.unpackAlignment,
                this.encoding = e.encoding,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                this.needsUpdate = !0,
                this
            }
            toJSON(e) {
                const i = e === void 0 || typeof e == "string";
                if (!i && e.textures[this.uuid] !== void 0)
                    return e.textures[this.uuid];
                const o = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(e).uuid,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (o.userData = this.userData),
                i || (e.textures[this.uuid] = o),
                o
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(e) {
                if (this.mapping !== Fi)
                    return e;
                if (e.applyMatrix3(this.matrix),
                e.x < 0 || e.x > 1)
                    switch (this.wrapS) {
                    case xs:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case hi:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case Ti:
                        Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                        break
                    }
                if (e.y < 0 || e.y > 1)
                    switch (this.wrapT) {
                    case xs:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case hi:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case Ti:
                        Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                        break
                    }
                return this.flipY && (e.y = 1 - e.y),
                e
            }
            set needsUpdate(e) {
                e === !0 && (this.version++,
                this.source.needsUpdate = !0)
            }
        }
        $t.DEFAULT_IMAGE = null,
        $t.DEFAULT_MAPPING = Fi,
        $t.DEFAULT_ANISOTROPY = 1;
        class mn {
            constructor(e=0, i=0, o=0, a=1) {
                mn.prototype.isVector4 = !0,
                this.x = e,
                this.y = i,
                this.z = o,
                this.w = a
            }
            get width() {
                return this.z
            }
            set width(e) {
                this.z = e
            }
            get height() {
                return this.w
            }
            set height(e) {
                this.w = e
            }
            set(e, i, o, a) {
                return this.x = e,
                this.y = i,
                this.z = o,
                this.w = a,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this.z = e,
                this.w = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setZ(e) {
                return this.z = e,
                this
            }
            setW(e) {
                return this.w = e,
                this
            }
            setComponent(e, i) {
                switch (e) {
                case 0:
                    this.x = i;
                    break;
                case 1:
                    this.y = i;
                    break;
                case 2:
                    this.z = i;
                    break;
                case 3:
                    this.w = i;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this.w = e.w !== void 0 ? e.w : 1,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this.w += e.w,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this.z += e,
                this.w += e,
                this
            }
            addVectors(e, i) {
                return this.x = e.x + i.x,
                this.y = e.y + i.y,
                this.z = e.z + i.z,
                this.w = e.w + i.w,
                this
            }
            addScaledVector(e, i) {
                return this.x += e.x * i,
                this.y += e.y * i,
                this.z += e.z * i,
                this.w += e.w * i,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this.w -= e.w,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this.z -= e,
                this.w -= e,
                this
            }
            subVectors(e, i) {
                return this.x = e.x - i.x,
                this.y = e.y - i.y,
                this.z = e.z - i.z,
                this.w = e.w - i.w,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this.w *= e.w,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this.w *= e,
                this
            }
            applyMatrix4(e) {
                const i = this.x
                  , o = this.y
                  , a = this.z
                  , c = this.w
                  , d = e.elements;
                return this.x = d[0] * i + d[4] * o + d[8] * a + d[12] * c,
                this.y = d[1] * i + d[5] * o + d[9] * a + d[13] * c,
                this.z = d[2] * i + d[6] * o + d[10] * a + d[14] * c,
                this.w = d[3] * i + d[7] * o + d[11] * a + d[15] * c,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            setAxisAngleFromQuaternion(e) {
                this.w = 2 * Math.acos(e.w);
                const i = Math.sqrt(1 - e.w * e.w);
                return i < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = e.x / i,
                this.y = e.y / i,
                this.z = e.z / i),
                this
            }
            setAxisAngleFromRotationMatrix(e) {
                let i, o, a, c;
                const v = e.elements
                  , x = v[0]
                  , w = v[4]
                  , P = v[8]
                  , M = v[1]
                  , I = v[5]
                  , z = v[9]
                  , O = v[2]
                  , k = v[6]
                  , Q = v[10];
                if (Math.abs(w - M) < .01 && Math.abs(P - O) < .01 && Math.abs(z - k) < .01) {
                    if (Math.abs(w + M) < .1 && Math.abs(P + O) < .1 && Math.abs(z + k) < .1 && Math.abs(x + I + Q - 3) < .1)
                        return this.set(1, 0, 0, 0),
                        this;
                    i = Math.PI;
                    const X = (x + 1) / 2
                      , K = (I + 1) / 2
                      , de = (Q + 1) / 2
                      , be = (w + M) / 4
                      , Me = (P + O) / 4
                      , J = (z + k) / 4;
                    return X > K && X > de ? X < .01 ? (o = 0,
                    a = .707106781,
                    c = .707106781) : (o = Math.sqrt(X),
                    a = be / o,
                    c = Me / o) : K > de ? K < .01 ? (o = .707106781,
                    a = 0,
                    c = .707106781) : (a = Math.sqrt(K),
                    o = be / a,
                    c = J / a) : de < .01 ? (o = .707106781,
                    a = .707106781,
                    c = 0) : (c = Math.sqrt(de),
                    o = Me / c,
                    a = J / c),
                    this.set(o, a, c, i),
                    this
                }
                let Z = Math.sqrt((k - z) * (k - z) + (P - O) * (P - O) + (M - w) * (M - w));
                return Math.abs(Z) < .001 && (Z = 1),
                this.x = (k - z) / Z,
                this.y = (P - O) / Z,
                this.z = (M - w) / Z,
                this.w = Math.acos((x + I + Q - 1) / 2),
                this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this.z = Math.min(this.z, e.z),
                this.w = Math.min(this.w, e.w),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this.z = Math.max(this.z, e.z),
                this.w = Math.max(this.w, e.w),
                this
            }
            clamp(e, i) {
                return this.x = Math.max(e.x, Math.min(i.x, this.x)),
                this.y = Math.max(e.y, Math.min(i.y, this.y)),
                this.z = Math.max(e.z, Math.min(i.z, this.z)),
                this.w = Math.max(e.w, Math.min(i.w, this.w)),
                this
            }
            clampScalar(e, i) {
                return this.x = Math.max(e, Math.min(i, this.x)),
                this.y = Math.max(e, Math.min(i, this.y)),
                this.z = Math.max(e, Math.min(i, this.z)),
                this.w = Math.max(e, Math.min(i, this.w)),
                this
            }
            clampLength(e, i) {
                const o = this.length();
                return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(i, o)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, i) {
                return this.x += (e.x - this.x) * i,
                this.y += (e.y - this.y) * i,
                this.z += (e.z - this.z) * i,
                this.w += (e.w - this.w) * i,
                this
            }
            lerpVectors(e, i, o) {
                return this.x = e.x + (i.x - e.x) * o,
                this.y = e.y + (i.y - e.y) * o,
                this.z = e.z + (i.z - e.z) * o,
                this.w = e.w + (i.w - e.w) * o,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
            fromArray(e, i=0) {
                return this.x = e[i],
                this.y = e[i + 1],
                this.z = e[i + 2],
                this.w = e[i + 3],
                this
            }
            toArray(e=[], i=0) {
                return e[i] = this.x,
                e[i + 1] = this.y,
                e[i + 2] = this.z,
                e[i + 3] = this.w,
                e
            }
            fromBufferAttribute(e, i) {
                return this.x = e.getX(i),
                this.y = e.getY(i),
                this.z = e.getZ(i),
                this.w = e.getW(i),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z,
                yield this.w
            }
        }
        class ki extends Kr {
            constructor(e=1, i=1, o={}) {
                super(),
                this.isWebGLRenderTarget = !0,
                this.width = e,
                this.height = i,
                this.depth = 1,
                this.scissor = new mn(0,0,e,i),
                this.scissorTest = !1,
                this.viewport = new mn(0,0,e,i);
                const a = {
                    width: e,
                    height: i,
                    depth: 1
                };
                this.texture = new $t(a,o.mapping,o.wrapS,o.wrapT,o.magFilter,o.minFilter,o.format,o.type,o.anisotropy,o.encoding),
                this.texture.isRenderTargetTexture = !0,
                this.texture.flipY = !1,
                this.texture.generateMipmaps = o.generateMipmaps !== void 0 ? o.generateMipmaps : !1,
                this.texture.internalFormat = o.internalFormat !== void 0 ? o.internalFormat : null,
                this.texture.minFilter = o.minFilter !== void 0 ? o.minFilter : Hi,
                this.depthBuffer = o.depthBuffer !== void 0 ? o.depthBuffer : !0,
                this.stencilBuffer = o.stencilBuffer !== void 0 ? o.stencilBuffer : !1,
                this.depthTexture = o.depthTexture !== void 0 ? o.depthTexture : null,
                this.samples = o.samples !== void 0 ? o.samples : 0
            }
            setSize(e, i, o=1) {
                (this.width !== e || this.height !== i || this.depth !== o) && (this.width = e,
                this.height = i,
                this.depth = o,
                this.texture.image.width = e,
                this.texture.image.height = i,
                this.texture.image.depth = o,
                this.dispose()),
                this.viewport.set(0, 0, e, i),
                this.scissor.set(0, 0, e, i)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                this.width = e.width,
                this.height = e.height,
                this.depth = e.depth,
                this.viewport.copy(e.viewport),
                this.texture = e.texture.clone(),
                this.texture.isRenderTargetTexture = !0;
                const i = Object.assign({}, e.texture.image);
                return this.texture.source = new Nn(i),
                this.depthBuffer = e.depthBuffer,
                this.stencilBuffer = e.stencilBuffer,
                e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
                this.samples = e.samples,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class pr extends $t {
            constructor(e=null, i=1, o=1, a=1) {
                super(null),
                this.isDataArrayTexture = !0,
                this.image = {
                    data: e,
                    width: i,
                    height: o,
                    depth: a
                },
                this.magFilter = gi,
                this.minFilter = gi,
                this.wrapR = hi,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class to extends ki {
            constructor(e=1, i=1, o=1) {
                super(e, i),
                this.isWebGLArrayRenderTarget = !0,
                this.depth = o,
                this.texture = new pr(null,e,i,o),
                this.texture.isRenderTargetTexture = !0
            }
        }
        class ir extends $t {
            constructor(e=null, i=1, o=1, a=1) {
                super(null),
                this.isData3DTexture = !0,
                this.image = {
                    data: e,
                    width: i,
                    height: o,
                    depth: a
                },
                this.magFilter = gi,
                this.minFilter = gi,
                this.wrapR = hi,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class Bi extends ki {
            constructor(e=1, i=1, o=1) {
                super(e, i),
                this.isWebGL3DRenderTarget = !0,
                this.depth = o,
                this.texture = new ir(null,e,i,o),
                this.texture.isRenderTargetTexture = !0
            }
        }
        class Hr extends ki {
            constructor(e=1, i=1, o=1, a={}) {
                super(e, i, a),
                this.isWebGLMultipleRenderTargets = !0;
                const c = this.texture;
                this.texture = [];
                for (let d = 0; d < o; d++)
                    this.texture[d] = c.clone(),
                    this.texture[d].isRenderTargetTexture = !0
            }
            setSize(e, i, o=1) {
                if (this.width !== e || this.height !== i || this.depth !== o) {
                    this.width = e,
                    this.height = i,
                    this.depth = o;
                    for (let a = 0, c = this.texture.length; a < c; a++)
                        this.texture[a].image.width = e,
                        this.texture[a].image.height = i,
                        this.texture[a].image.depth = o;
                    this.dispose()
                }
                return this.viewport.set(0, 0, e, i),
                this.scissor.set(0, 0, e, i),
                this
            }
            copy(e) {
                this.dispose(),
                this.width = e.width,
                this.height = e.height,
                this.depth = e.depth,
                this.viewport.set(0, 0, this.width, this.height),
                this.scissor.set(0, 0, this.width, this.height),
                this.depthBuffer = e.depthBuffer,
                this.stencilBuffer = e.stencilBuffer,
                e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
                this.texture.length = 0;
                for (let i = 0, o = e.texture.length; i < o; i++)
                    this.texture[i] = e.texture[i].clone(),
                    this.texture[i].isRenderTargetTexture = !0;
                return this
            }
        }
        class Zr {
            constructor(e=new me(1 / 0,1 / 0,1 / 0), i=new me(-1 / 0,-1 / 0,-1 / 0)) {
                this.isBox3 = !0,
                this.min = e,
                this.max = i
            }
            set(e, i) {
                return this.min.copy(e),
                this.max.copy(i),
                this
            }
            setFromArray(e) {
                let i = 1 / 0
                  , o = 1 / 0
                  , a = 1 / 0
                  , c = -1 / 0
                  , d = -1 / 0
                  , f = -1 / 0;
                for (let v = 0, x = e.length; v < x; v += 3) {
                    const w = e[v]
                      , P = e[v + 1]
                      , M = e[v + 2];
                    w < i && (i = w),
                    P < o && (o = P),
                    M < a && (a = M),
                    w > c && (c = w),
                    P > d && (d = P),
                    M > f && (f = M)
                }
                return this.min.set(i, o, a),
                this.max.set(c, d, f),
                this
            }
            setFromBufferAttribute(e) {
                let i = 1 / 0
                  , o = 1 / 0
                  , a = 1 / 0
                  , c = -1 / 0
                  , d = -1 / 0
                  , f = -1 / 0;
                for (let v = 0, x = e.count; v < x; v++) {
                    const w = e.getX(v)
                      , P = e.getY(v)
                      , M = e.getZ(v);
                    w < i && (i = w),
                    P < o && (o = P),
                    M < a && (a = M),
                    w > c && (c = w),
                    P > d && (d = P),
                    M > f && (f = M)
                }
                return this.min.set(i, o, a),
                this.max.set(c, d, f),
                this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let i = 0, o = e.length; i < o; i++)
                    this.expandByPoint(e[i]);
                return this
            }
            setFromCenterAndSize(e, i) {
                const o = Ri.copy(i).multiplyScalar(.5);
                return this.min.copy(e).sub(o),
                this.max.copy(e).add(o),
                this
            }
            setFromObject(e, i=!1) {
                return this.makeEmpty(),
                this.expandByObject(e, i)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.min.copy(e.min),
                this.max.copy(e.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e),
                this.max.max(e),
                this
            }
            expandByVector(e) {
                return this.min.sub(e),
                this.max.add(e),
                this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e),
                this.max.addScalar(e),
                this
            }
            expandByObject(e, i=!1) {
                e.updateWorldMatrix(!1, !1);
                const o = e.geometry;
                if (o !== void 0)
                    if (i && o.attributes != null && o.attributes.position !== void 0) {
                        const c = o.attributes.position;
                        for (let d = 0, f = c.count; d < f; d++)
                            Ri.fromBufferAttribute(c, d).applyMatrix4(e.matrixWorld),
                            this.expandByPoint(Ri)
                    } else
                        o.boundingBox === null && o.computeBoundingBox(),
                        er.copy(o.boundingBox),
                        er.applyMatrix4(e.matrixWorld),
                        this.union(er);
                const a = e.children;
                for (let c = 0, d = a.length; c < d; c++)
                    this.expandByObject(a[c], i);
                return this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            }
            getParameter(e, i) {
                return i.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, Ri),
                Ri.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsPlane(e) {
                let i, o;
                return e.normal.x > 0 ? (i = e.normal.x * this.min.x,
                o = e.normal.x * this.max.x) : (i = e.normal.x * this.max.x,
                o = e.normal.x * this.min.x),
                e.normal.y > 0 ? (i += e.normal.y * this.min.y,
                o += e.normal.y * this.max.y) : (i += e.normal.y * this.max.y,
                o += e.normal.y * this.min.y),
                e.normal.z > 0 ? (i += e.normal.z * this.min.z,
                o += e.normal.z * this.max.z) : (i += e.normal.z * this.max.z,
                o += e.normal.z * this.min.z),
                i <= -e.constant && o >= -e.constant
            }
            intersectsTriangle(e) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(Gh),
                Gf.subVectors(this.max, Gh),
                Hs.subVectors(e.a, Gh),
                Zo.subVectors(e.b, Gh),
                Ts.subVectors(e.c, Gh),
                Do.subVectors(Zo, Hs),
                Ql.subVectors(Ts, Zo),
                kc.subVectors(Hs, Ts);
                let i = [0, -Do.z, Do.y, 0, -Ql.z, Ql.y, 0, -kc.z, kc.y, Do.z, 0, -Do.x, Ql.z, 0, -Ql.x, kc.z, 0, -kc.x, -Do.y, Do.x, 0, -Ql.y, Ql.x, 0, -kc.y, kc.x, 0];
                return !Ng(i, Hs, Zo, Ts, Gf) || (i = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !Ng(i, Hs, Zo, Ts, Gf)) ? !1 : (Hf.crossVectors(Do, Ql),
                i = [Hf.x, Hf.y, Hf.z],
                Ng(i, Hs, Zo, Ts, Gf))
            }
            clampPoint(e, i) {
                return i.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, Ri).distanceTo(e)
            }
            getBoundingSphere(e) {
                return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                e.radius = this.getSize(Ri).length() * .5),
                e
            }
            intersect(e) {
                return this.min.max(e.min),
                this.max.min(e.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(e) {
                return this.min.min(e.min),
                this.max.max(e.max),
                this
            }
            applyMatrix4(e) {
                return this.isEmpty() ? this : (or[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                or[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                or[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                or[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                or[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                or[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                or[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                or[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                this.setFromPoints(or),
                this)
            }
            translate(e) {
                return this.min.add(e),
                this.max.add(e),
                this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const or = [new me, new me, new me, new me, new me, new me, new me, new me]
          , Ri = new me
          , er = new Zr
          , Hs = new me
          , Zo = new me
          , Ts = new me
          , Do = new me
          , Ql = new me
          , kc = new me
          , Gh = new me
          , Gf = new me
          , Hf = new me
          , Uc = new me;
        function Ng(u, e, i, o, a) {
            for (let c = 0, d = u.length - 3; c <= d; c += 3) {
                Uc.fromArray(u, c);
                const f = a.x * Math.abs(Uc.x) + a.y * Math.abs(Uc.y) + a.z * Math.abs(Uc.z)
                  , v = e.dot(Uc)
                  , x = i.dot(Uc)
                  , w = o.dot(Uc);
                if (Math.max(-Math.max(v, x, w), Math.min(v, x, w)) > f)
                    return !1
            }
            return !0
        }
        const NC = new Zr
          , Hh = new me
          , zg = new me;
        class Nc {
            constructor(e=new me, i=-1) {
                this.center = e,
                this.radius = i
            }
            set(e, i) {
                return this.center.copy(e),
                this.radius = i,
                this
            }
            setFromPoints(e, i) {
                const o = this.center;
                i !== void 0 ? o.copy(i) : NC.setFromPoints(e).getCenter(o);
                let a = 0;
                for (let c = 0, d = e.length; c < d; c++)
                    a = Math.max(a, o.distanceToSquared(e[c]));
                return this.radius = Math.sqrt(a),
                this
            }
            copy(e) {
                return this.center.copy(e.center),
                this.radius = e.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(e) {
                return e.distanceTo(this.center) - this.radius
            }
            intersectsSphere(e) {
                const i = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= i * i
            }
            intersectsBox(e) {
                return e.intersectsSphere(this)
            }
            intersectsPlane(e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(e, i) {
                const o = this.center.distanceToSquared(e);
                return i.copy(e),
                o > this.radius * this.radius && (i.sub(this.center).normalize(),
                i.multiplyScalar(this.radius).add(this.center)),
                i
            }
            getBoundingBox(e) {
                return this.isEmpty() ? (e.makeEmpty(),
                e) : (e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e)
            }
            applyMatrix4(e) {
                return this.center.applyMatrix4(e),
                this.radius = this.radius * e.getMaxScaleOnAxis(),
                this
            }
            translate(e) {
                return this.center.add(e),
                this
            }
            expandByPoint(e) {
                if (this.isEmpty())
                    return this.center.copy(e),
                    this.radius = 0,
                    this;
                Hh.subVectors(e, this.center);
                const i = Hh.lengthSq();
                if (i > this.radius * this.radius) {
                    const o = Math.sqrt(i)
                      , a = (o - this.radius) * .5;
                    this.center.addScaledVector(Hh, a / o),
                    this.radius += a
                }
                return this
            }
            union(e) {
                return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (zg.subVectors(e.center, this.center).setLength(e.radius),
                this.expandByPoint(Hh.copy(e.center).add(zg)),
                this.expandByPoint(Hh.copy(e.center).sub(zg))),
                this)
            }
            equals(e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const vl = new me
          , Gg = new me
          , Vf = new me
          , Kl = new me
          , Hg = new me
          , Wf = new me
          , Vg = new me;
        class Vh {
            constructor(e=new me, i=new me(0,0,-1)) {
                this.origin = e,
                this.direction = i
            }
            set(e, i) {
                return this.origin.copy(e),
                this.direction.copy(i),
                this
            }
            copy(e) {
                return this.origin.copy(e.origin),
                this.direction.copy(e.direction),
                this
            }
            at(e, i) {
                return i.copy(this.origin).addScaledVector(this.direction, e)
            }
            lookAt(e) {
                return this.direction.copy(e).sub(this.origin).normalize(),
                this
            }
            recast(e) {
                return this.origin.copy(this.at(e, vl)),
                this
            }
            closestPointToPoint(e, i) {
                i.subVectors(e, this.origin);
                const o = i.dot(this.direction);
                return o < 0 ? i.copy(this.origin) : i.copy(this.origin).addScaledVector(this.direction, o)
            }
            distanceToPoint(e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            }
            distanceSqToPoint(e) {
                const i = vl.subVectors(e, this.origin).dot(this.direction);
                return i < 0 ? this.origin.distanceToSquared(e) : (vl.copy(this.origin).addScaledVector(this.direction, i),
                vl.distanceToSquared(e))
            }
            distanceSqToSegment(e, i, o, a) {
                Gg.copy(e).add(i).multiplyScalar(.5),
                Vf.copy(i).sub(e).normalize(),
                Kl.copy(this.origin).sub(Gg);
                const c = e.distanceTo(i) * .5
                  , d = -this.direction.dot(Vf)
                  , f = Kl.dot(this.direction)
                  , v = -Kl.dot(Vf)
                  , x = Kl.lengthSq()
                  , w = Math.abs(1 - d * d);
                let P, M, I, z;
                if (w > 0)
                    if (P = d * v - f,
                    M = d * f - v,
                    z = c * w,
                    P >= 0)
                        if (M >= -z)
                            if (M <= z) {
                                const O = 1 / w;
                                P *= O,
                                M *= O,
                                I = P * (P + d * M + 2 * f) + M * (d * P + M + 2 * v) + x
                            } else
                                M = c,
                                P = Math.max(0, -(d * M + f)),
                                I = -P * P + M * (M + 2 * v) + x;
                        else
                            M = -c,
                            P = Math.max(0, -(d * M + f)),
                            I = -P * P + M * (M + 2 * v) + x;
                    else
                        M <= -z ? (P = Math.max(0, -(-d * c + f)),
                        M = P > 0 ? -c : Math.min(Math.max(-c, -v), c),
                        I = -P * P + M * (M + 2 * v) + x) : M <= z ? (P = 0,
                        M = Math.min(Math.max(-c, -v), c),
                        I = M * (M + 2 * v) + x) : (P = Math.max(0, -(d * c + f)),
                        M = P > 0 ? c : Math.min(Math.max(-c, -v), c),
                        I = -P * P + M * (M + 2 * v) + x);
                else
                    M = d > 0 ? -c : c,
                    P = Math.max(0, -(d * M + f)),
                    I = -P * P + M * (M + 2 * v) + x;
                return o && o.copy(this.origin).addScaledVector(this.direction, P),
                a && a.copy(Gg).addScaledVector(Vf, M),
                I
            }
            intersectSphere(e, i) {
                vl.subVectors(e.center, this.origin);
                const o = vl.dot(this.direction)
                  , a = vl.dot(vl) - o * o
                  , c = e.radius * e.radius;
                if (a > c)
                    return null;
                const d = Math.sqrt(c - a)
                  , f = o - d
                  , v = o + d;
                return v < 0 ? null : f < 0 ? this.at(v, i) : this.at(f, i)
            }
            intersectsSphere(e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            }
            distanceToPlane(e) {
                const i = e.normal.dot(this.direction);
                if (i === 0)
                    return e.distanceToPoint(this.origin) === 0 ? 0 : null;
                const o = -(this.origin.dot(e.normal) + e.constant) / i;
                return o >= 0 ? o : null
            }
            intersectPlane(e, i) {
                const o = this.distanceToPlane(e);
                return o === null ? null : this.at(o, i)
            }
            intersectsPlane(e) {
                const i = e.distanceToPoint(this.origin);
                return i === 0 || e.normal.dot(this.direction) * i < 0
            }
            intersectBox(e, i) {
                let o, a, c, d, f, v;
                const x = 1 / this.direction.x
                  , w = 1 / this.direction.y
                  , P = 1 / this.direction.z
                  , M = this.origin;
                return x >= 0 ? (o = (e.min.x - M.x) * x,
                a = (e.max.x - M.x) * x) : (o = (e.max.x - M.x) * x,
                a = (e.min.x - M.x) * x),
                w >= 0 ? (c = (e.min.y - M.y) * w,
                d = (e.max.y - M.y) * w) : (c = (e.max.y - M.y) * w,
                d = (e.min.y - M.y) * w),
                o > d || c > a || ((c > o || isNaN(o)) && (o = c),
                (d < a || isNaN(a)) && (a = d),
                P >= 0 ? (f = (e.min.z - M.z) * P,
                v = (e.max.z - M.z) * P) : (f = (e.max.z - M.z) * P,
                v = (e.min.z - M.z) * P),
                o > v || f > a) || ((f > o || o !== o) && (o = f),
                (v < a || a !== a) && (a = v),
                a < 0) ? null : this.at(o >= 0 ? o : a, i)
            }
            intersectsBox(e) {
                return this.intersectBox(e, vl) !== null
            }
            intersectTriangle(e, i, o, a, c) {
                Hg.subVectors(i, e),
                Wf.subVectors(o, e),
                Vg.crossVectors(Hg, Wf);
                let d = this.direction.dot(Vg), f;
                if (d > 0) {
                    if (a)
                        return null;
                    f = 1
                } else if (d < 0)
                    f = -1,
                    d = -d;
                else
                    return null;
                Kl.subVectors(this.origin, e);
                const v = f * this.direction.dot(Wf.crossVectors(Kl, Wf));
                if (v < 0)
                    return null;
                const x = f * this.direction.dot(Hg.cross(Kl));
                if (x < 0 || v + x > d)
                    return null;
                const w = -f * Kl.dot(Vg);
                return w < 0 ? null : this.at(w / d, c)
            }
            applyMatrix4(e) {
                return this.origin.applyMatrix4(e),
                this.direction.transformDirection(e),
                this
            }
            equals(e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class pi {
            constructor() {
                pi.prototype.isMatrix4 = !0,
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
            }
            set(e, i, o, a, c, d, f, v, x, w, P, M, I, z, O, k) {
                const Q = this.elements;
                return Q[0] = e,
                Q[4] = i,
                Q[8] = o,
                Q[12] = a,
                Q[1] = c,
                Q[5] = d,
                Q[9] = f,
                Q[13] = v,
                Q[2] = x,
                Q[6] = w,
                Q[10] = P,
                Q[14] = M,
                Q[3] = I,
                Q[7] = z,
                Q[11] = O,
                Q[15] = k,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return new pi().fromArray(this.elements)
            }
            copy(e) {
                const i = this.elements
                  , o = e.elements;
                return i[0] = o[0],
                i[1] = o[1],
                i[2] = o[2],
                i[3] = o[3],
                i[4] = o[4],
                i[5] = o[5],
                i[6] = o[6],
                i[7] = o[7],
                i[8] = o[8],
                i[9] = o[9],
                i[10] = o[10],
                i[11] = o[11],
                i[12] = o[12],
                i[13] = o[13],
                i[14] = o[14],
                i[15] = o[15],
                this
            }
            copyPosition(e) {
                const i = this.elements
                  , o = e.elements;
                return i[12] = o[12],
                i[13] = o[13],
                i[14] = o[14],
                this
            }
            setFromMatrix3(e) {
                const i = e.elements;
                return this.set(i[0], i[3], i[6], 0, i[1], i[4], i[7], 0, i[2], i[5], i[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(e, i, o) {
                return e.setFromMatrixColumn(this, 0),
                i.setFromMatrixColumn(this, 1),
                o.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(e, i, o) {
                return this.set(e.x, i.x, o.x, 0, e.y, i.y, o.y, 0, e.z, i.z, o.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(e) {
                const i = this.elements
                  , o = e.elements
                  , a = 1 / Eu.setFromMatrixColumn(e, 0).length()
                  , c = 1 / Eu.setFromMatrixColumn(e, 1).length()
                  , d = 1 / Eu.setFromMatrixColumn(e, 2).length();
                return i[0] = o[0] * a,
                i[1] = o[1] * a,
                i[2] = o[2] * a,
                i[3] = 0,
                i[4] = o[4] * c,
                i[5] = o[5] * c,
                i[6] = o[6] * c,
                i[7] = 0,
                i[8] = o[8] * d,
                i[9] = o[9] * d,
                i[10] = o[10] * d,
                i[11] = 0,
                i[12] = 0,
                i[13] = 0,
                i[14] = 0,
                i[15] = 1,
                this
            }
            makeRotationFromEuler(e) {
                const i = this.elements
                  , o = e.x
                  , a = e.y
                  , c = e.z
                  , d = Math.cos(o)
                  , f = Math.sin(o)
                  , v = Math.cos(a)
                  , x = Math.sin(a)
                  , w = Math.cos(c)
                  , P = Math.sin(c);
                if (e.order === "XYZ") {
                    const M = d * w
                      , I = d * P
                      , z = f * w
                      , O = f * P;
                    i[0] = v * w,
                    i[4] = -v * P,
                    i[8] = x,
                    i[1] = I + z * x,
                    i[5] = M - O * x,
                    i[9] = -f * v,
                    i[2] = O - M * x,
                    i[6] = z + I * x,
                    i[10] = d * v
                } else if (e.order === "YXZ") {
                    const M = v * w
                      , I = v * P
                      , z = x * w
                      , O = x * P;
                    i[0] = M + O * f,
                    i[4] = z * f - I,
                    i[8] = d * x,
                    i[1] = d * P,
                    i[5] = d * w,
                    i[9] = -f,
                    i[2] = I * f - z,
                    i[6] = O + M * f,
                    i[10] = d * v
                } else if (e.order === "ZXY") {
                    const M = v * w
                      , I = v * P
                      , z = x * w
                      , O = x * P;
                    i[0] = M - O * f,
                    i[4] = -d * P,
                    i[8] = z + I * f,
                    i[1] = I + z * f,
                    i[5] = d * w,
                    i[9] = O - M * f,
                    i[2] = -d * x,
                    i[6] = f,
                    i[10] = d * v
                } else if (e.order === "ZYX") {
                    const M = d * w
                      , I = d * P
                      , z = f * w
                      , O = f * P;
                    i[0] = v * w,
                    i[4] = z * x - I,
                    i[8] = M * x + O,
                    i[1] = v * P,
                    i[5] = O * x + M,
                    i[9] = I * x - z,
                    i[2] = -x,
                    i[6] = f * v,
                    i[10] = d * v
                } else if (e.order === "YZX") {
                    const M = d * v
                      , I = d * x
                      , z = f * v
                      , O = f * x;
                    i[0] = v * w,
                    i[4] = O - M * P,
                    i[8] = z * P + I,
                    i[1] = P,
                    i[5] = d * w,
                    i[9] = -f * w,
                    i[2] = -x * w,
                    i[6] = I * P + z,
                    i[10] = M - O * P
                } else if (e.order === "XZY") {
                    const M = d * v
                      , I = d * x
                      , z = f * v
                      , O = f * x;
                    i[0] = v * w,
                    i[4] = -P,
                    i[8] = x * w,
                    i[1] = M * P + O,
                    i[5] = d * w,
                    i[9] = I * P - z,
                    i[2] = z * P - I,
                    i[6] = f * w,
                    i[10] = O * P + M
                }
                return i[3] = 0,
                i[7] = 0,
                i[11] = 0,
                i[12] = 0,
                i[13] = 0,
                i[14] = 0,
                i[15] = 1,
                this
            }
            makeRotationFromQuaternion(e) {
                return this.compose(zC, e, GC)
            }
            lookAt(e, i, o) {
                const a = this.elements;
                return Lo.subVectors(e, i),
                Lo.lengthSq() === 0 && (Lo.z = 1),
                Lo.normalize(),
                Zl.crossVectors(o, Lo),
                Zl.lengthSq() === 0 && (Math.abs(o.z) === 1 ? Lo.x += 1e-4 : Lo.z += 1e-4,
                Lo.normalize(),
                Zl.crossVectors(o, Lo)),
                Zl.normalize(),
                jf.crossVectors(Lo, Zl),
                a[0] = Zl.x,
                a[4] = jf.x,
                a[8] = Lo.x,
                a[1] = Zl.y,
                a[5] = jf.y,
                a[9] = Lo.y,
                a[2] = Zl.z,
                a[6] = jf.z,
                a[10] = Lo.z,
                this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, i) {
                const o = e.elements
                  , a = i.elements
                  , c = this.elements
                  , d = o[0]
                  , f = o[4]
                  , v = o[8]
                  , x = o[12]
                  , w = o[1]
                  , P = o[5]
                  , M = o[9]
                  , I = o[13]
                  , z = o[2]
                  , O = o[6]
                  , k = o[10]
                  , Q = o[14]
                  , Z = o[3]
                  , X = o[7]
                  , K = o[11]
                  , de = o[15]
                  , be = a[0]
                  , Me = a[4]
                  , J = a[8]
                  , ge = a[12]
                  , Le = a[1]
                  , tt = a[5]
                  , lt = a[9]
                  , je = a[13]
                  , ze = a[2]
                  , st = a[6]
                  , yt = a[10]
                  , It = a[14]
                  , ht = a[3]
                  , Ot = a[7]
                  , Mt = a[11]
                  , Ln = a[15];
                return c[0] = d * be + f * Le + v * ze + x * ht,
                c[4] = d * Me + f * tt + v * st + x * Ot,
                c[8] = d * J + f * lt + v * yt + x * Mt,
                c[12] = d * ge + f * je + v * It + x * Ln,
                c[1] = w * be + P * Le + M * ze + I * ht,
                c[5] = w * Me + P * tt + M * st + I * Ot,
                c[9] = w * J + P * lt + M * yt + I * Mt,
                c[13] = w * ge + P * je + M * It + I * Ln,
                c[2] = z * be + O * Le + k * ze + Q * ht,
                c[6] = z * Me + O * tt + k * st + Q * Ot,
                c[10] = z * J + O * lt + k * yt + Q * Mt,
                c[14] = z * ge + O * je + k * It + Q * Ln,
                c[3] = Z * be + X * Le + K * ze + de * ht,
                c[7] = Z * Me + X * tt + K * st + de * Ot,
                c[11] = Z * J + X * lt + K * yt + de * Mt,
                c[15] = Z * ge + X * je + K * It + de * Ln,
                this
            }
            multiplyScalar(e) {
                const i = this.elements;
                return i[0] *= e,
                i[4] *= e,
                i[8] *= e,
                i[12] *= e,
                i[1] *= e,
                i[5] *= e,
                i[9] *= e,
                i[13] *= e,
                i[2] *= e,
                i[6] *= e,
                i[10] *= e,
                i[14] *= e,
                i[3] *= e,
                i[7] *= e,
                i[11] *= e,
                i[15] *= e,
                this
            }
            determinant() {
                const e = this.elements
                  , i = e[0]
                  , o = e[4]
                  , a = e[8]
                  , c = e[12]
                  , d = e[1]
                  , f = e[5]
                  , v = e[9]
                  , x = e[13]
                  , w = e[2]
                  , P = e[6]
                  , M = e[10]
                  , I = e[14]
                  , z = e[3]
                  , O = e[7]
                  , k = e[11]
                  , Q = e[15];
                return z * (+c * v * P - a * x * P - c * f * M + o * x * M + a * f * I - o * v * I) + O * (+i * v * I - i * x * M + c * d * M - a * d * I + a * x * w - c * v * w) + k * (+i * x * P - i * f * I - c * d * P + o * d * I + c * f * w - o * x * w) + Q * (-a * f * w - i * v * P + i * f * M + a * d * P - o * d * M + o * v * w)
            }
            transpose() {
                const e = this.elements;
                let i;
                return i = e[1],
                e[1] = e[4],
                e[4] = i,
                i = e[2],
                e[2] = e[8],
                e[8] = i,
                i = e[6],
                e[6] = e[9],
                e[9] = i,
                i = e[3],
                e[3] = e[12],
                e[12] = i,
                i = e[7],
                e[7] = e[13],
                e[13] = i,
                i = e[11],
                e[11] = e[14],
                e[14] = i,
                this
            }
            setPosition(e, i, o) {
                const a = this.elements;
                return e.isVector3 ? (a[12] = e.x,
                a[13] = e.y,
                a[14] = e.z) : (a[12] = e,
                a[13] = i,
                a[14] = o),
                this
            }
            invert() {
                const e = this.elements
                  , i = e[0]
                  , o = e[1]
                  , a = e[2]
                  , c = e[3]
                  , d = e[4]
                  , f = e[5]
                  , v = e[6]
                  , x = e[7]
                  , w = e[8]
                  , P = e[9]
                  , M = e[10]
                  , I = e[11]
                  , z = e[12]
                  , O = e[13]
                  , k = e[14]
                  , Q = e[15]
                  , Z = P * k * x - O * M * x + O * v * I - f * k * I - P * v * Q + f * M * Q
                  , X = z * M * x - w * k * x - z * v * I + d * k * I + w * v * Q - d * M * Q
                  , K = w * O * x - z * P * x + z * f * I - d * O * I - w * f * Q + d * P * Q
                  , de = z * P * v - w * O * v - z * f * M + d * O * M + w * f * k - d * P * k
                  , be = i * Z + o * X + a * K + c * de;
                if (be === 0)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const Me = 1 / be;
                return e[0] = Z * Me,
                e[1] = (O * M * c - P * k * c - O * a * I + o * k * I + P * a * Q - o * M * Q) * Me,
                e[2] = (f * k * c - O * v * c + O * a * x - o * k * x - f * a * Q + o * v * Q) * Me,
                e[3] = (P * v * c - f * M * c - P * a * x + o * M * x + f * a * I - o * v * I) * Me,
                e[4] = X * Me,
                e[5] = (w * k * c - z * M * c + z * a * I - i * k * I - w * a * Q + i * M * Q) * Me,
                e[6] = (z * v * c - d * k * c - z * a * x + i * k * x + d * a * Q - i * v * Q) * Me,
                e[7] = (d * M * c - w * v * c + w * a * x - i * M * x - d * a * I + i * v * I) * Me,
                e[8] = K * Me,
                e[9] = (z * P * c - w * O * c - z * o * I + i * O * I + w * o * Q - i * P * Q) * Me,
                e[10] = (d * O * c - z * f * c + z * o * x - i * O * x - d * o * Q + i * f * Q) * Me,
                e[11] = (w * f * c - d * P * c - w * o * x + i * P * x + d * o * I - i * f * I) * Me,
                e[12] = de * Me,
                e[13] = (w * O * a - z * P * a + z * o * M - i * O * M - w * o * k + i * P * k) * Me,
                e[14] = (z * f * a - d * O * a - z * o * v + i * O * v + d * o * k - i * f * k) * Me,
                e[15] = (d * P * a - w * f * a + w * o * v - i * P * v - d * o * M + i * f * M) * Me,
                this
            }
            scale(e) {
                const i = this.elements
                  , o = e.x
                  , a = e.y
                  , c = e.z;
                return i[0] *= o,
                i[4] *= a,
                i[8] *= c,
                i[1] *= o,
                i[5] *= a,
                i[9] *= c,
                i[2] *= o,
                i[6] *= a,
                i[10] *= c,
                i[3] *= o,
                i[7] *= a,
                i[11] *= c,
                this
            }
            getMaxScaleOnAxis() {
                const e = this.elements
                  , i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
                  , o = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
                  , a = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(i, o, a))
            }
            makeTranslation(e, i, o) {
                return this.set(1, 0, 0, e, 0, 1, 0, i, 0, 0, 1, o, 0, 0, 0, 1),
                this
            }
            makeRotationX(e) {
                const i = Math.cos(e)
                  , o = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, i, -o, 0, 0, o, i, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(e) {
                const i = Math.cos(e)
                  , o = Math.sin(e);
                return this.set(i, 0, o, 0, 0, 1, 0, 0, -o, 0, i, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(e) {
                const i = Math.cos(e)
                  , o = Math.sin(e);
                return this.set(i, -o, 0, 0, o, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(e, i) {
                const o = Math.cos(i)
                  , a = Math.sin(i)
                  , c = 1 - o
                  , d = e.x
                  , f = e.y
                  , v = e.z
                  , x = c * d
                  , w = c * f;
                return this.set(x * d + o, x * f - a * v, x * v + a * f, 0, x * f + a * v, w * f + o, w * v - a * d, 0, x * v - a * f, w * v + a * d, c * v * v + o, 0, 0, 0, 0, 1),
                this
            }
            makeScale(e, i, o) {
                return this.set(e, 0, 0, 0, 0, i, 0, 0, 0, 0, o, 0, 0, 0, 0, 1),
                this
            }
            makeShear(e, i, o, a, c, d) {
                return this.set(1, o, c, 0, e, 1, d, 0, i, a, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(e, i, o) {
                const a = this.elements
                  , c = i._x
                  , d = i._y
                  , f = i._z
                  , v = i._w
                  , x = c + c
                  , w = d + d
                  , P = f + f
                  , M = c * x
                  , I = c * w
                  , z = c * P
                  , O = d * w
                  , k = d * P
                  , Q = f * P
                  , Z = v * x
                  , X = v * w
                  , K = v * P
                  , de = o.x
                  , be = o.y
                  , Me = o.z;
                return a[0] = (1 - (O + Q)) * de,
                a[1] = (I + K) * de,
                a[2] = (z - X) * de,
                a[3] = 0,
                a[4] = (I - K) * be,
                a[5] = (1 - (M + Q)) * be,
                a[6] = (k + Z) * be,
                a[7] = 0,
                a[8] = (z + X) * Me,
                a[9] = (k - Z) * Me,
                a[10] = (1 - (M + O)) * Me,
                a[11] = 0,
                a[12] = e.x,
                a[13] = e.y,
                a[14] = e.z,
                a[15] = 1,
                this
            }
            decompose(e, i, o) {
                const a = this.elements;
                let c = Eu.set(a[0], a[1], a[2]).length();
                const d = Eu.set(a[4], a[5], a[6]).length()
                  , f = Eu.set(a[8], a[9], a[10]).length();
                this.determinant() < 0 && (c = -c),
                e.x = a[12],
                e.y = a[13],
                e.z = a[14],
                ba.copy(this);
                const x = 1 / c
                  , w = 1 / d
                  , P = 1 / f;
                return ba.elements[0] *= x,
                ba.elements[1] *= x,
                ba.elements[2] *= x,
                ba.elements[4] *= w,
                ba.elements[5] *= w,
                ba.elements[6] *= w,
                ba.elements[8] *= P,
                ba.elements[9] *= P,
                ba.elements[10] *= P,
                i.setFromRotationMatrix(ba),
                o.x = c,
                o.y = d,
                o.z = f,
                this
            }
            makePerspective(e, i, o, a, c, d) {
                const f = this.elements
                  , v = 2 * c / (i - e)
                  , x = 2 * c / (o - a)
                  , w = (i + e) / (i - e)
                  , P = (o + a) / (o - a)
                  , M = -(d + c) / (d - c)
                  , I = -2 * d * c / (d - c);
                return f[0] = v,
                f[4] = 0,
                f[8] = w,
                f[12] = 0,
                f[1] = 0,
                f[5] = x,
                f[9] = P,
                f[13] = 0,
                f[2] = 0,
                f[6] = 0,
                f[10] = M,
                f[14] = I,
                f[3] = 0,
                f[7] = 0,
                f[11] = -1,
                f[15] = 0,
                this
            }
            makeOrthographic(e, i, o, a, c, d) {
                const f = this.elements
                  , v = 1 / (i - e)
                  , x = 1 / (o - a)
                  , w = 1 / (d - c)
                  , P = (i + e) * v
                  , M = (o + a) * x
                  , I = (d + c) * w;
                return f[0] = 2 * v,
                f[4] = 0,
                f[8] = 0,
                f[12] = -P,
                f[1] = 0,
                f[5] = 2 * x,
                f[9] = 0,
                f[13] = -M,
                f[2] = 0,
                f[6] = 0,
                f[10] = -2 * w,
                f[14] = -I,
                f[3] = 0,
                f[7] = 0,
                f[11] = 0,
                f[15] = 1,
                this
            }
            equals(e) {
                const i = this.elements
                  , o = e.elements;
                for (let a = 0; a < 16; a++)
                    if (i[a] !== o[a])
                        return !1;
                return !0
            }
            fromArray(e, i=0) {
                for (let o = 0; o < 16; o++)
                    this.elements[o] = e[o + i];
                return this
            }
            toArray(e=[], i=0) {
                const o = this.elements;
                return e[i] = o[0],
                e[i + 1] = o[1],
                e[i + 2] = o[2],
                e[i + 3] = o[3],
                e[i + 4] = o[4],
                e[i + 5] = o[5],
                e[i + 6] = o[6],
                e[i + 7] = o[7],
                e[i + 8] = o[8],
                e[i + 9] = o[9],
                e[i + 10] = o[10],
                e[i + 11] = o[11],
                e[i + 12] = o[12],
                e[i + 13] = o[13],
                e[i + 14] = o[14],
                e[i + 15] = o[15],
                e
            }
        }
        const Eu = new me
          , ba = new pi
          , zC = new me(0,0,0)
          , GC = new me(1,1,1)
          , Zl = new me
          , jf = new me
          , Lo = new me
          , Ex = new pi
          , Mx = new Vi;
        class Wh {
            constructor(e=0, i=0, o=0, a=Wh.DEFAULT_ORDER) {
                this.isEuler = !0,
                this._x = e,
                this._y = i,
                this._z = o,
                this._order = a
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(e) {
                this._order = e,
                this._onChangeCallback()
            }
            set(e, i, o, a=this._order) {
                return this._x = e,
                this._y = i,
                this._z = o,
                this._order = a,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(e) {
                return this._x = e._x,
                this._y = e._y,
                this._z = e._z,
                this._order = e._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(e, i=this._order, o=!0) {
                const a = e.elements
                  , c = a[0]
                  , d = a[4]
                  , f = a[8]
                  , v = a[1]
                  , x = a[5]
                  , w = a[9]
                  , P = a[2]
                  , M = a[6]
                  , I = a[10];
                switch (i) {
                case "XYZ":
                    this._y = Math.asin(Wi(f, -1, 1)),
                    Math.abs(f) < .9999999 ? (this._x = Math.atan2(-w, I),
                    this._z = Math.atan2(-d, c)) : (this._x = Math.atan2(M, x),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-Wi(w, -1, 1)),
                    Math.abs(w) < .9999999 ? (this._y = Math.atan2(f, I),
                    this._z = Math.atan2(v, x)) : (this._y = Math.atan2(-P, c),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(Wi(M, -1, 1)),
                    Math.abs(M) < .9999999 ? (this._y = Math.atan2(-P, I),
                    this._z = Math.atan2(-d, x)) : (this._y = 0,
                    this._z = Math.atan2(v, c));
                    break;
                case "ZYX":
                    this._y = Math.asin(-Wi(P, -1, 1)),
                    Math.abs(P) < .9999999 ? (this._x = Math.atan2(M, I),
                    this._z = Math.atan2(v, c)) : (this._x = 0,
                    this._z = Math.atan2(-d, x));
                    break;
                case "YZX":
                    this._z = Math.asin(Wi(v, -1, 1)),
                    Math.abs(v) < .9999999 ? (this._x = Math.atan2(-w, x),
                    this._y = Math.atan2(-P, c)) : (this._x = 0,
                    this._y = Math.atan2(f, I));
                    break;
                case "XZY":
                    this._z = Math.asin(-Wi(d, -1, 1)),
                    Math.abs(d) < .9999999 ? (this._x = Math.atan2(M, x),
                    this._y = Math.atan2(f, c)) : (this._x = Math.atan2(-w, I),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + i)
                }
                return this._order = i,
                o === !0 && this._onChangeCallback(),
                this
            }
            setFromQuaternion(e, i, o) {
                return Ex.makeRotationFromQuaternion(e),
                this.setFromRotationMatrix(Ex, i, o)
            }
            setFromVector3(e, i=this._order) {
                return this.set(e.x, e.y, e.z, i)
            }
            reorder(e) {
                return Mx.setFromEuler(this),
                this.setFromQuaternion(Mx, e)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            }
            fromArray(e) {
                return this._x = e[0],
                this._y = e[1],
                this._z = e[2],
                e[3] !== void 0 && (this._order = e[3]),
                this._onChangeCallback(),
                this
            }
            toArray(e=[], i=0) {
                return e[i] = this._x,
                e[i + 1] = this._y,
                e[i + 2] = this._z,
                e[i + 3] = this._order,
                e
            }
            _onChange(e) {
                return this._onChangeCallback = e,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._order
            }
        }
        Wh.DEFAULT_ORDER = "XYZ";
        class Xf {
            constructor() {
                this.mask = 1
            }
            set(e) {
                this.mask = (1 << e | 0) >>> 0
            }
            enable(e) {
                this.mask |= 1 << e | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(e) {
                this.mask ^= 1 << e | 0
            }
            disable(e) {
                this.mask &= ~(1 << e | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(e) {
                return (this.mask & e.mask) !== 0
            }
            isEnabled(e) {
                return (this.mask & (1 << e | 0)) !== 0
            }
        }
        let HC = 0;
        const Cx = new me
          , Mu = new Vi
          , _l = new pi
          , Yf = new me
          , jh = new me
          , VC = new me
          , WC = new Vi
          , Px = new me(1,0,0)
          , Rx = new me(0,1,0)
          , Dx = new me(0,0,1)
          , jC = {
            type: "added"
        }
          , Lx = {
            type: "removed"
        };
        class Qi extends Kr {
            constructor() {
                super(),
                this.isObject3D = !0,
                Object.defineProperty(this, "id", {
                    value: HC++
                }),
                this.uuid = yr(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = Qi.DEFAULT_UP.clone();
                const e = new me
                  , i = new Wh
                  , o = new Vi
                  , a = new me(1,1,1);
                function c() {
                    o.setFromEuler(i, !1)
                }
                function d() {
                    i.setFromQuaternion(o, void 0, !1)
                }
                i._onChange(c),
                o._onChange(d),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: o
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: a
                    },
                    modelViewMatrix: {
                        value: new pi
                    },
                    normalMatrix: {
                        value: new Cr
                    }
                }),
                this.matrix = new pi,
                this.matrixWorld = new pi,
                this.matrixAutoUpdate = Qi.DEFAULT_MATRIX_AUTO_UPDATE,
                this.matrixWorldNeedsUpdate = !1,
                this.matrixWorldAutoUpdate = Qi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                this.layers = new Xf,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {},
                this.meshData = {},
                this.localUniforms = {}
            }
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(e) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(e),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(e) {
                return this.quaternion.premultiply(e),
                this
            }
            setRotationFromAxisAngle(e, i) {
                this.quaternion.setFromAxisAngle(e, i)
            }
            setRotationFromEuler(e) {
                this.quaternion.setFromEuler(e, !0)
            }
            setRotationFromMatrix(e) {
                this.quaternion.setFromRotationMatrix(e)
            }
            setRotationFromQuaternion(e) {
                this.quaternion.copy(e)
            }
            rotateOnAxis(e, i) {
                return Mu.setFromAxisAngle(e, i),
                this.quaternion.multiply(Mu),
                this
            }
            rotateOnWorldAxis(e, i) {
                return Mu.setFromAxisAngle(e, i),
                this.quaternion.premultiply(Mu),
                this
            }
            rotateX(e) {
                return this.rotateOnAxis(Px, e)
            }
            rotateY(e) {
                return this.rotateOnAxis(Rx, e)
            }
            rotateZ(e) {
                return this.rotateOnAxis(Dx, e)
            }
            translateOnAxis(e, i) {
                return Cx.copy(e).applyQuaternion(this.quaternion),
                this.position.add(Cx.multiplyScalar(i)),
                this
            }
            translateX(e) {
                return this.translateOnAxis(Px, e)
            }
            translateY(e) {
                return this.translateOnAxis(Rx, e)
            }
            translateZ(e) {
                return this.translateOnAxis(Dx, e)
            }
            localToWorld(e) {
                return this.updateWorldMatrix(!0, !1),
                e.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(e) {
                return this.updateWorldMatrix(!0, !1),
                e.applyMatrix4(_l.copy(this.matrixWorld).invert())
            }
            lookAt(e, i, o) {
                e.isVector3 ? Yf.copy(e) : Yf.set(e, i, o);
                const a = this.parent;
                this.updateWorldMatrix(!0, !1),
                jh.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? _l.lookAt(jh, Yf, this.up) : _l.lookAt(Yf, jh, this.up),
                this.quaternion.setFromRotationMatrix(_l),
                a && (_l.extractRotation(a.matrixWorld),
                Mu.setFromRotationMatrix(_l),
                this.quaternion.premultiply(Mu.invert()))
            }
            add(e) {
                if (arguments.length > 1) {
                    for (let i = 0; i < arguments.length; i++)
                        this.add(arguments[i]);
                    return this
                }
                return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
                this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
                e.parent = this,
                this.children.push(e),
                e.dispatchEvent(jC)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
                this)
            }
            addObject(e) {
                return this.add(e),
                e
            }
            remove(e) {
                if (arguments.length > 1) {
                    for (let o = 0; o < arguments.length; o++)
                        this.remove(arguments[o]);
                    return this
                }
                const i = this.children.indexOf(e);
                return i !== -1 && (e.parent = null,
                this.children.splice(i, 1),
                e.dispatchEvent(Lx)),
                this
            }
            removeObject(e) {
                return this.remove(e),
                e
            }
            removeFromParent() {
                const e = this.parent;
                return e !== null && e.remove(this),
                this
            }
            clear() {
                for (let e = 0; e < this.children.length; e++) {
                    const i = this.children[e];
                    i.parent = null,
                    i.dispatchEvent(Lx)
                }
                return this.children.length = 0,
                this
            }
            attach(e) {
                return this.updateWorldMatrix(!0, !1),
                _l.copy(this.matrixWorld).invert(),
                e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
                _l.multiply(e.parent.matrixWorld)),
                e.applyMatrix4(_l),
                this.add(e),
                e.updateWorldMatrix(!1, !0),
                this
            }
            getObjectById(e) {
                return this.getObjectByProperty("id", e)
            }
            getObjectByName(e) {
                return this.getObjectByProperty("name", e)
            }
            getObjectByProperty(e, i) {
                if (this[e] === i)
                    return this;
                for (let o = 0, a = this.children.length; o < a; o++) {
                    const d = this.children[o].getObjectByProperty(e, i);
                    if (d !== void 0)
                        return d
                }
            }
            getObjectsByProperty(e, i) {
                let o = [];
                this[e] === i && o.push(this);
                for (let a = 0, c = this.children.length; a < c; a++) {
                    const d = this.children[a].getObjectsByProperty(e, i);
                    d.length > 0 && (o = o.concat(d))
                }
                return o
            }
            getWorldPosition(e) {
                return this.updateWorldMatrix(!0, !1),
                e.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(e) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(jh, e, VC),
                e
            }
            getWorldScale(e) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(jh, WC, e),
                e
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const i = this.matrixWorld.elements;
                return e.set(i[8], i[9], i[10]).normalize()
            }
            raycast() {}
            traverse(e) {
                e(this);
                const i = this.children;
                for (let o = 0, a = i.length; o < a; o++)
                    i[o].traverse(e)
            }
            traverseVisible(e) {
                if (this.visible === !1)
                    return;
                e(this);
                const i = this.children;
                for (let o = 0, a = i.length; o < a; o++)
                    i[o].traverseVisible(e)
            }
            traverseAncestors(e) {
                const i = this.parent;
                i !== null && (e(i),
                i.traverseAncestors(e))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(e) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                e = !0);
                const i = this.children;
                for (let o = 0, a = i.length; o < a; o++) {
                    const c = i[o];
                    (c.matrixWorldAutoUpdate === !0 || e === !0) && c.updateMatrixWorld(e)
                }
            }
            updateWorldMatrix(e, i) {
                const o = this.parent;
                if (e === !0 && o !== null && o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                i === !0) {
                    const a = this.children;
                    for (let c = 0, d = a.length; c < d; c++) {
                        const f = a[c];
                        f.matrixWorldAutoUpdate === !0 && f.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(e) {
                const i = e === void 0 || typeof e == "string"
                  , o = {};
                i && (e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                },
                o.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const a = {};
                a.uuid = this.uuid,
                a.type = this.type,
                this.name !== "" && (a.name = this.name),
                this.castShadow === !0 && (a.castShadow = !0),
                this.receiveShadow === !0 && (a.receiveShadow = !0),
                this.visible === !1 && (a.visible = !1),
                this.frustumCulled === !1 && (a.frustumCulled = !1),
                this.renderOrder !== 0 && (a.renderOrder = this.renderOrder),
                Object.keys(this.userData).length > 0 && (a.userData = this.userData),
                a.layers = this.layers.mask,
                a.matrix = this.matrix.toArray(),
                this.matrixAutoUpdate === !1 && (a.matrixAutoUpdate = !1),
                this.isInstancedMesh && (a.type = "InstancedMesh",
                a.count = this.count,
                a.instanceMatrix = this.instanceMatrix.toJSON(),
                this.instanceColor !== null && (a.instanceColor = this.instanceColor.toJSON()));
                function c(f, v) {
                    return f[v.uuid] === void 0 && (f[v.uuid] = v.toJSON(e)),
                    v.uuid
                }
                if (this.isScene)
                    this.background && (this.background.isColor ? a.background = this.background.toJSON() : this.background.isTexture && (a.background = this.background.toJSON(e).uuid)),
                    this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (a.environment = this.environment.toJSON(e).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    a.geometry = c(e.geometries, this.geometry);
                    const f = this.geometry.parameters;
                    if (f !== void 0 && f.shapes !== void 0) {
                        const v = f.shapes;
                        if (Array.isArray(v))
                            for (let x = 0, w = v.length; x < w; x++) {
                                const P = v[x];
                                c(e.shapes, P)
                            }
                        else
                            c(e.shapes, v)
                    }
                }
                if (this.isSkinnedMesh && (a.bindMode = this.bindMode,
                a.bindMatrix = this.bindMatrix.toArray(),
                this.skeleton !== void 0 && (c(e.skeletons, this.skeleton),
                a.skeleton = this.skeleton.uuid)),
                this.material !== void 0)
                    if (Array.isArray(this.material)) {
                        const f = [];
                        for (let v = 0, x = this.material.length; v < x; v++)
                            f.push(c(e.materials, this.material[v]));
                        a.material = f
                    } else
                        a.material = c(e.materials, this.material);
                if (this.children.length > 0) {
                    a.children = [];
                    for (let f = 0; f < this.children.length; f++)
                        a.children.push(this.children[f].toJSON(e).object)
                }
                if (this.animations.length > 0) {
                    a.animations = [];
                    for (let f = 0; f < this.animations.length; f++) {
                        const v = this.animations[f];
                        a.animations.push(c(e.animations, v))
                    }
                }
                if (i) {
                    const f = d(e.geometries)
                      , v = d(e.materials)
                      , x = d(e.textures)
                      , w = d(e.images)
                      , P = d(e.shapes)
                      , M = d(e.skeletons)
                      , I = d(e.animations)
                      , z = d(e.nodes);
                    f.length > 0 && (o.geometries = f),
                    v.length > 0 && (o.materials = v),
                    x.length > 0 && (o.textures = x),
                    w.length > 0 && (o.images = w),
                    P.length > 0 && (o.shapes = P),
                    M.length > 0 && (o.skeletons = M),
                    I.length > 0 && (o.animations = I),
                    z.length > 0 && (o.nodes = z)
                }
                return o.object = a,
                o;
                function d(f) {
                    const v = [];
                    for (const x in f) {
                        const w = f[x];
                        delete w.metadata,
                        v.push(w)
                    }
                    return v
                }
            }
            clone(e) {
                return new this.constructor().copy(this, e)
            }
            copy(e, i=!0) {
                if (this.name = e.name,
                this.up.copy(e.up),
                this.position.copy(e.position),
                this.rotation.order = e.rotation.order,
                this.quaternion.copy(e.quaternion),
                this.scale.copy(e.scale),
                this.matrix.copy(e.matrix),
                this.matrixWorld.copy(e.matrixWorld),
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
                this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
                this.layers.mask = e.layers.mask,
                this.visible = e.visible,
                this.castShadow = e.castShadow,
                this.receiveShadow = e.receiveShadow,
                this.frustumCulled = e.frustumCulled,
                this.renderOrder = e.renderOrder,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                i === !0)
                    for (let o = 0; o < e.children.length; o++) {
                        const a = e.children[o];
                        this.add(a.clone())
                    }
                return this
            }
        }
        Qi.DEFAULT_UP = new me(0,1,0),
        Qi.DEFAULT_MATRIX_AUTO_UPDATE = !0,
        Qi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const wa = new me
          , yl = new me
          , Wg = new me
          , xl = new me
          , Cu = new me
          , Pu = new me
          , Ix = new me
          , jg = new me
          , Xg = new me
          , Yg = new me;
        class qo {
            constructor(e=new me, i=new me, o=new me) {
                this.a = e,
                this.b = i,
                this.c = o
            }
            static getNormal(e, i, o, a) {
                a.subVectors(o, i),
                wa.subVectors(e, i),
                a.cross(wa);
                const c = a.lengthSq();
                return c > 0 ? a.multiplyScalar(1 / Math.sqrt(c)) : a.set(0, 0, 0)
            }
            static getBarycoord(e, i, o, a, c) {
                wa.subVectors(a, i),
                yl.subVectors(o, i),
                Wg.subVectors(e, i);
                const d = wa.dot(wa)
                  , f = wa.dot(yl)
                  , v = wa.dot(Wg)
                  , x = yl.dot(yl)
                  , w = yl.dot(Wg)
                  , P = d * x - f * f;
                if (P === 0)
                    return c.set(-2, -1, -1);
                const M = 1 / P
                  , I = (x * v - f * w) * M
                  , z = (d * w - f * v) * M;
                return c.set(1 - I - z, z, I)
            }
            static containsPoint(e, i, o, a) {
                return this.getBarycoord(e, i, o, a, xl),
                xl.x >= 0 && xl.y >= 0 && xl.x + xl.y <= 1
            }
            static getUV(e, i, o, a, c, d, f, v) {
                return this.getBarycoord(e, i, o, a, xl),
                v.set(0, 0),
                v.addScaledVector(c, xl.x),
                v.addScaledVector(d, xl.y),
                v.addScaledVector(f, xl.z),
                v
            }
            static isFrontFacing(e, i, o, a) {
                return wa.subVectors(o, i),
                yl.subVectors(e, i),
                wa.cross(yl).dot(a) < 0
            }
            set(e, i, o) {
                return this.a.copy(e),
                this.b.copy(i),
                this.c.copy(o),
                this
            }
            setFromPointsAndIndices(e, i, o, a) {
                return this.a.copy(e[i]),
                this.b.copy(e[o]),
                this.c.copy(e[a]),
                this
            }
            setFromAttributeAndIndices(e, i, o, a) {
                return this.a.fromBufferAttribute(e, i),
                this.b.fromBufferAttribute(e, o),
                this.c.fromBufferAttribute(e, a),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.a.copy(e.a),
                this.b.copy(e.b),
                this.c.copy(e.c),
                this
            }
            getArea() {
                return wa.subVectors(this.c, this.b),
                yl.subVectors(this.a, this.b),
                wa.cross(yl).length() * .5
            }
            getMidpoint(e) {
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(e) {
                return qo.getNormal(this.a, this.b, this.c, e)
            }
            getPlane(e) {
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(e, i) {
                return qo.getBarycoord(e, this.a, this.b, this.c, i)
            }
            getUV(e, i, o, a, c) {
                return qo.getUV(e, this.a, this.b, this.c, i, o, a, c)
            }
            containsPoint(e) {
                return qo.containsPoint(e, this.a, this.b, this.c)
            }
            isFrontFacing(e) {
                return qo.isFrontFacing(this.a, this.b, this.c, e)
            }
            intersectsBox(e) {
                return e.intersectsTriangle(this)
            }
            closestPointToPoint(e, i) {
                const o = this.a
                  , a = this.b
                  , c = this.c;
                let d, f;
                Cu.subVectors(a, o),
                Pu.subVectors(c, o),
                jg.subVectors(e, o);
                const v = Cu.dot(jg)
                  , x = Pu.dot(jg);
                if (v <= 0 && x <= 0)
                    return i.copy(o);
                Xg.subVectors(e, a);
                const w = Cu.dot(Xg)
                  , P = Pu.dot(Xg);
                if (w >= 0 && P <= w)
                    return i.copy(a);
                const M = v * P - w * x;
                if (M <= 0 && v >= 0 && w <= 0)
                    return d = v / (v - w),
                    i.copy(o).addScaledVector(Cu, d);
                Yg.subVectors(e, c);
                const I = Cu.dot(Yg)
                  , z = Pu.dot(Yg);
                if (z >= 0 && I <= z)
                    return i.copy(c);
                const O = I * x - v * z;
                if (O <= 0 && x >= 0 && z <= 0)
                    return f = x / (x - z),
                    i.copy(o).addScaledVector(Pu, f);
                const k = w * z - I * P;
                if (k <= 0 && P - w >= 0 && I - z >= 0)
                    return Ix.subVectors(c, a),
                    f = (P - w) / (P - w + (I - z)),
                    i.copy(a).addScaledVector(Ix, f);
                const Q = 1 / (k + O + M);
                return d = O * Q,
                f = M * Q,
                i.copy(o).addScaledVector(Cu, d).addScaledVector(Pu, f)
            }
            equals(e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        }
        let XC = 0;
        class Vs extends Kr {
            constructor() {
                super(),
                this.isMaterial = !0,
                Object.defineProperty(this, "id", {
                    value: XC++
                }),
                this.uuid = yr(),
                this.name = "",
                this.type = "Material",
                this.blending = _e,
                this.side = Se,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.blendSrc = Sn,
                this.blendDst = rn,
                this.blendEquation = et,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.depthFunc = qe,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = qt,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = W,
                this.stencilZFail = W,
                this.stencilZPass = W,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.forceSinglePass = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(e) {
                this._alphaTest > 0 != e > 0 && this.version++,
                this._alphaTest = e
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(e) {
                if (e !== void 0)
                    for (const i in e) {
                        const o = e[i];
                        if (o === void 0) {
                            console.warn("THREE.Material: '" + i + "' parameter is undefined.");
                            continue
                        }
                        const a = this[i];
                        if (a === void 0) {
                            console.warn("THREE." + this.type + ": '" + i + "' is not a property of this material.");
                            continue
                        }
                        a && a.isColor ? a.set(o) : a && a.isVector3 && o && o.isVector3 ? a.copy(o) : this[i] = o
                    }
            }
            toJSON(e) {
                const i = e === void 0 || typeof e == "string";
                i && (e = {
                    textures: {},
                    images: {}
                });
                const o = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                o.uuid = this.uuid,
                o.type = this.type,
                this.name !== "" && (o.name = this.name),
                this.color && this.color.isColor && (o.color = this.color.getHex()),
                this.roughness !== void 0 && (o.roughness = this.roughness),
                this.metalness !== void 0 && (o.metalness = this.metalness),
                this.sheen !== void 0 && (o.sheen = this.sheen),
                this.sheenColor && this.sheenColor.isColor && (o.sheenColor = this.sheenColor.getHex()),
                this.sheenRoughness !== void 0 && (o.sheenRoughness = this.sheenRoughness),
                this.emissive && this.emissive.isColor && (o.emissive = this.emissive.getHex()),
                this.emissiveIntensity && this.emissiveIntensity !== 1 && (o.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (o.specular = this.specular.getHex()),
                this.specularIntensity !== void 0 && (o.specularIntensity = this.specularIntensity),
                this.specularColor && this.specularColor.isColor && (o.specularColor = this.specularColor.getHex()),
                this.shininess !== void 0 && (o.shininess = this.shininess),
                this.clearcoat !== void 0 && (o.clearcoat = this.clearcoat),
                this.clearcoatRoughness !== void 0 && (o.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (o.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (o.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (o.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                o.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                this.iridescence !== void 0 && (o.iridescence = this.iridescence),
                this.iridescenceIOR !== void 0 && (o.iridescenceIOR = this.iridescenceIOR),
                this.iridescenceThicknessRange !== void 0 && (o.iridescenceThicknessRange = this.iridescenceThicknessRange),
                this.iridescenceMap && this.iridescenceMap.isTexture && (o.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (o.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                this.map && this.map.isTexture && (o.map = this.map.toJSON(e).uuid),
                this.matcap && this.matcap.isTexture && (o.matcap = this.matcap.toJSON(e).uuid),
                this.alphaMap && this.alphaMap.isTexture && (o.alphaMap = this.alphaMap.toJSON(e).uuid),
                this.lightMap && this.lightMap.isTexture && (o.lightMap = this.lightMap.toJSON(e).uuid,
                o.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (o.aoMap = this.aoMap.toJSON(e).uuid,
                o.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (o.bumpMap = this.bumpMap.toJSON(e).uuid,
                o.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (o.normalMap = this.normalMap.toJSON(e).uuid,
                o.normalMapType = this.normalMapType,
                o.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (o.displacementMap = this.displacementMap.toJSON(e).uuid,
                o.displacementScale = this.displacementScale,
                o.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (o.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (o.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (o.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                this.specularMap && this.specularMap.isTexture && (o.specularMap = this.specularMap.toJSON(e).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (o.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                this.specularColorMap && this.specularColorMap.isTexture && (o.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                this.envMap && this.envMap.isTexture && (o.envMap = this.envMap.toJSON(e).uuid,
                this.combine !== void 0 && (o.combine = this.combine)),
                this.envMapIntensity !== void 0 && (o.envMapIntensity = this.envMapIntensity),
                this.reflectivity !== void 0 && (o.reflectivity = this.reflectivity),
                this.refractionRatio !== void 0 && (o.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (o.gradientMap = this.gradientMap.toJSON(e).uuid),
                this.transmission !== void 0 && (o.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (o.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                this.thickness !== void 0 && (o.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (o.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (o.attenuationDistance = this.attenuationDistance),
                this.attenuationColor !== void 0 && (o.attenuationColor = this.attenuationColor.getHex()),
                this.size !== void 0 && (o.size = this.size),
                this.shadowSide !== null && (o.shadowSide = this.shadowSide),
                this.sizeAttenuation !== void 0 && (o.sizeAttenuation = this.sizeAttenuation),
                this.blending !== _e && (o.blending = this.blending),
                this.side !== Se && (o.side = this.side),
                this.vertexColors && (o.vertexColors = !0),
                this.opacity < 1 && (o.opacity = this.opacity),
                this.transparent === !0 && (o.transparent = this.transparent),
                o.depthFunc = this.depthFunc,
                o.depthTest = this.depthTest,
                o.depthWrite = this.depthWrite,
                o.colorWrite = this.colorWrite,
                o.stencilWrite = this.stencilWrite,
                o.stencilWriteMask = this.stencilWriteMask,
                o.stencilFunc = this.stencilFunc,
                o.stencilRef = this.stencilRef,
                o.stencilFuncMask = this.stencilFuncMask,
                o.stencilFail = this.stencilFail,
                o.stencilZFail = this.stencilZFail,
                o.stencilZPass = this.stencilZPass,
                this.rotation !== void 0 && this.rotation !== 0 && (o.rotation = this.rotation),
                this.polygonOffset === !0 && (o.polygonOffset = !0),
                this.polygonOffsetFactor !== 0 && (o.polygonOffsetFactor = this.polygonOffsetFactor),
                this.polygonOffsetUnits !== 0 && (o.polygonOffsetUnits = this.polygonOffsetUnits),
                this.linewidth !== void 0 && this.linewidth !== 1 && (o.linewidth = this.linewidth),
                this.dashSize !== void 0 && (o.dashSize = this.dashSize),
                this.gapSize !== void 0 && (o.gapSize = this.gapSize),
                this.scale !== void 0 && (o.scale = this.scale),
                this.dithering === !0 && (o.dithering = !0),
                this.alphaTest > 0 && (o.alphaTest = this.alphaTest),
                this.alphaToCoverage === !0 && (o.alphaToCoverage = this.alphaToCoverage),
                this.premultipliedAlpha === !0 && (o.premultipliedAlpha = this.premultipliedAlpha),
                this.forceSinglePass === !0 && (o.forceSinglePass = this.forceSinglePass),
                this.wireframe === !0 && (o.wireframe = this.wireframe),
                this.wireframeLinewidth > 1 && (o.wireframeLinewidth = this.wireframeLinewidth),
                this.wireframeLinecap !== "round" && (o.wireframeLinecap = this.wireframeLinecap),
                this.wireframeLinejoin !== "round" && (o.wireframeLinejoin = this.wireframeLinejoin),
                this.flatShading === !0 && (o.flatShading = this.flatShading),
                this.visible === !1 && (o.visible = !1),
                this.toneMapped === !1 && (o.toneMapped = !1),
                this.fog === !1 && (o.fog = !1),
                Object.keys(this.userData).length > 0 && (o.userData = this.userData);
                function a(c) {
                    const d = [];
                    for (const f in c) {
                        const v = c[f];
                        delete v.metadata,
                        d.push(v)
                    }
                    return d
                }
                if (i) {
                    const c = a(e.textures)
                      , d = a(e.images);
                    c.length > 0 && (o.textures = c),
                    d.length > 0 && (o.images = d)
                }
                return o
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                this.name = e.name,
                this.blending = e.blending,
                this.side = e.side,
                this.vertexColors = e.vertexColors,
                this.opacity = e.opacity,
                this.transparent = e.transparent,
                this.blendSrc = e.blendSrc,
                this.blendDst = e.blendDst,
                this.blendEquation = e.blendEquation,
                this.blendSrcAlpha = e.blendSrcAlpha,
                this.blendDstAlpha = e.blendDstAlpha,
                this.blendEquationAlpha = e.blendEquationAlpha,
                this.depthFunc = e.depthFunc,
                this.depthTest = e.depthTest,
                this.depthWrite = e.depthWrite,
                this.stencilWriteMask = e.stencilWriteMask,
                this.stencilFunc = e.stencilFunc,
                this.stencilRef = e.stencilRef,
                this.stencilFuncMask = e.stencilFuncMask,
                this.stencilFail = e.stencilFail,
                this.stencilZFail = e.stencilZFail,
                this.stencilZPass = e.stencilZPass,
                this.stencilWrite = e.stencilWrite;
                const i = e.clippingPlanes;
                let o = null;
                if (i !== null) {
                    const a = i.length;
                    o = new Array(a);
                    for (let c = 0; c !== a; ++c)
                        o[c] = i[c].clone()
                }
                return this.clippingPlanes = o,
                this.clipIntersection = e.clipIntersection,
                this.clipShadows = e.clipShadows,
                this.shadowSide = e.shadowSide,
                this.colorWrite = e.colorWrite,
                this.precision = e.precision,
                this.polygonOffset = e.polygonOffset,
                this.polygonOffsetFactor = e.polygonOffsetFactor,
                this.polygonOffsetUnits = e.polygonOffsetUnits,
                this.dithering = e.dithering,
                this.alphaTest = e.alphaTest,
                this.alphaToCoverage = e.alphaToCoverage,
                this.premultipliedAlpha = e.premultipliedAlpha,
                this.forceSinglePass = e.forceSinglePass,
                this.visible = e.visible,
                this.toneMapped = e.toneMapped,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(e) {
                e === !0 && this.version++
            }
        }
        const Ox = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Aa = {
            h: 0,
            s: 0,
            l: 0
        }
          , Qf = {
            h: 0,
            s: 0,
            l: 0
        };
        function Qg(u, e, i) {
            return i < 0 && (i += 1),
            i > 1 && (i -= 1),
            i < 1 / 6 ? u + (e - u) * 6 * i : i < 1 / 2 ? e : i < 2 / 3 ? u + (e - u) * 6 * (2 / 3 - i) : u
        }
        class gn {
            constructor(e, i, o) {
                return this.isColor = !0,
                this.r = 1,
                this.g = 1,
                this.b = 1,
                i === void 0 && o === void 0 ? this.set(e) : this.setRGB(e, i, o)
            }
            set(e) {
                return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e),
                this
            }
            setScalar(e) {
                return this.r = e,
                this.g = e,
                this.b = e,
                this
            }
            setHex(e, i=T) {
                return e = Math.floor(e),
                this.r = (e >> 16 & 255) / 255,
                this.g = (e >> 8 & 255) / 255,
                this.b = (e & 255) / 255,
                bt.toWorkingColorSpace(this, i),
                this
            }
            setRGB(e, i, o, a=bt.workingColorSpace) {
                return this.r = e,
                this.g = i,
                this.b = o,
                bt.toWorkingColorSpace(this, a),
                this
            }
            setHSL(e, i, o, a=bt.workingColorSpace) {
                if (e = ve(e, 1),
                i = Wi(i, 0, 1),
                o = Wi(o, 0, 1),
                i === 0)
                    this.r = this.g = this.b = o;
                else {
                    const c = o <= .5 ? o * (1 + i) : o + i - o * i
                      , d = 2 * o - c;
                    this.r = Qg(d, c, e + 1 / 3),
                    this.g = Qg(d, c, e),
                    this.b = Qg(d, c, e - 1 / 3)
                }
                return bt.toWorkingColorSpace(this, a),
                this
            }
            setStyle(e, i=T) {
                function o(c) {
                    c !== void 0 && parseFloat(c) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                let a;
                if (a = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                    let c;
                    const d = a[1]
                      , f = a[2];
                    switch (d) {
                    case "rgb":
                    case "rgba":
                        if (c = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f))
                            return this.r = Math.min(255, parseInt(c[1], 10)) / 255,
                            this.g = Math.min(255, parseInt(c[2], 10)) / 255,
                            this.b = Math.min(255, parseInt(c[3], 10)) / 255,
                            bt.toWorkingColorSpace(this, i),
                            o(c[4]),
                            this;
                        if (c = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f))
                            return this.r = Math.min(100, parseInt(c[1], 10)) / 100,
                            this.g = Math.min(100, parseInt(c[2], 10)) / 100,
                            this.b = Math.min(100, parseInt(c[3], 10)) / 100,
                            bt.toWorkingColorSpace(this, i),
                            o(c[4]),
                            this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (c = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f)) {
                            const v = parseFloat(c[1]) / 360
                              , x = parseFloat(c[2]) / 100
                              , w = parseFloat(c[3]) / 100;
                            return o(c[4]),
                            this.setHSL(v, x, w, i)
                        }
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + e)
                    }
                } else if (a = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const c = a[1]
                      , d = c.length;
                    if (d === 3)
                        return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255,
                        this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255,
                        this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255,
                        bt.toWorkingColorSpace(this, i),
                        this;
                    if (d === 6)
                        return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255,
                        this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255,
                        this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255,
                        bt.toWorkingColorSpace(this, i),
                        this;
                    console.warn("THREE.Color: Invalid hex color " + e)
                } else if (e && e.length > 0)
                    return this.setColorName(e, i);
                return this
            }
            setColorName(e, i=T) {
                const o = Ox[e.toLowerCase()];
                return o !== void 0 ? this.setHex(o, i) : console.warn("THREE.Color: Unknown color " + e),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(e) {
                return this.r = e.r,
                this.g = e.g,
                this.b = e.b,
                this
            }
            copySRGBToLinear(e) {
                return this.r = le(e.r),
                this.g = le(e.g),
                this.b = le(e.b),
                this
            }
            copyLinearToSRGB(e) {
                return this.r = Ee(e.r),
                this.g = Ee(e.g),
                this.b = Ee(e.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex(e=T) {
                return bt.fromWorkingColorSpace(Ws.copy(this), e),
                Wi(Ws.r * 255, 0, 255) << 16 ^ Wi(Ws.g * 255, 0, 255) << 8 ^ Wi(Ws.b * 255, 0, 255) << 0
            }
            getHexString(e=T) {
                return ("000000" + this.getHex(e).toString(16)).slice(-6)
            }
            getHSL(e, i=bt.workingColorSpace) {
                bt.fromWorkingColorSpace(Ws.copy(this), i);
                const o = Ws.r
                  , a = Ws.g
                  , c = Ws.b
                  , d = Math.max(o, a, c)
                  , f = Math.min(o, a, c);
                let v, x;
                const w = (f + d) / 2;
                if (f === d)
                    v = 0,
                    x = 0;
                else {
                    const P = d - f;
                    switch (x = w <= .5 ? P / (d + f) : P / (2 - d - f),
                    d) {
                    case o:
                        v = (a - c) / P + (a < c ? 6 : 0);
                        break;
                    case a:
                        v = (c - o) / P + 2;
                        break;
                    case c:
                        v = (o - a) / P + 4;
                        break
                    }
                    v /= 6
                }
                return e.h = v,
                e.s = x,
                e.l = w,
                e
            }
            getRGB(e, i=bt.workingColorSpace) {
                return bt.fromWorkingColorSpace(Ws.copy(this), i),
                e.r = Ws.r,
                e.g = Ws.g,
                e.b = Ws.b,
                e
            }
            getStyle(e=T) {
                bt.fromWorkingColorSpace(Ws.copy(this), e);
                const i = Ws.r
                  , o = Ws.g
                  , a = Ws.b;
                return e !== T ? `color(${e} ${i.toFixed(3)} ${o.toFixed(3)} ${a.toFixed(3)})` : `rgb(${i * 255 | 0},${o * 255 | 0},${a * 255 | 0})`
            }
            offsetHSL(e, i, o) {
                return this.getHSL(Aa),
                Aa.h += e,
                Aa.s += i,
                Aa.l += o,
                this.setHSL(Aa.h, Aa.s, Aa.l),
                this
            }
            add(e) {
                return this.r += e.r,
                this.g += e.g,
                this.b += e.b,
                this
            }
            addColors(e, i) {
                return this.r = e.r + i.r,
                this.g = e.g + i.g,
                this.b = e.b + i.b,
                this
            }
            addScalar(e) {
                return this.r += e,
                this.g += e,
                this.b += e,
                this
            }
            sub(e) {
                return this.r = Math.max(0, this.r - e.r),
                this.g = Math.max(0, this.g - e.g),
                this.b = Math.max(0, this.b - e.b),
                this
            }
            multiply(e) {
                return this.r *= e.r,
                this.g *= e.g,
                this.b *= e.b,
                this
            }
            multiplyScalar(e) {
                return this.r *= e,
                this.g *= e,
                this.b *= e,
                this
            }
            lerp(e, i) {
                return this.r += (e.r - this.r) * i,
                this.g += (e.g - this.g) * i,
                this.b += (e.b - this.b) * i,
                this
            }
            lerpColors(e, i, o) {
                return this.r = e.r + (i.r - e.r) * o,
                this.g = e.g + (i.g - e.g) * o,
                this.b = e.b + (i.b - e.b) * o,
                this
            }
            lerpHSL(e, i) {
                this.getHSL(Aa),
                e.getHSL(Qf);
                const o = ee(Aa.h, Qf.h, i)
                  , a = ee(Aa.s, Qf.s, i)
                  , c = ee(Aa.l, Qf.l, i);
                return this.setHSL(o, a, c),
                this
            }
            equals(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
            fromArray(e, i=0) {
                return this.r = e[i],
                this.g = e[i + 1],
                this.b = e[i + 2],
                this
            }
            toArray(e=[], i=0) {
                return e[i] = this.r,
                e[i + 1] = this.g,
                e[i + 2] = this.b,
                e
            }
            fromBufferAttribute(e, i) {
                return this.r = e.getX(i),
                this.g = e.getY(i),
                this.b = e.getZ(i),
                this
            }
            toJSON() {
                return this.getHex()
            }
            *[Symbol.iterator]() {
                yield this.r,
                yield this.g,
                yield this.b
            }
        }
        const Ws = new gn;
        gn.NAMES = Ox;
        class ql extends Vs {
            constructor(e) {
                super(),
                this.isMeshBasicMaterial = !0,
                this.type = "MeshBasicMaterial",
                this.color = new gn(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = ui,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.fog = e.fog,
                this
            }
        }
        const qr = new me
          , Kf = new _t;
        class dr {
            constructor(e, i, o=!1) {
                if (Array.isArray(e))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0,
                this.name = "",
                this.array = e,
                this.itemSize = i,
                this.count = e !== void 0 ? e.length / i : 0,
                this.normalized = o,
                this.usage = ln,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                e === !0 && this.version++
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            copy(e) {
                return this.name = e.name,
                this.array = new e.array.constructor(e.array),
                this.itemSize = e.itemSize,
                this.count = e.count,
                this.normalized = e.normalized,
                this.usage = e.usage,
                this
            }
            copyAt(e, i, o) {
                e *= this.itemSize,
                o *= i.itemSize;
                for (let a = 0, c = this.itemSize; a < c; a++)
                    this.array[e + a] = i.array[o + a];
                return this
            }
            copyArray(e) {
                return this.array.set(e),
                this
            }
            applyMatrix3(e) {
                if (this.itemSize === 2)
                    for (let i = 0, o = this.count; i < o; i++)
                        Kf.fromBufferAttribute(this, i),
                        Kf.applyMatrix3(e),
                        this.setXY(i, Kf.x, Kf.y);
                else if (this.itemSize === 3)
                    for (let i = 0, o = this.count; i < o; i++)
                        qr.fromBufferAttribute(this, i),
                        qr.applyMatrix3(e),
                        this.setXYZ(i, qr.x, qr.y, qr.z);
                return this
            }
            applyMatrix4(e) {
                for (let i = 0, o = this.count; i < o; i++)
                    qr.fromBufferAttribute(this, i),
                    qr.applyMatrix4(e),
                    this.setXYZ(i, qr.x, qr.y, qr.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let i = 0, o = this.count; i < o; i++)
                    qr.fromBufferAttribute(this, i),
                    qr.applyNormalMatrix(e),
                    this.setXYZ(i, qr.x, qr.y, qr.z);
                return this
            }
            transformDirection(e) {
                for (let i = 0, o = this.count; i < o; i++)
                    qr.fromBufferAttribute(this, i),
                    qr.transformDirection(e),
                    this.setXYZ(i, qr.x, qr.y, qr.z);
                return this
            }
            set(e, i=0) {
                return this.array.set(e, i),
                this
            }
            getX(e) {
                let i = this.array[e * this.itemSize];
                return this.normalized && (i = ur(i, this.array)),
                i
            }
            setX(e, i) {
                return this.normalized && (i = fi(i, this.array)),
                this.array[e * this.itemSize] = i,
                this
            }
            getY(e) {
                let i = this.array[e * this.itemSize + 1];
                return this.normalized && (i = ur(i, this.array)),
                i
            }
            setY(e, i) {
                return this.normalized && (i = fi(i, this.array)),
                this.array[e * this.itemSize + 1] = i,
                this
            }
            getZ(e) {
                let i = this.array[e * this.itemSize + 2];
                return this.normalized && (i = ur(i, this.array)),
                i
            }
            setZ(e, i) {
                return this.normalized && (i = fi(i, this.array)),
                this.array[e * this.itemSize + 2] = i,
                this
            }
            getW(e) {
                let i = this.array[e * this.itemSize + 3];
                return this.normalized && (i = ur(i, this.array)),
                i
            }
            setW(e, i) {
                return this.normalized && (i = fi(i, this.array)),
                this.array[e * this.itemSize + 3] = i,
                this
            }
            setXY(e, i, o) {
                return e *= this.itemSize,
                this.normalized && (i = fi(i, this.array),
                o = fi(o, this.array)),
                this.array[e + 0] = i,
                this.array[e + 1] = o,
                this
            }
            setXYZ(e, i, o, a) {
                return e *= this.itemSize,
                this.normalized && (i = fi(i, this.array),
                o = fi(o, this.array),
                a = fi(a, this.array)),
                this.array[e + 0] = i,
                this.array[e + 1] = o,
                this.array[e + 2] = a,
                this
            }
            setXYZW(e, i, o, a, c) {
                return e *= this.itemSize,
                this.normalized && (i = fi(i, this.array),
                o = fi(o, this.array),
                a = fi(a, this.array),
                c = fi(c, this.array)),
                this.array[e + 0] = i,
                this.array[e + 1] = o,
                this.array[e + 2] = a,
                this.array[e + 3] = c,
                this
            }
            onUpload(e) {
                return this.onUploadCallback = e,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const e = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return this.name !== "" && (e.name = this.name),
                this.usage !== ln && (e.usage = this.usage),
                (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange),
                e
            }
            copyColorsArray() {
                console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
            }
            copyVector2sArray() {
                console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
            }
            copyVector3sArray() {
                console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
            }
            copyVector4sArray() {
                console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
            }
        }
        class YC extends dr {
            constructor(e, i, o) {
                super(new Int8Array(e), i, o)
            }
        }
        class QC extends dr {
            constructor(e, i, o) {
                super(new Uint8Array(e), i, o)
            }
        }
        class KC extends dr {
            constructor(e, i, o) {
                super(new Uint8ClampedArray(e), i, o)
            }
        }
        class ZC extends dr {
            constructor(e, i, o) {
                super(new Int16Array(e), i, o)
            }
        }
        class Kg extends dr {
            constructor(e, i, o) {
                super(new Uint16Array(e), i, o)
            }
        }
        class qC extends dr {
            constructor(e, i, o) {
                super(new Int32Array(e), i, o)
            }
        }
        class Zg extends dr {
            constructor(e, i, o) {
                super(new Uint32Array(e), i, o)
            }
        }
        class JC extends dr {
            constructor(e, i, o) {
                super(new Uint16Array(e), i, o),
                this.isFloat16BufferAttribute = !0
            }
        }
        class Rn extends dr {
            constructor(e, i, o) {
                super(new Float32Array(e), i, o)
            }
        }
        class $C extends dr {
            constructor(e, i, o) {
                super(new Float64Array(e), i, o)
            }
        }
        let e2 = 0;
        const Jo = new pi
          , qg = new Qi
          , Ru = new me
          , Io = new Zr
          , Xh = new Zr
          , hs = new me;
        class Ai extends Kr {
            constructor() {
                super(),
                this.isBufferGeometry = !0,
                Object.defineProperty(this, "id", {
                    value: e2++
                }),
                this.uuid = yr(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(e) {
                return Array.isArray(e) ? this.index = new (Ci(e) ? Zg : Kg)(e,1) : this.index = e,
                this
            }
            getAttribute(e) {
                return this.attributes[e]
            }
            setAttribute(e, i) {
                return this.attributes[e] = i,
                this
            }
            deleteAttribute(e) {
                return delete this.attributes[e],
                this
            }
            hasAttribute(e) {
                return this.attributes[e] !== void 0
            }
            addGroup(e, i, o=0) {
                this.groups.push({
                    start: e,
                    count: i,
                    materialIndex: o
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(e, i) {
                this.drawRange.start = e,
                this.drawRange.count = i
            }
            applyMatrix4(e) {
                const i = this.attributes.position;
                i !== void 0 && (i.applyMatrix4(e),
                i.needsUpdate = !0);
                const o = this.attributes.normal;
                if (o !== void 0) {
                    const c = new Cr().getNormalMatrix(e);
                    o.applyNormalMatrix(c),
                    o.needsUpdate = !0
                }
                const a = this.attributes.tangent;
                return a !== void 0 && (a.transformDirection(e),
                a.needsUpdate = !0),
                this.boundingBox !== null && this.computeBoundingBox(),
                this.boundingSphere !== null && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(e) {
                return Jo.makeRotationFromQuaternion(e),
                this.applyMatrix4(Jo),
                this
            }
            rotateX(e) {
                return Jo.makeRotationX(e),
                this.applyMatrix4(Jo),
                this
            }
            rotateY(e) {
                return Jo.makeRotationY(e),
                this.applyMatrix4(Jo),
                this
            }
            rotateZ(e) {
                return Jo.makeRotationZ(e),
                this.applyMatrix4(Jo),
                this
            }
            translate(e, i, o) {
                return Jo.makeTranslation(e, i, o),
                this.applyMatrix4(Jo),
                this
            }
            scale(e, i, o) {
                return Jo.makeScale(e, i, o),
                this.applyMatrix4(Jo),
                this
            }
            lookAt(e) {
                return qg.lookAt(e),
                qg.updateMatrix(),
                this.applyMatrix4(qg.matrix),
                this
            }
            center() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(Ru).negate(),
                this.translate(Ru.x, Ru.y, Ru.z),
                this
            }
            setFromPoints(e) {
                const i = [];
                for (let o = 0, a = e.length; o < a; o++) {
                    const c = e[o];
                    i.push(c.x, c.y, c.z || 0)
                }
                return this.setAttribute("position", new Rn(i,3)),
                this
            }
            computeBoundingBox() {
                this.boundingBox === null && (this.boundingBox = new Zr);
                const e = this.attributes.position
                  , i = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute) {
                    console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                    this.boundingBox.set(new me(-1 / 0,-1 / 0,-1 / 0), new me(1 / 0,1 / 0,1 / 0));
                    return
                }
                if (e !== void 0) {
                    if (this.boundingBox.setFromBufferAttribute(e),
                    i)
                        for (let o = 0, a = i.length; o < a; o++) {
                            const c = i[o];
                            Io.setFromBufferAttribute(c),
                            this.morphTargetsRelative ? (hs.addVectors(this.boundingBox.min, Io.min),
                            this.boundingBox.expandByPoint(hs),
                            hs.addVectors(this.boundingBox.max, Io.max),
                            this.boundingBox.expandByPoint(hs)) : (this.boundingBox.expandByPoint(Io.min),
                            this.boundingBox.expandByPoint(Io.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                this.boundingSphere === null && (this.boundingSphere = new Nc);
                const e = this.attributes.position
                  , i = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute) {
                    console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                    this.boundingSphere.set(new me, 1 / 0);
                    return
                }
                if (e) {
                    const o = this.boundingSphere.center;
                    if (Io.setFromBufferAttribute(e),
                    i)
                        for (let c = 0, d = i.length; c < d; c++) {
                            const f = i[c];
                            Xh.setFromBufferAttribute(f),
                            this.morphTargetsRelative ? (hs.addVectors(Io.min, Xh.min),
                            Io.expandByPoint(hs),
                            hs.addVectors(Io.max, Xh.max),
                            Io.expandByPoint(hs)) : (Io.expandByPoint(Xh.min),
                            Io.expandByPoint(Xh.max))
                        }
                    Io.getCenter(o);
                    let a = 0;
                    for (let c = 0, d = e.count; c < d; c++)
                        hs.fromBufferAttribute(e, c),
                        a = Math.max(a, o.distanceToSquared(hs));
                    if (i)
                        for (let c = 0, d = i.length; c < d; c++) {
                            const f = i[c]
                              , v = this.morphTargetsRelative;
                            for (let x = 0, w = f.count; x < w; x++)
                                hs.fromBufferAttribute(f, x),
                                v && (Ru.fromBufferAttribute(e, x),
                                hs.add(Ru)),
                                a = Math.max(a, o.distanceToSquared(hs))
                        }
                    this.boundingSphere.radius = Math.sqrt(a),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const e = this.index
                  , i = this.attributes;
                if (e === null || i.position === void 0 || i.normal === void 0 || i.uv === void 0) {
                    console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    return
                }
                const o = e.array
                  , a = i.position.array
                  , c = i.normal.array
                  , d = i.uv.array
                  , f = a.length / 3;
                this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new dr(new Float32Array(4 * f),4));
                const v = this.getAttribute("tangent").array
                  , x = []
                  , w = [];
                for (let Le = 0; Le < f; Le++)
                    x[Le] = new me,
                    w[Le] = new me;
                const P = new me
                  , M = new me
                  , I = new me
                  , z = new _t
                  , O = new _t
                  , k = new _t
                  , Q = new me
                  , Z = new me;
                function X(Le, tt, lt) {
                    P.fromArray(a, Le * 3),
                    M.fromArray(a, tt * 3),
                    I.fromArray(a, lt * 3),
                    z.fromArray(d, Le * 2),
                    O.fromArray(d, tt * 2),
                    k.fromArray(d, lt * 2),
                    M.sub(P),
                    I.sub(P),
                    O.sub(z),
                    k.sub(z);
                    const je = 1 / (O.x * k.y - k.x * O.y);
                    isFinite(je) && (Q.copy(M).multiplyScalar(k.y).addScaledVector(I, -O.y).multiplyScalar(je),
                    Z.copy(I).multiplyScalar(O.x).addScaledVector(M, -k.x).multiplyScalar(je),
                    x[Le].add(Q),
                    x[tt].add(Q),
                    x[lt].add(Q),
                    w[Le].add(Z),
                    w[tt].add(Z),
                    w[lt].add(Z))
                }
                let K = this.groups;
                K.length === 0 && (K = [{
                    start: 0,
                    count: o.length
                }]);
                for (let Le = 0, tt = K.length; Le < tt; ++Le) {
                    const lt = K[Le]
                      , je = lt.start
                      , ze = lt.count;
                    for (let st = je, yt = je + ze; st < yt; st += 3)
                        X(o[st + 0], o[st + 1], o[st + 2])
                }
                const de = new me
                  , be = new me
                  , Me = new me
                  , J = new me;
                function ge(Le) {
                    Me.fromArray(c, Le * 3),
                    J.copy(Me);
                    const tt = x[Le];
                    de.copy(tt),
                    de.sub(Me.multiplyScalar(Me.dot(tt))).normalize(),
                    be.crossVectors(J, tt);
                    const je = be.dot(w[Le]) < 0 ? -1 : 1;
                    v[Le * 4] = de.x,
                    v[Le * 4 + 1] = de.y,
                    v[Le * 4 + 2] = de.z,
                    v[Le * 4 + 3] = je
                }
                for (let Le = 0, tt = K.length; Le < tt; ++Le) {
                    const lt = K[Le]
                      , je = lt.start
                      , ze = lt.count;
                    for (let st = je, yt = je + ze; st < yt; st += 3)
                        ge(o[st + 0]),
                        ge(o[st + 1]),
                        ge(o[st + 2])
                }
            }
            computeVertexNormals() {
                const e = this.index
                  , i = this.getAttribute("position");
                if (i !== void 0) {
                    let o = this.getAttribute("normal");
                    if (o === void 0)
                        o = new dr(new Float32Array(i.count * 3),3),
                        this.setAttribute("normal", o);
                    else
                        for (let M = 0, I = o.count; M < I; M++)
                            o.setXYZ(M, 0, 0, 0);
                    const a = new me
                      , c = new me
                      , d = new me
                      , f = new me
                      , v = new me
                      , x = new me
                      , w = new me
                      , P = new me;
                    if (e)
                        for (let M = 0, I = e.count; M < I; M += 3) {
                            const z = e.getX(M + 0)
                              , O = e.getX(M + 1)
                              , k = e.getX(M + 2);
                            a.fromBufferAttribute(i, z),
                            c.fromBufferAttribute(i, O),
                            d.fromBufferAttribute(i, k),
                            w.subVectors(d, c),
                            P.subVectors(a, c),
                            w.cross(P),
                            f.fromBufferAttribute(o, z),
                            v.fromBufferAttribute(o, O),
                            x.fromBufferAttribute(o, k),
                            f.add(w),
                            v.add(w),
                            x.add(w),
                            o.setXYZ(z, f.x, f.y, f.z),
                            o.setXYZ(O, v.x, v.y, v.z),
                            o.setXYZ(k, x.x, x.y, x.z)
                        }
                    else
                        for (let M = 0, I = i.count; M < I; M += 3)
                            a.fromBufferAttribute(i, M + 0),
                            c.fromBufferAttribute(i, M + 1),
                            d.fromBufferAttribute(i, M + 2),
                            w.subVectors(d, c),
                            P.subVectors(a, c),
                            w.cross(P),
                            o.setXYZ(M + 0, w.x, w.y, w.z),
                            o.setXYZ(M + 1, w.x, w.y, w.z),
                            o.setXYZ(M + 2, w.x, w.y, w.z);
                    this.normalizeNormals(),
                    o.needsUpdate = !0
                }
            }
            merge() {
                return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),
                this
            }
            normalizeNormals() {
                const e = this.attributes.normal;
                for (let i = 0, o = e.count; i < o; i++)
                    hs.fromBufferAttribute(e, i),
                    hs.normalize(),
                    e.setXYZ(i, hs.x, hs.y, hs.z)
            }
            toNonIndexed() {
                function e(f, v) {
                    const x = f.array
                      , w = f.itemSize
                      , P = f.normalized
                      , M = new x.constructor(v.length * w);
                    let I = 0
                      , z = 0;
                    for (let O = 0, k = v.length; O < k; O++) {
                        f.isInterleavedBufferAttribute ? I = v[O] * f.data.stride + f.offset : I = v[O] * w;
                        for (let Q = 0; Q < w; Q++)
                            M[z++] = x[I++]
                    }
                    return new dr(M,w,P)
                }
                if (this.index === null)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const i = new Ai
                  , o = this.index.array
                  , a = this.attributes;
                for (const f in a) {
                    const v = a[f]
                      , x = e(v, o);
                    i.setAttribute(f, x)
                }
                const c = this.morphAttributes;
                for (const f in c) {
                    const v = []
                      , x = c[f];
                    for (let w = 0, P = x.length; w < P; w++) {
                        const M = x[w]
                          , I = e(M, o);
                        v.push(I)
                    }
                    i.morphAttributes[f] = v
                }
                i.morphTargetsRelative = this.morphTargetsRelative;
                const d = this.groups;
                for (let f = 0, v = d.length; f < v; f++) {
                    const x = d[f];
                    i.addGroup(x.start, x.count, x.materialIndex)
                }
                return i
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid,
                e.type = this.type,
                this.name !== "" && (e.name = this.name),
                Object.keys(this.userData).length > 0 && (e.userData = this.userData),
                this.parameters !== void 0) {
                    const v = this.parameters;
                    for (const x in v)
                        v[x] !== void 0 && (e[x] = v[x]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                const i = this.index;
                i !== null && (e.data.index = {
                    type: i.array.constructor.name,
                    array: Array.prototype.slice.call(i.array)
                });
                const o = this.attributes;
                for (const v in o) {
                    const x = o[v];
                    e.data.attributes[v] = x.toJSON(e.data)
                }
                const a = {};
                let c = !1;
                for (const v in this.morphAttributes) {
                    const x = this.morphAttributes[v]
                      , w = [];
                    for (let P = 0, M = x.length; P < M; P++) {
                        const I = x[P];
                        w.push(I.toJSON(e.data))
                    }
                    w.length > 0 && (a[v] = w,
                    c = !0)
                }
                c && (e.data.morphAttributes = a,
                e.data.morphTargetsRelative = this.morphTargetsRelative);
                const d = this.groups;
                d.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(d)));
                const f = this.boundingSphere;
                return f !== null && (e.data.boundingSphere = {
                    center: f.center.toArray(),
                    radius: f.radius
                }),
                e
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const i = {};
                this.name = e.name;
                const o = e.index;
                o !== null && this.setIndex(o.clone(i));
                const a = e.attributes;
                for (const x in a) {
                    const w = a[x];
                    this.setAttribute(x, w.clone(i))
                }
                const c = e.morphAttributes;
                for (const x in c) {
                    const w = []
                      , P = c[x];
                    for (let M = 0, I = P.length; M < I; M++)
                        w.push(P[M].clone(i));
                    this.morphAttributes[x] = w
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                const d = e.groups;
                for (let x = 0, w = d.length; x < w; x++) {
                    const P = d[x];
                    this.addGroup(P.start, P.count, P.materialIndex)
                }
                const f = e.boundingBox;
                f !== null && (this.boundingBox = f.clone());
                const v = e.boundingSphere;
                return v !== null && (this.boundingSphere = v.clone()),
                this.drawRange.start = e.drawRange.start,
                this.drawRange.count = e.drawRange.count,
                this.userData = e.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Bx = new pi
          , Wa = new Vh
          , Zf = new Nc
          , Fx = new me
          , Yh = new me
          , Qh = new me
          , Kh = new me
          , Jg = new me
          , qf = new me
          , Jf = new _t
          , $f = new _t
          , ep = new _t
          , $g = new me
          , tp = new me;
        class Es extends Qi {
            constructor(e=new Ai, i=new ql) {
                super(),
                this.isMesh = !0,
                this.type = "Mesh",
                this.geometry = e,
                this.material = i,
                this.updateMorphTargets()
            }
            copy(e, i) {
                return super.copy(e, i),
                e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                this.material = e.material,
                this.geometry = e.geometry,
                this
            }
            updateMorphTargets() {
                const i = this.geometry.morphAttributes
                  , o = Object.keys(i);
                if (o.length > 0) {
                    const a = i[o[0]];
                    if (a !== void 0) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let c = 0, d = a.length; c < d; c++) {
                            const f = a[c].name || String(c);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[f] = c
                        }
                    }
                }
            }
            getVertexPosition(e, i) {
                const o = this.geometry
                  , a = o.attributes.position
                  , c = o.morphAttributes.position
                  , d = o.morphTargetsRelative;
                i.fromBufferAttribute(a, e);
                const f = this.morphTargetInfluences;
                if (c && f) {
                    qf.set(0, 0, 0);
                    for (let v = 0, x = c.length; v < x; v++) {
                        const w = f[v]
                          , P = c[v];
                        w !== 0 && (Jg.fromBufferAttribute(P, e),
                        d ? qf.addScaledVector(Jg, w) : qf.addScaledVector(Jg.sub(i), w))
                    }
                    i.add(qf)
                }
                return this.isSkinnedMesh && this.boneTransform(e, i),
                i
            }
            raycast(e, i) {
                const o = this.geometry
                  , a = this.material
                  , c = this.matrixWorld;
                if (a === void 0 || (o.boundingSphere === null && o.computeBoundingSphere(),
                Zf.copy(o.boundingSphere),
                Zf.applyMatrix4(c),
                Wa.copy(e.ray).recast(e.near),
                Zf.containsPoint(Wa.origin) === !1 && (Wa.intersectSphere(Zf, Fx) === null || Wa.origin.distanceToSquared(Fx) > (e.far - e.near) ** 2)) || (Bx.copy(c).invert(),
                Wa.copy(e.ray).applyMatrix4(Bx),
                o.boundingBox !== null && Wa.intersectsBox(o.boundingBox) === !1))
                    return;
                let d;
                const f = o.index
                  , v = o.attributes.position
                  , x = o.attributes.uv
                  , w = o.attributes.uv2
                  , P = o.groups
                  , M = o.drawRange;
                if (f !== null)
                    if (Array.isArray(a))
                        for (let I = 0, z = P.length; I < z; I++) {
                            const O = P[I]
                              , k = a[O.materialIndex]
                              , Q = Math.max(O.start, M.start)
                              , Z = Math.min(f.count, Math.min(O.start + O.count, M.start + M.count));
                            for (let X = Q, K = Z; X < K; X += 3) {
                                const de = f.getX(X)
                                  , be = f.getX(X + 1)
                                  , Me = f.getX(X + 2);
                                d = np(this, k, e, Wa, x, w, de, be, Me),
                                d && (d.faceIndex = Math.floor(X / 3),
                                d.face.materialIndex = O.materialIndex,
                                i.push(d))
                            }
                        }
                    else {
                        const I = Math.max(0, M.start)
                          , z = Math.min(f.count, M.start + M.count);
                        for (let O = I, k = z; O < k; O += 3) {
                            const Q = f.getX(O)
                              , Z = f.getX(O + 1)
                              , X = f.getX(O + 2);
                            d = np(this, a, e, Wa, x, w, Q, Z, X),
                            d && (d.faceIndex = Math.floor(O / 3),
                            i.push(d))
                        }
                    }
                else if (v !== void 0)
                    if (Array.isArray(a))
                        for (let I = 0, z = P.length; I < z; I++) {
                            const O = P[I]
                              , k = a[O.materialIndex]
                              , Q = Math.max(O.start, M.start)
                              , Z = Math.min(v.count, Math.min(O.start + O.count, M.start + M.count));
                            for (let X = Q, K = Z; X < K; X += 3) {
                                const de = X
                                  , be = X + 1
                                  , Me = X + 2;
                                d = np(this, k, e, Wa, x, w, de, be, Me),
                                d && (d.faceIndex = Math.floor(X / 3),
                                d.face.materialIndex = O.materialIndex,
                                i.push(d))
                            }
                        }
                    else {
                        const I = Math.max(0, M.start)
                          , z = Math.min(v.count, M.start + M.count);
                        for (let O = I, k = z; O < k; O += 3) {
                            const Q = O
                              , Z = O + 1
                              , X = O + 2;
                            d = np(this, a, e, Wa, x, w, Q, Z, X),
                            d && (d.faceIndex = Math.floor(O / 3),
                            i.push(d))
                        }
                    }
            }
        }
        function t2(u, e, i, o, a, c, d, f) {
            let v;
            if (e.side === $ ? v = o.intersectTriangle(d, c, a, !0, f) : v = o.intersectTriangle(a, c, d, e.side === Se, f),
            v === null)
                return null;
            tp.copy(f),
            tp.applyMatrix4(u.matrixWorld);
            const x = i.ray.origin.distanceTo(tp);
            return x < i.near || x > i.far ? null : {
                distance: x,
                point: tp.clone(),
                object: u
            }
        }
        function np(u, e, i, o, a, c, d, f, v) {
            u.getVertexPosition(d, Yh),
            u.getVertexPosition(f, Qh),
            u.getVertexPosition(v, Kh);
            const x = t2(u, e, i, o, Yh, Qh, Kh, $g);
            if (x) {
                a && (Jf.fromBufferAttribute(a, d),
                $f.fromBufferAttribute(a, f),
                ep.fromBufferAttribute(a, v),
                x.uv = qo.getUV($g, Yh, Qh, Kh, Jf, $f, ep, new _t)),
                c && (Jf.fromBufferAttribute(c, d),
                $f.fromBufferAttribute(c, f),
                ep.fromBufferAttribute(c, v),
                x.uv2 = qo.getUV($g, Yh, Qh, Kh, Jf, $f, ep, new _t));
                const w = {
                    a: d,
                    b: f,
                    c: v,
                    normal: new me,
                    materialIndex: 0
                };
                qo.getNormal(Yh, Qh, Kh, w.normal),
                x.face = w
            }
            return x
        }
        class Jl extends Ai {
            constructor(e=1, i=1, o=1, a=1, c=1, d=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: e,
                    height: i,
                    depth: o,
                    widthSegments: a,
                    heightSegments: c,
                    depthSegments: d
                };
                const f = this;
                a = Math.floor(a),
                c = Math.floor(c),
                d = Math.floor(d);
                const v = []
                  , x = []
                  , w = []
                  , P = [];
                let M = 0
                  , I = 0;
                z("z", "y", "x", -1, -1, o, i, e, d, c, 0),
                z("z", "y", "x", 1, -1, o, i, -e, d, c, 1),
                z("x", "z", "y", 1, 1, e, o, i, a, d, 2),
                z("x", "z", "y", 1, -1, e, o, -i, a, d, 3),
                z("x", "y", "z", 1, -1, e, i, o, a, c, 4),
                z("x", "y", "z", -1, -1, e, i, -o, a, c, 5),
                this.setIndex(v),
                this.setAttribute("position", new Rn(x,3)),
                this.setAttribute("normal", new Rn(w,3)),
                this.setAttribute("uv", new Rn(P,2));
                function z(O, k, Q, Z, X, K, de, be, Me, J, ge) {
                    const Le = K / Me
                      , tt = de / J
                      , lt = K / 2
                      , je = de / 2
                      , ze = be / 2
                      , st = Me + 1
                      , yt = J + 1;
                    let It = 0
                      , ht = 0;
                    const Ot = new me;
                    for (let Mt = 0; Mt < yt; Mt++) {
                        const Ln = Mt * tt - je;
                        for (let Ye = 0; Ye < st; Ye++) {
                            const Pt = Ye * Le - lt;
                            Ot[O] = Pt * Z,
                            Ot[k] = Ln * X,
                            Ot[Q] = ze,
                            x.push(Ot.x, Ot.y, Ot.z),
                            Ot[O] = 0,
                            Ot[k] = 0,
                            Ot[Q] = be > 0 ? 1 : -1,
                            w.push(Ot.x, Ot.y, Ot.z),
                            P.push(Ye / Me),
                            P.push(1 - Mt / J),
                            It += 1
                        }
                    }
                    for (let Mt = 0; Mt < J; Mt++)
                        for (let Ln = 0; Ln < Me; Ln++) {
                            const Ye = M + Ln + st * Mt
                              , Pt = M + Ln + st * (Mt + 1)
                              , tn = M + (Ln + 1) + st * (Mt + 1)
                              , De = M + (Ln + 1) + st * Mt;
                            v.push(Ye, Pt, De),
                            v.push(Pt, tn, De),
                            ht += 6
                        }
                    f.addGroup(I, ht, ge),
                    I += ht,
                    M += It
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Jl(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
            }
        }
        function Du(u) {
            const e = {};
            for (const i in u) {
                e[i] = {};
                for (const o in u[i]) {
                    const a = u[i][o];
                    a && (a.isColor || a.isMatrix3 || a.isMatrix4 || a.isVector2 || a.isVector3 || a.isVector4 || a.isTexture || a.isQuaternion) ? e[i][o] = a.clone() : Array.isArray(a) ? e[i][o] = a.slice() : e[i][o] = a
                }
            }
            return e
        }
        function no(u) {
            const e = {};
            for (let i = 0; i < u.length; i++) {
                const o = Du(u[i]);
                for (const a in o)
                    e[a] = o[a]
            }
            return e
        }
        function n2(u) {
            const e = [];
            for (let i = 0; i < u.length; i++)
                e.push(u[i].clone());
            return e
        }
        function kx(u) {
            return u.getRenderTarget() === null && u.outputEncoding === cn ? T : L
        }
        const Ux = {
            clone: Du,
            merge: no
        }
          , i2 = `
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`
          , r2 = `
void main() {
    gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;
        class ja extends Vs {
            constructor(e) {
                super(),
                this.isShaderMaterial = !0,
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.uniformsGroups = [],
                this.vertexShader = i2,
                this.fragmentShader = r2,
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                e !== void 0 && this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.fragmentShader = e.fragmentShader,
                this.vertexShader = e.vertexShader,
                this.uniforms = Du(e.uniforms),
                this.uniformsGroups = n2(e.uniformsGroups),
                this.defines = Object.assign({}, e.defines),
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.fog = e.fog,
                this.lights = e.lights,
                this.clipping = e.clipping,
                this.extensions = Object.assign({}, e.extensions),
                this.glslVersion = e.glslVersion,
                this
            }
            toJSON(e) {
                const i = super.toJSON(e);
                i.glslVersion = this.glslVersion,
                i.uniforms = {};
                for (const a in this.uniforms) {
                    const d = this.uniforms[a].value;
                    d && d.isTexture ? i.uniforms[a] = {
                        type: "t",
                        value: d.toJSON(e).uuid
                    } : d && d.isColor ? i.uniforms[a] = {
                        type: "c",
                        value: d.getHex()
                    } : d && d.isVector2 ? i.uniforms[a] = {
                        type: "v2",
                        value: d.toArray()
                    } : d && d.isVector3 ? i.uniforms[a] = {
                        type: "v3",
                        value: d.toArray()
                    } : d && d.isVector4 ? i.uniforms[a] = {
                        type: "v4",
                        value: d.toArray()
                    } : d && d.isMatrix3 ? i.uniforms[a] = {
                        type: "m3",
                        value: d.toArray()
                    } : d && d.isMatrix4 ? i.uniforms[a] = {
                        type: "m4",
                        value: d.toArray()
                    } : i.uniforms[a] = {
                        value: d
                    }
                }
                Object.keys(this.defines).length > 0 && (i.defines = this.defines),
                i.vertexShader = this.vertexShader,
                i.fragmentShader = this.fragmentShader;
                const o = {};
                for (const a in this.extensions)
                    this.extensions[a] === !0 && (o[a] = !0);
                return Object.keys(o).length > 0 && (i.extensions = o),
                i
            }
        }
        class ip extends Qi {
            constructor() {
                super(),
                this.isCamera = !0,
                this.type = "Camera",
                this.matrixWorldInverse = new pi,
                this.projectionMatrix = new pi,
                this.projectionMatrixInverse = new pi
            }
            copy(e, i) {
                return super.copy(e, i),
                this.matrixWorldInverse.copy(e.matrixWorldInverse),
                this.projectionMatrix.copy(e.projectionMatrix),
                this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                this
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const i = this.matrixWorld.elements;
                return e.set(-i[8], -i[9], -i[10]).normalize()
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(e, i) {
                super.updateWorldMatrix(e, i),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class Ms extends ip {
            constructor(e=50, i=1, o=.1, a=2e3) {
                super(),
                this.isPerspectiveCamera = !0,
                this.type = "PerspectiveCamera",
                this.fov = e,
                this.zoom = 1,
                this.near = o,
                this.far = a,
                this.focus = 10,
                this.aspect = i,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(e, i) {
                return super.copy(e, i),
                this.fov = e.fov,
                this.zoom = e.zoom,
                this.near = e.near,
                this.far = e.far,
                this.focus = e.focus,
                this.aspect = e.aspect,
                this.view = e.view === null ? null : Object.assign({}, e.view),
                this.filmGauge = e.filmGauge,
                this.filmOffset = e.filmOffset,
                this
            }
            setFocalLength(e) {
                const i = .5 * this.getFilmHeight() / e;
                this.fov = Mr * 2 * Math.atan(i),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const e = Math.tan(wi * .5 * this.fov);
                return .5 * this.getFilmHeight() / e
            }
            getEffectiveFOV() {
                return Mr * 2 * Math.atan(Math.tan(wi * .5 * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(e, i, o, a, c, d) {
                this.aspect = e / i,
                this.view === null && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = e,
                this.view.fullHeight = i,
                this.view.offsetX = o,
                this.view.offsetY = a,
                this.view.width = c,
                this.view.height = d,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                this.view !== null && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = this.near;
                let i = e * Math.tan(wi * .5 * this.fov) / this.zoom
                  , o = 2 * i
                  , a = this.aspect * o
                  , c = -.5 * a;
                const d = this.view;
                if (this.view !== null && this.view.enabled) {
                    const v = d.fullWidth
                      , x = d.fullHeight;
                    c += d.offsetX * a / v,
                    i -= d.offsetY * o / x,
                    a *= d.width / v,
                    o *= d.height / x
                }
                const f = this.filmOffset;
                f !== 0 && (c += e * f / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(c, c + a, i, i - o, e, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const i = super.toJSON(e);
                return i.object.fov = this.fov,
                i.object.zoom = this.zoom,
                i.object.near = this.near,
                i.object.far = this.far,
                i.object.focus = this.focus,
                i.object.aspect = this.aspect,
                this.view !== null && (i.object.view = Object.assign({}, this.view)),
                i.object.filmGauge = this.filmGauge,
                i.object.filmOffset = this.filmOffset,
                i
            }
        }
        const Lu = -90
          , Iu = 1;
        class Nx extends Qi {
            constructor(e, i, o) {
                super(),
                this.type = "CubeCamera",
                this.renderTarget = o;
                const a = new Ms(Lu,Iu,e,i);
                a.layers = this.layers,
                a.up.set(0, 1, 0),
                a.lookAt(1, 0, 0),
                this.add(a);
                const c = new Ms(Lu,Iu,e,i);
                c.layers = this.layers,
                c.up.set(0, 1, 0),
                c.lookAt(-1, 0, 0),
                this.add(c);
                const d = new Ms(Lu,Iu,e,i);
                d.layers = this.layers,
                d.up.set(0, 0, -1),
                d.lookAt(0, 1, 0),
                this.add(d);
                const f = new Ms(Lu,Iu,e,i);
                f.layers = this.layers,
                f.up.set(0, 0, 1),
                f.lookAt(0, -1, 0),
                this.add(f);
                const v = new Ms(Lu,Iu,e,i);
                v.layers = this.layers,
                v.up.set(0, 1, 0),
                v.lookAt(0, 0, 1),
                this.add(v);
                const x = new Ms(Lu,Iu,e,i);
                x.layers = this.layers,
                x.up.set(0, 1, 0),
                x.lookAt(0, 0, -1),
                this.add(x)
            }
            update(e, i) {
                this.parent === null && this.updateMatrixWorld();
                const o = this.renderTarget
                  , [a,c,d,f,v,x] = this.children
                  , w = e.getRenderTarget()
                  , P = e.toneMapping
                  , M = e.xr.enabled;
                e.toneMapping = Gt,
                e.xr.enabled = !1;
                const I = o.texture.generateMipmaps;
                o.texture.generateMipmaps = !1,
                e.setRenderTarget(o, 0),
                e.render(i, a),
                e.setRenderTarget(o, 1),
                e.render(i, c),
                e.setRenderTarget(o, 2),
                e.render(i, d),
                e.setRenderTarget(o, 3),
                e.render(i, f),
                e.setRenderTarget(o, 4),
                e.render(i, v),
                o.texture.generateMipmaps = I,
                e.setRenderTarget(o, 5),
                e.render(i, x),
                e.setRenderTarget(w),
                e.toneMapping = P,
                e.xr.enabled = M,
                o.texture.needsPMREMUpdate = !0
            }
        }
        class Zh extends $t {
            constructor(e, i, o, a, c, d, f, v, x, w) {
                e = e !== void 0 ? e : [],
                i = i !== void 0 ? i : vr,
                super(e, i, o, a, c, d, f, v, x, w),
                this.isCubeTexture = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(e) {
                this.image = e
            }
        }
        class zx extends ki {
            constructor(e=1, i={}) {
                super(e, e, i),
                this.isWebGLCubeRenderTarget = !0;
                const o = {
                    width: e,
                    height: e,
                    depth: 1
                }
                  , a = [o, o, o, o, o, o];
                this.texture = new Zh(a,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1,
                this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : Hi
            }
            fromEquirectangularTexture(e, i) {
                this.texture.type = i.type,
                this.texture.encoding = i.encoding,
                this.texture.generateMipmaps = i.generateMipmaps,
                this.texture.minFilter = i.minFilter,
                this.texture.magFilter = i.magFilter;
                const o = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: `

                varying vec3 vWorldDirection;

                vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

                    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

                }

                void main() {

                    vWorldDirection = transformDirection( position, modelMatrix );

                    #include <begin_vertex>
                    #include <project_vertex>

                }
            `,
                    fragmentShader: `

                uniform sampler2D tEquirect;

                varying vec3 vWorldDirection;

                #include <common>

                void main() {

                    vec3 direction = normalize( vWorldDirection );

                    vec2 sampleUV = equirectUv( direction );

                    gl_FragColor = texture2D( tEquirect, sampleUV );

                }
            `
                }
                  , a = new Jl(5,5,5)
                  , c = new ja({
                    name: "CubemapFromEquirect",
                    uniforms: Du(o.uniforms),
                    vertexShader: o.vertexShader,
                    fragmentShader: o.fragmentShader,
                    side: $,
                    blending: ie
                });
                c.uniforms.tEquirect.value = i;
                const d = new Es(a,c)
                  , f = i.minFilter;
                return i.minFilter === Fr && (i.minFilter = Hi),
                new Nx(1,10,this).update(e, d),
                i.minFilter = f,
                d.geometry.dispose(),
                d.material.dispose(),
                this
            }
            clear(e, i, o, a) {
                const c = e.getRenderTarget();
                for (let d = 0; d < 6; d++)
                    e.setRenderTarget(this, d),
                    e.clear(i, o, a);
                e.setRenderTarget(c)
            }
        }
        const e0 = new me
          , s2 = new me
          , o2 = new Cr;
        class $l {
            constructor(e=new me(1,0,0), i=0) {
                this.isPlane = !0,
                this.normal = e,
                this.constant = i
            }
            set(e, i) {
                return this.normal.copy(e),
                this.constant = i,
                this
            }
            setComponents(e, i, o, a) {
                return this.normal.set(e, i, o),
                this.constant = a,
                this
            }
            setFromNormalAndCoplanarPoint(e, i) {
                return this.normal.copy(e),
                this.constant = -i.dot(this.normal),
                this
            }
            setFromCoplanarPoints(e, i, o) {
                const a = e0.subVectors(o, i).cross(s2.subVectors(e, i)).normalize();
                return this.setFromNormalAndCoplanarPoint(a, e),
                this
            }
            copy(e) {
                return this.normal.copy(e.normal),
                this.constant = e.constant,
                this
            }
            normalize() {
                const e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e),
                this.constant *= e,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(e) {
                return this.normal.dot(e) + this.constant
            }
            distanceToSphere(e) {
                return this.distanceToPoint(e.center) - e.radius
            }
            projectPoint(e, i) {
                return i.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
            }
            intersectLine(e, i) {
                const o = e.delta(e0)
                  , a = this.normal.dot(o);
                if (a === 0)
                    return this.distanceToPoint(e.start) === 0 ? i.copy(e.start) : null;
                const c = -(e.start.dot(this.normal) + this.constant) / a;
                return c < 0 || c > 1 ? null : i.copy(e.start).addScaledVector(o, c)
            }
            intersectsLine(e) {
                const i = this.distanceToPoint(e.start)
                  , o = this.distanceToPoint(e.end);
                return i < 0 && o > 0 || o < 0 && i > 0
            }
            intersectsBox(e) {
                return e.intersectsPlane(this)
            }
            intersectsSphere(e) {
                return e.intersectsPlane(this)
            }
            coplanarPoint(e) {
                return e.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(e, i) {
                const o = i || o2.getNormalMatrix(e)
                  , a = this.coplanarPoint(e0).applyMatrix4(e)
                  , c = this.normal.applyMatrix3(o).normalize();
                return this.constant = -a.dot(c),
                this
            }
            translate(e) {
                return this.constant -= e.dot(this.normal),
                this
            }
            equals(e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const Ou = new Nc
          , rp = new me;
        class sp {
            constructor(e=new $l, i=new $l, o=new $l, a=new $l, c=new $l, d=new $l) {
                this.planes = [e, i, o, a, c, d]
            }
            set(e, i, o, a, c, d) {
                const f = this.planes;
                return f[0].copy(e),
                f[1].copy(i),
                f[2].copy(o),
                f[3].copy(a),
                f[4].copy(c),
                f[5].copy(d),
                this
            }
            copy(e) {
                const i = this.planes;
                for (let o = 0; o < 6; o++)
                    i[o].copy(e.planes[o]);
                return this
            }
            setFromProjectionMatrix(e) {
                const i = this.planes
                  , o = e.elements
                  , a = o[0]
                  , c = o[1]
                  , d = o[2]
                  , f = o[3]
                  , v = o[4]
                  , x = o[5]
                  , w = o[6]
                  , P = o[7]
                  , M = o[8]
                  , I = o[9]
                  , z = o[10]
                  , O = o[11]
                  , k = o[12]
                  , Q = o[13]
                  , Z = o[14]
                  , X = o[15];
                return i[0].setComponents(f - a, P - v, O - M, X - k).normalize(),
                i[1].setComponents(f + a, P + v, O + M, X + k).normalize(),
                i[2].setComponents(f + c, P + x, O + I, X + Q).normalize(),
                i[3].setComponents(f - c, P - x, O - I, X - Q).normalize(),
                i[4].setComponents(f - d, P - w, O - z, X - Z).normalize(),
                i[5].setComponents(f + d, P + w, O + z, X + Z).normalize(),
                this
            }
            intersectsObject(e) {
                const i = e.geometry;
                return i.boundingSphere === null && i.computeBoundingSphere(),
                Ou.copy(i.boundingSphere).applyMatrix4(e.matrixWorld),
                this.intersectsSphere(Ou)
            }
            intersectsSprite(e) {
                return Ou.center.set(0, 0, 0),
                Ou.radius = .7071067811865476,
                Ou.applyMatrix4(e.matrixWorld),
                this.intersectsSphere(Ou)
            }
            intersectsSphere(e) {
                const i = this.planes
                  , o = e.center
                  , a = -e.radius;
                for (let c = 0; c < 6; c++)
                    if (i[c].distanceToPoint(o) < a)
                        return !1;
                return !0
            }
            intersectsBox(e) {
                const i = this.planes;
                for (let o = 0; o < 6; o++) {
                    const a = i[o];
                    if (rp.x = a.normal.x > 0 ? e.max.x : e.min.x,
                    rp.y = a.normal.y > 0 ? e.max.y : e.min.y,
                    rp.z = a.normal.z > 0 ? e.max.z : e.min.z,
                    a.distanceToPoint(rp) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(e) {
                const i = this.planes;
                for (let o = 0; o < 6; o++)
                    if (i[o].distanceToPoint(e) < 0)
                        return !1;
                return !0
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        function Gx() {
            let u = null
              , e = !1
              , i = null
              , o = null;
            function a(c, d) {
                i(c, d),
                o = u.requestAnimationFrame(a)
            }
            return {
                start: function() {
                    e !== !0 && i !== null && (o = u.requestAnimationFrame(a),
                    e = !0)
                },
                stop: function() {
                    u.cancelAnimationFrame(o),
                    e = !1
                },
                setAnimationLoop: function(c) {
                    i = c
                },
                setContext: function(c) {
                    u = c
                }
            }
        }
        function a2(u, e) {
            const i = e.isWebGL2
              , o = new WeakMap;
            function a(x, w) {
                const P = x.array
                  , M = x.usage
                  , I = u.createBuffer();
                u.bindBuffer(w, I),
                u.bufferData(w, P, M),
                x.onUploadCallback();
                let z;
                if (P instanceof Float32Array)
                    z = u.FLOAT;
                else if (P instanceof Uint16Array)
                    if (x.isFloat16BufferAttribute)
                        if (i)
                            z = u.HALF_FLOAT;
                        else
                            throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                    else
                        z = u.UNSIGNED_SHORT;
                else if (P instanceof Int16Array)
                    z = u.SHORT;
                else if (P instanceof Uint32Array)
                    z = u.UNSIGNED_INT;
                else if (P instanceof Int32Array)
                    z = u.INT;
                else if (P instanceof Int8Array)
                    z = u.BYTE;
                else if (P instanceof Uint8Array)
                    z = u.UNSIGNED_BYTE;
                else if (P instanceof Uint8ClampedArray)
                    z = u.UNSIGNED_BYTE;
                else
                    throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + P);
                return {
                    buffer: I,
                    type: z,
                    bytesPerElement: P.BYTES_PER_ELEMENT,
                    version: x.version
                }
            }
            function c(x, w, P) {
                const M = w.array
                  , I = w.updateRange;
                u.bindBuffer(P, x),
                I.count === -1 ? u.bufferSubData(P, 0, M) : (i ? u.bufferSubData(P, I.offset * M.BYTES_PER_ELEMENT, M, I.offset, I.count) : u.bufferSubData(P, I.offset * M.BYTES_PER_ELEMENT, M.subarray(I.offset, I.offset + I.count)),
                I.count = -1),
                w.onUploadCallback()
            }
            function d(x) {
                return x.isInterleavedBufferAttribute && (x = x.data),
                o.get(x)
            }
            function f(x) {
                x.isInterleavedBufferAttribute && (x = x.data);
                const w = o.get(x);
                w && (u.deleteBuffer(w.buffer),
                o.delete(x))
            }
            function v(x, w) {
                if (x.isGLBufferAttribute) {
                    const M = o.get(x);
                    (!M || M.version < x.version) && o.set(x, {
                        buffer: x.buffer,
                        type: x.type,
                        bytesPerElement: x.elementSize,
                        version: x.version
                    });
                    return
                }
                x.isInterleavedBufferAttribute && (x = x.data);
                const P = o.get(x);
                P === void 0 ? o.set(x, a(x, w)) : P.version < x.version && (c(P.buffer, x, w),
                P.version = x.version)
            }
            return {
                get: d,
                remove: f,
                update: v
            }
        }
        class Bu extends Ai {
            constructor(e=1, i=1, o=1, a=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: e,
                    height: i,
                    widthSegments: o,
                    heightSegments: a
                };
                const c = e / 2
                  , d = i / 2
                  , f = Math.floor(o)
                  , v = Math.floor(a)
                  , x = f + 1
                  , w = v + 1
                  , P = e / f
                  , M = i / v
                  , I = []
                  , z = []
                  , O = []
                  , k = [];
                for (let Q = 0; Q < w; Q++) {
                    const Z = Q * M - d;
                    for (let X = 0; X < x; X++) {
                        const K = X * P - c;
                        z.push(K, -Z, 0),
                        O.push(0, 0, 1),
                        k.push(X / f),
                        k.push(1 - Q / v)
                    }
                }
                for (let Q = 0; Q < v; Q++)
                    for (let Z = 0; Z < f; Z++) {
                        const X = Z + x * Q
                          , K = Z + x * (Q + 1)
                          , de = Z + 1 + x * (Q + 1)
                          , be = Z + 1 + x * Q;
                        I.push(X, K, be),
                        I.push(K, de, be)
                    }
                this.setIndex(I),
                this.setAttribute("position", new Rn(z,3)),
                this.setAttribute("normal", new Rn(O,3)),
                this.setAttribute("uv", new Rn(k,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Bu(e.width,e.height,e.widthSegments,e.heightSegments)
            }
        }
        const yi = {
            alphamap_fragment: `
#ifdef USE_ALPHAMAP

    diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`,
            alphamap_pars_fragment: `
#ifdef USE_ALPHAMAP

    uniform sampler2D alphaMap;

#endif
`,
            alphatest_fragment: `
#ifdef USE_ALPHATEST

    if ( diffuseColor.a < alphaTest ) discard;

#endif
`,
            alphatest_pars_fragment: `
#ifdef USE_ALPHATEST
    uniform float alphaTest;
#endif
`,
            aomap_fragment: `
#ifdef USE_AOMAP

    // reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
    float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

    reflectedLight.indirectDiffuse *= ambientOcclusion;

    #if defined( USE_ENVMAP ) && defined( STANDARD )

        float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

        reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );

    #endif

#endif
`,
            aomap_pars_fragment: `
#ifdef USE_AOMAP

    uniform sampler2D aoMap;
    uniform float aoMapIntensity;

#endif
`,
            begin_vertex: `
vec3 transformed = vec3( position );
`,
            beginnormal_vertex: `
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

    vec3 objectTangent = vec3( tangent.xyz );

#endif
`,
            bsdfs: `

vec3 BRDF_Lambert( const in vec3 diffuseColor ) {

    return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {

    // Original approximation by Christophe Schlick '94
    // float fresnel = pow( 1.0 - dotVH, 5.0 );

    // Optimized variant (presented by Epic at SIGGRAPH '13)
    // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
    float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

    return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated

float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {

    // Original approximation by Christophe Schlick '94
    // float fresnel = pow( 1.0 - dotVH, 5.0 );

    // Optimized variant (presented by Epic at SIGGRAPH '13)
    // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
    float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

    return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated

vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );

    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

    float a2 = pow2( alpha );

    float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
    float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

    return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney’s reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

    float a2 = pow2( alpha );

    float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

    return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {

    float alpha = pow2( roughness ); // UE4's roughness

    vec3 halfDir = normalize( lightDir + viewDir );

    float dotNL = saturate( dot( normal, lightDir ) );
    float dotNV = saturate( dot( normal, viewDir ) );
    float dotNH = saturate( dot( normal, halfDir ) );
    float dotVH = saturate( dot( viewDir, halfDir ) );

    vec3 F = F_Schlick( f0, f90, dotVH );

    float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );

    float D = D_GGX( alpha, dotNH );

    return F * ( V * D );

}

#ifdef USE_IRIDESCENCE

    vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {

        float alpha = pow2( roughness ); // UE4's roughness

        vec3 halfDir = normalize( lightDir + viewDir );

        float dotNL = saturate( dot( normal, lightDir ) );
        float dotNV = saturate( dot( normal, viewDir ) );
        float dotNH = saturate( dot( normal, halfDir ) );
        float dotVH = saturate( dot( viewDir, halfDir ) );

        vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );

        float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );

        float D = D_GGX( alpha, dotNH );

        return F * ( V * D );

    }

#endif

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

    const float LUT_SIZE = 64.0;
    const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
    const float LUT_BIAS = 0.5 / LUT_SIZE;

    float dotNV = saturate( dot( N, V ) );

    // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
    vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

    uv = uv * LUT_SCALE + LUT_BIAS;

    return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

    // Real-Time Area Lighting: a Journey from Research to Production (p.102)
    // An approximation of the form factor of a horizon-clipped rectangle.

    float l = length( f );

    return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

    float x = dot( v1, v2 );

    float y = abs( x );

    // rational polynomial approximation to theta / sin( theta ) / 2PI
    float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
    float b = 3.4175940 + ( 4.1616724 + y ) * y;
    float v = a / b;

    float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

    return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

    // bail if point is on back side of plane of light
    // assumes ccw winding order of light vertices
    vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
    vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
    vec3 lightNormal = cross( v1, v2 );

    if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

    // construct orthonormal basis around N
    vec3 T1, T2;
    T1 = normalize( V - N * dot( V, N ) );
    T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

    // compute transform
    mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

    // transform rect
    vec3 coords[ 4 ];
    coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
    coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
    coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
    coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

    // project rect onto sphere
    coords[ 0 ] = normalize( coords[ 0 ] );
    coords[ 1 ] = normalize( coords[ 1 ] );
    coords[ 2 ] = normalize( coords[ 2 ] );
    coords[ 3 ] = normalize( coords[ 3 ] );

    // calculate vector form factor
    vec3 vectorFormFactor = vec3( 0.0 );
    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

    // adjust for horizon clipping
    float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
    // alternate method of adjusting for horizon clipping (see referece)
    // refactoring required
    float len = length( vectorFormFactor );
    float z = vectorFormFactor.z / len;

    const float LUT_SIZE = 64.0;
    const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
    const float LUT_BIAS = 0.5 / LUT_SIZE;

    // tabulated horizon-clipped sphere, apparently...
    vec2 uv = vec2( z * 0.5 + 0.5, len );
    uv = uv * LUT_SCALE + LUT_BIAS;

    float scale = texture2D( ltc_2, uv ).w;

    float result = len * scale;
*/

    return vec3( result );

}

// End Rect Area Light


float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
    return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {

    vec3 halfDir = normalize( lightDir + viewDir );

    float dotNH = saturate( dot( normal, halfDir ) );
    float dotVH = saturate( dot( viewDir, halfDir ) );

    vec3 F = F_Schlick( specularColor, 1.0, dotVH );

    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

    float D = D_BlinnPhong( shininess, dotNH );

    return F * ( G * D );

} // validated

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float D_Charlie( float roughness, float dotNH ) {

    float alpha = pow2( roughness );

    // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
    float invAlpha = 1.0 / alpha;
    float cos2h = dotNH * dotNH;
    float sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

    return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );

}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float V_Neubelt( float dotNV, float dotNL ) {

    // Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
    return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );

}

vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {

    vec3 halfDir = normalize( lightDir + viewDir );

    float dotNL = saturate( dot( normal, lightDir ) );
    float dotNV = saturate( dot( normal, viewDir ) );
    float dotNH = saturate( dot( normal, halfDir ) );

    float D = D_Charlie( sheenRoughness, dotNH );
    float V = V_Neubelt( dotNV, dotNL );

    return sheenColor * ( D * V );

}

#endif
`,
            iridescence_fragment: `

#ifdef USE_IRIDESCENCE

    // XYZ to linear-sRGB color space
    const mat3 XYZ_TO_REC709 = mat3(
         3.2404542, -0.9692660,  0.0556434,
        -1.5371385,  1.8760108, -0.2040259,
        -0.4985314,  0.0415560,  1.0572252
    );

    // Assume air interface for top
    // Note: We don't handle the case fresnel0 == 1
    vec3 Fresnel0ToIor( vec3 fresnel0 ) {

        vec3 sqrtF0 = sqrt( fresnel0 );
        return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );

    }

    // Conversion FO/IOR
    vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {

        return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );

    }

    // ior is a value between 1.0 and 3.0. 1.0 is air interface
    float IorToFresnel0( float transmittedIor, float incidentIor ) {

        return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));

    }

    // Fresnel equations for dielectric/dielectric interfaces.
    // Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
    // Evaluation XYZ sensitivity curves in Fourier space
    vec3 evalSensitivity( float OPD, vec3 shift ) {

        float phase = 2.0 * PI * OPD * 1.0e-9;
        vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
        vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
        vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

        vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
        xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
        xyz /= 1.0685e-7;

        vec3 rgb = XYZ_TO_REC709 * xyz;
        return rgb;

    }

    vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {

        vec3 I;

        // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
        float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
        // Evaluate the cosTheta on the base layer (Snell law)
        float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );

        // Handle TIR:
        float cosTheta2Sq = 1.0 - sinTheta2Sq;
        if ( cosTheta2Sq < 0.0 ) {

             return vec3( 1.0 );

        }

        float cosTheta2 = sqrt( cosTheta2Sq );

        // First interface
        float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
        float R12 = F_Schlick( R0, 1.0, cosTheta1 );
        float R21 = R12;
        float T121 = 1.0 - R12;
        float phi12 = 0.0;
        if ( iridescenceIOR < outsideIOR ) phi12 = PI;
        float phi21 = PI - phi12;

        // Second interface
        vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0
        vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
        vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
        vec3 phi23 = vec3( 0.0 );
        if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
        if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
        if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;

        // Phase shift
        float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
        vec3 phi = vec3( phi21 ) + phi23;

        // Compound terms
        vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
        vec3 r123 = sqrt( R123 );
        vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );

        // Reflectance term for m = 0 (DC term amplitude)
        vec3 C0 = R12 + Rs;
        I = C0;

        // Reflectance term for m > 0 (pairs of diracs)
        vec3 Cm = Rs - T121;
        for ( int m = 1; m <= 2; ++ m ) {

            Cm *= r123;
            vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
            I += Cm * Sm;

        }

        // Since out of gamut colors might be produced, negative color values are clamped to 0.
        return max( I, vec3( 0.0 ) );

    }

#endif

`,
            bumpmap_pars_fragment: `
#ifdef USE_BUMPMAP

    uniform sampler2D bumpMap;
    uniform float bumpScale;

    // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
    // https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

    // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

    vec2 dHdxy_fwd() {

        vec2 dSTdx = dFdx( vUv );
        vec2 dSTdy = dFdy( vUv );

        float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
        float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
        float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

        return vec2( dBx, dBy );

    }

    vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

        vec3 vSigmaX = dFdx( surf_pos.xyz );
        vec3 vSigmaY = dFdy( surf_pos.xyz );
        vec3 vN = surf_norm; // normalized

        vec3 R1 = cross( vSigmaY, vN );
        vec3 R2 = cross( vN, vSigmaX );

        float fDet = dot( vSigmaX, R1 ) * faceDirection;

        vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
        return normalize( abs( fDet ) * surf_norm - vGrad );

    }

#endif
`,
            clipping_planes_fragment: `
#if NUM_CLIPPING_PLANES > 0

    vec4 plane;

    #pragma unroll_loop_start
    for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

        plane = clippingPlanes[ i ];
        if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

    }
    #pragma unroll_loop_end

    #if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

        bool clipped = true;

        #pragma unroll_loop_start
        for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

            plane = clippingPlanes[ i ];
            clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

        }
        #pragma unroll_loop_end

        if ( clipped ) discard;

    #endif

#endif
`,
            clipping_planes_pars_fragment: `
#if NUM_CLIPPING_PLANES > 0

    varying vec3 vClipPosition;

    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`,
            clipping_planes_pars_vertex: `
#if NUM_CLIPPING_PLANES > 0

    varying vec3 vClipPosition;

#endif
`,
            clipping_planes_vertex: `
#if NUM_CLIPPING_PLANES > 0

    vClipPosition = - mvPosition.xyz;

#endif
`,
            color_fragment: `
#if defined( USE_COLOR_ALPHA )

    diffuseColor *= vColor;

#elif defined( USE_COLOR )

    diffuseColor.rgb *= vColor;

#endif
`,
            color_pars_fragment: `
#if defined( USE_COLOR_ALPHA )

    varying vec4 vColor;

#elif defined( USE_COLOR )

    varying vec3 vColor;

#endif
`,
            color_pars_vertex: `
#if defined( USE_COLOR_ALPHA )

    varying vec4 vColor;

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

    varying vec3 vColor;

#endif
`,
            color_vertex: `
#if defined( USE_COLOR_ALPHA )

    vColor = vec4( 1.0 );

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

    vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

    vColor *= color;

#endif

#ifdef USE_INSTANCING_COLOR

    vColor.xyz *= instanceColor.xyz;

#endif
`,
            common: `
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }

// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {

    const highp float a = 12.9898, b = 78.233, c = 43758.5453;
    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );

    return fract( sin( sn ) * c );

}

#ifdef HIGH_PRECISION
    float precisionSafeLength( vec3 v ) { return length( v ); }
#else
    float precisionSafeLength( vec3 v ) {
        float maxComponent = max3( abs( v ) );
        return length( v / maxComponent ) * maxComponent;
    }
#endif

struct IncidentLight {
    vec3 color;
    vec3 direction;
    bool visible;
};

struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};

struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
#ifdef USE_CLEARCOAT
    vec3 clearcoatNormal;
#endif
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

    // dir can be either a direction vector or a normal vector
    // upper-left 3x3 of matrix is assumed to be orthogonal

    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

mat3 transposeMat3( const in mat3 m ) {

    mat3 tmp;

    tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
    tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
    tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

    return tmp;

}

float luminance( const in vec3 rgb ) {

    // assumes rgb is in linear color space with sRGB primaries and D65 white point

    const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );

    return dot( weights, rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

    return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

    // dir is assumed to be unit length

    float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

    float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

    return vec2( u, v );

}

// Mipped Bicubic Texture Filtering by N8
// https://www.shadertoy.com/view/Dl2SDW

float w0( float a ) {

    return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );

}

float w1( float a ) {

    return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );

}

float w2( float a ){

    return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );

}

float w3( float a ) {

    return ( 1.0 / 6.0 ) * ( a * a * a );

}

// g0 and g1 are the two amplitude functions
float g0( float a ) {

    return w0( a ) + w1( a );

}

float g1( float a ) {

    return w2( a ) + w3( a );

}

// h0 and h1 are the two offset functions
float h0( float a ) {

    return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );

}

float h1( float a ) {

    return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );

}

vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {

    uv = uv * texelSize.zw + 0.5;

    vec2 iuv = floor( uv );
    vec2 fuv = fract( uv );

    float g0x = g0( fuv.x );
    float g1x = g1( fuv.x );
    float h0x = h0( fuv.x );
    float h1x = h1( fuv.x );
    float h0y = h0( fuv.y );
    float h1y = h1( fuv.y );

    vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
    vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
    vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
    vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;

    vec2 lodFudge = pow( 1.95, lod ) / fullSize;
#if __VERSION__ > 130
    return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
           g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
#else
    return texture2D(tex, uv); //TODO: remove
#endif
}

vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {

#if __VERSION__ > 130
    vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
    vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
    vec2 fLodSizeInv = 1.0 / fLodSize;
    vec2 cLodSizeInv = 1.0 / cLodSize;
    vec2 fullSize = vec2( textureSize( sampler, 0 ) );
    vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
    vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
    return mix( fSample, cSample, fract( lod ) );
#else
    return texture2D(sampler, uv); //TODO: remove
#endif

}
`,
            cube_uv_reflection_fragment: `
#ifdef ENVMAP_TYPE_CUBE_UV

    #define cubeUV_minMipLevel 4.0
    #define cubeUV_minTileSize 16.0

    // These shader functions convert between the UV coordinates of a single face of
    // a cubemap, the 0-5 integer index of a cube face, and the direction vector for
    // sampling a textureCube (not generally normalized ).

    float getFace( vec3 direction ) {

        vec3 absDirection = abs( direction );

        float face = - 1.0;

        if ( absDirection.x > absDirection.z ) {

            if ( absDirection.x > absDirection.y )

                face = direction.x > 0.0 ? 0.0 : 3.0;

            else

                face = direction.y > 0.0 ? 1.0 : 4.0;

        } else {

            if ( absDirection.z > absDirection.y )

                face = direction.z > 0.0 ? 2.0 : 5.0;

            else

                face = direction.y > 0.0 ? 1.0 : 4.0;

        }

        return face;

    }

    // RH coordinate system; PMREM face-indexing convention
    vec2 getUV( vec3 direction, float face ) {

        vec2 uv;

        if ( face == 0.0 ) {

            uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

        } else if ( face == 1.0 ) {

            uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

        } else if ( face == 2.0 ) {

            uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

        } else if ( face == 3.0 ) {

            uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

        } else if ( face == 4.0 ) {

            uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

        } else {

            uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

        }

        return 0.5 * ( uv + 1.0 );

    }

    vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

        float face = getFace( direction );

        float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

        mipInt = max( mipInt, cubeUV_minMipLevel );

        float faceSize = exp2( mipInt );

        highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071

        if ( face > 2.0 ) {

            uv.y += faceSize;

            face -= 3.0;

        }

        uv.x += face * faceSize;

        uv.x += filterInt * 3.0 * cubeUV_minTileSize;

        uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );

        uv.x *= CUBEUV_TEXEL_WIDTH;
        uv.y *= CUBEUV_TEXEL_HEIGHT;

        #ifdef texture2DGradEXT

            return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering

        #else

            return texture2D( envMap, uv ).rgb;

        #endif

    }

    // These defines must match with PMREMGenerator

    #define cubeUV_r0 1.0
    #define cubeUV_v0 0.339
    #define cubeUV_m0 - 2.0
    #define cubeUV_r1 0.8
    #define cubeUV_v1 0.276
    #define cubeUV_m1 - 1.0
    #define cubeUV_r4 0.4
    #define cubeUV_v4 0.046
    #define cubeUV_m4 2.0
    #define cubeUV_r5 0.305
    #define cubeUV_v5 0.016
    #define cubeUV_m5 3.0
    #define cubeUV_r6 0.21
    #define cubeUV_v6 0.0038
    #define cubeUV_m6 4.0

    float roughnessToMip( float roughness ) {

        float mip = 0.0;

        if ( roughness >= cubeUV_r1 ) {

            mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;

        } else if ( roughness >= cubeUV_r4 ) {

            mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;

        } else if ( roughness >= cubeUV_r5 ) {

            mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;

        } else if ( roughness >= cubeUV_r6 ) {

            mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;

        } else {

            mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
        }

        return mip;

    }

    vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

        float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );

        float mipF = fract( mip );

        float mipInt = floor( mip );

        vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

        if ( mipF == 0.0 ) {

            return vec4( color0, 1.0 );

        } else {

            vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

            return vec4( mix( color0, color1, mipF ), 1.0 );

        }

    }

#endif
`,
            defaultnormal_vertex: `
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING

    // this is in lieu of a per-instance normal-matrix
    // shear transforms in the instance matrix are not supported

    mat3 m = mat3( instanceMatrix );

    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );

    transformedNormal = m * transformedNormal;

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

    transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

    vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;

    #ifdef FLIP_SIDED

        transformedTangent = - transformedTangent;

    #endif

#endif
`,
            displacementmap_pars_vertex: `
#ifdef USE_DISPLACEMENTMAP

    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;

#endif
`,
            displacementmap_vertex: `
#ifdef USE_DISPLACEMENTMAP

    transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );

#endif
`,
            emissivemap_fragment: `
#ifdef USE_EMISSIVEMAP

    vec4 emissiveColor = texture2D( emissiveMap, vUv );

    totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`,
            emissivemap_pars_fragment: `
#ifdef USE_EMISSIVEMAP

    uniform sampler2D emissiveMap;

#endif
`,
            encodings_fragment: `
gl_FragColor = linearToOutputTexel( gl_FragColor );
`,
            encodings_pars_fragment: `

vec4 LinearToLinear( in vec4 value ) {
    return value;
}

vec4 LinearTosRGB( in vec4 value ) {
    return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

`,
            envmap_fragment: `
#ifdef USE_ENVMAP

    #ifdef ENV_WORLDPOS

        vec3 cameraToFrag;

        if ( isOrthographic ) {

            cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

        } else {

            cameraToFrag = normalize( vWorldPosition - cameraPosition );

        }

        // Transforming Normal Vectors with the Inverse Transformation
        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

        #ifdef ENVMAP_MODE_REFLECTION

            vec3 reflectVec = reflect( cameraToFrag, worldNormal );

        #else

            vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

        #endif

    #else

        vec3 reflectVec = vReflect;

    #endif

    #ifdef ENVMAP_TYPE_CUBE

        vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

    #else

        vec4 envColor = vec4( 0.0 );

    #endif

    #ifdef ENVMAP_BLENDING_MULTIPLY

        outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

    #elif defined( ENVMAP_BLENDING_MIX )

        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

    #elif defined( ENVMAP_BLENDING_ADD )

        outgoingLight += envColor.xyz * specularStrength * reflectivity;

    #endif

#endif
`,
            envmap_common_pars_fragment: `
#ifdef USE_ENVMAP

    uniform float envMapIntensity;
    uniform float flipEnvMap;

    #ifdef ENVMAP_TYPE_CUBE
        uniform samplerCube envMap;
    #else
        uniform sampler2D envMap;
    #endif

#endif
`,
            envmap_pars_fragment: `
#ifdef USE_ENVMAP

    uniform float reflectivity;

    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )

        #define ENV_WORLDPOS

    #endif

    #ifdef ENV_WORLDPOS

        varying vec3 vWorldPosition;
        uniform float refractionRatio;
    #else
        varying vec3 vReflect;
    #endif

#endif
`,
            envmap_pars_vertex: `
#ifdef USE_ENVMAP

    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )

        #define ENV_WORLDPOS

    #endif

    #ifdef ENV_WORLDPOS

        varying vec3 vWorldPosition;

    #else

        varying vec3 vReflect;
        uniform float refractionRatio;

    #endif

#endif
`,
            envmap_physical_pars_fragment: `
#if defined( USE_ENVMAP )

#if defined( USE_BOX_PROJECTION )

    uniform vec4 probePos;
    uniform vec3 probeBoxMin;
    uniform vec3 probeBoxMax;

    vec3 boxProjection(vec3 nrdir, vec3 worldPos, vec3 probePos, vec3 boxMin, vec3 boxMax) {

        vec3 tbot = boxMin - worldPos;
        vec3 ttop = boxMax - worldPos;
        vec3 tmax = mix(tbot, ttop, step(vec3(0), nrdir));
        tmax /= nrdir;
        float t = min(min(tmax.x, tmax.y), tmax.z);
        return worldPos + nrdir * t - probePos;

    }

#endif

    vec3 getIBLIrradiance( const in vec3 normal ) {

        #if defined( ENVMAP_TYPE_CUBE_UV )

            vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

            vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

            return PI * envMapColor.rgb * envMapIntensity;

        #else

            return vec3( 0.0 );

        #endif

    }

    vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {

        #if defined( ENVMAP_TYPE_CUBE_UV )

            vec3 reflectVec = reflect( - viewDir, normal );

            // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
            reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

            reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

        #if defined( USE_BOX_PROJECTION )
            if (probePos.w > 0.001) {
                reflectVec = boxProjection(reflectVec, vWorldPosition, probePos.xyz, probeBoxMin.xyz, probeBoxMax.xyz);
            }
        #endif

            vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

            return envMapColor.rgb * envMapIntensity;

        #else

            return vec3( 0.0 );

        #endif

    }

#endif
`,
            envmap_vertex: `
#ifdef USE_ENVMAP

    #ifdef ENV_WORLDPOS

        vWorldPosition = worldPosition.xyz;

    #else

        vec3 cameraToVertex;

        if ( isOrthographic ) {

            cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

        } else {

            cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

        }

        vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

        #ifdef ENVMAP_MODE_REFLECTION

            vReflect = reflect( cameraToVertex, worldNormal );

        #else

            vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

        #endif

    #endif

#endif
`,
            fog_vertex: `
#ifdef USE_FOG

    vFogDepth = - mvPosition.z;

#endif
`,
            fog_pars_vertex: `
#ifdef USE_FOG

    varying float vFogDepth;

#endif
`,
            fog_fragment: `
#ifdef USE_FOG

    #ifdef FOG_EXP2

        float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );

    #else

        float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );

    #endif

    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`,
            fog_pars_fragment: `
#ifdef USE_FOG

    uniform vec3 fogColor;
    varying float vFogDepth;

    #ifdef FOG_EXP2

        uniform float fogDensity;

    #else

        uniform float fogNear;
        uniform float fogFar;

    #endif

#endif
`,
            gradientmap_pars_fragment: `

#ifdef USE_GRADIENTMAP

    uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

    // dotNL will be from -1.0 to 1.0
    float dotNL = dot( normal, lightDirection );
    vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

    #ifdef USE_GRADIENTMAP

        return vec3( texture2D( gradientMap, coord ).r );

    #else

        vec2 fw = fwidth( coord ) * 0.5;
        return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );

    #endif

}
`,
            lightmap_fragment: `
#ifdef USE_LIGHTMAP

    vec4 lightMapTexel = texture2D( lightMap, vUv2 );
    vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;

    reflectedLight.indirectDiffuse += lightMapIrradiance;

#endif
`,
            lightmap_pars_fragment: `
#ifdef USE_LIGHTMAP

    uniform sampler2D lightMap;
    uniform float lightMapIntensity;

#endif
`,
            lights_lambert_fragment: `
LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;
`,
            lights_lambert_pars_fragment: `
varying vec3 vViewPosition;

struct LambertMaterial {

    vec3 diffuseColor;
    float specularStrength;

};

void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {

    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
    vec3 irradiance = dotNL * directLight.color;

    reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {

    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct               RE_Direct_Lambert
#define RE_IndirectDiffuse      RE_IndirectDiffuse_Lambert
`,
            lights_pars_begin: `
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

    // normal is assumed to have unit length

    float x = normal.x, y = normal.y, z = normal.z;

    // band 0
    vec3 result = shCoefficients[ 0 ] * 0.886227;

    // band 1
    result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
    result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
    result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

    // band 2
    result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
    result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
    result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
    result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
    result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

    return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {

    vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

    vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

    return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

    vec3 irradiance = ambientLightColor;

    return irradiance;

}

float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

    #if defined ( LEGACY_LIGHTS )

        if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

            return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );

        }

        return 1.0;

    #else

        // based upon Frostbite 3 Moving to Physically-based Rendering
        // page 32, equation 26: E[window1]
        // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
        float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

        if ( cutoffDistance > 0.0 ) {

            distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

        }

        return distanceFalloff;

    #endif

}

float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {

    return smoothstep( coneCosine, penumbraCosine, angleCosine );

}

#if NUM_DIR_LIGHTS > 0

    struct DirectionalLight {
        vec3 direction;
        vec3 color;
    };

    uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

    void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {

        light.color = directionalLight.color;
        light.direction = directionalLight.direction;
        light.visible = true;

    }

#endif


#if NUM_POINT_LIGHTS > 0

    struct PointLight {
        vec3 position;
        vec3 color;
        float distance;
        float decay;
    };

    uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

    // light is an out parameter as having it as a return value caused compiler errors on some devices
    void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {

        vec3 lVector = pointLight.position - geometry.position;

        light.direction = normalize( lVector );

        float lightDistance = length( lVector );

        light.color = pointLight.color;
        light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
        light.visible = ( light.color != vec3( 0.0 ) );

    }

#endif


#if NUM_SPOT_LIGHTS > 0

    struct SpotLight {
        vec3 position;
        vec3 direction;
        vec3 color;
        float distance;
        float decay;
        float coneCos;
        float penumbraCos;
    };

    uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

    // light is an out parameter as having it as a return value caused compiler errors on some devices
    void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {

        vec3 lVector = spotLight.position - geometry.position;

        light.direction = normalize( lVector );

        float angleCos = dot( light.direction, spotLight.direction );

        float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );

        if ( spotAttenuation > 0.0 ) {

            float lightDistance = length( lVector );

            light.color = spotLight.color * spotAttenuation;
            light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
            light.visible = ( light.color != vec3( 0.0 ) );

        } else {

            light.color = vec3( 0.0 );
            light.visible = false;

        }

    }

#endif


#if NUM_RECT_AREA_LIGHTS > 0

    struct RectAreaLight {
        vec3 color;
        vec3 position;
        vec3 halfWidth;
        vec3 halfHeight;
    };

    // Pre-computed values of LinearTransformedCosine approximation of BRDF
    // BRDF approximation Texture is 64x64
    uniform sampler2D ltc_1; // RGBA Float
    uniform sampler2D ltc_2; // RGBA Float

    uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

    struct HemisphereLight {
        vec3 direction;
        vec3 skyColor;
        vec3 groundColor;
    };

    uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

    vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {

        float dotNL = dot( normal, hemiLight.direction );
        float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

        vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

        return irradiance;

    }

#endif
`,
            lights_toon_fragment: `
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`,
            lights_toon_pars_fragment: `
varying vec3 vViewPosition;

struct ToonMaterial {

    vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

    vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

    reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct               RE_Direct_Toon
#define RE_IndirectDiffuse      RE_IndirectDiffuse_Toon
`,
            lights_phong_fragment: `
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`,
            lights_phong_pars_fragment: `
varying vec3 vViewPosition;

struct BlinnPhongMaterial {

    vec3 diffuseColor;
    vec3 specularColor;
    float specularShininess;
    float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
    vec3 irradiance = dotNL * directLight.color;

    reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct               RE_Direct_BlinnPhong
#define RE_IndirectDiffuse      RE_IndirectDiffuse_BlinnPhong
`,
            lights_physical_fragment: `
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );

#ifdef IOR

    material.ior = ior;

    #ifdef SPECULAR

        float specularIntensityFactor = specularIntensity;
        vec3 specularColorFactor = specularColor;

        #ifdef USE_SPECULARINTENSITYMAP

            specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;

        #endif

        #ifdef USE_SPECULARCOLORMAP

            specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;

        #endif

        material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );

    #else

        float specularIntensityFactor = 1.0;
        vec3 specularColorFactor = vec3( 1.0 );
        material.specularF90 = 1.0;

    #endif

    material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );

#else

    material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
    material.specularF90 = 1.0;

#endif

#ifdef USE_CLEARCOAT

    material.clearcoat = clearcoat;
    material.clearcoatRoughness = clearcoatRoughness;
    material.clearcoatF0 = vec3( 0.04 );
    material.clearcoatF90 = 1.0;

    #ifdef USE_CLEARCOATMAP

        material.clearcoat *= texture2D( clearcoatMap, vUv ).x;

    #endif

    #ifdef USE_CLEARCOAT_ROUGHNESSMAP

        material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;

    #endif

    material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
    material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
    material.clearcoatRoughness += geometryRoughness;
    material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_IRIDESCENCE

    material.iridescence = iridescence;
    material.iridescenceIOR = iridescenceIOR;

    #ifdef USE_IRIDESCENCEMAP

        material.iridescence *= texture2D( iridescenceMap, vUv ).r;

    #endif

    #ifdef USE_IRIDESCENCE_THICKNESSMAP

        material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;

    #else

        material.iridescenceThickness = iridescenceThicknessMaximum;

    #endif

#endif

#ifdef USE_SHEEN

    material.sheenColor = sheenColor;

    #ifdef USE_SHEENCOLORMAP

        material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;

    #endif

    material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );

    #ifdef USE_SHEENROUGHNESSMAP

        material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;

    #endif

#endif
`,
            lights_physical_pars_fragment: `
struct PhysicalMaterial {

    vec3 diffuseColor;
    float roughness;
    vec3 specularColor;
    float specularF90;

    #ifdef USE_CLEARCOAT
        float clearcoat;
        float clearcoatRoughness;
        vec3 clearcoatF0;
        float clearcoatF90;
    #endif

    #ifdef USE_IRIDESCENCE
        float iridescence;
        float iridescenceIOR;
        float iridescenceThickness;
        vec3 iridescenceFresnel;
        vec3 iridescenceF0;
    #endif

    #ifdef USE_SHEEN
        vec3 sheenColor;
        float sheenRoughness;
    #endif

    #ifdef IOR
        float ior;
    #endif

    #ifdef USE_TRANSMISSION
        float transmission;
        float transmissionAlpha;
        float thickness;
        float attenuationDistance;
        vec3 attenuationColor;
    #endif

};

// temporary
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );

// This is a curve-fit approxmation to the "Charlie sheen" BRDF integrated over the hemisphere from
// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {

    float dotNV = saturate( dot( normal, viewDir ) );

    float r2 = roughness * roughness;

    float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;

    float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;

    float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );

    return saturate( DG * RECIPROCAL_PI );

}

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {

    float dotNV = saturate( dot( normal, viewDir ) );

    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

    vec4 r = roughness * c0 + c1;

    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

    vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;

    return fab;

}

vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {

    vec2 fab = DFGApprox( normal, viewDir, roughness );

    return specularColor * fab.x + specularF90 * fab.y;

}

// Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif

    vec2 fab = DFGApprox( normal, viewDir, roughness );

    #ifdef USE_IRIDESCENCE

        vec3 Fr = mix( specularColor, iridescenceF0, iridescence );

    #else

        vec3 Fr = specularColor;

    #endif

    vec3 FssEss = Fr * fab.x + specularF90 * fab.y;

    float Ess = fab.x + fab.y;
    float Ems = 1.0 - Ess;

    vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619; // 1/21
    vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

    singleScatter += FssEss;
    multiScatter += Fms * Ems;

}

#if NUM_RECT_AREA_LIGHTS > 0

    void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

        vec3 normal = geometry.normal;
        vec3 viewDir = geometry.viewDir;
        vec3 position = geometry.position;
        vec3 lightPos = rectAreaLight.position;
        vec3 halfWidth = rectAreaLight.halfWidth;
        vec3 halfHeight = rectAreaLight.halfHeight;
        vec3 lightColor = rectAreaLight.color;
        float roughness = material.roughness;

        vec3 rectCoords[ 4 ];
        rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
        rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
        rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
        rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

        vec2 uv = LTC_Uv( normal, viewDir, roughness );

        vec4 t1 = texture2D( ltc_1, uv );
        vec4 t2 = texture2D( ltc_2, uv );

        mat3 mInv = mat3(
            vec3( t1.x, 0, t1.y ),
            vec3(    0, 1,    0 ),
            vec3( t1.z, 0, t1.w )
        );

        // LTC Fresnel Approximation by Stephen Hill
        // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
        vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

        reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

        reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

    }

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

    vec3 irradiance = dotNL * directLight.color;

    #ifdef USE_CLEARCOAT

        float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );

        vec3 ccIrradiance = dotNLcc * directLight.color;

        clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );

    #endif

    #ifdef USE_SHEEN

        sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );

    #endif

    #ifdef USE_IRIDESCENCE

        reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );

    #else

        reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );

    #endif

    reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

    #ifdef USE_CLEARCOAT

        clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );

    #endif

    #ifdef USE_SHEEN

        sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );

    #endif

    // Both indirect specular and indirect diffuse light accumulate here

    vec3 singleScattering = vec3( 0.0 );
    vec3 multiScattering = vec3( 0.0 );
    vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

    #ifdef USE_IRIDESCENCE

        computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );

    #else

        computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );

    #endif

    vec3 totalScattering = singleScattering + multiScattering;
    vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );

    reflectedLight.indirectSpecular += radiance * singleScattering;
    reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

    reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct               RE_Direct_Physical
#define RE_Direct_RectArea      RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse      RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular     RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`,
            lights_fragment_begin: `
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef USE_CLEARCOAT

    geometry.clearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE

    float dotNVi = saturate( dot( normal, geometry.viewDir ) );

    if ( material.iridescenceThickness == 0.0 ) {

        material.iridescence = 0.0;

    } else {

        material.iridescence = saturate( material.iridescence );

    }

    if ( material.iridescence > 0.0 ) {

        material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );

        // Iridescence F0 approximation
        material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );

    }

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

    PointLight pointLight;
    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
    PointLightShadow pointLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

        pointLight = pointLights[ i ];

        getPointLightInfo( pointLight, geometry, directLight );

        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
        pointLightShadow = pointLightShadows[ i ];
        directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
        #endif

        RE_Direct( directLight, geometry, material, reflectedLight );

    }
    #pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

    SpotLight spotLight;
    vec4 spotColor;
    vec3 spotLightCoord;
    bool inSpotLightMap;

    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
    SpotLightShadow spotLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

        spotLight = spotLights[ i ];

        getSpotLightInfo( spotLight, geometry, directLight );

        // spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
        #if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
        #define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
        #elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
        #define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
        #else
        #define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
        #endif

        #if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
            spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
            inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
            spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
            directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
        #endif

        #undef SPOT_LIGHT_MAP_INDEX

        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
        spotLightShadow = spotLightShadows[ i ];
        directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
        #endif

        RE_Direct( directLight, geometry, material, reflectedLight );

    }
    #pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

    DirectionalLight directionalLight;
    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
    DirectionalLightShadow directionalLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

        directionalLight = directionalLights[ i ];

        getDirectionalLightInfo( directionalLight, geometry, directLight );

        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
        directionalLightShadow = directionalLightShadows[ i ];
        directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
        #endif

        RE_Direct( directLight, geometry, material, reflectedLight );

    }
    #pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

    RectAreaLight rectAreaLight;

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

        rectAreaLight = rectAreaLights[ i ];
        RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

    }
    #pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

    vec3 iblIrradiance = vec3( 0.0 );

    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

    irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );

    #if ( NUM_HEMI_LIGHTS > 0 )

        #pragma unroll_loop_start
        for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

            irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

        }
        #pragma unroll_loop_end

    #endif

#endif

#if defined( RE_IndirectSpecular )

    vec3 radiance = vec3( 0.0 );
    vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,
            lights_fragment_maps: `
#if defined( RE_IndirectDiffuse )

    #ifdef USE_LIGHTMAP

        vec4 lightMapTexel = texture2D( lightMap, vUv2 );
        vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;

        irradiance += lightMapIrradiance;

    #endif

    #if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

        iblIrradiance += getIBLIrradiance( geometry.normal );

    #endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

    radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );

    #ifdef USE_CLEARCOAT

        clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );

    #endif

#endif
`,
            lights_fragment_end: `
#if defined( RE_IndirectDiffuse )

    RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

    RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`,
            logdepthbuf_fragment: `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

    // Doing a strict comparison with == 1.0 can cause noise artifacts
    // on some platforms. See issue #17623.
    gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`,
            logdepthbuf_pars_fragment: `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

    uniform float logDepthBufFC;
    varying float vFragDepth;
    varying float vIsPerspective;

#endif
`,
            logdepthbuf_pars_vertex: `
#ifdef USE_LOGDEPTHBUF

    #ifdef USE_LOGDEPTHBUF_EXT

        varying float vFragDepth;
        varying float vIsPerspective;

    #else

        uniform float logDepthBufFC;

    #endif

#endif
`,
            logdepthbuf_vertex: `
#ifdef USE_LOGDEPTHBUF

    #ifdef USE_LOGDEPTHBUF_EXT

        vFragDepth = 1.0 + gl_Position.w;
        vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

    #else

        if ( isPerspectiveMatrix( projectionMatrix ) ) {

            gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

            gl_Position.z *= gl_Position.w;

        }

    #endif

#endif
`,
            map_fragment: `
#ifdef USE_MAP

    vec4 sampledDiffuseColor = texture2D( map, vUv );

    #ifdef DECODE_VIDEO_TEXTURE

        // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)

        sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );

    #endif

    diffuseColor *= sampledDiffuseColor;

#endif
`,
            map_pars_fragment: `
#ifdef USE_MAP

    uniform sampler2D map;

#endif
`,
            map_particle_fragment: `
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

    vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

    diffuseColor *= texture2D( map, uv );

#endif

#ifdef USE_ALPHAMAP

    diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`,
            map_particle_pars_fragment: `
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

    uniform mat3 uvTransform;

#endif

#ifdef USE_MAP

    uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

    uniform sampler2D alphaMap;

#endif
`,
            metalnessmap_fragment: `
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

    vec4 texelMetalness = texture2D( metalnessMap, vUv );

    // reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
    metalnessFactor *= texelMetalness.b;

#endif
`,
            metalnessmap_pars_fragment: `
#ifdef USE_METALNESSMAP

    uniform sampler2D metalnessMap;

#endif
`,
            morphcolor_vertex: `
#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )

    // morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
    // When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
    // When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
    vColor *= morphTargetBaseInfluence;

    for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

        #if defined( USE_COLOR_ALPHA )

            if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];

        #elif defined( USE_COLOR )

            if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];

        #endif

    }

#endif
`,
            morphnormal_vertex: `
#ifdef USE_MORPHNORMALS

    // morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
    // When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
    // When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
    objectNormal *= morphTargetBaseInfluence;

    #ifdef MORPHTARGETS_TEXTURE

        for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

            if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];

        }

    #else

        objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
        objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
        objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
        objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

    #endif

#endif
`,
            morphtarget_pars_vertex: `
#ifdef USE_MORPHTARGETS

    uniform float morphTargetBaseInfluence;

    #ifdef MORPHTARGETS_TEXTURE

        uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
        uniform sampler2DArray morphTargetsTexture;
        uniform ivec2 morphTargetsTextureSize;

        vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {

            int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
            int y = texelIndex / morphTargetsTextureSize.x;
            int x = texelIndex - y * morphTargetsTextureSize.x;

            ivec3 morphUV = ivec3( x, y, morphTargetIndex );
            return texelFetch( morphTargetsTexture, morphUV, 0 );

        }

    #else

        #ifndef USE_MORPHNORMALS

            uniform float morphTargetInfluences[ 8 ];

        #else

            uniform float morphTargetInfluences[ 4 ];

        #endif

    #endif

#endif
`,
            morphtarget_vertex: `
#ifdef USE_MORPHTARGETS

    // morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
    // When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
    // When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
    transformed *= morphTargetBaseInfluence;

    #ifdef MORPHTARGETS_TEXTURE

        for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

            if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];

        }

    #else

        transformed += morphTarget0 * morphTargetInfluences[ 0 ];
        transformed += morphTarget1 * morphTargetInfluences[ 1 ];
        transformed += morphTarget2 * morphTargetInfluences[ 2 ];
        transformed += morphTarget3 * morphTargetInfluences[ 3 ];

        #ifndef USE_MORPHNORMALS

            transformed += morphTarget4 * morphTargetInfluences[ 4 ];
            transformed += morphTarget5 * morphTargetInfluences[ 5 ];
            transformed += morphTarget6 * morphTargetInfluences[ 6 ];
            transformed += morphTarget7 * morphTargetInfluences[ 7 ];

        #endif

    #endif

#endif
`,
            normal_fragment_begin: `
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;

#ifdef FLAT_SHADED

    vec3 fdx = dFdx( vViewPosition );
    vec3 fdy = dFdy( vViewPosition );
    vec3 normal = normalize( cross( fdx, fdy ) );

#else

    vec3 normal = normalize( vNormal );

    #ifdef DOUBLE_SIDED

        normal = normal * faceDirection;

    #endif

    #ifdef USE_TANGENT

        vec3 tangent = normalize( vTangent );
        vec3 bitangent = normalize( vBitangent );

        #ifdef DOUBLE_SIDED

            tangent = tangent * faceDirection;
            bitangent = bitangent * faceDirection;

        #endif

        #if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

            mat3 vTBN = mat3( tangent, bitangent, normal );

        #endif

    #endif

#endif

// non perturbed normal for clearcoat among others

vec3 geometryNormal = normal;

`,
            normal_fragment_maps: `

#ifdef OBJECTSPACE_NORMALMAP

    normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

    #ifdef FLIP_SIDED

        normal = - normal;

    #endif

    #ifdef DOUBLE_SIDED

        normal = normal * faceDirection;

    #endif

    normal = normalize( normalMatrix * normal );

#elif defined( TANGENTSPACE_NORMALMAP )

    vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
    mapN.xy *= normalScale;

    #ifdef USE_TANGENT

        normal = normalize( vTBN * mapN );

    #else

        normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );

    #endif

#elif defined( USE_BUMPMAP )

    normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

#endif
`,
            normal_pars_fragment: `
#ifndef FLAT_SHADED

    varying vec3 vNormal;

    #ifdef USE_TANGENT

        varying vec3 vTangent;
        varying vec3 vBitangent;

    #endif

#endif
`,
            normal_pars_vertex: `
#ifndef FLAT_SHADED

    varying vec3 vNormal;

    #ifdef USE_TANGENT

        varying vec3 vTangent;
        varying vec3 vBitangent;

    #endif

#endif
`,
            normal_vertex: `
#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED

    vNormal = normalize( transformedNormal );

    #ifdef USE_TANGENT

        vTangent = normalize( transformedTangent );
        vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

    #endif

#endif
`,
            normalmap_pars_fragment: `
#ifdef USE_NORMALMAP

    uniform sampler2D normalMap;
    uniform vec2 normalScale;

#endif

#ifdef OBJECTSPACE_NORMALMAP

    uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )

    // Normal Mapping Without Precomputed Tangents
    // http://www.thetenthplanet.de/archives/1180

    vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

        vec3 q0 = dFdx( eye_pos.xyz );
        vec3 q1 = dFdy( eye_pos.xyz );
        vec2 st0 = dFdx( vUv.st );
        vec2 st1 = dFdy( vUv.st );

        vec3 N = surf_norm; // normalized

        vec3 q1perp = cross( q1, N );
        vec3 q0perp = cross( N, q0 );

        vec3 T = q1perp * st0.x + q0perp * st1.x;
        vec3 B = q1perp * st0.y + q0perp * st1.y;

        float det = max( dot( T, T ), dot( B, B ) );
        float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

        return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

    }

#endif
`,
            clearcoat_normal_fragment_begin: `
#ifdef USE_CLEARCOAT

    vec3 clearcoatNormal = geometryNormal;

#endif
`,
            clearcoat_normal_fragment_maps: `
#ifdef USE_CLEARCOAT_NORMALMAP

    vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
    clearcoatMapN.xy *= clearcoatNormalScale;

    #ifdef USE_TANGENT

        clearcoatNormal = normalize( vTBN * clearcoatMapN );

    #else

        clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );

    #endif

#endif
`,
            clearcoat_pars_fragment: `

#ifdef USE_CLEARCOATMAP

    uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

    uniform sampler2D clearcoatRoughnessMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

    uniform sampler2D clearcoatNormalMap;
    uniform vec2 clearcoatNormalScale;

#endif
`,
            iridescence_pars_fragment: `

#ifdef USE_IRIDESCENCEMAP

    uniform sampler2D iridescenceMap;

#endif

#ifdef USE_IRIDESCENCE_THICKNESSMAP

    uniform sampler2D iridescenceThicknessMap;

#endif
`,
            output_fragment: `
#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif

// https://github.com/mrdoob/three.js/pull/22425
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif

gl_FragColor = vec4( outgoingLight, diffuseColor.a );
`,
            packing: `
vec3 packNormalToRGB( const in vec3 normal ) {
    return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
    return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
    vec4 r = vec4( fract( v * PackFactors ), v );
    r.yzw -= r.xyz * ShiftRight8; // tidy overflow
    return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
    return dot( v, UnpackFactors );
}

vec2 packDepthToRG( in highp float v ) {
    return packDepthToRGBA( v ).yx;
}

float unpackRGToDepth( const in highp vec2 v ) {
    return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}

vec4 pack2HalfToRGBA( vec2 v ) {
    vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
    return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}

vec2 unpackRGBATo2Half( vec4 v ) {
    return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
    return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
    return linearClipZ * ( near - far ) - near;
}

// NOTE: https://twitter.com/gonnavis/status/1377183786949959682

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
    return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
    return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`,
            premultiplied_alpha_fragment: `
#ifdef PREMULTIPLIED_ALPHA

    // Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
    gl_FragColor.rgb *= gl_FragColor.a;

#endif
`,
            project_vertex: `
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING

    mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`,
            dithering_fragment: `
#ifdef DITHERING

    gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`,
            dithering_pars_fragment: `
#ifdef DITHERING

    // based on https://www.shadertoy.com/view/MslGR8
    vec3 dithering( vec3 color ) {
        //Calculate grid position
        float grid_position = rand( gl_FragCoord.xy );

        //Shift the individual colors differently, thus making it even harder to see the dithering pattern
        vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

        //modify shift according to grid position.
        dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

        //shift the color by dither_shift
        return color + dither_shift_RGB;
    }

#endif
`,
            roughnessmap_fragment: `
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

    vec4 texelRoughness = texture2D( roughnessMap, vUv );

    // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
    roughnessFactor *= texelRoughness.g;

#endif
`,
            roughnessmap_pars_fragment: `
#ifdef USE_ROUGHNESSMAP

    uniform sampler2D roughnessMap;

#endif
`,
            shadowmap_pars_fragment: `
#if NUM_SPOT_LIGHT_COORDS > 0

    varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];

#endif

#if NUM_SPOT_LIGHT_MAPS > 0

    uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];

#endif

#ifdef USE_SHADOWMAP

    #if NUM_DIR_LIGHT_SHADOWS > 0

        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

    #endif

    #if NUM_SPOT_LIGHT_SHADOWS > 0

        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];

        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };

        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): create uniforms for area light shadows

    #endif
    */

    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

    }

    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

        return unpackRGBATo2Half( texture2D( shadow, uv ) );

    }

    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

        float occlusion = 1.0;

        vec2 distribution = texture2DDistribution( shadow, uv );

        float hard_shadow = step( compare , distribution.x ); // Hard Shadow

        if (hard_shadow != 1.0 ) {

            float distance = compare - distribution.x ;
            float variance = max( 0.00000, distribution.y * distribution.y );
            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

        }
        return occlusion;

    }

    float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

        float shadow = 1.0;

        shadowCoord.xyz /= shadowCoord.w;
        shadowCoord.z += shadowBias;

        bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
        bool frustumTest = inFrustum && shadowCoord.z <= 1.0;

        if ( frustumTest ) {

        #if defined( SHADOWMAP_TYPE_PCF )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

            float dx0 = - texelSize.x * shadowRadius;
            float dy0 = - texelSize.y * shadowRadius;
            float dx1 = + texelSize.x * shadowRadius;
            float dy1 = + texelSize.y * shadowRadius;
            float dx2 = dx0 / 2.0;
            float dy2 = dy0 / 2.0;
            float dx3 = dx1 / 2.0;
            float dy3 = dy1 / 2.0;

            shadow = (
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
            ) * ( 1.0 / 17.0 );

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx = texelSize.x;
            float dy = texelSize.y;

            vec2 uv = shadowCoord.xy;
            vec2 f = fract( uv * shadowMapSize + 0.5 );
            uv -= f * texelSize;

            shadow = (
                texture2DCompare( shadowMap, uv, shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
                          f.x ),
                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
                          f.x ),
                     f.y )
            ) * ( 1.0 / 9.0 );

        #elif defined( SHADOWMAP_TYPE_VSM )

            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

        #else // no percentage-closer filtering:

            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

        #endif

        }

        return shadow;

    }

    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
    // vector suitable for 2D texture mapping. This code uses the following layout for the
    // 2D texture:
    //
    // xzXZ
    //  y Y
    //
    // Y - Positive y direction
    // y - Negative y direction
    // X - Positive x direction
    // x - Negative x direction
    // Z - Positive z direction
    // z - Negative z direction
    //
    // Source and test bed:
    // https://gist.github.com/tschw/da10c43c467ce8afd0c4

    vec2 cubeToUV( vec3 v, float texelSizeY ) {

        // Number of texels to avoid at the edge of each square

        vec3 absV = abs( v );

        // Intersect unit cube

        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
        absV *= scaleToCube;

        // Apply scale to avoid seams

        // two texels less per square (one texel will do for NEAREST)
        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

        // Unwrap

        // space: -1 ... 1 range for each square
        //
        // #X##     dim    := ( 4 , 2 )
        //  # #     center := ( 1 , 1 )

        vec2 planar = v.xy;

        float almostATexel = 1.5 * texelSizeY;
        float almostOne = 1.0 - almostATexel;

        if ( absV.z >= almostOne ) {

            if ( v.z > 0.0 )
                planar.x = 4.0 - v.x;

        } else if ( absV.x >= almostOne ) {

            float signX = sign( v.x );
            planar.x = v.z * signX + 2.0 * signX;

        } else if ( absV.y >= almostOne ) {

            float signY = sign( v.y );
            planar.x = v.x + 2.0 * signY + 2.0;
            planar.y = v.z * signY - 2.0;

        }

        // Transform to UV space

        // scale := 0.5 / dim
        // translate := ( center + 0.5 ) / dim
        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

    }

    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

        // for point lights, the uniform @vShadowCoord is re-purposed to hold
        // the vector from the light to the world-space position of the fragment.
        vec3 lightToPosition = shadowCoord.xyz;

        // dp = normalized distance from light to fragment position
        float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
        dp += shadowBias;

        // bd3D = base direction 3D
        vec3 bd3D = normalize( lightToPosition );

        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

            vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

            return (
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
            ) * ( 1.0 / 9.0 );

        #else // no percentage-closer filtering

            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

        #endif

    }

#endif
`,
            shadowmap_pars_vertex: `

#if NUM_SPOT_LIGHT_COORDS > 0

    uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
    varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];

#endif

#ifdef USE_SHADOWMAP

    #if NUM_DIR_LIGHT_SHADOWS > 0

        uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

    #endif

    #if NUM_SPOT_LIGHT_SHADOWS > 0

        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

        uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };

        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): uniforms for area light shadows

    #endif
    */

#endif
`,
            shadowmap_vertex: `

#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )

    // Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
    vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
    vec4 shadowWorldPosition;

#endif

#if defined( USE_SHADOWMAP )

    #if NUM_DIR_LIGHT_SHADOWS > 0

        #pragma unroll_loop_start
        for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

            shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
            vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

        }
        #pragma unroll_loop_end

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

        #pragma unroll_loop_start
        for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

            shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
            vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

        }
        #pragma unroll_loop_end

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): update vAreaShadowCoord with area light info

    #endif
    */

#endif

// spot lights can be evaluated without active shadow mapping (when SpotLight.map is used)

#if NUM_SPOT_LIGHT_COORDS > 0

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {

        shadowWorldPosition = worldPosition;
        #if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
            shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
        #endif
        vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;

    }
    #pragma unroll_loop_end

#endif


`,
            shadowmask_pars_fragment: `
float getShadowMask() {

    float shadow = 1.0;

    #ifdef USE_SHADOWMAP

    #if NUM_DIR_LIGHT_SHADOWS > 0

    DirectionalLightShadow directionalLight;

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

        directionalLight = directionalLightShadows[ i ];
        shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

    }
    #pragma unroll_loop_end

    #endif

    #if NUM_SPOT_LIGHT_SHADOWS > 0

    SpotLightShadow spotLight;

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

        spotLight = spotLightShadows[ i ];
        shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

    }
    #pragma unroll_loop_end

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

    PointLightShadow pointLight;

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

        pointLight = pointLightShadows[ i ];
        shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

    }
    #pragma unroll_loop_end

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): update shadow for Area light

    #endif
    */

    #endif

    return shadow;

}
`,
            skinbase_vertex: `
#ifdef USE_SKINNING

    mat4 boneMatX = getBoneMatrix( skinIndex.x );
    mat4 boneMatY = getBoneMatrix( skinIndex.y );
    mat4 boneMatZ = getBoneMatrix( skinIndex.z );
    mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`,
            skinning_pars_vertex: `
#ifdef USE_SKINNING

    uniform mat4 bindMatrix;
    uniform mat4 bindMatrixInverse;

    uniform highp sampler2D boneTexture;
    uniform int boneTextureSize;

    mat4 getBoneMatrix( const in float i ) {

        float j = i * 4.0;
        float x = mod( j, float( boneTextureSize ) );
        float y = floor( j / float( boneTextureSize ) );

        float dx = 1.0 / float( boneTextureSize );
        float dy = 1.0 / float( boneTextureSize );

        y = dy * ( y + 0.5 );

        vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
        vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
        vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
        vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

        mat4 bone = mat4( v1, v2, v3, v4 );

        return bone;

    }

#endif
`,
            skinning_vertex: `
#ifdef USE_SKINNING

    vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

    vec4 skinned = vec4( 0.0 );
    skinned += boneMatX * skinVertex * skinWeight.x;
    skinned += boneMatY * skinVertex * skinWeight.y;
    skinned += boneMatZ * skinVertex * skinWeight.z;
    skinned += boneMatW * skinVertex * skinWeight.w;

    transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`,
            skinnormal_vertex: `
#ifdef USE_SKINNING

    mat4 skinMatrix = mat4( 0.0 );
    skinMatrix += skinWeight.x * boneMatX;
    skinMatrix += skinWeight.y * boneMatY;
    skinMatrix += skinWeight.z * boneMatZ;
    skinMatrix += skinWeight.w * boneMatW;
    skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

    objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

    #ifdef USE_TANGENT

        objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

    #endif

#endif
`,
            specularmap_fragment: `
float specularStrength;

#ifdef USE_SPECULARMAP

    vec4 texelSpecular = texture2D( specularMap, vUv );
    specularStrength = texelSpecular.r;

#else

    specularStrength = 1.0;

#endif
`,
            specularmap_pars_fragment: `
#ifdef USE_SPECULARMAP

    uniform sampler2D specularMap;

#endif
`,
            tonemapping_fragment: `
#if defined( TONE_MAPPING )

    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`,
            tonemapping_pars_fragment: `
#ifndef saturate
// <common> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

    return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf
vec3 ReinhardToneMapping( vec3 color ) {

    color *= toneMappingExposure;
    return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 OptimizedCineonToneMapping( vec3 color ) {

    // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
    color *= toneMappingExposure;
    color = max( vec3( 0.0 ), color - 0.004 );
    return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

    vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
    vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
    return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

    // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
    const mat3 ACESInputMat = mat3(
        vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
        vec3( 0.35458, 0.90834, 0.13383 ),
        vec3( 0.04823, 0.01566, 0.83777 )
    );

    // ODT_SAT => XYZ => D60_2_D65 => sRGB
    const mat3 ACESOutputMat = mat3(
        vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
        vec3( -0.53108,  1.10813, -0.07276 ),
        vec3( -0.07367, -0.00605,  1.07602 )
    );

    color *= toneMappingExposure / 0.6;

    color = ACESInputMat * color;

    // Apply RRT and ODT
    color = RRTAndODTFit( color );

    color = ACESOutputMat * color;

    // Clamp to [0, 1]
    return saturate( color );
}

vec3 CustomToneMapping( vec3 color ) { return color; }
`,
            transmission_fragment: `
#ifdef USE_TRANSMISSION

    material.transmission = transmission;
    material.transmissionAlpha = 1.0;
    material.thickness = thickness;
    material.attenuationDistance = attenuationDistance;
    material.attenuationColor = attenuationColor;

    #ifdef USE_TRANSMISSIONMAP

        material.transmission *= texture2D( transmissionMap, vUv ).r;

    #endif

    #ifdef USE_THICKNESSMAP

        material.thickness *= texture2D( thicknessMap, vUv ).g;

    #endif

    vec3 pos = vWorldPosition;
    vec3 v = normalize( cameraPosition - pos );
    vec3 n = inverseTransformDirection( normal, viewMatrix );

    vec4 transmission = getIBLVolumeRefraction(
        n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
        pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
        material.attenuationColor, material.attenuationDistance );

    material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );

    totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );

#endif
`,
            transmission_pars_fragment: `
#ifdef USE_TRANSMISSION

    // Transmission code is based on glTF-Sampler-Viewer
    // https://github.com/KhronosGroup/glTF-Sample-Viewer

    uniform float transmission;
    uniform float thickness;
    uniform float attenuationDistance;
    uniform vec3 attenuationColor;

    #ifdef USE_TRANSMISSIONMAP

        uniform sampler2D transmissionMap;

    #endif

    #ifdef USE_THICKNESSMAP

        uniform sampler2D thicknessMap;

    #endif

    uniform vec2 transmissionSamplerSize;
    uniform sampler2D transmissionSamplerMap;

    uniform mat4 modelMatrix;
    uniform mat4 projectionMatrix;

    vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {

        // Direction of refracted light.
        vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );

        // Compute rotation-independant scaling of the model matrix.
        vec3 modelScale;
        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

        // The thickness is specified in local space.
        return normalize( refractionVector ) * thickness * modelScale;

    }

    float applyIorToRoughness( const in float roughness, const in float ior ) {

        // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
        // an IOR of 1.5 results in the default amount of microfacet refraction.
        return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );

    }

    vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {

        float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
        return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );

    }

    vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {

        if ( isinf( attenuationDistance ) ) {

            // Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.
            return radiance;

        } else {

            // Compute light attenuation using Beer's law.
            vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
            vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law
            return transmittance * radiance;

        }

    }

    vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
        const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
        const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
        const in vec3 attenuationColor, const in float attenuationDistance ) {

        vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
        vec3 refractedRayExit = position + transmissionRay;

        // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
        vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
        vec2 refractionCoords = ndcPos.xy / ndcPos.w;
        refractionCoords += 1.0;
        refractionCoords /= 2.0;

        // Sample framebuffer to get pixel the refracted ray hits.
        vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );

        vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );

        // Get the specular component.
        vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );

        return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );

    }
#endif
`,
            uv_pars_fragment: `
#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )

    varying vec2 vUv;

#endif
`,
            uv_pars_vertex: `
#ifdef USE_UV

    #ifdef UVS_VERTEX_ONLY

        vec2 vUv;

    #else

        varying vec2 vUv;

    #endif

    uniform mat3 uvTransform;

#endif
`,
            uv_vertex: `
#ifdef USE_UV

    vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`,
            uv2_pars_fragment: `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

    varying vec2 vUv2;

#endif
`,
            uv2_pars_vertex: `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

    attribute vec2 uv2;
    varying vec2 vUv2;

    uniform mat3 uv2Transform;

#endif
`,
            uv2_vertex: `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

    vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;

#endif
`,
            worldpos_vertex: `
#if defined( USE_BOX_PROJECTION ) || defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0

    vec4 worldPosition = vec4( transformed, 1.0 );

    #ifdef USE_INSTANCING

        worldPosition = instanceMatrix * worldPosition;

    #endif

    worldPosition = modelMatrix * worldPosition;

#endif
`,
            background_vert: `
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

    vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

    gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`,
            background_frag: `
uniform sampler2D t2D;
uniform float backgroundIntensity;

varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );

    #ifdef DECODE_VIDEO_TEXTURE

        // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)

        texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    #endif

    texColor.rgb *= backgroundIntensity;

    gl_FragColor = texColor;

    #include <tonemapping_fragment>
    #include <encodings_fragment>

}
`,
            backgroundCube_vert: `
varying vec3 vWorldDirection;

#include <common>

void main() {

    vWorldDirection = transformDirection( position, modelMatrix );

    #include <begin_vertex>
    #include <project_vertex>

    gl_Position.z = gl_Position.w; // set z to camera.far

}
`,
            backgroundCube_frag: `

#ifdef ENVMAP_TYPE_CUBE

    uniform samplerCube envMap;

#elif defined( ENVMAP_TYPE_CUBE_UV )

    uniform sampler2D envMap;

#endif

uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

    vec3 dir = vWorldDirection;

    #ifdef ENVMAP_TYPE_CUBE

        vec4 texColor = textureCube( envMap, vec3( flipEnvMap * dir.x, dir.yz ) );

    #elif defined( ENVMAP_TYPE_CUBE_UV )

        vec4 texColor = textureCubeUV( envMap, dir, backgroundBlurriness );

    #else

        vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );

    #endif

    texColor.rgb *= backgroundIntensity;

    gl_FragColor = texColor;

    #include <tonemapping_fragment>
    #include <encodings_fragment>

}
`,
            cube_vert: `
varying vec3 vWorldDirection;

#include <common>

void main() {

    vWorldDirection = transformDirection( position, modelMatrix );

    #include <begin_vertex>
    #include <project_vertex>

    gl_Position.z = gl_Position.w; // set z to camera.far

}
`,
            cube_frag: `
uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;

varying vec3 vWorldDirection;

void main() {

    vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );

    gl_FragColor = texColor;
    gl_FragColor.a *= opacity;

    #include <tonemapping_fragment>
    #include <encodings_fragment>

}
`,
            depth_vert: `
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

    #include <uv_vertex>

    #include <skinbase_vertex>

    #ifdef USE_DISPLACEMENTMAP

        #include <beginnormal_vertex>
        #include <morphnormal_vertex>
        #include <skinnormal_vertex>

    #endif

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vHighPrecisionZW = gl_Position.zw;

}
`,
            depth_frag: `
#if DEPTH_PACKING == 3200

    uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( 1.0 );

    #if DEPTH_PACKING == 3200

        diffuseColor.a = opacity;

    #endif

    #include <map_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>

    #include <logdepthbuf_fragment>

    // Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
    float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

    #if DEPTH_PACKING == 3200

        gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

    #elif DEPTH_PACKING == 3201

        gl_FragColor = packDepthToRGBA( fragCoordZ );

    #endif

}
`,
            distanceRGBA_vert: `
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <uv_vertex>

    #include <skinbase_vertex>

    #ifdef USE_DISPLACEMENTMAP

        #include <beginnormal_vertex>
        #include <morphnormal_vertex>
        #include <skinnormal_vertex>

    #endif

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <worldpos_vertex>
    #include <clipping_planes_vertex>

    vWorldPosition = worldPosition.xyz;

}
`,
            distanceRGBA_frag: `
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( 1.0 );

    #include <map_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>

    float dist = length( vWorldPosition - referencePosition );
    dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
    dist = saturate( dist ); // clamp to [ 0, 1 ]

    gl_FragColor = packDepthToRGBA( dist );

}
`,
            equirect_vert: `
varying vec3 vWorldDirection;

#include <common>

void main() {

    vWorldDirection = transformDirection( position, modelMatrix );

    #include <begin_vertex>
    #include <project_vertex>

}
`,
            equirect_frag: `
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

    vec3 direction = normalize( vWorldDirection );

    vec2 sampleUV = equirectUv( direction );

    gl_FragColor = texture2D( tEquirect, sampleUV );

    #include <tonemapping_fragment>
    #include <encodings_fragment>

}
`,
            linedashed_vert: `
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    vLineDistance = scale * lineDistance;

    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    #include <fog_vertex>

}
`,
            linedashed_frag: `
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    if ( mod( vLineDistance, totalSize ) > dashSize ) {

        discard;

    }

    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vec4( diffuse, opacity );

    #include <logdepthbuf_fragment>
    #include <color_fragment>

    outgoingLight = diffuseColor.rgb; // simple shader

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>

}
`,
            meshbasic_vert: `
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>

    #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )

        #include <beginnormal_vertex>
        #include <morphnormal_vertex>
        #include <skinbase_vertex>
        #include <skinnormal_vertex>
        #include <defaultnormal_vertex>

    #endif

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    #include <worldpos_vertex>
    #include <envmap_vertex>
    #include <fog_vertex>

}
`,
            meshbasic_frag: `
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

    varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( diffuse, opacity );

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <specularmap_fragment>

    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

    // accumulation (baked indirect lighting only)
    #ifdef USE_LIGHTMAP

        vec4 lightMapTexel = texture2D( lightMap, vUv2 );
        reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;

    #else

        reflectedLight.indirectDiffuse += vec3( 1.0 );

    #endif

    // modulation
    #include <aomap_fragment>

    reflectedLight.indirectDiffuse *= diffuseColor.rgb;

    vec3 outgoingLight = reflectedLight.indirectDiffuse;

    #include <envmap_fragment>

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>

}
`,
            meshlambert_vert: `
#define LAMBERT

varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>

    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vViewPosition = - mvPosition.xyz;

    #include <worldpos_vertex>
    #include <envmap_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>

}
`,
            meshlambert_frag: `
#define LAMBERT

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <specularmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <emissivemap_fragment>

    // accumulation
    #include <lights_lambert_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>

    // modulation
    #include <aomap_fragment>

    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

    #include <envmap_fragment>
    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>

}
`,
            meshmatcap_vert: `
#define MATCAP

varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <uv_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>

    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    #include <fog_vertex>

    vViewPosition = - mvPosition.xyz;

}
`,
            meshmatcap_frag: `
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( diffuse, opacity );

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>

    vec3 viewDir = normalize( vViewPosition );
    vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
    vec3 y = cross( viewDir, x );
    vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

    #ifdef USE_MATCAP

        vec4 matcapColor = texture2D( matcap, uv );

    #else

        vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 ); // default if matcap is missing

    #endif

    vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>

}
`,
            meshnormal_vert: `
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

    varying vec3 vViewPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <uv_vertex>

    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

    vViewPosition = - mvPosition.xyz;

#endif

}
`,
            meshnormal_frag: `
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

    varying vec3 vViewPosition;

#endif

#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>
    #include <logdepthbuf_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>

    gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

    #ifdef OPAQUE

        gl_FragColor.a = 1.0;

    #endif

}
`,
            meshphong_vert: `
#define PHONG

varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>

    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vViewPosition = - mvPosition.xyz;

    #include <worldpos_vertex>
    #include <envmap_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>

}
`,
            meshphong_frag: `
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <specularmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <emissivemap_fragment>

    // accumulation
    #include <lights_phong_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>

    // modulation
    #include <aomap_fragment>

    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

    #include <envmap_fragment>
    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>

}
`,
            meshphysical_vert: `
#define STANDARD

varying vec3 vViewPosition;

#if defined(USE_TRANSMISSION) || defined(USE_BOX_PROJECTION)

    varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>

    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vViewPosition = - mvPosition.xyz;

    #include <worldpos_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>

#if defined(USE_TRANSMISSION) || defined(USE_BOX_PROJECTION)

    vWorldPosition = worldPosition.xyz;

#endif
}
`,
            meshphysical_frag: `
#define STANDARD

#ifdef PHYSICAL
    #define IOR
    #define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
    uniform float ior;
#endif

#ifdef SPECULAR
    uniform float specularIntensity;
    uniform vec3 specularColor;

    #ifdef USE_SPECULARINTENSITYMAP
        uniform sampler2D specularIntensityMap;
    #endif

    #ifdef USE_SPECULARCOLORMAP
        uniform sampler2D specularColorMap;
    #endif
#endif

#ifdef USE_CLEARCOAT
    uniform float clearcoat;
    uniform float clearcoatRoughness;
#endif

#ifdef USE_IRIDESCENCE
    uniform float iridescence;
    uniform float iridescenceIOR;
    uniform float iridescenceThicknessMinimum;
    uniform float iridescenceThicknessMaximum;
#endif

#ifdef USE_SHEEN
    uniform vec3 sheenColor;
    uniform float sheenRoughness;

    #ifdef USE_SHEENCOLORMAP
        uniform sampler2D sheenColorMap;
    #endif

    #ifdef USE_SHEENROUGHNESSMAP
        uniform sampler2D sheenRoughnessMap;
    #endif
#endif

varying vec3 vViewPosition;

#if defined(USE_TRANSMISSION) || defined(USE_BOX_PROJECTION)

varying vec3 vWorldPosition;

#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <roughnessmap_fragment>
    #include <metalnessmap_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <clearcoat_normal_fragment_begin>
    #include <clearcoat_normal_fragment_maps>
    #include <emissivemap_fragment>

    // accumulation
    #include <lights_physical_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>

    // modulation
    #include <aomap_fragment>

    vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
    vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

    #include <transmission_fragment>

    vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

    #ifdef USE_SHEEN

        // Sheen energy compensation approximation calculation can be found at the end of
        // https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
        float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

        outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;

    #endif

    #ifdef USE_CLEARCOAT

        float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

        vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

        outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;

    #endif

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>

#if defined(DEBUG_OCCLUSION) && defined(USE_AOMAP)
    gl_FragColor.rgb = vec3(ambientOcclusion);
#endif

#if defined(DEBUG_NORMAL)
    gl_FragColor.rgb = geometry.normal * 0.5 + 0.5;
#endif

#if defined(DEBUG_ROUGHNESS)
    gl_FragColor.rgb = vec3(material.roughness);
#endif

#if defined(DEBUG_METALNESS)
    gl_FragColor.rgb = vec3(metalnessFactor);
#endif

}
`,
            meshtoon_vert: `
#define TOON

varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <uv_vertex>
    #include <uv2_vertex>
    #include <color_vertex>
    #include <morphcolor_vertex>

    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <displacementmap_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>

    vViewPosition = - mvPosition.xyz;

    #include <worldpos_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>

}
`,
            meshtoon_frag: `
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec4 diffuseColor = vec4( diffuse, opacity );
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
    vec3 totalEmissiveRadiance = emissive;

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <color_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>
    #include <normal_fragment_begin>
    #include <normal_fragment_maps>
    #include <emissivemap_fragment>

    // accumulation
    #include <lights_toon_fragment>
    #include <lights_fragment_begin>
    #include <lights_fragment_maps>
    #include <lights_fragment_end>

    // modulation
    #include <aomap_fragment>

    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>
    #include <dithering_fragment>

}
`,
            points_vert: `
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <color_vertex>
    #include <morphcolor_vertex>
    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <project_vertex>

    gl_PointSize = size;

    #ifdef USE_SIZEATTENUATION

        bool isPerspective = isPerspectiveMatrix( projectionMatrix );

        if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

    #endif

    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    #include <worldpos_vertex>
    #include <fog_vertex>

}
`,
            points_frag: `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vec4( diffuse, opacity );

    #include <logdepthbuf_fragment>
    #include <map_particle_fragment>
    #include <color_fragment>
    #include <alphatest_fragment>

    outgoingLight = diffuseColor.rgb;

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>
    #include <premultiplied_alpha_fragment>

}
`,
            shadow_vert: `
#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>

    #include <begin_vertex>
    #include <morphtarget_vertex>
    #include <skinning_vertex>
    #include <project_vertex>
    #include <logdepthbuf_vertex>

    #include <worldpos_vertex>
    #include <shadowmap_vertex>
    #include <fog_vertex>

}
`,
            shadow_frag: `
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

    #include <logdepthbuf_fragment>

    gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>

}
`,
            sprite_vert: `
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

    #include <uv_vertex>

    vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

    vec2 scale;
    scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
    scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

    #ifndef USE_SIZEATTENUATION

        bool isPerspective = isPerspectiveMatrix( projectionMatrix );

        if ( isPerspective ) scale *= - mvPosition.z;

    #endif

    vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

    vec2 rotatedPosition;
    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

    mvPosition.xy += rotatedPosition;

    gl_Position = projectionMatrix * mvPosition;

    #include <logdepthbuf_vertex>
    #include <clipping_planes_vertex>
    #include <fog_vertex>

}
`,
            sprite_frag: `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

    #include <clipping_planes_fragment>

    vec3 outgoingLight = vec3( 0.0 );
    vec4 diffuseColor = vec4( diffuse, opacity );

    #include <logdepthbuf_fragment>
    #include <map_fragment>
    #include <alphamap_fragment>
    #include <alphatest_fragment>

    outgoingLight = diffuseColor.rgb;

    #include <output_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
    #include <fog_fragment>

}
`
        }
          , Zt = {
            common: {
                diffuse: {
                    value: new gn(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new Cr
                },
                uv2Transform: {
                    value: new Cr
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new _t(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new gn(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new gn(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new Cr
                }
            },
            sprite: {
                diffuse: {
                    value: new gn(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new _t(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new Cr
                }
            }
        }
          , Sa = {
            basic: {
                uniforms: no([Zt.common, Zt.specularmap, Zt.envmap, Zt.aomap, Zt.lightmap, Zt.fog]),
                vertexShader: yi.meshbasic_vert,
                fragmentShader: yi.meshbasic_frag
            },
            lambert: {
                uniforms: no([Zt.common, Zt.specularmap, Zt.envmap, Zt.aomap, Zt.lightmap, Zt.emissivemap, Zt.bumpmap, Zt.normalmap, Zt.displacementmap, Zt.fog, Zt.lights, {
                    emissive: {
                        value: new gn(0)
                    }
                }]),
                vertexShader: yi.meshlambert_vert,
                fragmentShader: yi.meshlambert_frag
            },
            phong: {
                uniforms: no([Zt.common, Zt.specularmap, Zt.envmap, Zt.aomap, Zt.lightmap, Zt.emissivemap, Zt.bumpmap, Zt.normalmap, Zt.displacementmap, Zt.fog, Zt.lights, {
                    emissive: {
                        value: new gn(0)
                    },
                    specular: {
                        value: new gn(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: yi.meshphong_vert,
                fragmentShader: yi.meshphong_frag
            },
            standard: {
                uniforms: no([Zt.common, Zt.envmap, Zt.aomap, Zt.lightmap, Zt.emissivemap, Zt.bumpmap, Zt.normalmap, Zt.displacementmap, Zt.roughnessmap, Zt.metalnessmap, Zt.fog, Zt.lights, {
                    emissive: {
                        value: new gn(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: yi.meshphysical_vert,
                fragmentShader: yi.meshphysical_frag
            },
            toon: {
                uniforms: no([Zt.common, Zt.aomap, Zt.lightmap, Zt.emissivemap, Zt.bumpmap, Zt.normalmap, Zt.displacementmap, Zt.gradientmap, Zt.fog, Zt.lights, {
                    emissive: {
                        value: new gn(0)
                    }
                }]),
                vertexShader: yi.meshtoon_vert,
                fragmentShader: yi.meshtoon_frag
            },
            matcap: {
                uniforms: no([Zt.common, Zt.bumpmap, Zt.normalmap, Zt.displacementmap, Zt.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: yi.meshmatcap_vert,
                fragmentShader: yi.meshmatcap_frag
            },
            points: {
                uniforms: no([Zt.points, Zt.fog]),
                vertexShader: yi.points_vert,
                fragmentShader: yi.points_frag
            },
            dashed: {
                uniforms: no([Zt.common, Zt.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: yi.linedashed_vert,
                fragmentShader: yi.linedashed_frag
            },
            depth: {
                uniforms: no([Zt.common, Zt.displacementmap]),
                vertexShader: yi.depth_vert,
                fragmentShader: yi.depth_frag
            },
            normal: {
                uniforms: no([Zt.common, Zt.bumpmap, Zt.normalmap, Zt.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: yi.meshnormal_vert,
                fragmentShader: yi.meshnormal_frag
            },
            sprite: {
                uniforms: no([Zt.sprite, Zt.fog]),
                vertexShader: yi.sprite_vert,
                fragmentShader: yi.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new Cr
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: yi.background_vert,
                fragmentShader: yi.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: yi.backgroundCube_vert,
                fragmentShader: yi.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: yi.cube_vert,
                fragmentShader: yi.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: yi.equirect_vert,
                fragmentShader: yi.equirect_frag
            },
            distanceRGBA: {
                uniforms: no([Zt.common, Zt.displacementmap, {
                    referencePosition: {
                        value: new me
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: yi.distanceRGBA_vert,
                fragmentShader: yi.distanceRGBA_frag
            },
            shadow: {
                uniforms: no([Zt.lights, Zt.fog, {
                    color: {
                        value: new gn(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: yi.shadow_vert,
                fragmentShader: yi.shadow_frag
            }
        };
        Sa.physical = {
            uniforms: no([Sa.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new _t(1,1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new gn(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionSamplerSize: {
                    value: new _t
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new gn(0)
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularColor: {
                    value: new gn(1,1,1)
                },
                specularColorMap: {
                    value: null
                }
            }]),
            vertexShader: yi.meshphysical_vert,
            fragmentShader: yi.meshphysical_frag
        };
        const op = {
            r: 0,
            b: 0,
            g: 0
        };
        function l2(u, e, i, o, a, c, d) {
            const f = new gn(0);
            let v = c === !0 ? 0 : 1, x, w, P = null, M = 0, I = null;
            function z(k, Q) {
                let Z = !1
                  , X = Q.isScene === !0 ? Q.background : null;
                X && X.isTexture && (X = (Q.backgroundBlurriness > 0 ? i : e).get(X));
                const K = u.xr
                  , de = K.getSession && K.getSession();
                de && de.environmentBlendMode === "additive" && (X = null),
                X === null ? O(f, v) : X && X.isColor && (O(X, 1),
                Z = !0),
                (u.autoClear || Z) && u.clear(u.autoClearColor, u.autoClearDepth, u.autoClearStencil),
                X && (X.isCubeTexture || X.mapping === ys) ? (w === void 0 && (w = new Es(new Jl(1,1,1),new ja({
                    name: "BackgroundCubeMaterial",
                    uniforms: Du(Sa.backgroundCube.uniforms),
                    vertexShader: Sa.backgroundCube.vertexShader,
                    fragmentShader: Sa.backgroundCube.fragmentShader,
                    side: $,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                w.geometry.deleteAttribute("normal"),
                w.geometry.deleteAttribute("uv"),
                w.onBeforeRender = function(be, Me, J) {
                    this.matrixWorld.copyPosition(J.matrixWorld)
                }
                ,
                Object.defineProperty(w.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }),
                a.update(w)),
                w.material.uniforms.envMap.value = X,
                w.material.uniforms.flipEnvMap.value = X.isCubeTexture && X.isRenderTargetTexture === !1 ? -1 : 1,
                w.material.uniforms.backgroundBlurriness.value = Q.backgroundBlurriness,
                w.material.uniforms.backgroundIntensity.value = Q.backgroundIntensity,
                w.material.toneMapped = X.encoding !== cn,
                (P !== X || M !== X.version || I !== u.toneMapping) && (w.material.needsUpdate = !0,
                P = X,
                M = X.version,
                I = u.toneMapping),
                w.layers.enableAll(),
                k.unshift(w, w.geometry, w.material, 0, 0, null)) : X && X.isTexture && (x === void 0 && (x = new Es(new Bu(2,2),new ja({
                    name: "BackgroundMaterial",
                    uniforms: Du(Sa.background.uniforms),
                    vertexShader: Sa.background.vertexShader,
                    fragmentShader: Sa.background.fragmentShader,
                    side: Se,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                x.geometry.deleteAttribute("normal"),
                Object.defineProperty(x.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }),
                a.update(x)),
                x.material.uniforms.t2D.value = X,
                x.material.uniforms.backgroundIntensity.value = Q.backgroundIntensity,
                x.material.toneMapped = X.encoding !== cn,
                X.matrixAutoUpdate === !0 && X.updateMatrix(),
                x.material.uniforms.uvTransform.value.copy(X.matrix),
                (P !== X || M !== X.version || I !== u.toneMapping) && (x.material.needsUpdate = !0,
                P = X,
                M = X.version,
                I = u.toneMapping),
                x.layers.enableAll(),
                k.unshift(x, x.geometry, x.material, 0, 0, null))
            }
            function O(k, Q) {
                k.getRGB(op, kx(u)),
                o.buffers.color.setClear(op.r, op.g, op.b, Q, d)
            }
            return {
                getClearColor: function() {
                    return f
                },
                setClearColor: function(k, Q=1) {
                    f.set(k),
                    v = Q,
                    O(f, v)
                },
                getClearAlpha: function() {
                    return v
                },
                setClearAlpha: function(k) {
                    v = k,
                    O(f, v)
                },
                render: z
            }
        }
        function c2(u, e, i, o) {
            const a = u.getParameter(u.MAX_VERTEX_ATTRIBS)
              , c = o.isWebGL2 ? null : e.get("OES_vertex_array_object")
              , d = o.isWebGL2 || c !== null
              , f = {}
              , v = k(null);
            let x = v
              , w = !1;
            function P(ze, st, yt, It, ht) {
                let Ot = !1;
                if (d) {
                    const Mt = O(It, yt, st);
                    x !== Mt && (x = Mt,
                    I(x.object)),
                    Ot = Q(ze, It, yt, ht),
                    Ot && Z(ze, It, yt, ht)
                } else {
                    const Mt = st.wireframe === !0;
                    (x.geometry !== It.id || x.program !== yt.id || x.wireframe !== Mt) && (x.geometry = It.id,
                    x.program = yt.id,
                    x.wireframe = Mt,
                    Ot = !0)
                }
                ht !== null && i.update(ht, u.ELEMENT_ARRAY_BUFFER),
                (Ot || w) && (w = !1,
                J(ze, st, yt, It),
                ht !== null && u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, i.get(ht).buffer))
            }
            function M() {
                return o.isWebGL2 ? u.createVertexArray() : c.createVertexArrayOES()
            }
            function I(ze) {
                return o.isWebGL2 ? u.bindVertexArray(ze) : c.bindVertexArrayOES(ze)
            }
            function z(ze) {
                return o.isWebGL2 ? u.deleteVertexArray(ze) : c.deleteVertexArrayOES(ze)
            }
            function O(ze, st, yt) {
                const It = yt.wireframe === !0;
                let ht = f[ze.id];
                ht === void 0 && (ht = {},
                f[ze.id] = ht);
                let Ot = ht[st.id];
                Ot === void 0 && (Ot = {},
                ht[st.id] = Ot);
                let Mt = Ot[It];
                return Mt === void 0 && (Mt = k(M()),
                Ot[It] = Mt),
                Mt
            }
            function k(ze) {
                const st = []
                  , yt = []
                  , It = [];
                for (let ht = 0; ht < a; ht++)
                    st[ht] = 0,
                    yt[ht] = 0,
                    It[ht] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: st,
                    enabledAttributes: yt,
                    attributeDivisors: It,
                    object: ze,
                    attributes: {},
                    index: null
                }
            }
            function Q(ze, st, yt, It) {
                const ht = x.attributes
                  , Ot = st.attributes;
                let Mt = 0;
                const Ln = yt.getAttributes();
                for (const Ye in Ln)
                    if (Ln[Ye].location >= 0) {
                        const tn = ht[Ye];
                        let De = Ot[Ye];
                        if (De === void 0 && (Ye === "instanceMatrix" && ze.instanceMatrix && (De = ze.instanceMatrix),
                        Ye === "instanceColor" && ze.instanceColor && (De = ze.instanceColor)),
                        tn === void 0 || tn.attribute !== De || De && tn.data !== De.data)
                            return !0;
                        Mt++
                    }
                return x.attributesNum !== Mt || x.index !== It
            }
            function Z(ze, st, yt, It) {
                const ht = {}
                  , Ot = st.attributes;
                let Mt = 0;
                const Ln = yt.getAttributes();
                for (const Ye in Ln)
                    if (Ln[Ye].location >= 0) {
                        let tn = Ot[Ye];
                        tn === void 0 && (Ye === "instanceMatrix" && ze.instanceMatrix && (tn = ze.instanceMatrix),
                        Ye === "instanceColor" && ze.instanceColor && (tn = ze.instanceColor));
                        const De = {};
                        De.attribute = tn,
                        tn && tn.data && (De.data = tn.data),
                        ht[Ye] = De,
                        Mt++
                    }
                x.attributes = ht,
                x.attributesNum = Mt,
                x.index = It
            }
            function X() {
                const ze = x.newAttributes;
                for (let st = 0, yt = ze.length; st < yt; st++)
                    ze[st] = 0
            }
            function K(ze) {
                de(ze, 0)
            }
            function de(ze, st) {
                const yt = x.newAttributes
                  , It = x.enabledAttributes
                  , ht = x.attributeDivisors;
                yt[ze] = 1,
                It[ze] === 0 && (u.enableVertexAttribArray(ze),
                It[ze] = 1),
                ht[ze] !== st && ((o.isWebGL2 ? u : e.get("ANGLE_instanced_arrays"))[o.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](ze, st),
                ht[ze] = st)
            }
            function be() {
                const ze = x.newAttributes
                  , st = x.enabledAttributes;
                for (let yt = 0, It = st.length; yt < It; yt++)
                    st[yt] !== ze[yt] && (u.disableVertexAttribArray(yt),
                    st[yt] = 0)
            }
            function Me(ze, st, yt, It, ht, Ot) {
                o.isWebGL2 === !0 && (yt === u.INT || yt === u.UNSIGNED_INT) ? u.vertexAttribIPointer(ze, st, yt, ht, Ot) : u.vertexAttribPointer(ze, st, yt, It, ht, Ot)
            }
            function J(ze, st, yt, It) {
                if (o.isWebGL2 === !1 && (ze.isInstancedMesh || It.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
                    return;
                X();
                const ht = It.attributes
                  , Ot = yt.getAttributes()
                  , Mt = st.defaultAttributeValues;
                for (const Ln in Ot) {
                    const Ye = Ot[Ln];
                    if (Ye.location >= 0) {
                        let Pt = ht[Ln];
                        if (Pt === void 0 && (Ln === "instanceMatrix" && ze.instanceMatrix && (Pt = ze.instanceMatrix),
                        Ln === "instanceColor" && ze.instanceColor && (Pt = ze.instanceColor)),
                        Pt !== void 0) {
                            const tn = Pt.normalized
                              , De = Pt.itemSize
                              , Cn = i.get(Pt);
                            if (Cn === void 0)
                                continue;
                            const on = Cn.buffer
                              , Mn = Cn.type
                              , In = Cn.bytesPerElement;
                            if (Pt.isInterleavedBufferAttribute) {
                                const Un = Pt.data
                                  , ei = Un.stride
                                  , dt = Pt.offset;
                                if (Un.isInstancedInterleavedBuffer) {
                                    for (let Tt = 0; Tt < Ye.locationSize; Tt++)
                                        de(Ye.location + Tt, Un.meshPerAttribute);
                                    ze.isInstancedMesh !== !0 && It._maxInstanceCount === void 0 && (It._maxInstanceCount = Un.meshPerAttribute * Un.count)
                                } else
                                    for (let Tt = 0; Tt < Ye.locationSize; Tt++)
                                        K(Ye.location + Tt);
                                u.bindBuffer(u.ARRAY_BUFFER, on);
                                for (let Tt = 0; Tt < Ye.locationSize; Tt++)
                                    Me(Ye.location + Tt, De / Ye.locationSize, Mn, tn, ei * In, (dt + De / Ye.locationSize * Tt) * In)
                            } else {
                                if (Pt.isInstancedBufferAttribute) {
                                    for (let Un = 0; Un < Ye.locationSize; Un++)
                                        de(Ye.location + Un, Pt.meshPerAttribute);
                                    ze.isInstancedMesh !== !0 && It._maxInstanceCount === void 0 && (It._maxInstanceCount = Pt.meshPerAttribute * Pt.count)
                                } else
                                    for (let Un = 0; Un < Ye.locationSize; Un++)
                                        K(Ye.location + Un);
                                u.bindBuffer(u.ARRAY_BUFFER, on);
                                for (let Un = 0; Un < Ye.locationSize; Un++)
                                    Me(Ye.location + Un, De / Ye.locationSize, Mn, tn, De * In, De / Ye.locationSize * Un * In)
                            }
                        } else if (Mt !== void 0) {
                            const tn = Mt[Ln];
                            if (tn !== void 0)
                                switch (tn.length) {
                                case 2:
                                    u.vertexAttrib2fv(Ye.location, tn);
                                    break;
                                case 3:
                                    u.vertexAttrib3fv(Ye.location, tn);
                                    break;
                                case 4:
                                    u.vertexAttrib4fv(Ye.location, tn);
                                    break;
                                default:
                                    u.vertexAttrib1fv(Ye.location, tn)
                                }
                        }
                    }
                }
                be()
            }
            function ge() {
                lt();
                for (const ze in f) {
                    const st = f[ze];
                    for (const yt in st) {
                        const It = st[yt];
                        for (const ht in It)
                            z(It[ht].object),
                            delete It[ht];
                        delete st[yt]
                    }
                    delete f[ze]
                }
            }
            function Le(ze) {
                if (f[ze.id] === void 0)
                    return;
                const st = f[ze.id];
                for (const yt in st) {
                    const It = st[yt];
                    for (const ht in It)
                        z(It[ht].object),
                        delete It[ht];
                    delete st[yt]
                }
                delete f[ze.id]
            }
            function tt(ze) {
                for (const st in f) {
                    const yt = f[st];
                    if (yt[ze.id] === void 0)
                        continue;
                    const It = yt[ze.id];
                    for (const ht in It)
                        z(It[ht].object),
                        delete It[ht];
                    delete yt[ze.id]
                }
            }
            function lt() {
                je(),
                w = !0,
                x !== v && (x = v,
                I(x.object))
            }
            function je() {
                v.geometry = null,
                v.program = null,
                v.wireframe = !1
            }
            return {
                setup: P,
                reset: lt,
                resetDefaultState: je,
                dispose: ge,
                releaseStatesOfGeometry: Le,
                releaseStatesOfProgram: tt,
                initAttributes: X,
                enableAttribute: K,
                disableUnusedAttributes: be
            }
        }
        function u2(u, e, i, o) {
            const a = o.isWebGL2;
            let c;
            function d(x) {
                c = x
            }
            function f(x, w) {
                u.drawArrays(c, x, w),
                i.update(w, c, 1)
            }
            function v(x, w, P) {
                if (P === 0)
                    return;
                let M, I;
                if (a)
                    M = u,
                    I = "drawArraysInstanced";
                else if (M = e.get("ANGLE_instanced_arrays"),
                I = "drawArraysInstancedANGLE",
                M === null) {
                    console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    return
                }
                M[I](c, x, w, P),
                i.update(w, c, P)
            }
            this.setMode = d,
            this.render = f,
            this.renderInstances = v
        }
        function h2(u, e, i) {
            let o;
            function a() {
                if (o !== void 0)
                    return o;
                if (e.has("EXT_texture_filter_anisotropic") === !0) {
                    const Me = e.get("EXT_texture_filter_anisotropic");
                    o = u.getParameter(Me.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else
                    o = 0;
                return o
            }
            function c(Me) {
                if (Me === "highp") {
                    if (u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_FLOAT).precision > 0 && u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_FLOAT).precision > 0)
                        return "highp";
                    Me = "mediump"
                }
                return Me === "mediump" && u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_FLOAT).precision > 0 && u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const d = typeof WebGL2RenderingContext < "u" && u instanceof WebGL2RenderingContext;
            let f = i.precision !== void 0 ? i.precision : "highp";
            const v = c(f);
            v !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", v, "instead."),
            f = v);
            const x = d || e.has("WEBGL_draw_buffers")
              , w = i.logarithmicDepthBuffer === !0
              , P = u.getParameter(u.MAX_TEXTURE_IMAGE_UNITS)
              , M = u.getParameter(u.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
              , I = u.getParameter(u.MAX_TEXTURE_SIZE)
              , z = u.getParameter(u.MAX_CUBE_MAP_TEXTURE_SIZE)
              , O = u.getParameter(u.MAX_VERTEX_ATTRIBS)
              , k = u.getParameter(u.MAX_VERTEX_UNIFORM_VECTORS)
              , Q = u.getParameter(u.MAX_VARYING_VECTORS)
              , Z = u.getParameter(u.MAX_FRAGMENT_UNIFORM_VECTORS)
              , X = M > 0
              , K = d || e.has("OES_texture_float")
              , de = X && K
              , be = d ? u.getParameter(u.MAX_SAMPLES) : 0;
            return {
                isWebGL2: d,
                drawBuffers: x,
                getMaxAnisotropy: a,
                getMaxPrecision: c,
                precision: f,
                logarithmicDepthBuffer: w,
                maxTextures: P,
                maxVertexTextures: M,
                maxTextureSize: I,
                maxCubemapSize: z,
                maxAttributes: O,
                maxVertexUniforms: k,
                maxVaryings: Q,
                maxFragmentUniforms: Z,
                vertexTextures: X,
                floatFragmentTextures: K,
                floatVertexTextures: de,
                maxSamples: be
            }
        }
        function d2(u) {
            const e = this;
            let i = null
              , o = 0
              , a = !1
              , c = !1;
            const d = new $l
              , f = new Cr
              , v = {
                value: null,
                needsUpdate: !1
            };
            this.uniform = v,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(P, M) {
                const I = P.length !== 0 || M || o !== 0 || a;
                return a = M,
                o = P.length,
                I
            }
            ,
            this.beginShadows = function() {
                c = !0,
                w(null)
            }
            ,
            this.endShadows = function() {
                c = !1
            }
            ,
            this.setGlobalState = function(P, M) {
                i = w(P, M, 0)
            }
            ,
            this.setState = function(P, M, I) {
                const z = P.clippingPlanes
                  , O = P.clipIntersection
                  , k = P.clipShadows
                  , Q = u.get(P);
                if (!a || z === null || z.length === 0 || c && !k)
                    c ? w(null) : x();
                else {
                    const Z = c ? 0 : o
                      , X = Z * 4;
                    let K = Q.clippingState || null;
                    v.value = K,
                    K = w(z, M, X, I);
                    for (let de = 0; de !== X; ++de)
                        K[de] = i[de];
                    Q.clippingState = K,
                    this.numIntersection = O ? this.numPlanes : 0,
                    this.numPlanes += Z
                }
            }
            ;
            function x() {
                v.value !== i && (v.value = i,
                v.needsUpdate = o > 0),
                e.numPlanes = o,
                e.numIntersection = 0
            }
            function w(P, M, I, z) {
                const O = P !== null ? P.length : 0;
                let k = null;
                if (O !== 0) {
                    if (k = v.value,
                    z !== !0 || k === null) {
                        const Q = I + O * 4
                          , Z = M.matrixWorldInverse;
                        f.getNormalMatrix(Z),
                        (k === null || k.length < Q) && (k = new Float32Array(Q));
                        for (let X = 0, K = I; X !== O; ++X,
                        K += 4)
                            d.copy(P[X]).applyMatrix4(Z, f),
                            d.normal.toArray(k, K),
                            k[K + 3] = d.constant
                    }
                    v.value = k,
                    v.needsUpdate = !0
                }
                return e.numPlanes = O,
                e.numIntersection = 0,
                k
            }
        }
        function f2(u) {
            let e = new WeakMap;
            function i(d, f) {
                return f === ts ? d.mapping = vr : f === Gr && (d.mapping = Oi),
                d
            }
            function o(d) {
                if (d && d.isTexture && d.isRenderTargetTexture === !1) {
                    const f = d.mapping;
                    if (f === ts || f === Gr)
                        if (e.has(d)) {
                            const v = e.get(d).texture;
                            return i(v, d.mapping)
                        } else {
                            const v = d.image;
                            if (v && v.height > 0) {
                                const x = new zx(v.height / 2);
                                return x.fromEquirectangularTexture(u, d),
                                e.set(d, x),
                                d.addEventListener("dispose", a),
                                i(x.texture, d.mapping)
                            } else
                                return null
                        }
                }
                return d
            }
            function a(d) {
                const f = d.target;
                f.removeEventListener("dispose", a);
                const v = e.get(f);
                v !== void 0 && (e.delete(f),
                v.dispose())
            }
            function c() {
                e = new WeakMap
            }
            return {
                get: o,
                dispose: c
            }
        }
        class ap extends ip {
            constructor(e=-1, i=1, o=1, a=-1, c=.1, d=2e3) {
                super(),
                this.isOrthographicCamera = !0,
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = e,
                this.right = i,
                this.top = o,
                this.bottom = a,
                this.near = c,
                this.far = d,
                this.updateProjectionMatrix()
            }
            copy(e, i) {
                return super.copy(e, i),
                this.left = e.left,
                this.right = e.right,
                this.top = e.top,
                this.bottom = e.bottom,
                this.near = e.near,
                this.far = e.far,
                this.zoom = e.zoom,
                this.view = e.view === null ? null : Object.assign({}, e.view),
                this
            }
            setViewOffset(e, i, o, a, c, d) {
                this.view === null && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = e,
                this.view.fullHeight = i,
                this.view.offsetX = o,
                this.view.offsetY = a,
                this.view.width = c,
                this.view.height = d,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                this.view !== null && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = (this.right - this.left) / (2 * this.zoom)
                  , i = (this.top - this.bottom) / (2 * this.zoom)
                  , o = (this.right + this.left) / 2
                  , a = (this.top + this.bottom) / 2;
                let c = o - e
                  , d = o + e
                  , f = a + i
                  , v = a - i;
                if (this.view !== null && this.view.enabled) {
                    const x = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , w = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    c += x * this.view.offsetX,
                    d = c + x * this.view.width,
                    f -= w * this.view.offsetY,
                    v = f - w * this.view.height
                }
                this.projectionMatrix.makeOrthographic(c, d, f, v, this.near, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const i = super.toJSON(e);
                return i.object.zoom = this.zoom,
                i.object.left = this.left,
                i.object.right = this.right,
                i.object.top = this.top,
                i.object.bottom = this.bottom,
                i.object.near = this.near,
                i.object.far = this.far,
                this.view !== null && (i.object.view = Object.assign({}, this.view)),
                i
            }
        }
        const Fu = 4
          , Hx = [.125, .215, .35, .446, .526, .582]
          , zc = 20
          , t0 = new ap
          , Vx = new gn;
        let n0 = null;
        const Gc = (1 + Math.sqrt(5)) / 2
          , ku = 1 / Gc
          , Wx = [new me(1,1,1), new me(-1,1,1), new me(1,1,-1), new me(-1,1,-1), new me(0,Gc,ku), new me(0,Gc,-ku), new me(ku,0,Gc), new me(-ku,0,Gc), new me(Gc,ku,0), new me(-Gc,ku,0)];
        class i0 {
            constructor(e) {
                this._renderer = e,
                this._pingPongRenderTarget = null,
                this._lodMax = 0,
                this._cubeSize = 0,
                this._lodPlanes = [],
                this._sizeLods = [],
                this._sigmas = [],
                this._blurMaterial = null,
                this._cubemapMaterial = null,
                this._equirectMaterial = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(e, i=0, o=.1, a=100) {
                n0 = this._renderer.getRenderTarget(),
                this._setSize(256);
                const c = this._allocateTargets();
                return c.depthBuffer = !0,
                this._sceneToCubeUV(e, o, a, c),
                i > 0 && this._blur(c, 0, 0, i),
                this._applyPMREM(c),
                this._cleanup(c),
                c
            }
            fromEquirectangular(e, i=null) {
                return this._fromTexture(e, i)
            }
            fromCubemap(e, i=null) {
                return this._fromTexture(e, i)
            }
            compileCubemapShader() {
                this._cubemapMaterial === null && (this._cubemapMaterial = Yx(),
                this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                this._equirectMaterial === null && (this._equirectMaterial = Xx(),
                this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(),
                this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
                this._equirectMaterial !== null && this._equirectMaterial.dispose()
            }
            _setSize(e) {
                this._lodMax = Math.floor(Math.log2(e)),
                this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                this._blurMaterial !== null && this._blurMaterial.dispose(),
                this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
                for (let e = 0; e < this._lodPlanes.length; e++)
                    this._lodPlanes[e].dispose()
            }
            _cleanup(e) {
                this._renderer.setRenderTarget(n0),
                e.scissorTest = !1,
                lp(e, 0, 0, e.width, e.height)
            }
            _fromTexture(e, i) {
                e.mapping === vr || e.mapping === Oi ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                n0 = this._renderer.getRenderTarget();
                const o = i || this._allocateTargets();
                return this._textureToCubeUV(e, o),
                this._applyPMREM(o),
                this._cleanup(o),
                o
            }
            _allocateTargets() {
                const e = 3 * Math.max(this._cubeSize, 112)
                  , i = 4 * this._cubeSize
                  , o = {
                    magFilter: Hi,
                    minFilter: Hi,
                    generateMipmaps: !1,
                    type: So,
                    format: Xr,
                    encoding: nn,
                    depthBuffer: !1
                }
                  , a = jx(e, i, o);
                if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== i) {
                    this._pingPongRenderTarget !== null && this._dispose(),
                    this._pingPongRenderTarget = jx(e, i, o);
                    const {_lodMax: c} = this;
                    ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = p2(c)),
                    this._blurMaterial = m2(c, e, i)
                }
                return a
            }
            _compileMaterial(e) {
                const i = new Es(this._lodPlanes[0],e);
                this._renderer.compile(i, t0)
            }
            _sceneToCubeUV(e, i, o, a) {
                const f = new Ms(90,1,i,o)
                  , v = [1, -1, 1, 1, 1, 1]
                  , x = [1, 1, 1, -1, -1, -1]
                  , w = this._renderer
                  , P = w.autoClear
                  , M = w.toneMapping;
                w.getClearColor(Vx),
                w.toneMapping = Gt,
                w.autoClear = !1;
                const I = new ql({
                    name: "PMREM.Background",
                    side: $,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , z = new Es(new Jl,I);
                let O = !1;
                const k = e.background;
                k ? k.isColor && (I.color.copy(k),
                e.background = null,
                O = !0) : (I.color.copy(Vx),
                O = !0);
                for (let Q = 0; Q < 6; Q++) {
                    const Z = Q % 3;
                    Z === 0 ? (f.up.set(0, v[Q], 0),
                    f.lookAt(x[Q], 0, 0)) : Z === 1 ? (f.up.set(0, 0, v[Q]),
                    f.lookAt(0, x[Q], 0)) : (f.up.set(0, v[Q], 0),
                    f.lookAt(0, 0, x[Q]));
                    const X = this._cubeSize;
                    lp(a, Z * X, Q > 2 ? X : 0, X, X),
                    w.setRenderTarget(a),
                    O && w.render(z, f),
                    w.render(e, f)
                }
                z.geometry.dispose(),
                z.material.dispose(),
                w.toneMapping = M,
                w.autoClear = P,
                e.background = k
            }
            _textureToCubeUV(e, i) {
                const o = this._renderer
                  , a = e.mapping === vr || e.mapping === Oi;
                a ? (this._cubemapMaterial === null && (this._cubemapMaterial = Yx()),
                this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Xx());
                const c = a ? this._cubemapMaterial : this._equirectMaterial
                  , d = new Es(this._lodPlanes[0],c)
                  , f = c.uniforms;
                f.envMap.value = e;
                const v = this._cubeSize;
                lp(i, 0, 0, 3 * v, 2 * v),
                o.setRenderTarget(i),
                o.render(d, t0)
            }
            _applyPMREM(e) {
                const i = this._renderer
                  , o = i.autoClear;
                i.autoClear = !1;
                for (let a = 1; a < this._lodPlanes.length; a++) {
                    const c = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1])
                      , d = Wx[(a - 1) % Wx.length];
                    this._blur(e, a - 1, a, c, d)
                }
                i.autoClear = o
            }
            _blur(e, i, o, a, c) {
                const d = this._pingPongRenderTarget;
                this._halfBlur(e, d, i, o, a, "latitudinal", c),
                this._halfBlur(d, e, o, o, a, "longitudinal", c)
            }
            _halfBlur(e, i, o, a, c, d, f) {
                const v = this._renderer
                  , x = this._blurMaterial;
                d !== "latitudinal" && d !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
                const w = 3
                  , P = new Es(this._lodPlanes[a],x)
                  , M = x.uniforms
                  , I = this._sizeLods[o] - 1
                  , z = isFinite(c) ? Math.PI / (2 * I) : 2 * Math.PI / (2 * zc - 1)
                  , O = c / z
                  , k = isFinite(c) ? 1 + Math.floor(w * O) : zc;
                k > zc && console.warn(`sigmaRadians, ${c}, is too large and will clip, as it requested ${k} samples when the maximum is set to ${zc}`);
                const Q = [];
                let Z = 0;
                for (let Me = 0; Me < zc; ++Me) {
                    const J = Me / O
                      , ge = Math.exp(-J * J / 2);
                    Q.push(ge),
                    Me === 0 ? Z += ge : Me < k && (Z += 2 * ge)
                }
                for (let Me = 0; Me < Q.length; Me++)
                    Q[Me] = Q[Me] / Z;
                M.envMap.value = e.texture,
                M.samples.value = k,
                M.weights.value = Q,
                M.latitudinal.value = d === "latitudinal",
                f && (M.poleAxis.value = f);
                const {_lodMax: X} = this;
                M.dTheta.value = z,
                M.mipInt.value = X - o;
                const K = this._sizeLods[a]
                  , de = 3 * K * (a > X - Fu ? a - X + Fu : 0)
                  , be = 4 * (this._cubeSize - K);
                lp(i, de, be, 3 * K, 2 * K),
                v.setRenderTarget(i),
                v.render(P, t0)
            }
        }
        function p2(u) {
            const e = []
              , i = []
              , o = [];
            let a = u;
            const c = u - Fu + 1 + Hx.length;
            for (let d = 0; d < c; d++) {
                const f = Math.pow(2, a);
                i.push(f);
                let v = 1 / f;
                d > u - Fu ? v = Hx[d - u + Fu - 1] : d === 0 && (v = 0),
                o.push(v);
                const x = 1 / (f - 2)
                  , w = -x
                  , P = 1 + x
                  , M = [w, w, P, w, P, P, w, w, P, P, w, P]
                  , I = 6
                  , z = 6
                  , O = 3
                  , k = 2
                  , Q = 1
                  , Z = new Float32Array(O * z * I)
                  , X = new Float32Array(k * z * I)
                  , K = new Float32Array(Q * z * I);
                for (let be = 0; be < I; be++) {
                    const Me = be % 3 * 2 / 3 - 1
                      , J = be > 2 ? 0 : -1
                      , ge = [Me, J, 0, Me + 2 / 3, J, 0, Me + 2 / 3, J + 1, 0, Me, J, 0, Me + 2 / 3, J + 1, 0, Me, J + 1, 0];
                    Z.set(ge, O * z * be),
                    X.set(M, k * z * be);
                    const Le = [be, be, be, be, be, be];
                    K.set(Le, Q * z * be)
                }
                const de = new Ai;
                de.setAttribute("position", new dr(Z,O)),
                de.setAttribute("uv", new dr(X,k)),
                de.setAttribute("faceIndex", new dr(K,Q)),
                e.push(de),
                a > Fu && a--
            }
            return {
                lodPlanes: e,
                sizeLods: i,
                sigmas: o
            }
        }
        function jx(u, e, i) {
            const o = new ki(u,e,i);
            return o.texture.mapping = ys,
            o.texture.name = "PMREM.cubeUv",
            o.scissorTest = !0,
            o
        }
        function lp(u, e, i, o, a) {
            u.viewport.set(e, i, o, a),
            u.scissor.set(e, i, o, a)
        }
        function m2(u, e, i) {
            const o = new Float32Array(zc)
              , a = new me(0,1,0);
            return new ja({
                name: "SphericalGaussianBlur",
                defines: {
                    n: zc,
                    CUBEUV_TEXEL_WIDTH: 1 / e,
                    CUBEUV_TEXEL_HEIGHT: 1 / i,
                    CUBEUV_MAX_MIP: `${u}.0`
                },
                uniforms: {
                    envMap: {
                        value: null
                    },
                    samples: {
                        value: 1
                    },
                    weights: {
                        value: o
                    },
                    latitudinal: {
                        value: !1
                    },
                    dTheta: {
                        value: 0
                    },
                    mipInt: {
                        value: 0
                    },
                    poleAxis: {
                        value: a
                    }
                },
                vertexShader: r0(),
                fragmentShader: `

            precision mediump float;
            precision mediump int;

            varying vec3 vOutputDirection;

            uniform sampler2D envMap;
            uniform int samples;
            uniform float weights[ n ];
            uniform bool latitudinal;
            uniform float dTheta;
            uniform float mipInt;
            uniform vec3 poleAxis;

            #define ENVMAP_TYPE_CUBE_UV
            #include <cube_uv_reflection_fragment>

            vec3 getSample( float theta, vec3 axis ) {

                float cosTheta = cos( theta );
                // Rodrigues' axis-angle rotation
                vec3 sampleDirection = vOutputDirection * cosTheta
                    + cross( axis, vOutputDirection ) * sin( theta )
                    + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

                return bilinearCubeUV( envMap, sampleDirection, mipInt );

            }

            void main() {

                vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

                if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

                    axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

                }

                axis = normalize( axis );

                gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
                gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

                for ( int i = 1; i < n; i++ ) {

                    if ( i >= samples ) {

                        break;

                    }

                    float theta = dTheta * float( i );
                    gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
                    gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

                }

            }
        `,
                blending: ie,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Xx() {
            return new ja({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: r0(),
                fragmentShader: `

            precision mediump float;
            precision mediump int;

            varying vec3 vOutputDirection;

            uniform sampler2D envMap;

            #include <common>

            void main() {

                vec3 outputDirection = normalize( vOutputDirection );
                vec2 uv = equirectUv( outputDirection );

                gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

            }
        `,
                blending: ie,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Yx() {
            return new ja({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: r0(),
                fragmentShader: `

            precision mediump float;
            precision mediump int;

            uniform float flipEnvMap;

            varying vec3 vOutputDirection;

            uniform samplerCube envMap;

            void main() {

                gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

            }
        `,
                blending: ie,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function r0() {
            return `

        precision mediump float;
        precision mediump int;

        attribute float faceIndex;

        varying vec3 vOutputDirection;

        // RH coordinate system; PMREM face-indexing convention
        vec3 getDirection( vec2 uv, float face ) {

            uv = 2.0 * uv - 1.0;

            vec3 direction = vec3( uv, 1.0 );

            if ( face == 0.0 ) {

                direction = direction.zyx; // ( 1, v, u ) pos x

            } else if ( face == 1.0 ) {

                direction = direction.xzy;
                direction.xz *= -1.0; // ( -u, 1, -v ) pos y

            } else if ( face == 2.0 ) {

                direction.x *= -1.0; // ( -u, v, 1 ) pos z

            } else if ( face == 3.0 ) {

                direction = direction.zyx;
                direction.xz *= -1.0; // ( -1, v, -u ) neg x

            } else if ( face == 4.0 ) {

                direction = direction.xzy;
                direction.xy *= -1.0; // ( -u, -1, v ) neg y

            } else if ( face == 5.0 ) {

                direction.z *= -1.0; // ( u, v, -1 ) neg z

            }

            return direction;

        }

        void main() {

            vOutputDirection = getDirection( uv, faceIndex );
            gl_Position = vec4( position, 1.0 );

        }
    `
        }
        function g2(u) {
            let e = new WeakMap
              , i = null;
            function o(f) {
                if (f && f.isTexture) {
                    const v = f.mapping
                      , x = v === ts || v === Gr
                      , w = v === vr || v === Oi;
                    if (x || w)
                        if (f.isRenderTargetTexture && f.needsPMREMUpdate === !0) {
                            f.needsPMREMUpdate = !1;
                            let P = e.get(f);
                            return i === null && (i = new i0(u)),
                            P = x ? i.fromEquirectangular(f, P) : i.fromCubemap(f, P),
                            e.set(f, P),
                            P.texture
                        } else {
                            if (e.has(f))
                                return e.get(f).texture;
                            {
                                const P = f.image;
                                if (x && P && P.height > 0 || w && P && a(P)) {
                                    i === null && (i = new i0(u));
                                    const M = x ? i.fromEquirectangular(f) : i.fromCubemap(f);
                                    return e.set(f, M),
                                    f.addEventListener("dispose", c),
                                    M.texture
                                } else
                                    return null
                            }
                        }
                }
                return f
            }
            function a(f) {
                let v = 0;
                const x = 6;
                for (let w = 0; w < x; w++)
                    f[w] !== void 0 && v++;
                return v === x
            }
            function c(f) {
                const v = f.target;
                v.removeEventListener("dispose", c);
                const x = e.get(v);
                x !== void 0 && (e.delete(v),
                x.dispose())
            }
            function d() {
                e = new WeakMap,
                i !== null && (i.dispose(),
                i = null)
            }
            return {
                get: o,
                dispose: d
            }
        }
        function v2(u) {
            const e = {};
            function i(o) {
                if (e[o] !== void 0)
                    return e[o];
                let a;
                switch (o) {
                case "WEBGL_depth_texture":
                    a = u.getExtension("WEBGL_depth_texture") || u.getExtension("MOZ_WEBGL_depth_texture") || u.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    a = u.getExtension("EXT_texture_filter_anisotropic") || u.getExtension("MOZ_EXT_texture_filter_anisotropic") || u.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    a = u.getExtension("WEBGL_compressed_texture_s3tc") || u.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || u.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    a = u.getExtension("WEBGL_compressed_texture_pvrtc") || u.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    a = u.getExtension(o)
                }
                return e[o] = a,
                a
            }
            return {
                has: function(o) {
                    return i(o) !== null
                },
                init: function(o) {
                    o.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"),
                    i("OES_texture_float"),
                    i("OES_texture_half_float"),
                    i("OES_texture_half_float_linear"),
                    i("OES_standard_derivatives"),
                    i("OES_element_index_uint"),
                    i("OES_vertex_array_object"),
                    i("ANGLE_instanced_arrays")),
                    i("OES_texture_float_linear"),
                    i("EXT_color_buffer_half_float"),
                    i("WEBGL_multisampled_render_to_texture")
                },
                get: function(o) {
                    const a = i(o);
                    return a === null && console.warn("THREE.WebGLRenderer: " + o + " extension not supported."),
                    a
                }
            }
        }
        function _2(u, e, i, o) {
            const a = {}
              , c = new WeakMap;
            function d(P) {
                const M = P.target;
                M.index !== null && e.remove(M.index);
                for (const z in M.attributes)
                    e.remove(M.attributes[z]);
                M.removeEventListener("dispose", d),
                delete a[M.id];
                const I = c.get(M);
                I && (e.remove(I),
                c.delete(M)),
                o.releaseStatesOfGeometry(M),
                M.isInstancedBufferGeometry === !0 && delete M._maxInstanceCount,
                i.memory.geometries--
            }
            function f(P, M) {
                return a[M.id] === !0 || (M.addEventListener("dispose", d),
                a[M.id] = !0,
                i.memory.geometries++),
                M
            }
            function v(P) {
                const M = P.attributes;
                for (const z in M)
                    e.update(M[z], u.ARRAY_BUFFER);
                const I = P.morphAttributes;
                for (const z in I) {
                    const O = I[z];
                    for (let k = 0, Q = O.length; k < Q; k++)
                        e.update(O[k], u.ARRAY_BUFFER)
                }
            }
            function x(P) {
                const M = []
                  , I = P.index
                  , z = P.attributes.position;
                let O = 0;
                if (I !== null) {
                    const Z = I.array;
                    O = I.version;
                    for (let X = 0, K = Z.length; X < K; X += 3) {
                        const de = Z[X + 0]
                          , be = Z[X + 1]
                          , Me = Z[X + 2];
                        M.push(de, be, be, Me, Me, de)
                    }
                } else {
                    const Z = z.array;
                    O = z.version;
                    for (let X = 0, K = Z.length / 3 - 1; X < K; X += 3) {
                        const de = X + 0
                          , be = X + 1
                          , Me = X + 2;
                        M.push(de, be, be, Me, Me, de)
                    }
                }
                const k = new (Ci(M) ? Zg : Kg)(M,1);
                k.version = O;
                const Q = c.get(P);
                Q && e.remove(Q),
                c.set(P, k)
            }
            function w(P) {
                const M = c.get(P);
                if (M) {
                    const I = P.index;
                    I !== null && M.version < I.version && x(P)
                } else
                    x(P);
                return c.get(P)
            }
            return {
                get: f,
                update: v,
                getWireframeAttribute: w
            }
        }
        function y2(u, e, i, o) {
            const a = o.isWebGL2;
            let c;
            function d(M) {
                c = M
            }
            let f, v;
            function x(M) {
                f = M.type,
                v = M.bytesPerElement
            }
            function w(M, I) {
                u.drawElements(c, I, f, M * v),
                i.update(I, c, 1)
            }
            function P(M, I, z) {
                if (z === 0)
                    return;
                let O, k;
                if (a)
                    O = u,
                    k = "drawElementsInstanced";
                else if (O = e.get("ANGLE_instanced_arrays"),
                k = "drawElementsInstancedANGLE",
                O === null) {
                    console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    return
                }
                O[k](c, I, f, M * v, z),
                i.update(I, c, z)
            }
            this.setMode = d,
            this.setIndex = x,
            this.render = w,
            this.renderInstances = P
        }
        function x2(u) {
            const e = {
                geometries: 0,
                textures: 0
            }
              , i = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            function o(c, d, f) {
                switch (i.calls++,
                d) {
                case u.TRIANGLES:
                    i.triangles += f * (c / 3);
                    break;
                case u.LINES:
                    i.lines += f * (c / 2);
                    break;
                case u.LINE_STRIP:
                    i.lines += f * (c - 1);
                    break;
                case u.LINE_LOOP:
                    i.lines += f * c;
                    break;
                case u.POINTS:
                    i.points += f * c;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", d);
                    break
                }
            }
            function a() {
                i.frame++,
                i.calls = 0,
                i.triangles = 0,
                i.points = 0,
                i.lines = 0
            }
            return {
                memory: e,
                render: i,
                programs: null,
                autoReset: !0,
                reset: a,
                update: o
            }
        }
        function b2(u, e) {
            return u[0] - e[0]
        }
        function w2(u, e) {
            return Math.abs(e[1]) - Math.abs(u[1])
        }
        function A2(u, e, i) {
            const o = {}
              , a = new Float32Array(8)
              , c = new WeakMap
              , d = new mn
              , f = [];
            for (let x = 0; x < 8; x++)
                f[x] = [x, 0];
            function v(x, w, P) {
                const M = x.morphTargetInfluences;
                if (e.isWebGL2 === !0) {
                    const z = w.morphAttributes.position || w.morphAttributes.normal || w.morphAttributes.color
                      , O = z !== void 0 ? z.length : 0;
                    let k = c.get(w);
                    if (k === void 0 || k.count !== O) {
                        let st = function() {
                            je.dispose(),
                            c.delete(w),
                            w.removeEventListener("dispose", st)
                        };
                        var I = st;
                        k !== void 0 && k.texture.dispose();
                        const X = w.morphAttributes.position !== void 0
                          , K = w.morphAttributes.normal !== void 0
                          , de = w.morphAttributes.color !== void 0
                          , be = w.morphAttributes.position || []
                          , Me = w.morphAttributes.normal || []
                          , J = w.morphAttributes.color || [];
                        let ge = 0;
                        X === !0 && (ge = 1),
                        K === !0 && (ge = 2),
                        de === !0 && (ge = 3);
                        let Le = w.attributes.position.count * ge
                          , tt = 1;
                        Le > e.maxTextureSize && (tt = Math.ceil(Le / e.maxTextureSize),
                        Le = e.maxTextureSize);
                        const lt = new Float32Array(Le * tt * 4 * O)
                          , je = new pr(lt,Le,tt,O);
                        je.type = Js,
                        je.needsUpdate = !0;
                        const ze = ge * 4;
                        for (let yt = 0; yt < O; yt++) {
                            const It = be[yt]
                              , ht = Me[yt]
                              , Ot = J[yt]
                              , Mt = Le * tt * 4 * yt;
                            for (let Ln = 0; Ln < It.count; Ln++) {
                                const Ye = Ln * ze;
                                X === !0 && (d.fromBufferAttribute(It, Ln),
                                lt[Mt + Ye + 0] = d.x,
                                lt[Mt + Ye + 1] = d.y,
                                lt[Mt + Ye + 2] = d.z,
                                lt[Mt + Ye + 3] = 0),
                                K === !0 && (d.fromBufferAttribute(ht, Ln),
                                lt[Mt + Ye + 4] = d.x,
                                lt[Mt + Ye + 5] = d.y,
                                lt[Mt + Ye + 6] = d.z,
                                lt[Mt + Ye + 7] = 0),
                                de === !0 && (d.fromBufferAttribute(Ot, Ln),
                                lt[Mt + Ye + 8] = d.x,
                                lt[Mt + Ye + 9] = d.y,
                                lt[Mt + Ye + 10] = d.z,
                                lt[Mt + Ye + 11] = Ot.itemSize === 4 ? d.w : 1)
                            }
                        }
                        k = {
                            count: O,
                            texture: je,
                            size: new _t(Le,tt)
                        },
                        c.set(w, k),
                        w.addEventListener("dispose", st)
                    }
                    let Q = 0;
                    for (let X = 0; X < M.length; X++)
                        Q += M[X];
                    const Z = w.morphTargetsRelative ? 1 : 1 - Q;
                    P.getUniforms().setValue(u, "morphTargetBaseInfluence", Z),
                    P.getUniforms().setValue(u, "morphTargetInfluences", M),
                    P.getUniforms().setValue(u, "morphTargetsTexture", k.texture, i),
                    P.getUniforms().setValue(u, "morphTargetsTextureSize", k.size)
                } else {
                    const z = M === void 0 ? 0 : M.length;
                    let O = o[w.id];
                    if (O === void 0 || O.length !== z) {
                        O = [];
                        for (let K = 0; K < z; K++)
                            O[K] = [K, 0];
                        o[w.id] = O
                    }
                    for (let K = 0; K < z; K++) {
                        const de = O[K];
                        de[0] = K,
                        de[1] = M[K]
                    }
                    O.sort(w2);
                    for (let K = 0; K < 8; K++)
                        K < z && O[K][1] ? (f[K][0] = O[K][0],
                        f[K][1] = O[K][1]) : (f[K][0] = Number.MAX_SAFE_INTEGER,
                        f[K][1] = 0);
                    f.sort(b2);
                    const k = w.morphAttributes.position
                      , Q = w.morphAttributes.normal;
                    let Z = 0;
                    for (let K = 0; K < 8; K++) {
                        const de = f[K]
                          , be = de[0]
                          , Me = de[1];
                        be !== Number.MAX_SAFE_INTEGER && Me ? (k && w.getAttribute("morphTarget" + K) !== k[be] && w.setAttribute("morphTarget" + K, k[be]),
                        Q && w.getAttribute("morphNormal" + K) !== Q[be] && w.setAttribute("morphNormal" + K, Q[be]),
                        a[K] = Me,
                        Z += Me) : (k && w.hasAttribute("morphTarget" + K) === !0 && w.deleteAttribute("morphTarget" + K),
                        Q && w.hasAttribute("morphNormal" + K) === !0 && w.deleteAttribute("morphNormal" + K),
                        a[K] = 0)
                    }
                    const X = w.morphTargetsRelative ? 1 : 1 - Z;
                    P.getUniforms().setValue(u, "morphTargetBaseInfluence", X),
                    P.getUniforms().setValue(u, "morphTargetInfluences", a)
                }
            }
            return {
                update: v
            }
        }
        function S2(u, e, i, o) {
            let a = new WeakMap;
            function c(v) {
                const x = o.render.frame
                  , w = v.geometry
                  , P = e.get(v, w);
                return a.get(P) !== x && (e.update(P),
                a.set(P, x)),
                v.isInstancedMesh && (v.hasEventListener("dispose", f) === !1 && v.addEventListener("dispose", f),
                i.update(v.instanceMatrix, u.ARRAY_BUFFER),
                v.instanceColor !== null && i.update(v.instanceColor, u.ARRAY_BUFFER)),
                P
            }
            function d() {
                a = new WeakMap
            }
            function f(v) {
                const x = v.target;
                x.removeEventListener("dispose", f),
                i.remove(x.instanceMatrix),
                x.instanceColor !== null && i.remove(x.instanceColor)
            }
            return {
                update: c,
                dispose: d
            }
        }
        const Qx = new $t
          , Kx = new pr
          , Zx = new ir
          , qx = new Zh
          , Jx = []
          , $x = []
          , e1 = new Float32Array(16)
          , t1 = new Float32Array(9)
          , n1 = new Float32Array(4);
        function Uu(u, e, i) {
            const o = u[0];
            if (o <= 0 || o > 0)
                return u;
            const a = e * i;
            let c = Jx[a];
            if (c === void 0 && (c = new Float32Array(a),
            Jx[a] = c),
            e !== 0) {
                o.toArray(c, 0);
                for (let d = 1, f = 0; d !== e; ++d)
                    f += i,
                    u[d].toArray(c, f)
            }
            return c
        }
        function rs(u, e) {
            if (u.length !== e.length)
                return !1;
            for (let i = 0, o = u.length; i < o; i++)
                if (u[i] !== e[i])
                    return !1;
            return !0
        }
        function ss(u, e) {
            for (let i = 0, o = e.length; i < o; i++)
                u[i] = e[i]
        }
        function cp(u, e) {
            let i = $x[e];
            i === void 0 && (i = new Int32Array(e),
            $x[e] = i);
            for (let o = 0; o !== e; ++o)
                i[o] = u.allocateTextureUnit();
            return i
        }
        function T2(u, e) {
            const i = this.cache;
            i[0] !== e && (u.uniform1f(this.addr, e),
            i[0] = e)
        }
        function E2(u, e) {
            const i = this.cache;
            if (e.x !== void 0)
                (i[0] !== e.x || i[1] !== e.y) && (u.uniform2f(this.addr, e.x, e.y),
                i[0] = e.x,
                i[1] = e.y);
            else {
                if (rs(i, e))
                    return;
                u.uniform2fv(this.addr, e),
                ss(i, e)
            }
        }
        function M2(u, e) {
            const i = this.cache;
            if (e.x !== void 0)
                (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (u.uniform3f(this.addr, e.x, e.y, e.z),
                i[0] = e.x,
                i[1] = e.y,
                i[2] = e.z);
            else if (e.r !== void 0)
                (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) && (u.uniform3f(this.addr, e.r, e.g, e.b),
                i[0] = e.r,
                i[1] = e.g,
                i[2] = e.b);
            else {
                if (rs(i, e))
                    return;
                u.uniform3fv(this.addr, e),
                ss(i, e)
            }
        }
        function C2(u, e) {
            const i = this.cache;
            if (e.x !== void 0)
                (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (u.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                i[0] = e.x,
                i[1] = e.y,
                i[2] = e.z,
                i[3] = e.w);
            else {
                if (rs(i, e))
                    return;
                u.uniform4fv(this.addr, e),
                ss(i, e)
            }
        }
        function P2(u, e) {
            const i = this.cache
              , o = e.elements;
            if (o === void 0) {
                if (rs(i, e))
                    return;
                u.uniformMatrix2fv(this.addr, !1, e),
                ss(i, e)
            } else {
                if (rs(i, o))
                    return;
                n1.set(o),
                u.uniformMatrix2fv(this.addr, !1, n1),
                ss(i, o)
            }
        }
        function R2(u, e) {
            const i = this.cache
              , o = e.elements;
            if (o === void 0) {
                if (rs(i, e))
                    return;
                u.uniformMatrix3fv(this.addr, !1, e),
                ss(i, e)
            } else {
                if (rs(i, o))
                    return;
                t1.set(o),
                u.uniformMatrix3fv(this.addr, !1, t1),
                ss(i, o)
            }
        }
        function D2(u, e) {
            const i = this.cache
              , o = e.elements;
            if (o === void 0) {
                if (rs(i, e))
                    return;
                u.uniformMatrix4fv(this.addr, !1, e),
                ss(i, e)
            } else {
                if (rs(i, o))
                    return;
                e1.set(o),
                u.uniformMatrix4fv(this.addr, !1, e1),
                ss(i, o)
            }
        }
        function L2(u, e) {
            const i = this.cache;
            i[0] !== e && (u.uniform1i(this.addr, e),
            i[0] = e)
        }
        function I2(u, e) {
            const i = this.cache;
            if (e.x !== void 0)
                (i[0] !== e.x || i[1] !== e.y) && (u.uniform2i(this.addr, e.x, e.y),
                i[0] = e.x,
                i[1] = e.y);
            else {
                if (rs(i, e))
                    return;
                u.uniform2iv(this.addr, e),
                ss(i, e)
            }
        }
        function O2(u, e) {
            const i = this.cache;
            if (e.x !== void 0)
                (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (u.uniform3i(this.addr, e.x, e.y, e.z),
                i[0] = e.x,
                i[1] = e.y,
                i[2] = e.z);
            else {
                if (rs(i, e))
                    return;
                u.uniform3iv(this.addr, e),
                ss(i, e)
            }
        }
        function B2(u, e) {
            const i = this.cache;
            if (e.x !== void 0)
                (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (u.uniform4i(this.addr, e.x, e.y, e.z, e.w),
                i[0] = e.x,
                i[1] = e.y,
                i[2] = e.z,
                i[3] = e.w);
            else {
                if (rs(i, e))
                    return;
                u.uniform4iv(this.addr, e),
                ss(i, e)
            }
        }
        function F2(u, e) {
            const i = this.cache;
            i[0] !== e && (u.uniform1ui(this.addr, e),
            i[0] = e)
        }
        function k2(u, e) {
            const i = this.cache;
            if (e.x !== void 0)
                (i[0] !== e.x || i[1] !== e.y) && (u.uniform2ui(this.addr, e.x, e.y),
                i[0] = e.x,
                i[1] = e.y);
            else {
                if (rs(i, e))
                    return;
                u.uniform2uiv(this.addr, e),
                ss(i, e)
            }
        }
        function U2(u, e) {
            const i = this.cache;
            if (e.x !== void 0)
                (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) && (u.uniform3ui(this.addr, e.x, e.y, e.z),
                i[0] = e.x,
                i[1] = e.y,
                i[2] = e.z);
            else {
                if (rs(i, e))
                    return;
                u.uniform3uiv(this.addr, e),
                ss(i, e)
            }
        }
        function N2(u, e) {
            const i = this.cache;
            if (e.x !== void 0)
                (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) && (u.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
                i[0] = e.x,
                i[1] = e.y,
                i[2] = e.z,
                i[3] = e.w);
            else {
                if (rs(i, e))
                    return;
                u.uniform4uiv(this.addr, e),
                ss(i, e)
            }
        }
        function z2(u, e, i) {
            const o = this.cache
              , a = i.allocateTextureUnit();
            o[0] !== a && (u.uniform1i(this.addr, a),
            o[0] = a),
            i.setTexture2D(e || Qx, a)
        }
        function G2(u, e, i) {
            const o = this.cache
              , a = i.allocateTextureUnit();
            o[0] !== a && (u.uniform1i(this.addr, a),
            o[0] = a),
            i.setTexture3D(e || Zx, a)
        }
        function H2(u, e, i) {
            const o = this.cache
              , a = i.allocateTextureUnit();
            o[0] !== a && (u.uniform1i(this.addr, a),
            o[0] = a),
            i.setTextureCube(e || qx, a)
        }
        function V2(u, e, i) {
            const o = this.cache
              , a = i.allocateTextureUnit();
            o[0] !== a && (u.uniform1i(this.addr, a),
            o[0] = a),
            i.setTexture2DArray(e || Kx, a)
        }
        function W2(u) {
            switch (u) {
            case 5126:
                return T2;
            case 35664:
                return E2;
            case 35665:
                return M2;
            case 35666:
                return C2;
            case 35674:
                return P2;
            case 35675:
                return R2;
            case 35676:
                return D2;
            case 5124:
            case 35670:
                return L2;
            case 35667:
            case 35671:
                return I2;
            case 35668:
            case 35672:
                return O2;
            case 35669:
            case 35673:
                return B2;
            case 5125:
                return F2;
            case 36294:
                return k2;
            case 36295:
                return U2;
            case 36296:
                return N2;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return z2;
            case 35679:
            case 36299:
            case 36307:
                return G2;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return H2;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return V2
            }
        }
        function j2(u, e) {
            u.uniform1fv(this.addr, e)
        }
        function X2(u, e) {
            const i = Uu(e, this.size, 2);
            u.uniform2fv(this.addr, i)
        }
        function Y2(u, e) {
            const i = Uu(e, this.size, 3);
            u.uniform3fv(this.addr, i)
        }
        function Q2(u, e) {
            const i = Uu(e, this.size, 4);
            u.uniform4fv(this.addr, i)
        }
        function K2(u, e) {
            const i = Uu(e, this.size, 4);
            u.uniformMatrix2fv(this.addr, !1, i)
        }
        function Z2(u, e) {
            const i = Uu(e, this.size, 9);
            u.uniformMatrix3fv(this.addr, !1, i)
        }
        function q2(u, e) {
            const i = Uu(e, this.size, 16);
            u.uniformMatrix4fv(this.addr, !1, i)
        }
        function J2(u, e) {
            u.uniform1iv(this.addr, e)
        }
        function $2(u, e) {
            u.uniform2iv(this.addr, e)
        }
        function eP(u, e) {
            u.uniform3iv(this.addr, e)
        }
        function tP(u, e) {
            u.uniform4iv(this.addr, e)
        }
        function nP(u, e) {
            u.uniform1uiv(this.addr, e)
        }
        function iP(u, e) {
            u.uniform2uiv(this.addr, e)
        }
        function rP(u, e) {
            u.uniform3uiv(this.addr, e)
        }
        function sP(u, e) {
            u.uniform4uiv(this.addr, e)
        }
        function oP(u, e, i) {
            const o = this.cache
              , a = e.length
              , c = cp(i, a);
            rs(o, c) || (u.uniform1iv(this.addr, c),
            ss(o, c));
            for (let d = 0; d !== a; ++d)
                i.setTexture2D(e[d] || Qx, c[d])
        }
        function aP(u, e, i) {
            const o = this.cache
              , a = e.length
              , c = cp(i, a);
            rs(o, c) || (u.uniform1iv(this.addr, c),
            ss(o, c));
            for (let d = 0; d !== a; ++d)
                i.setTexture3D(e[d] || Zx, c[d])
        }
        function lP(u, e, i) {
            const o = this.cache
              , a = e.length
              , c = cp(i, a);
            rs(o, c) || (u.uniform1iv(this.addr, c),
            ss(o, c));
            for (let d = 0; d !== a; ++d)
                i.setTextureCube(e[d] || qx, c[d])
        }
        function cP(u, e, i) {
            const o = this.cache
              , a = e.length
              , c = cp(i, a);
            rs(o, c) || (u.uniform1iv(this.addr, c),
            ss(o, c));
            for (let d = 0; d !== a; ++d)
                i.setTexture2DArray(e[d] || Kx, c[d])
        }
        function uP(u) {
            switch (u) {
            case 5126:
                return j2;
            case 35664:
                return X2;
            case 35665:
                return Y2;
            case 35666:
                return Q2;
            case 35674:
                return K2;
            case 35675:
                return Z2;
            case 35676:
                return q2;
            case 5124:
            case 35670:
                return J2;
            case 35667:
            case 35671:
                return $2;
            case 35668:
            case 35672:
                return eP;
            case 35669:
            case 35673:
                return tP;
            case 5125:
                return nP;
            case 36294:
                return iP;
            case 36295:
                return rP;
            case 36296:
                return sP;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return oP;
            case 35679:
            case 36299:
            case 36307:
                return aP;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return lP;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return cP
            }
        }
        class hP {
            constructor(e, i, o) {
                this.id = e,
                this.addr = o,
                this.cache = [],
                this.setValue = W2(i.type)
            }
        }
        class dP {
            constructor(e, i, o) {
                this.id = e,
                this.addr = o,
                this.cache = [],
                this.size = i.size,
                this.setValue = uP(i.type)
            }
        }
        class fP {
            constructor(e) {
                this.id = e,
                this.seq = [],
                this.map = {}
            }
            setValue(e, i, o) {
                const a = this.seq;
                for (let c = 0, d = a.length; c !== d; ++c) {
                    const f = a[c];
                    f.setValue(e, i[f.id], o)
                }
            }
        }
        const s0 = /(\w+)(\])?(\[|\.)?/g;
        function i1(u, e) {
            u.seq.push(e),
            u.map[e.id] = e
        }
        function pP(u, e, i) {
            const o = u.name
              , a = o.length;
            for (s0.lastIndex = 0; ; ) {
                const c = s0.exec(o)
                  , d = s0.lastIndex;
                let f = c[1];
                const v = c[2] === "]"
                  , x = c[3];
                if (v && (f = f | 0),
                x === void 0 || x === "[" && d + 2 === a) {
                    i1(i, x === void 0 ? new hP(f,u,e) : new dP(f,u,e));
                    break
                } else {
                    let P = i.map[f];
                    P === void 0 && (P = new fP(f),
                    i1(i, P)),
                    i = P
                }
            }
        }
        class up {
            constructor(e, i) {
                this.seq = [],
                this.map = {};
                const o = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
                for (let a = 0; a < o; ++a) {
                    const c = e.getActiveUniform(i, a)
                      , d = e.getUniformLocation(i, c.name);
                    pP(c, d, this)
                }
            }
            setValue(e, i, o, a) {
                const c = this.map[i];
                c !== void 0 && c.setValue(e, o, a)
            }
            setOptional(e, i, o) {
                const a = i[o];
                a !== void 0 && this.setValue(e, o, a)
            }
            static upload(e, i, o, a) {
                for (let c = 0, d = i.length; c !== d; ++c) {
                    const f = i[c]
                      , v = o[f.id];
                    v.needsUpdate !== !1 && f.setValue(e, v.value, a)
                }
            }
            static seqWithValue(e, i) {
                const o = [];
                for (let a = 0, c = e.length; a !== c; ++a) {
                    const d = e[a];
                    d.id in i && o.push(d)
                }
                return o
            }
        }
        function r1(u, e, i) {
            const o = u.createShader(e);
            return u.shaderSource(o, i),
            u.compileShader(o),
            o
        }
        let mP = 0;
        function gP(u, e) {
            const i = u.split(`
`)
              , o = []
              , a = Math.max(e - 6, 0)
              , c = Math.min(e + 6, i.length);
            for (let d = a; d < c; d++) {
                const f = d + 1;
                o.push(`${f === e ? ">" : " "} ${f}: ${i[d]}`)
            }
            return o.join(`
`)
        }
        function vP(u) {
            switch (u) {
            case nn:
                return ["Linear", "( value )"];
            case cn:
                return ["sRGB", "( value )"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported encoding:", u),
                ["Linear", "( value )"]
            }
        }
        function s1(u, e, i) {
            const o = u.getShaderParameter(e, u.COMPILE_STATUS)
              , a = u.getShaderInfoLog(e).trim();
            if (o && a === "")
                return "";
            const c = /ERROR: 0:(\d+)/.exec(a);
            if (c) {
                const d = parseInt(c[1]);
                return i.toUpperCase() + `

` + a + `

` + gP(u.getShaderSource(e), d)
            } else
                return a
        }
        function _P(u, e) {
            const i = vP(e);
            return "vec4 " + u + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
        }
        function yP(u, e) {
            let i;
            switch (e) {
            case On:
                i = "Linear";
                break;
            case kn:
                i = "Reinhard";
                break;
            case bi:
                i = "OptimizedCineon";
                break;
            case $i:
                i = "ACESFilmic";
                break;
            case zr:
                i = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                i = "Linear"
            }
            return "vec3 " + u + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
        }
        function xP(u) {
            return [u.extensionDerivatives || u.envMapCubeUVHeight || u.bumpMap || u.tangentSpaceNormalMap || u.clearcoatNormalMap || u.flatShading || u.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (u.extensionFragDepth || u.logarithmicDepthBuffer) && u.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", u.extensionDrawBuffers && u.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (u.extensionShaderTextureLOD || u.envMap || u.transmission) && u.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(qh).join(`
`)
        }
        function bP(u) {
            const e = [];
            for (const i in u) {
                const o = u[i];
                o !== !1 && e.push("#define " + i + " " + o)
            }
            return e.join(`
`)
        }
        function wP(u, e) {
            const i = {}
              , o = u.getProgramParameter(e, u.ACTIVE_ATTRIBUTES);
            for (let a = 0; a < o; a++) {
                const c = u.getActiveAttrib(e, a)
                  , d = c.name;
                let f = 1;
                c.type === u.FLOAT_MAT2 && (f = 2),
                c.type === u.FLOAT_MAT3 && (f = 3),
                c.type === u.FLOAT_MAT4 && (f = 4),
                i[d] = {
                    type: c.type,
                    location: u.getAttribLocation(e, d),
                    locationSize: f
                }
            }
            return i
        }
        function qh(u) {
            return u !== ""
        }
        function o1(u, e) {
            const i = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
            return u.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }
        function a1(u, e) {
            return u.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const AP = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function o0(u) {
            return u.replace(AP, SP)
        }
        function SP(u, e) {
            const i = yi[e];
            if (i === void 0)
                throw new Error("Can not resolve #include <" + e + ">");
            return o0(i)
        }
        const TP = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function l1(u) {
            return u.replace(TP, EP)
        }
        function EP(u, e, i, o) {
            let a = "";
            for (let c = parseInt(e); c < parseInt(i); c++)
                a += o.replace(/\[\s*i\s*\]/g, "[ " + c + " ]").replace(/UNROLLED_LOOP_INDEX/g, c);
            return a
        }
        function c1(u) {
            let e = "precision " + u.precision + ` float;
precision ` + u.precision + " int;";
            return u.precision === "highp" ? e += `
#define HIGH_PRECISION` : u.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : u.precision === "lowp" && (e += `
#define LOW_PRECISION`),
            e
        }
        function MP(u) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return u.shadowMapType === ne ? e = "SHADOWMAP_TYPE_PCF" : u.shadowMapType === ce ? e = "SHADOWMAP_TYPE_PCF_SOFT" : u.shadowMapType === xe && (e = "SHADOWMAP_TYPE_VSM"),
            e
        }
        function CP(u) {
            let e = "ENVMAP_TYPE_CUBE";
            if (u.envMap)
                switch (u.envMapMode) {
                case vr:
                case Oi:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                case ys:
                    e = "ENVMAP_TYPE_CUBE_UV";
                    break
                }
            return e
        }
        function PP(u) {
            let e = "ENVMAP_MODE_REFLECTION";
            if (u.envMap)
                switch (u.envMapMode) {
                case Oi:
                    e = "ENVMAP_MODE_REFRACTION";
                    break
                }
            return e
        }
        function RP(u) {
            let e = "ENVMAP_BLENDING_NONE";
            if (u.envMap)
                switch (u.combine) {
                case ui:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case mi:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                case Si:
                    e = "ENVMAP_BLENDING_ADD";
                    break
                }
            return e
        }
        function DP(u) {
            const e = u.envMapCubeUVHeight;
            if (e === null)
                return null;
            const i = Math.log2(e) - 2
              , o = 1 / e;
            return {
                texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 7 * 16)),
                texelHeight: o,
                maxMip: i
            }
        }
        function LP(u, e, i, o) {
            const a = u.getContext()
              , c = i.defines;
            let d = i.vertexShader
              , f = i.fragmentShader;
            const v = MP(i)
              , x = CP(i)
              , w = PP(i)
              , P = RP(i)
              , M = DP(i)
              , I = i.isWebGL2 ? "" : xP(i)
              , z = bP(c)
              , O = a.createProgram();
            let k, Q, Z = i.glslVersion ? "#version " + i.glslVersion + `
` : "";
            i.isRawShaderMaterial ? (k = [z].filter(qh).join(`
`),
            k.length > 0 && (k += `
`),
            Q = [I, z].filter(qh).join(`
`),
            Q.length > 0 && (Q += `
`)) : (k = [c1(i), "#define SHADER_NAME " + i.shaderName, z, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + w : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && i.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", i.morphColors && i.isWebGL2 ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + v : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", " attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "   attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", " attribute vec4 color;", "#elif defined( USE_COLOR )", " attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", " attribute vec3 morphTarget0;", "    attribute vec3 morphTarget1;", "    attribute vec3 morphTarget2;", "    attribute vec3 morphTarget3;", "    #ifdef USE_MORPHNORMALS", "     attribute vec3 morphNormal0;", "        attribute vec3 morphNormal1;", "        attribute vec3 morphNormal2;", "        attribute vec3 morphNormal3;", "    #else", "       attribute vec3 morphTarget4;", "        attribute vec3 morphTarget5;", "        attribute vec3 morphTarget6;", "        attribute vec3 morphTarget7;", "    #endif", "#endif", "#ifdef USE_SKINNING", " attribute vec4 skinIndex;", "   attribute vec4 skinWeight;", "#endif", `
`].filter(qh).join(`
`),
            Q = [I, c1(i), "#define SHADER_NAME " + i.shaderName, z, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + x : "", i.envMap ? "#define " + w : "", i.envMap ? "#define " + P : "", M ? "#define CUBEUV_TEXEL_WIDTH " + M.texelWidth : "", M ? "#define CUBEUV_TEXEL_HEIGHT " + M.texelHeight : "", M ? "#define CUBEUV_MAX_MIP " + M.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescence ? "#define USE_IRIDESCENCE" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + v : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.useLegacyLights ? "#define LEGACY_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== Gt ? "#define TONE_MAPPING" : "", i.toneMapping !== Gt ? yi.tonemapping_pars_fragment : "", i.toneMapping !== Gt ? yP("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", yi.encodings_pars_fragment, _P("linearToOutputTexel", i.outputEncoding), i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", `
`].filter(qh).join(`
`)),
            d = o0(d),
            d = o1(d, i),
            d = a1(d, i),
            f = o0(f),
            f = o1(f, i),
            f = a1(f, i),
            d = l1(d),
            f = l1(f),
            i.isWebGL2 && i.isRawShaderMaterial !== !0 && (Z = `#version 300 es
`,
            k = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + k,
            Q = ["#define varying in", i.glslVersion === Tr ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === Tr ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + Q);
            const X = Z + k + d
              , K = Z + Q + f
              , de = r1(a, a.VERTEX_SHADER, X)
              , be = r1(a, a.FRAGMENT_SHADER, K);
            if (a.attachShader(O, de),
            a.attachShader(O, be),
            i.index0AttributeName !== void 0 ? a.bindAttribLocation(O, 0, i.index0AttributeName) : i.morphTargets === !0 && a.bindAttribLocation(O, 0, "position"),
            a.linkProgram(O),
            u.debug.checkShaderErrors) {
                const ge = a.getProgramInfoLog(O).trim()
                  , Le = a.getShaderInfoLog(de).trim()
                  , tt = a.getShaderInfoLog(be).trim();
                let lt = !0
                  , je = !0;
                if (a.getProgramParameter(O, a.LINK_STATUS) === !1) {
                    lt = !1;
                    const ze = s1(a, de, "vertex")
                      , st = s1(a, be, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + a.getError() + " - VALIDATE_STATUS " + a.getProgramParameter(O, a.VALIDATE_STATUS) + `

Program Info Log: ` + ge + `
` + ze + `
` + st)
                } else
                    ge !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", ge) : (Le === "" || tt === "") && (je = !1);
                je && (this.diagnostics = {
                    runnable: lt,
                    programLog: ge,
                    vertexShader: {
                        log: Le,
                        prefix: k
                    },
                    fragmentShader: {
                        log: tt,
                        prefix: Q
                    }
                })
            }
            a.deleteShader(de),
            a.deleteShader(be);
            O.glVertexShader = X;
            O.glFragmentShader = K;
            let Me;
            this.getUniforms = function() {
                return Me === void 0 && (Me = new up(a,O)),
                Me
            }
            ;
            let J;
            return this.getAttributes = function() {
                return J === void 0 && (J = wP(a, O)),
                J
            }
            ,
            this.destroy = function() {
                o.releaseStatesOfProgram(this),
                a.deleteProgram(O),
                this.program = void 0
            }
            ,
            this.name = i.shaderName,
            this.id = mP++,
            this.cacheKey = e,
            this.usedTimes = 1,
            this.program = O,
            this.vertexShader = de,
            this.fragmentShader = be,
            this
        }
        let IP = 0;
        class OP {
            constructor() {
                this.shaderCache = new Map,
                this.materialCache = new Map
            }
            update(e) {
                const i = e.vertexShader
                  , o = e.fragmentShader
                  , a = this._getShaderStage(i)
                  , c = this._getShaderStage(o)
                  , d = this._getShaderCacheForMaterial(e);
                return d.has(a) === !1 && (d.add(a),
                a.usedTimes++),
                d.has(c) === !1 && (d.add(c),
                c.usedTimes++),
                this
            }
            remove(e) {
                const i = this.materialCache.get(e);
                for (const o of i)
                    o.usedTimes--,
                    o.usedTimes === 0 && this.shaderCache.delete(o.code);
                return this.materialCache.delete(e),
                this
            }
            getVertexShaderID(e) {
                return this._getShaderStage(e.vertexShader).id
            }
            getFragmentShaderID(e) {
                return this._getShaderStage(e.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(),
                this.materialCache.clear()
            }
            _getShaderCacheForMaterial(e) {
                const i = this.materialCache;
                let o = i.get(e);
                return o === void 0 && (o = new Set,
                i.set(e, o)),
                o
            }
            _getShaderStage(e) {
                const i = this.shaderCache;
                let o = i.get(e);
                return o === void 0 && (o = new BP(e),
                i.set(e, o)),
                o
            }
        }
        class BP {
            constructor(e) {
                this.id = IP++,
                this.code = e,
                this.usedTimes = 0
            }
        }
        function FP(u, e, i, o, a, c, d) {
            const f = new Xf
              , v = new OP
              , x = []
              , w = a.isWebGL2
              , P = a.logarithmicDepthBuffer
              , M = a.vertexTextures;
            let I = a.precision;
            const z = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            function O(J, ge, Le, tt, lt) {
                const je = tt.fog
                  , ze = lt.geometry
                  , st = J.isMeshStandardMaterial ? tt.environment : null
                  , yt = (J.isMeshStandardMaterial ? i : e).get(J.envMap || st)
                  , It = yt && yt.mapping === ys ? yt.image.height : null
                  , ht = z[J.type];
                J.precision !== null && (I = a.getMaxPrecision(J.precision),
                I !== J.precision && console.warn("THREE.WebGLProgram.getParameters:", J.precision, "not supported, using", I, "instead."));
                const Ot = ze.morphAttributes.position || ze.morphAttributes.normal || ze.morphAttributes.color
                  , Mt = Ot !== void 0 ? Ot.length : 0;
                let Ln = 0;
                ze.morphAttributes.position !== void 0 && (Ln = 1),
                ze.morphAttributes.normal !== void 0 && (Ln = 2),
                ze.morphAttributes.color !== void 0 && (Ln = 3);
                let Ye, Pt, tn, De;
                if (ht) {
                    const ei = Sa[ht];
                    Ye = ei.vertexShader,
                    Pt = ei.fragmentShader
                } else
                    Ye = J.vertexShader,
                    Pt = J.fragmentShader,
                    v.update(J),
                    tn = v.getVertexShaderID(J),
                    De = v.getFragmentShaderID(J);
                const Cn = u.getRenderTarget()
                  , on = J.alphaTest > 0
                  , Mn = J.clearcoat > 0
                  , In = J.iridescence > 0;
                return {
                    isWebGL2: w,
                    shaderID: ht,
                    shaderName: J.type,
                    vertexShader: Ye,
                    fragmentShader: Pt,
                    defines: J.defines,
                    customVertexShaderID: tn,
                    customFragmentShaderID: De,
                    isRawShaderMaterial: J.isRawShaderMaterial === !0,
                    glslVersion: J.glslVersion,
                    precision: I,
                    instancing: lt.isInstancedMesh === !0,
                    instancingColor: lt.isInstancedMesh === !0 && lt.instanceColor !== null,
                    supportsVertexTextures: M,
                    outputEncoding: Cn === null ? u.outputEncoding : Cn.isXRRenderTarget === !0 ? Cn.texture.encoding : nn,
                    map: !!J.map,
                    matcap: !!J.matcap,
                    envMap: !!yt,
                    envMapMode: yt && yt.mapping,
                    envMapCubeUVHeight: It,
                    lightMap: !!J.lightMap,
                    aoMap: !!J.aoMap,
                    emissiveMap: !!J.emissiveMap,
                    bumpMap: !!J.bumpMap,
                    normalMap: !!J.normalMap,
                    objectSpaceNormalMap: J.normalMapType === b,
                    tangentSpaceNormalMap: J.normalMapType === y,
                    decodeVideoTexture: !!J.map && J.map.isVideoTexture === !0 && J.map.encoding === cn,
                    clearcoat: Mn,
                    clearcoatMap: Mn && !!J.clearcoatMap,
                    clearcoatRoughnessMap: Mn && !!J.clearcoatRoughnessMap,
                    clearcoatNormalMap: Mn && !!J.clearcoatNormalMap,
                    iridescence: In,
                    iridescenceMap: In && !!J.iridescenceMap,
                    iridescenceThicknessMap: In && !!J.iridescenceThicknessMap,
                    displacementMap: !!J.displacementMap,
                    roughnessMap: !!J.roughnessMap,
                    metalnessMap: !!J.metalnessMap,
                    specularMap: !!J.specularMap,
                    specularIntensityMap: !!J.specularIntensityMap,
                    specularColorMap: !!J.specularColorMap,
                    opaque: J.transparent === !1 && J.blending === _e,
                    alphaMap: !!J.alphaMap,
                    alphaTest: on,
                    gradientMap: !!J.gradientMap,
                    sheen: J.sheen > 0,
                    sheenColorMap: !!J.sheenColorMap,
                    sheenRoughnessMap: !!J.sheenRoughnessMap,
                    transmission: J.transmission > 0,
                    transmissionMap: !!J.transmissionMap,
                    thicknessMap: !!J.thicknessMap,
                    combine: J.combine,
                    vertexTangents: !!J.normalMap && !!ze.attributes.tangent,
                    vertexColors: J.vertexColors,
                    vertexAlphas: J.vertexColors === !0 && !!ze.attributes.color && ze.attributes.color.itemSize === 4,
                    vertexUvs: !!J.map || !!J.bumpMap || !!J.normalMap || !!J.specularMap || !!J.alphaMap || !!J.emissiveMap || !!J.roughnessMap || !!J.metalnessMap || !!J.clearcoatMap || !!J.clearcoatRoughnessMap || !!J.clearcoatNormalMap || !!J.iridescenceMap || !!J.iridescenceThicknessMap || !!J.displacementMap || !!J.transmissionMap || !!J.thicknessMap || !!J.specularIntensityMap || !!J.specularColorMap || !!J.sheenColorMap || !!J.sheenRoughnessMap,
                    uvsVertexOnly: !(J.map || J.bumpMap || J.normalMap || J.specularMap || J.alphaMap || J.emissiveMap || J.roughnessMap || J.metalnessMap || J.clearcoatNormalMap || J.iridescenceMap || J.iridescenceThicknessMap || J.transmission > 0 || J.transmissionMap || J.thicknessMap || J.specularIntensityMap || J.specularColorMap || J.sheen > 0 || J.sheenColorMap || J.sheenRoughnessMap) && !!J.displacementMap,
                    fog: !!je,
                    useFog: J.fog === !0,
                    fogExp2: je && je.isFogExp2,
                    flatShading: !!J.flatShading,
                    sizeAttenuation: J.sizeAttenuation,
                    logarithmicDepthBuffer: P,
                    skinning: lt.isSkinnedMesh === !0,
                    morphTargets: ze.morphAttributes.position !== void 0,
                    morphNormals: ze.morphAttributes.normal !== void 0,
                    morphColors: ze.morphAttributes.color !== void 0,
                    morphTargetsCount: Mt,
                    morphTextureStride: Ln,
                    numDirLights: ge.directional.length,
                    numPointLights: ge.point.length,
                    numSpotLights: ge.spot.length,
                    numSpotLightMaps: ge.spotLightMap.length,
                    numRectAreaLights: ge.rectArea.length,
                    numHemiLights: ge.hemi.length,
                    numDirLightShadows: ge.directionalShadowMap.length,
                    numPointLightShadows: ge.pointShadowMap.length,
                    numSpotLightShadows: ge.spotShadowMap.length,
                    numSpotLightShadowsWithMaps: ge.numSpotLightShadowsWithMaps,
                    numClippingPlanes: d.numPlanes,
                    numClipIntersection: d.numIntersection,
                    dithering: J.dithering,
                    shadowMapEnabled: u.shadowMap.enabled && Le.length > 0,
                    shadowMapType: u.shadowMap.type,
                    toneMapping: J.toneMapped ? u.toneMapping : Gt,
                    useLegacyLights: u.useLegacyLights,
                    premultipliedAlpha: J.premultipliedAlpha,
                    doubleSided: J.side === q,
                    flipSided: J.side === $,
                    useDepthPacking: !!J.depthPacking,
                    depthPacking: J.depthPacking || 0,
                    index0AttributeName: J.index0AttributeName,
                    extensionDerivatives: J.extensions && J.extensions.derivatives,
                    extensionFragDepth: J.extensions && J.extensions.fragDepth,
                    extensionDrawBuffers: J.extensions && J.extensions.drawBuffers,
                    extensionShaderTextureLOD: J.extensions && J.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: w || o.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: w || o.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: w || o.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: J.customProgramCacheKey()
                }
            }
            function k(J) {
                const ge = [];
                if (J.shaderID ? ge.push(J.shaderID) : (ge.push(J.customVertexShaderID),
                ge.push(J.customFragmentShaderID)),
                J.defines !== void 0)
                    for (const Le in J.defines)
                        ge.push(Le),
                        ge.push(J.defines[Le]);
                return J.isRawShaderMaterial === !1 && (Q(ge, J),
                Z(ge, J),
                ge.push(u.outputEncoding)),
                ge.push(J.customProgramCacheKey),
                ge.join()
            }
            function Q(J, ge) {
                J.push(ge.precision),
                J.push(ge.outputEncoding),
                J.push(ge.envMapMode),
                J.push(ge.envMapCubeUVHeight),
                J.push(ge.combine),
                J.push(ge.vertexUvs),
                J.push(ge.fogExp2),
                J.push(ge.sizeAttenuation),
                J.push(ge.morphTargetsCount),
                J.push(ge.morphAttributeCount),
                J.push(ge.numDirLights),
                J.push(ge.numPointLights),
                J.push(ge.numSpotLights),
                J.push(ge.numSpotLightMaps),
                J.push(ge.numHemiLights),
                J.push(ge.numRectAreaLights),
                J.push(ge.numDirLightShadows),
                J.push(ge.numPointLightShadows),
                J.push(ge.numSpotLightShadows),
                J.push(ge.numSpotLightShadowsWithMaps),
                J.push(ge.shadowMapType),
                J.push(ge.toneMapping),
                J.push(ge.numClippingPlanes),
                J.push(ge.numClipIntersection),
                J.push(ge.depthPacking)
            }
            function Z(J, ge) {
                f.disableAll(),
                ge.isWebGL2 && f.enable(0),
                ge.supportsVertexTextures && f.enable(1),
                ge.instancing && f.enable(2),
                ge.instancingColor && f.enable(3),
                ge.map && f.enable(4),
                ge.matcap && f.enable(5),
                ge.envMap && f.enable(6),
                ge.lightMap && f.enable(7),
                ge.aoMap && f.enable(8),
                ge.emissiveMap && f.enable(9),
                ge.bumpMap && f.enable(10),
                ge.normalMap && f.enable(11),
                ge.objectSpaceNormalMap && f.enable(12),
                ge.tangentSpaceNormalMap && f.enable(13),
                ge.clearcoat && f.enable(14),
                ge.clearcoatMap && f.enable(15),
                ge.clearcoatRoughnessMap && f.enable(16),
                ge.clearcoatNormalMap && f.enable(17),
                ge.iridescence && f.enable(18),
                ge.iridescenceMap && f.enable(19),
                ge.iridescenceThicknessMap && f.enable(20),
                ge.displacementMap && f.enable(21),
                ge.specularMap && f.enable(22),
                ge.roughnessMap && f.enable(23),
                ge.metalnessMap && f.enable(24),
                ge.gradientMap && f.enable(25),
                ge.alphaMap && f.enable(26),
                ge.alphaTest && f.enable(27),
                ge.vertexColors && f.enable(28),
                ge.vertexAlphas && f.enable(29),
                ge.vertexUvs && f.enable(30),
                ge.vertexTangents && f.enable(31),
                ge.uvsVertexOnly && f.enable(32),
                J.push(f.mask),
                f.disableAll(),
                ge.fog && f.enable(0),
                ge.useFog && f.enable(1),
                ge.flatShading && f.enable(2),
                ge.logarithmicDepthBuffer && f.enable(3),
                ge.skinning && f.enable(4),
                ge.morphTargets && f.enable(5),
                ge.morphNormals && f.enable(6),
                ge.morphColors && f.enable(7),
                ge.premultipliedAlpha && f.enable(8),
                ge.shadowMapEnabled && f.enable(9),
                ge.useLegacyLights && f.enable(10),
                ge.doubleSided && f.enable(11),
                ge.flipSided && f.enable(12),
                ge.useDepthPacking && f.enable(13),
                ge.dithering && f.enable(14),
                ge.specularIntensityMap && f.enable(15),
                ge.specularColorMap && f.enable(16),
                ge.transmission && f.enable(17),
                ge.transmissionMap && f.enable(18),
                ge.thicknessMap && f.enable(19),
                ge.sheen && f.enable(20),
                ge.sheenColorMap && f.enable(21),
                ge.sheenRoughnessMap && f.enable(22),
                ge.decodeVideoTexture && f.enable(23),
                ge.opaque && f.enable(24),
                J.push(f.mask)
            }
            function X(J) {
                const ge = z[J.type];
                let Le;
                if (ge) {
                    const tt = Sa[ge];
                    Le = Ux.clone(tt.uniforms)
                } else
                    Le = J.uniforms;
                return Le
            }
            function K(J, ge) {
                let Le;
                for (let tt = 0, lt = x.length; tt < lt; tt++) {
                    const je = x[tt];
                    if (je.cacheKey === ge) {
                        Le = je,
                        ++Le.usedTimes;
                        break
                    }
                }
                return Le === void 0 && (Le = new LP(u,ge,J,c),
                x.push(Le)),
                Le
            }
            function de(J) {
                if (--J.usedTimes === 0) {
                    const ge = x.indexOf(J);
                    x[ge] = x[x.length - 1],
                    x.pop(),
                    J.destroy()
                }
            }
            function be(J) {
                v.remove(J)
            }
            function Me() {
                v.dispose()
            }
            return {
                getParameters: O,
                getProgramCacheKey: k,
                getUniforms: X,
                acquireProgram: K,
                releaseProgram: de,
                releaseShaderCache: be,
                programs: x,
                dispose: Me
            }
        }
        function kP() {
            let u = new WeakMap;
            function e(c) {
                let d = u.get(c);
                return d === void 0 && (d = {},
                u.set(c, d)),
                d
            }
            function i(c) {
                u.delete(c)
            }
            function o(c, d, f) {
                u.get(c)[d] = f
            }
            function a() {
                u = new WeakMap
            }
            return {
                get: e,
                remove: i,
                update: o,
                dispose: a
            }
        }
        function UP(u, e) {
            return u.groupOrder !== e.groupOrder ? u.groupOrder - e.groupOrder : u.renderOrder !== e.renderOrder ? u.renderOrder - e.renderOrder : u.material.id !== e.material.id ? u.material.id - e.material.id : u.z !== e.z ? u.z - e.z : u.id - e.id
        }
        function u1(u, e) {
            return u.groupOrder !== e.groupOrder ? u.groupOrder - e.groupOrder : u.renderOrder !== e.renderOrder ? u.renderOrder - e.renderOrder : u.z !== e.z ? e.z - u.z : u.id - e.id
        }
        function h1() {
            const u = [];
            let e = 0;
            const i = []
              , o = []
              , a = [];
            function c() {
                e = 0,
                i.length = 0,
                o.length = 0,
                a.length = 0
            }
            function d(P, M, I, z, O, k) {
                let Q = u[e];
                return Q === void 0 ? (Q = {
                    id: P.id,
                    object: P,
                    geometry: M,
                    material: I,
                    groupOrder: z,
                    renderOrder: P.renderOrder,
                    z: O,
                    group: k
                },
                u[e] = Q) : (Q.id = P.id,
                Q.object = P,
                Q.geometry = M,
                Q.material = I,
                Q.groupOrder = z,
                Q.renderOrder = P.renderOrder,
                Q.z = O,
                Q.group = k),
                e++,
                Q
            }
            function f(P, M, I, z, O, k) {
                const Q = d(P, M, I, z, O, k);
                I.transmission > 0 ? o.push(Q) : I.transparent === !0 ? a.push(Q) : i.push(Q)
            }
            function v(P, M, I, z, O, k) {
                const Q = d(P, M, I, z, O, k);
                I.transmission > 0 ? o.unshift(Q) : I.transparent === !0 ? a.unshift(Q) : i.unshift(Q)
            }
            function x(P, M) {
                i.length > 1 && i.sort(P || UP),
                o.length > 1 && o.sort(M || u1),
                a.length > 1 && a.sort(M || u1)
            }
            function w() {
                for (let P = e, M = u.length; P < M; P++) {
                    const I = u[P];
                    if (I.id === null)
                        break;
                    I.id = null,
                    I.object = null,
                    I.geometry = null,
                    I.material = null,
                    I.group = null
                }
            }
            return {
                opaque: i,
                transmissive: o,
                transparent: a,
                init: c,
                push: f,
                unshift: v,
                finish: w,
                sort: x
            }
        }
        function NP() {
            let u = new WeakMap;
            function e(o, a) {
                const c = u.get(o);
                let d;
                return c === void 0 ? (d = new h1,
                u.set(o, [d])) : a >= c.length ? (d = new h1,
                c.push(d)) : d = c[a],
                d
            }
            function i() {
                u = new WeakMap
            }
            return {
                get: e,
                dispose: i
            }
        }
        function zP() {
            const u = {};
            return {
                get: function(e) {
                    if (u[e.id] !== void 0)
                        return u[e.id];
                    let i;
                    switch (e.type) {
                    case "DirectionalLight":
                        i = {
                            direction: new me,
                            color: new gn
                        };
                        break;
                    case "SpotLight":
                        i = {
                            position: new me,
                            direction: new me,
                            color: new gn,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        i = {
                            position: new me,
                            color: new gn,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        i = {
                            direction: new me,
                            skyColor: new gn,
                            groundColor: new gn
                        };
                        break;
                    case "RectAreaLight":
                        i = {
                            color: new gn,
                            position: new me,
                            halfWidth: new me,
                            halfHeight: new me
                        };
                        break
                    }
                    return u[e.id] = i,
                    i
                }
            }
        }
        function GP() {
            const u = {};
            return {
                get: function(e) {
                    if (u[e.id] !== void 0)
                        return u[e.id];
                    let i;
                    switch (e.type) {
                    case "DirectionalLight":
                        i = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new _t
                        };
                        break;
                    case "SpotLight":
                        i = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new _t
                        };
                        break;
                    case "PointLight":
                        i = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new _t,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break
                    }
                    return u[e.id] = i,
                    i
                }
            }
        }
        let HP = 0;
        function VP(u, e) {
            return (e.castShadow ? 2 : 0) - (u.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (u.map ? 1 : 0)
        }
        function WP(u, e) {
            const i = new zP
              , o = GP()
              , a = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0
            };
            for (let w = 0; w < 9; w++)
                a.probe.push(new me);
            const c = new me
              , d = new pi
              , f = new pi;
            function v(w, P) {
                let M = 0
                  , I = 0
                  , z = 0;
                for (let tt = 0; tt < 9; tt++)
                    a.probe[tt].set(0, 0, 0);
                let O = 0
                  , k = 0
                  , Q = 0
                  , Z = 0
                  , X = 0
                  , K = 0
                  , de = 0
                  , be = 0
                  , Me = 0
                  , J = 0;
                w.sort(VP);
                const ge = P === !0 ? Math.PI : 1;
                for (let tt = 0, lt = w.length; tt < lt; tt++) {
                    const je = w[tt]
                      , ze = je.color
                      , st = je.intensity
                      , yt = je.distance
                      , It = je.shadow && je.shadow.map ? je.shadow.map.texture : null;
                    if (je.isAmbientLight)
                        M += ze.r * st * ge,
                        I += ze.g * st * ge,
                        z += ze.b * st * ge;
                    else if (je.isLightProbe)
                        for (let ht = 0; ht < 9; ht++)
                            a.probe[ht].addScaledVector(je.sh.coefficients[ht], st);
                    else if (je.isDirectionalLight) {
                        const ht = i.get(je);
                        if (ht.color.copy(je.color).multiplyScalar(je.intensity * ge),
                        je.castShadow) {
                            const Ot = je.shadow
                              , Mt = o.get(je);
                            Mt.shadowBias = Ot.bias,
                            Mt.shadowNormalBias = Ot.normalBias,
                            Mt.shadowRadius = Ot.radius,
                            Mt.shadowMapSize = Ot.mapSize,
                            a.directionalShadow[O] = Mt,
                            a.directionalShadowMap[O] = It,
                            a.directionalShadowMatrix[O] = je.shadow.matrix,
                            K++
                        }
                        a.directional[O] = ht,
                        O++
                    } else if (je.isSpotLight) {
                        const ht = i.get(je);
                        ht.position.setFromMatrixPosition(je.matrixWorld),
                        ht.color.copy(ze).multiplyScalar(st * ge),
                        ht.distance = yt,
                        ht.coneCos = Math.cos(je.angle),
                        ht.penumbraCos = Math.cos(je.angle * (1 - je.penumbra)),
                        ht.decay = je.decay,
                        a.spot[Q] = ht;
                        const Ot = je.shadow;
                        if (je.map && (a.spotLightMap[Me] = je.map,
                        Me++,
                        Ot.updateMatrices(je),
                        je.castShadow && J++),
                        a.spotLightMatrix[Q] = Ot.matrix,
                        je.castShadow) {
                            const Mt = o.get(je);
                            Mt.shadowBias = Ot.bias,
                            Mt.shadowNormalBias = Ot.normalBias,
                            Mt.shadowRadius = Ot.radius,
                            Mt.shadowMapSize = Ot.mapSize,
                            a.spotShadow[Q] = Mt,
                            a.spotShadowMap[Q] = It,
                            be++
                        }
                        Q++
                    } else if (je.isRectAreaLight) {
                        const ht = i.get(je);
                        ht.color.copy(ze).multiplyScalar(st),
                        ht.halfWidth.set(je.width * .5, 0, 0),
                        ht.halfHeight.set(0, je.height * .5, 0),
                        a.rectArea[Z] = ht,
                        Z++
                    } else if (je.isPointLight) {
                        const ht = i.get(je);
                        if (ht.color.copy(je.color).multiplyScalar(je.intensity * ge),
                        ht.distance = je.distance,
                        ht.decay = je.decay,
                        je.castShadow) {
                            const Ot = je.shadow
                              , Mt = o.get(je);
                            Mt.shadowBias = Ot.bias,
                            Mt.shadowNormalBias = Ot.normalBias,
                            Mt.shadowRadius = Ot.radius,
                            Mt.shadowMapSize = Ot.mapSize,
                            Mt.shadowCameraNear = Ot.camera.near,
                            Mt.shadowCameraFar = Ot.camera.far,
                            a.pointShadow[k] = Mt,
                            a.pointShadowMap[k] = It,
                            a.pointShadowMatrix[k] = je.shadow.matrix,
                            de++
                        }
                        a.point[k] = ht,
                        k++
                    } else if (je.isHemisphereLight) {
                        const ht = i.get(je);
                        ht.skyColor.copy(je.color).multiplyScalar(st * ge),
                        ht.groundColor.copy(je.groundColor).multiplyScalar(st * ge),
                        a.hemi[X] = ht,
                        X++
                    }
                }
                Z > 0 && (e.isWebGL2 || u.has("OES_texture_float_linear") === !0 ? (a.rectAreaLTC1 = Zt.LTC_FLOAT_1,
                a.rectAreaLTC2 = Zt.LTC_FLOAT_2) : u.has("OES_texture_half_float_linear") === !0 ? (a.rectAreaLTC1 = Zt.LTC_HALF_1,
                a.rectAreaLTC2 = Zt.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                a.ambient[0] = M,
                a.ambient[1] = I,
                a.ambient[2] = z;
                const Le = a.hash;
                (Le.directionalLength !== O || Le.pointLength !== k || Le.spotLength !== Q || Le.rectAreaLength !== Z || Le.hemiLength !== X || Le.numDirectionalShadows !== K || Le.numPointShadows !== de || Le.numSpotShadows !== be || Le.numSpotMaps !== Me) && (a.directional.length = O,
                a.spot.length = Q,
                a.rectArea.length = Z,
                a.point.length = k,
                a.hemi.length = X,
                a.directionalShadow.length = K,
                a.directionalShadowMap.length = K,
                a.pointShadow.length = de,
                a.pointShadowMap.length = de,
                a.spotShadow.length = be,
                a.spotShadowMap.length = be,
                a.directionalShadowMatrix.length = K,
                a.pointShadowMatrix.length = de,
                a.spotLightMatrix.length = be + Me - J,
                a.spotLightMap.length = Me,
                a.numSpotLightShadowsWithMaps = J,
                Le.directionalLength = O,
                Le.pointLength = k,
                Le.spotLength = Q,
                Le.rectAreaLength = Z,
                Le.hemiLength = X,
                Le.numDirectionalShadows = K,
                Le.numPointShadows = de,
                Le.numSpotShadows = be,
                Le.numSpotMaps = Me,
                a.version = HP++)
            }
            function x(w, P) {
                let M = 0
                  , I = 0
                  , z = 0
                  , O = 0
                  , k = 0;
                const Q = P.matrixWorldInverse;
                for (let Z = 0, X = w.length; Z < X; Z++) {
                    const K = w[Z];
                    if (K.isDirectionalLight) {
                        const de = a.directional[M];
                        de.direction.setFromMatrixPosition(K.matrixWorld),
                        c.setFromMatrixPosition(K.target.matrixWorld),
                        de.direction.sub(c),
                        de.direction.transformDirection(Q),
                        M++
                    } else if (K.isSpotLight) {
                        const de = a.spot[z];
                        de.position.setFromMatrixPosition(K.matrixWorld),
                        de.position.applyMatrix4(Q),
                        de.direction.setFromMatrixPosition(K.matrixWorld),
                        c.setFromMatrixPosition(K.target.matrixWorld),
                        de.direction.sub(c),
                        de.direction.transformDirection(Q),
                        z++
                    } else if (K.isRectAreaLight) {
                        const de = a.rectArea[O];
                        de.position.setFromMatrixPosition(K.matrixWorld),
                        de.position.applyMatrix4(Q),
                        f.identity(),
                        d.copy(K.matrixWorld),
                        d.premultiply(Q),
                        f.extractRotation(d),
                        de.halfWidth.set(K.width * .5, 0, 0),
                        de.halfHeight.set(0, K.height * .5, 0),
                        de.halfWidth.applyMatrix4(f),
                        de.halfHeight.applyMatrix4(f),
                        O++
                    } else if (K.isPointLight) {
                        const de = a.point[I];
                        de.position.setFromMatrixPosition(K.matrixWorld),
                        de.position.applyMatrix4(Q),
                        I++
                    } else if (K.isHemisphereLight) {
                        const de = a.hemi[k];
                        de.direction.setFromMatrixPosition(K.matrixWorld),
                        de.direction.transformDirection(Q),
                        k++
                    }
                }
            }
            return {
                setup: v,
                setupView: x,
                state: a
            }
        }
        function d1(u, e) {
            const i = new WP(u,e)
              , o = []
              , a = [];
            function c() {
                o.length = 0,
                a.length = 0
            }
            function d(P) {
                o.push(P)
            }
            function f(P) {
                a.push(P)
            }
            function v(P) {
                i.setup(o, P)
            }
            function x(P) {
                i.setupView(o, P)
            }
            return {
                init: c,
                state: {
                    lightsArray: o,
                    shadowsArray: a,
                    lights: i
                },
                setupLights: v,
                setupLightsView: x,
                pushLight: d,
                pushShadow: f
            }
        }
        function jP(u, e) {
            let i = new WeakMap;
            function o(c, d=0) {
                const f = i.get(c);
                let v;
                return f === void 0 ? (v = new d1(u,e),
                i.set(c, [v])) : d >= f.length ? (v = new d1(u,e),
                f.push(v)) : v = f[d],
                v
            }
            function a() {
                i = new WeakMap
            }
            return {
                get: o,
                dispose: a
            }
        }
        class a0 extends Vs {
            constructor(e) {
                super(),
                this.isMeshDepthMaterial = !0,
                this.type = "MeshDepthMaterial",
                this.depthPacking = ni,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.depthPacking = e.depthPacking,
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this
            }
        }
        class l0 extends Vs {
            constructor(e) {
                super(),
                this.isMeshDistanceMaterial = !0,
                this.type = "MeshDistanceMaterial",
                this.referencePosition = new me,
                this.nearDistance = 1,
                this.farDistance = 1e3,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.referencePosition.copy(e.referencePosition),
                this.nearDistance = e.nearDistance,
                this.farDistance = e.farDistance,
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this
            }
        }
        const XP = `
void main() {

    gl_Position = vec4( position, 1.0 );

}
`
          , YP = `
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

    const float samples = float( VSM_SAMPLES );

    float mean = 0.0;
    float squared_mean = 0.0;

    float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
    float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
    for ( float i = 0.0; i < samples; i ++ ) {

        float uvOffset = uvStart + i * uvStride;

        #ifdef HORIZONTAL_PASS

            vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
            mean += distribution.x;
            squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

        #else

            float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
            mean += depth;
            squared_mean += depth * depth;

        #endif

    }

    mean = mean / samples;
    squared_mean = squared_mean / samples;

    float std_dev = sqrt( squared_mean - mean * mean );

    gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`;
        function QP(u, e, i) {
            let o = new sp;
            const a = new _t
              , c = new _t
              , d = new mn
              , f = new a0({
                depthPacking: ae
            })
              , v = new l0
              , x = {}
              , w = i.maxTextureSize
              , P = {
                [Se]: $,
                [$]: Se,
                [q]: q
            }
              , M = new ja({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new _t
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: XP,
                fragmentShader: YP
            })
              , I = M.clone();
            I.defines.HORIZONTAL_PASS = 1;
            const z = new Ai;
            z.setAttribute("position", new dr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const O = new Es(z,M)
              , k = this;
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = ne,
            this.render = function(K, de, be) {
                if (k.enabled === !1 || k.autoUpdate === !1 && k.needsUpdate === !1 || K.length === 0)
                    return;
                const Me = u.getRenderTarget()
                  , J = u.getActiveCubeFace()
                  , ge = u.getActiveMipmapLevel()
                  , Le = u.state;
                Le.setBlending(ie),
                Le.buffers.color.setClear(1, 1, 1, 1),
                Le.buffers.depth.setTest(!0),
                Le.setScissorTest(!1);
                for (let tt = 0, lt = K.length; tt < lt; tt++) {
                    const je = K[tt]
                      , ze = je.shadow;
                    if (ze === void 0) {
                        console.warn("THREE.WebGLShadowMap:", je, "has no shadow.");
                        continue
                    }
                    if (ze.autoUpdate === !1 && ze.needsUpdate === !1)
                        continue;
                    a.copy(ze.mapSize);
                    const st = ze.getFrameExtents();
                    if (a.multiply(st),
                    c.copy(ze.mapSize),
                    (a.x > w || a.y > w) && (a.x > w && (c.x = Math.floor(w / st.x),
                    a.x = c.x * st.x,
                    ze.mapSize.x = c.x),
                    a.y > w && (c.y = Math.floor(w / st.y),
                    a.y = c.y * st.y,
                    ze.mapSize.y = c.y)),
                    ze.map === null) {
                        const It = this.type !== xe ? {
                            minFilter: gi,
                            magFilter: gi
                        } : {};
                        ze.map = new ki(a.x,a.y,It),
                        ze.map.texture.name = je.name + ".shadowMap",
                        ze.camera.updateProjectionMatrix()
                    }
                    u.setRenderTarget(ze.map),
                    u.clear();
                    const yt = ze.getViewportCount();
                    for (let It = 0; It < yt; It++) {
                        const ht = ze.getViewport(It);
                        d.set(c.x * ht.x, c.y * ht.y, c.x * ht.z, c.y * ht.w),
                        Le.viewport(d),
                        ze.updateMatrices(je, It),
                        o = ze.getFrustum(),
                        X(de, be, ze.camera, je, this.type)
                    }
                    ze.isPointLightShadow !== !0 && this.type === xe && Q(ze, be),
                    ze.needsUpdate = !1
                }
                k.needsUpdate = !1,
                u.setRenderTarget(Me, J, ge)
            }
            ;
            function Q(K, de) {
                const be = e.update(O);
                M.defines.VSM_SAMPLES !== K.blurSamples && (M.defines.VSM_SAMPLES = K.blurSamples,
                I.defines.VSM_SAMPLES = K.blurSamples,
                M.needsUpdate = !0,
                I.needsUpdate = !0),
                K.mapPass === null && (K.mapPass = new ki(a.x,a.y)),
                M.uniforms.shadow_pass.value = K.map.texture,
                M.uniforms.resolution.value = K.mapSize,
                M.uniforms.radius.value = K.radius,
                u.setRenderTarget(K.mapPass),
                u.clear(),
                u.renderBufferDirect(de, null, be, M, O, null),
                I.uniforms.shadow_pass.value = K.mapPass.texture,
                I.uniforms.resolution.value = K.mapSize,
                I.uniforms.radius.value = K.radius,
                u.setRenderTarget(K.map),
                u.clear(),
                u.renderBufferDirect(de, null, be, I, O, null)
            }
            function Z(K, de, be, Me, J, ge) {
                let Le = null;
                const tt = be.isPointLight === !0 ? K.customDistanceMaterial : K.customDepthMaterial;
                if (tt !== void 0)
                    Le = tt;
                else if (Le = be.isPointLight === !0 ? v : f,
                u.localClippingEnabled && de.clipShadows === !0 && Array.isArray(de.clippingPlanes) && de.clippingPlanes.length !== 0 || de.displacementMap && de.displacementScale !== 0 || de.alphaMap && de.alphaTest > 0 || de.map && de.alphaTest > 0) {
                    const lt = Le.uuid
                      , je = de.uuid;
                    let ze = x[lt];
                    ze === void 0 && (ze = {},
                    x[lt] = ze);
                    let st = ze[je];
                    st === void 0 && (st = Le.clone(),
                    ze[je] = st),
                    Le = st
                }
                return Le.visible = de.visible,
                Le.wireframe = de.wireframe,
                ge === xe ? Le.side = de.shadowSide !== null ? de.shadowSide : de.side : Le.side = de.shadowSide !== null ? de.shadowSide : P[de.side],
                Le.alphaMap = de.alphaMap,
                Le.alphaTest = de.alphaTest,
                Le.map = de.map,
                Le.clipShadows = de.clipShadows,
                Le.clippingPlanes = de.clippingPlanes,
                Le.clipIntersection = de.clipIntersection,
                Le.displacementMap = de.displacementMap,
                Le.displacementScale = de.displacementScale,
                Le.displacementBias = de.displacementBias,
                Le.wireframeLinewidth = de.wireframeLinewidth,
                Le.linewidth = de.linewidth,
                be.isPointLight === !0 && Le.isMeshDistanceMaterial === !0 && (Le.referencePosition.setFromMatrixPosition(be.matrixWorld),
                Le.nearDistance = Me,
                Le.farDistance = J),
                Le
            }
            function X(K, de, be, Me, J) {
                if (K.visible === !1)
                    return;
                if (K.layers.test(de.layers) && (K.isMesh || K.isLine || K.isPoints) && (K.castShadow || K.receiveShadow && J === xe) && (!K.frustumCulled || o.intersectsObject(K))) {
                    K.modelViewMatrix.multiplyMatrices(be.matrixWorldInverse, K.matrixWorld);
                    const tt = e.update(K)
                      , lt = K.material;
                    if (Array.isArray(lt)) {
                        const je = tt.groups;
                        for (let ze = 0, st = je.length; ze < st; ze++) {
                            const yt = je[ze]
                              , It = lt[yt.materialIndex];
                            if (It && It.visible) {
                                const ht = Z(K, It, Me, be.near, be.far, J);
                                u.renderBufferDirect(be, null, tt, ht, K, yt)
                            }
                        }
                    } else if (lt.visible) {
                        const je = Z(K, lt, Me, be.near, be.far, J);
                        u.renderBufferDirect(be, null, tt, je, K, null)
                    }
                }
                const Le = K.children;
                for (let tt = 0, lt = Le.length; tt < lt; tt++)
                    X(Le[tt], de, be, Me, J)
            }
        }
        function KP(u, e, i) {
            const o = i.isWebGL2;
            function a() {
                let Ue = !1;
                const ot = new mn;
                let Dt = null;
                const bn = new mn(0,0,0,0);
                return {
                    setMask: function(Gn) {
                        Dt !== Gn && !Ue && (u.colorMask(Gn, Gn, Gn, Gn),
                        Dt = Gn)
                    },
                    setLocked: function(Gn) {
                        Ue = Gn
                    },
                    setClear: function(Gn, tr, fs, js, eu) {
                        eu === !0 && (Gn *= js,
                        tr *= js,
                        fs *= js),
                        ot.set(Gn, tr, fs, js),
                        bn.equals(ot) === !1 && (u.clearColor(Gn, tr, fs, js),
                        bn.copy(ot))
                    },
                    reset: function() {
                        Ue = !1,
                        Dt = null,
                        bn.set(-1, 0, 0, 0)
                    }
                }
            }
            function c() {
                let Ue = !1
                  , ot = null
                  , Dt = null
                  , bn = null;
                return {
                    setTest: function(Gn) {
                        Gn ? on(u.DEPTH_TEST) : Mn(u.DEPTH_TEST)
                    },
                    setMask: function(Gn) {
                        ot !== Gn && !Ue && (u.depthMask(Gn),
                        ot = Gn)
                    },
                    setFunc: function(Gn) {
                        if (Dt !== Gn) {
                            switch (Gn) {
                            case He:
                                u.depthFunc(u.NEVER);
                                break;
                            case pt:
                                u.depthFunc(u.ALWAYS);
                                break;
                            case Fe:
                                u.depthFunc(u.LESS);
                                break;
                            case qe:
                                u.depthFunc(u.LEQUAL);
                                break;
                            case wt:
                                u.depthFunc(u.EQUAL);
                                break;
                            case An:
                                u.depthFunc(u.GEQUAL);
                                break;
                            case Qt:
                                u.depthFunc(u.GREATER);
                                break;
                            case Pi:
                                u.depthFunc(u.NOTEQUAL);
                                break;
                            default:
                                u.depthFunc(u.LEQUAL)
                            }
                            Dt = Gn
                        }
                    },
                    setLocked: function(Gn) {
                        Ue = Gn
                    },
                    setClear: function(Gn) {
                        bn !== Gn && (u.clearDepth(Gn),
                        bn = Gn)
                    },
                    reset: function() {
                        Ue = !1,
                        ot = null,
                        Dt = null,
                        bn = null
                    }
                }
            }
            function d() {
                let Ue = !1
                  , ot = null
                  , Dt = null
                  , bn = null
                  , Gn = null
                  , tr = null
                  , fs = null
                  , js = null
                  , eu = null;
                return {
                    setTest: function(Ar) {
                        Ue || (Ar ? on(u.STENCIL_TEST) : Mn(u.STENCIL_TEST))
                    },
                    setMask: function(Ar) {
                        ot !== Ar && !Ue && (u.stencilMask(Ar),
                        ot = Ar)
                    },
                    setFunc: function(Ar, Tl, ea) {
                        (Dt !== Ar || bn !== Tl || Gn !== ea) && (u.stencilFunc(Ar, Tl, ea),
                        Dt = Ar,
                        bn = Tl,
                        Gn = ea)
                    },
                    setOp: function(Ar, Tl, ea) {
                        (tr !== Ar || fs !== Tl || js !== ea) && (u.stencilOp(Ar, Tl, ea),
                        tr = Ar,
                        fs = Tl,
                        js = ea)
                    },
                    setLocked: function(Ar) {
                        Ue = Ar
                    },
                    setClear: function(Ar) {
                        eu !== Ar && (u.clearStencil(Ar),
                        eu = Ar)
                    },
                    reset: function() {
                        Ue = !1,
                        ot = null,
                        Dt = null,
                        bn = null,
                        Gn = null,
                        tr = null,
                        fs = null,
                        js = null,
                        eu = null
                    }
                }
            }
            const f = new a
              , v = new c
              , x = new d
              , w = new WeakMap
              , P = new WeakMap;
            let M = {}
              , I = {}
              , z = new WeakMap
              , O = []
              , k = null
              , Q = !1
              , Z = null
              , X = null
              , K = null
              , de = null
              , be = null
              , Me = null
              , J = null
              , ge = !1
              , Le = null
              , tt = null
              , lt = null
              , je = null
              , ze = null;
            const st = u.getParameter(u.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let yt = !1
              , It = 0;
            const ht = u.getParameter(u.VERSION);
            ht.indexOf("WebGL") !== -1 ? (It = parseFloat(/^WebGL (\d)/.exec(ht)[1]),
            yt = It >= 1) : ht.indexOf("OpenGL ES") !== -1 && (It = parseFloat(/^OpenGL ES (\d)/.exec(ht)[1]),
            yt = It >= 2);
            let Ot = null
              , Mt = {};
            const Ln = u.getParameter(u.SCISSOR_BOX)
              , Ye = u.getParameter(u.VIEWPORT)
              , Pt = new mn().fromArray(Ln)
              , tn = new mn().fromArray(Ye);
            function De(Ue, ot, Dt) {
                const bn = new Uint8Array(4)
                  , Gn = u.createTexture();
                u.bindTexture(Ue, Gn),
                u.texParameteri(Ue, u.TEXTURE_MIN_FILTER, u.NEAREST),
                u.texParameteri(Ue, u.TEXTURE_MAG_FILTER, u.NEAREST);
                for (let tr = 0; tr < Dt; tr++)
                    u.texImage2D(ot + tr, 0, u.RGBA, 1, 1, 0, u.RGBA, u.UNSIGNED_BYTE, bn);
                return Gn
            }
            const Cn = {};
            Cn[u.TEXTURE_2D] = De(u.TEXTURE_2D, u.TEXTURE_2D, 1),
            Cn[u.TEXTURE_CUBE_MAP] = De(u.TEXTURE_CUBE_MAP, u.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
            f.setClear(0, 0, 0, 1),
            v.setClear(1),
            x.setClear(0),
            on(u.DEPTH_TEST),
            v.setFunc(qe),
            sn(!1),
            ri(m),
            on(u.CULL_FACE),
            Kt(ie);
            function on(Ue) {
                M[Ue] !== !0 && (u.enable(Ue),
                M[Ue] = !0)
            }
            function Mn(Ue) {
                M[Ue] !== !1 && (u.disable(Ue),
                M[Ue] = !1)
            }
            function In(Ue, ot) {
                return I[Ue] !== ot ? (u.bindFramebuffer(Ue, ot),
                I[Ue] = ot,
                o && (Ue === u.DRAW_FRAMEBUFFER && (I[u.FRAMEBUFFER] = ot),
                Ue === u.FRAMEBUFFER && (I[u.DRAW_FRAMEBUFFER] = ot)),
                !0) : !1
            }
            function Un(Ue, ot) {
                let Dt = O
                  , bn = !1;
                if (Ue)
                    if (Dt = z.get(ot),
                    Dt === void 0 && (Dt = [],
                    z.set(ot, Dt)),
                    Ue.isWebGLMultipleRenderTargets) {
                        const Gn = Ue.texture;
                        if (Dt.length !== Gn.length || Dt[0] !== u.COLOR_ATTACHMENT0) {
                            for (let tr = 0, fs = Gn.length; tr < fs; tr++)
                                Dt[tr] = u.COLOR_ATTACHMENT0 + tr;
                            Dt.length = Gn.length,
                            bn = !0
                        }
                    } else
                        Dt[0] !== u.COLOR_ATTACHMENT0 && (Dt[0] = u.COLOR_ATTACHMENT0,
                        bn = !0);
                else
                    Dt[0] !== u.BACK && (Dt[0] = u.BACK,
                    bn = !0);
                bn && (i.isWebGL2 ? u.drawBuffers(Dt) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Dt))
            }
            function ei(Ue) {
                return k !== Ue ? (u.useProgram(Ue),
                k = Ue,
                !0) : !1
            }
            const dt = {
                [et]: u.FUNC_ADD,
                [Ze]: u.FUNC_SUBTRACT,
                [Nt]: u.FUNC_REVERSE_SUBTRACT
            };
            if (o)
                dt[Bt] = u.MIN,
                dt[en] = u.MAX;
            else {
                const Ue = e.get("EXT_blend_minmax");
                Ue !== null && (dt[Bt] = Ue.MIN_EXT,
                dt[en] = Ue.MAX_EXT)
            }
            const Tt = {
                [li]: u.ZERO,
                [di]: u.ONE,
                [xi]: u.SRC_COLOR,
                [Sn]: u.SRC_ALPHA,
                [Wn]: u.SRC_ALPHA_SATURATE,
                [Xt]: u.DST_COLOR,
                [Ft]: u.DST_ALPHA,
                [zt]: u.ONE_MINUS_SRC_COLOR,
                [rn]: u.ONE_MINUS_SRC_ALPHA,
                [Rt]: u.ONE_MINUS_DST_COLOR,
                [jt]: u.ONE_MINUS_DST_ALPHA
            };
            function Kt(Ue, ot, Dt, bn, Gn, tr, fs, js) {
                if (Ue === ie) {
                    Q === !0 && (Mn(u.BLEND),
                    Q = !1);
                    return
                }
                if (Q === !1 && (on(u.BLEND),
                Q = !0),
                Ue !== ct) {
                    if (Ue !== Z || js !== ge) {
                        if ((X !== et || be !== et) && (u.blendEquation(u.FUNC_ADD),
                        X = et,
                        be = et),
                        js)
                            switch (Ue) {
                            case _e:
                                u.blendFuncSeparate(u.ONE, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA);
                                break;
                            case Pe:
                                u.blendFunc(u.ONE, u.ONE);
                                break;
                            case Be:
                                u.blendFuncSeparate(u.ZERO, u.ONE_MINUS_SRC_COLOR, u.ZERO, u.ONE);
                                break;
                            case Re:
                                u.blendFuncSeparate(u.ZERO, u.SRC_COLOR, u.ZERO, u.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", Ue);
                                break
                            }
                        else
                            switch (Ue) {
                            case _e:
                                u.blendFuncSeparate(u.SRC_ALPHA, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA);
                                break;
                            case Pe:
                                u.blendFunc(u.SRC_ALPHA, u.ONE);
                                break;
                            case Be:
                                u.blendFuncSeparate(u.ZERO, u.ONE_MINUS_SRC_COLOR, u.ZERO, u.ONE);
                                break;
                            case Re:
                                u.blendFunc(u.ZERO, u.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", Ue);
                                break
                            }
                        K = null,
                        de = null,
                        Me = null,
                        J = null,
                        Z = Ue,
                        ge = js
                    }
                    return
                }
                Gn = Gn || ot,
                tr = tr || Dt,
                fs = fs || bn,
                (ot !== X || Gn !== be) && (u.blendEquationSeparate(dt[ot], dt[Gn]),
                X = ot,
                be = Gn),
                (Dt !== K || bn !== de || tr !== Me || fs !== J) && (u.blendFuncSeparate(Tt[Dt], Tt[bn], Tt[tr], Tt[fs]),
                K = Dt,
                de = bn,
                Me = tr,
                J = fs),
                Z = Ue,
                ge = !1
            }
            function zn(Ue, ot) {
                Ue.side === q ? Mn(u.CULL_FACE) : on(u.CULL_FACE);
                let Dt = Ue.side === $;
                ot && (Dt = !Dt),
                sn(Dt),
                Ue.blending === _e && Ue.transparent === !1 ? Kt(ie) : Kt(Ue.blending, Ue.blendEquation, Ue.blendSrc, Ue.blendDst, Ue.blendEquationAlpha, Ue.blendSrcAlpha, Ue.blendDstAlpha, Ue.premultipliedAlpha),
                v.setFunc(Ue.depthFunc),
                v.setTest(Ue.depthTest),
                v.setMask(Ue.depthWrite),
                f.setMask(Ue.colorWrite);
                const bn = Ue.stencilWrite;
                x.setTest(bn),
                bn && (x.setMask(Ue.stencilWriteMask),
                x.setFunc(Ue.stencilFunc, Ue.stencilRef, Ue.stencilFuncMask),
                x.setOp(Ue.stencilFail, Ue.stencilZFail, Ue.stencilZPass)),
                si(Ue.polygonOffset, Ue.polygonOffsetFactor, Ue.polygonOffsetUnits),
                Ue.alphaToCoverage === !0 ? on(u.SAMPLE_ALPHA_TO_COVERAGE) : Mn(u.SAMPLE_ALPHA_TO_COVERAGE)
            }
            function sn(Ue) {
                Le !== Ue && (Ue ? u.frontFace(u.CW) : u.frontFace(u.CCW),
                Le = Ue)
            }
            function ri(Ue) {
                Ue !== A ? (on(u.CULL_FACE),
                Ue !== tt && (Ue === m ? u.cullFace(u.BACK) : Ue === D ? u.cullFace(u.FRONT) : u.cullFace(u.FRONT_AND_BACK))) : Mn(u.CULL_FACE),
                tt = Ue
            }
            function jn(Ue) {
                Ue !== lt && (yt && u.lineWidth(Ue),
                lt = Ue)
            }
            function si(Ue, ot, Dt) {
                Ue ? (on(u.POLYGON_OFFSET_FILL),
                (je !== ot || ze !== Dt) && (u.polygonOffset(ot, Dt),
                je = ot,
                ze = Dt)) : Mn(u.POLYGON_OFFSET_FILL)
            }
            function mr(Ue) {
                Ue ? on(u.SCISSOR_TEST) : Mn(u.SCISSOR_TEST)
            }
            function rr(Ue) {
                Ue === void 0 && (Ue = u.TEXTURE0 + st - 1),
                Ot !== Ue && (u.activeTexture(Ue),
                Ot = Ue)
            }
            function we(Ue, ot, Dt) {
                Dt === void 0 && (Ot === null ? Dt = u.TEXTURE0 + st - 1 : Dt = Ot);
                let bn = Mt[Dt];
                bn === void 0 && (bn = {
                    type: void 0,
                    texture: void 0
                },
                Mt[Dt] = bn),
                (bn.type !== Ue || bn.texture !== ot) && (Ot !== Dt && (u.activeTexture(Dt),
                Ot = Dt),
                u.bindTexture(Ue, ot || Cn[Ue]),
                bn.type = Ue,
                bn.texture = ot)
            }
            function he() {
                const Ue = Mt[Ot];
                Ue !== void 0 && Ue.type !== void 0 && (u.bindTexture(Ue.type, null),
                Ue.type = void 0,
                Ue.texture = void 0)
            }
            function it() {
                try {
                    u.compressedTexImage2D.apply(u, arguments)
                } catch (Ue) {
                    console.error("THREE.WebGLState:", Ue)
                }
            }
            function Ht() {
                try {
                    u.compressedTexImage3D.apply(u, arguments)
                } catch (Ue) {
                    console.error("THREE.WebGLState:", Ue)
                }
            }
            function Wt() {
                try {
                    u.texSubImage2D.apply(u, arguments)
                } catch (Ue) {
                    console.error("THREE.WebGLState:", Ue)
                }
            }
            function an() {
                try {
                    u.texSubImage3D.apply(u, arguments)
                } catch (Ue) {
                    console.error("THREE.WebGLState:", Ue)
                }
            }
            function Vn() {
                try {
                    u.compressedTexSubImage2D.apply(u, arguments)
                } catch (Ue) {
                    console.error("THREE.WebGLState:", Ue)
                }
            }
            function xn() {
                try {
                    u.compressedTexSubImage3D.apply(u, arguments)
                } catch (Ue) {
                    console.error("THREE.WebGLState:", Ue)
                }
            }
            function ft() {
                try {
                    u.texStorage2D.apply(u, arguments)
                } catch (Ue) {
                    console.error("THREE.WebGLState:", Ue)
                }
            }
            function Qn() {
                try {
                    u.texStorage3D.apply(u, arguments)
                } catch (Ue) {
                    console.error("THREE.WebGLState:", Ue)
                }
            }
            function Fn() {
                try {
                    u.texImage2D.apply(u, arguments)
                } catch (Ue) {
                    console.error("THREE.WebGLState:", Ue)
                }
            }
            function oi() {
                try {
                    u.texImage3D.apply(u, arguments)
                } catch (Ue) {
                    console.error("THREE.WebGLState:", Ue)
                }
            }
            function Zn(Ue) {
                Pt.equals(Ue) === !1 && (u.scissor(Ue.x, Ue.y, Ue.z, Ue.w),
                Pt.copy(Ue))
            }
            function Xn(Ue) {
                tn.equals(Ue) === !1 && (u.viewport(Ue.x, Ue.y, Ue.z, Ue.w),
                tn.copy(Ue))
            }
            function Ki(Ue, ot) {
                let Dt = P.get(ot);
                Dt === void 0 && (Dt = new WeakMap,
                P.set(ot, Dt));
                let bn = Dt.get(Ue);
                bn === void 0 && (bn = u.getUniformBlockIndex(ot, Ue.name),
                Dt.set(Ue, bn))
            }
            function Rr(Ue, ot) {
                const bn = P.get(ot).get(Ue);
                w.get(ot) !== bn && (u.uniformBlockBinding(ot, bn, Ue.__bindingPointIndex),
                w.set(ot, bn))
            }
            function ds() {
                u.disable(u.BLEND),
                u.disable(u.CULL_FACE),
                u.disable(u.DEPTH_TEST),
                u.disable(u.POLYGON_OFFSET_FILL),
                u.disable(u.SCISSOR_TEST),
                u.disable(u.STENCIL_TEST),
                u.disable(u.SAMPLE_ALPHA_TO_COVERAGE),
                u.blendEquation(u.FUNC_ADD),
                u.blendFunc(u.ONE, u.ZERO),
                u.blendFuncSeparate(u.ONE, u.ZERO, u.ONE, u.ZERO),
                u.colorMask(!0, !0, !0, !0),
                u.clearColor(0, 0, 0, 0),
                u.depthMask(!0),
                u.depthFunc(u.LESS),
                u.clearDepth(1),
                u.stencilMask(4294967295),
                u.stencilFunc(u.ALWAYS, 0, 4294967295),
                u.stencilOp(u.KEEP, u.KEEP, u.KEEP),
                u.clearStencil(0),
                u.cullFace(u.BACK),
                u.frontFace(u.CCW),
                u.polygonOffset(0, 0),
                u.activeTexture(u.TEXTURE0),
                u.bindFramebuffer(u.FRAMEBUFFER, null),
                o === !0 && (u.bindFramebuffer(u.DRAW_FRAMEBUFFER, null),
                u.bindFramebuffer(u.READ_FRAMEBUFFER, null)),
                u.useProgram(null),
                u.lineWidth(1),
                u.scissor(0, 0, u.canvas.width, u.canvas.height),
                u.viewport(0, 0, u.canvas.width, u.canvas.height),
                M = {},
                Ot = null,
                Mt = {},
                I = {},
                z = new WeakMap,
                O = [],
                k = null,
                Q = !1,
                Z = null,
                X = null,
                K = null,
                de = null,
                be = null,
                Me = null,
                J = null,
                ge = !1,
                Le = null,
                tt = null,
                lt = null,
                je = null,
                ze = null,
                Pt.set(0, 0, u.canvas.width, u.canvas.height),
                tn.set(0, 0, u.canvas.width, u.canvas.height),
                f.reset(),
                v.reset(),
                x.reset()
            }
            return {
                buffers: {
                    color: f,
                    depth: v,
                    stencil: x
                },
                enable: on,
                disable: Mn,
                bindFramebuffer: In,
                drawBuffers: Un,
                useProgram: ei,
                setBlending: Kt,
                setMaterial: zn,
                setFlipSided: sn,
                setCullFace: ri,
                setLineWidth: jn,
                setPolygonOffset: si,
                setScissorTest: mr,
                activeTexture: rr,
                bindTexture: we,
                unbindTexture: he,
                compressedTexImage2D: it,
                compressedTexImage3D: Ht,
                texImage2D: Fn,
                texImage3D: oi,
                updateUBOMapping: Ki,
                uniformBlockBinding: Rr,
                texStorage2D: ft,
                texStorage3D: Qn,
                texSubImage2D: Wt,
                texSubImage3D: an,
                compressedTexSubImage2D: Vn,
                compressedTexSubImage3D: xn,
                scissor: Zn,
                viewport: Xn,
                reset: ds
            }
        }
        function ZP(u, e, i, o, a, c, d) {
            const f = a.isWebGL2
              , v = a.maxTextures
              , x = a.maxCubemapSize
              , w = a.maxTextureSize
              , P = a.maxSamples
              , M = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
              , I = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
              , z = new WeakMap;
            let O;
            const k = new WeakMap;
            let Q = !1;
            try {
                Q = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
            } catch {}
            function Z(we, he) {
                return Q ? new OffscreenCanvas(we,he) : Y("canvas")
            }
            function X(we, he, it, Ht) {
                let Wt = 1;
                if ((we.width > Ht || we.height > Ht) && (Wt = Ht / Math.max(we.width, we.height)),
                Wt < 1 || he === !0)
                    if (typeof HTMLImageElement < "u" && we instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && we instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && we instanceof ImageBitmap) {
                        const an = he ? Jn : Math.floor
                          , Vn = an(Wt * we.width)
                          , xn = an(Wt * we.height);
                        O === void 0 && (O = Z(Vn, xn));
                        const ft = it ? Z(Vn, xn) : O;
                        return ft.width = Vn,
                        ft.height = xn,
                        ft.getContext("2d").drawImage(we, 0, 0, Vn, xn),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + we.width + "x" + we.height + ") to (" + Vn + "x" + xn + ")."),
                        ft
                    } else
                        return "data"in we && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + we.width + "x" + we.height + ")."),
                        we;
                return we
            }
            function K(we) {
                return ii(we.width) && ii(we.height)
            }
            function de(we) {
                return f ? !1 : we.wrapS !== hi || we.wrapT !== hi || we.minFilter !== gi && we.minFilter !== Hi
            }
            function be(we, he) {
                return we.generateMipmaps && he && we.minFilter !== gi && we.minFilter !== Hi
            }
            function Me(we) {
                u.generateMipmap(we)
            }
            function J(we, he, it, Ht, Wt=!1) {
                if (f === !1)
                    return he;
                if (we !== null) {
                    if (u[we] !== void 0)
                        return u[we];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + we + "'")
                }
                let an = he;
                return he === u.RED && (it === u.FLOAT && (an = u.R32F),
                it === u.HALF_FLOAT && (an = u.R16F),
                it === u.UNSIGNED_BYTE && (an = u.R8)),
                he === u.RG && (it === u.FLOAT && (an = u.RG32F),
                it === u.HALF_FLOAT && (an = u.RG16F),
                it === u.UNSIGNED_BYTE && (an = u.RG8)),
                he === u.RGBA && (it === u.FLOAT && (an = u.RGBA32F),
                it === u.HALF_FLOAT && (an = u.RGBA16F),
                it === u.UNSIGNED_BYTE && (an = Ht === cn && Wt === !1 ? u.SRGB8_ALPHA8 : u.RGBA8),
                it === u.UNSIGNED_SHORT_4_4_4_4 && (an = u.RGBA4),
                it === u.UNSIGNED_SHORT_5_5_5_1 && (an = u.RGB5_A1)),
                (an === u.R16F || an === u.R32F || an === u.RG16F || an === u.RG32F || an === u.RGBA16F || an === u.RGBA32F) && e.get("EXT_color_buffer_float"),
                an
            }
            function ge(we, he, it) {
                return be(we, it) === !0 || we.isFramebufferTexture && we.minFilter !== gi && we.minFilter !== Hi ? Math.log2(Math.max(he.width, he.height)) + 1 : we.mipmaps !== void 0 && we.mipmaps.length > 0 ? we.mipmaps.length : we.isCompressedTexture && Array.isArray(we.image) ? he.mipmaps.length : 1
            }
            function Le(we) {
                return we === gi || we === qi || we === Gi ? u.NEAREST : u.LINEAR
            }
            function tt(we) {
                const he = we.target;
                he.removeEventListener("dispose", tt),
                je(he),
                he.isVideoTexture && z.delete(he)
            }
            function lt(we) {
                const he = we.target;
                he.removeEventListener("dispose", lt),
                st(he)
            }
            function je(we) {
                const he = o.get(we);
                if (he.__webglInit === void 0)
                    return;
                const it = we.source
                  , Ht = k.get(it);
                if (Ht) {
                    const Wt = Ht[he.__cacheKey];
                    Wt.usedTimes--,
                    Wt.usedTimes === 0 && ze(we),
                    Object.keys(Ht).length === 0 && k.delete(it)
                }
                o.remove(we)
            }
            function ze(we) {
                const he = o.get(we);
                u.deleteTexture(he.__webglTexture);
                const it = we.source
                  , Ht = k.get(it);
                delete Ht[he.__cacheKey],
                d.memory.textures--
            }
            function st(we) {
                const he = we.texture
                  , it = o.get(we)
                  , Ht = o.get(he);
                if (Ht.__webglTexture !== void 0 && (u.deleteTexture(Ht.__webglTexture),
                d.memory.textures--),
                we.depthTexture && we.depthTexture.dispose(),
                we.isWebGLCubeRenderTarget)
                    for (let Wt = 0; Wt < 6; Wt++)
                        u.deleteFramebuffer(it.__webglFramebuffer[Wt]),
                        it.__webglDepthbuffer && u.deleteRenderbuffer(it.__webglDepthbuffer[Wt]);
                else {
                    if (u.deleteFramebuffer(it.__webglFramebuffer),
                    it.__webglDepthbuffer && u.deleteRenderbuffer(it.__webglDepthbuffer),
                    it.__webglMultisampledFramebuffer && u.deleteFramebuffer(it.__webglMultisampledFramebuffer),
                    it.__webglColorRenderbuffer)
                        for (let Wt = 0; Wt < it.__webglColorRenderbuffer.length; Wt++)
                            it.__webglColorRenderbuffer[Wt] && u.deleteRenderbuffer(it.__webglColorRenderbuffer[Wt]);
                    it.__webglDepthRenderbuffer && u.deleteRenderbuffer(it.__webglDepthRenderbuffer)
                }
                if (we.isWebGLMultipleRenderTargets)
                    for (let Wt = 0, an = he.length; Wt < an; Wt++) {
                        const Vn = o.get(he[Wt]);
                        Vn.__webglTexture && (u.deleteTexture(Vn.__webglTexture),
                        d.memory.textures--),
                        o.remove(he[Wt])
                    }
                o.remove(he),
                o.remove(we)
            }
            let yt = 0;
            function It() {
                yt = 0
            }
            function ht() {
                const we = yt;
                return we >= v && console.warn("THREE.WebGLTextures: Trying to use " + we + " texture units while this GPU supports only " + v),
                yt += 1,
                we
            }
            function Ot(we) {
                const he = [];
                return he.push(we.wrapS),
                he.push(we.wrapT),
                he.push(we.wrapR || 0),
                he.push(we.magFilter),
                he.push(we.minFilter),
                he.push(we.anisotropy),
                he.push(we.internalFormat),
                he.push(we.format),
                he.push(we.type),
                he.push(we.generateMipmaps),
                he.push(we.premultiplyAlpha),
                he.push(we.flipY),
                he.push(we.unpackAlignment),
                he.push(we.encoding),
                he.join()
            }
            function Mt(we, he) {
                const it = o.get(we);
                if (we.isVideoTexture && mr(we),
                we.isRenderTargetTexture === !1 && we.version > 0 && it.__version !== we.version) {
                    const Ht = we.image;
                    if (Ht === null)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else if (Ht.complete === !1)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                    else {
                        Mn(it, we, he);
                        return
                    }
                }
                i.bindTexture(u.TEXTURE_2D, it.__webglTexture, u.TEXTURE0 + he)
            }
            function Ln(we, he) {
                const it = o.get(we);
                if (we.version > 0 && it.__version !== we.version) {
                    Mn(it, we, he);
                    return
                }
                i.bindTexture(u.TEXTURE_2D_ARRAY, it.__webglTexture, u.TEXTURE0 + he)
            }
            function Ye(we, he) {
                const it = o.get(we);
                if (we.version > 0 && it.__version !== we.version) {
                    Mn(it, we, he);
                    return
                }
                i.bindTexture(u.TEXTURE_3D, it.__webglTexture, u.TEXTURE0 + he)
            }
            function Pt(we, he) {
                const it = o.get(we);
                if (we.version > 0 && it.__version !== we.version) {
                    In(it, we, he);
                    return
                }
                i.bindTexture(u.TEXTURE_CUBE_MAP, it.__webglTexture, u.TEXTURE0 + he)
            }
            const tn = {
                [xs]: u.REPEAT,
                [hi]: u.CLAMP_TO_EDGE,
                [Ti]: u.MIRRORED_REPEAT
            }
              , De = {
                [gi]: u.NEAREST,
                [qi]: u.NEAREST_MIPMAP_NEAREST,
                [Gi]: u.NEAREST_MIPMAP_LINEAR,
                [Hi]: u.LINEAR,
                [Us]: u.LINEAR_MIPMAP_NEAREST,
                [Fr]: u.LINEAR_MIPMAP_LINEAR
            };
            function Cn(we, he, it) {
                if (it ? (u.texParameteri(we, u.TEXTURE_WRAP_S, tn[he.wrapS]),
                u.texParameteri(we, u.TEXTURE_WRAP_T, tn[he.wrapT]),
                (we === u.TEXTURE_3D || we === u.TEXTURE_2D_ARRAY) && u.texParameteri(we, u.TEXTURE_WRAP_R, tn[he.wrapR]),
                u.texParameteri(we, u.TEXTURE_MAG_FILTER, De[he.magFilter]),
                u.texParameteri(we, u.TEXTURE_MIN_FILTER, De[he.minFilter])) : (u.texParameteri(we, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE),
                u.texParameteri(we, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE),
                (we === u.TEXTURE_3D || we === u.TEXTURE_2D_ARRAY) && u.texParameteri(we, u.TEXTURE_WRAP_R, u.CLAMP_TO_EDGE),
                (he.wrapS !== hi || he.wrapT !== hi) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                u.texParameteri(we, u.TEXTURE_MAG_FILTER, Le(he.magFilter)),
                u.texParameteri(we, u.TEXTURE_MIN_FILTER, Le(he.minFilter)),
                he.minFilter !== gi && he.minFilter !== Hi && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                e.has("EXT_texture_filter_anisotropic") === !0) {
                    const Ht = e.get("EXT_texture_filter_anisotropic");
                    if (he.magFilter === gi || he.minFilter !== Gi && he.minFilter !== Fr || he.type === Js && e.has("OES_texture_float_linear") === !1 || f === !1 && he.type === So && e.has("OES_texture_half_float_linear") === !1)
                        return;
                    (he.anisotropy > 1 || o.get(he).__currentAnisotropy) && (u.texParameterf(we, Ht.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(he.anisotropy, a.getMaxAnisotropy())),
                    o.get(he).__currentAnisotropy = he.anisotropy)
                }
            }
            function on(we, he) {
                let it = !1;
                we.__webglInit === void 0 && (we.__webglInit = !0,
                he.addEventListener("dispose", tt));
                const Ht = he.source;
                let Wt = k.get(Ht);
                Wt === void 0 && (Wt = {},
                k.set(Ht, Wt));
                const an = Ot(he);
                if (an !== we.__cacheKey) {
                    Wt[an] === void 0 && (Wt[an] = {
                        texture: u.createTexture(),
                        usedTimes: 0
                    },
                    d.memory.textures++,
                    it = !0),
                    Wt[an].usedTimes++;
                    const Vn = Wt[we.__cacheKey];
                    Vn !== void 0 && (Wt[we.__cacheKey].usedTimes--,
                    Vn.usedTimes === 0 && ze(he)),
                    we.__cacheKey = an,
                    we.__webglTexture = Wt[an].texture
                }
                return it
            }
            function Mn(we, he, it) {
                let Ht = u.TEXTURE_2D;
                (he.isDataArrayTexture || he.isCompressedArrayTexture) && (Ht = u.TEXTURE_2D_ARRAY),
                he.isData3DTexture && (Ht = u.TEXTURE_3D);
                const Wt = on(we, he)
                  , an = he.source;
                i.bindTexture(Ht, we.__webglTexture, u.TEXTURE0 + it);
                const Vn = o.get(an);
                if (an.version !== Vn.__version || Wt === !0) {
                    i.activeTexture(u.TEXTURE0 + it),
                    u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL, he.flipY),
                    u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, he.premultiplyAlpha),
                    u.pixelStorei(u.UNPACK_ALIGNMENT, he.unpackAlignment),
                    u.pixelStorei(u.UNPACK_COLORSPACE_CONVERSION_WEBGL, u.NONE);
                    const xn = de(he) && K(he.image) === !1;
                    let ft = X(he.image, xn, !1, w);
                    ft = rr(he, ft);
                    const Qn = K(ft) || f
                      , Fn = c.convert(he.format, he.encoding);
                    let oi = c.convert(he.type)
                      , Zn = J(he.internalFormat, Fn, oi, he.encoding, he.isVideoTexture);
                    Cn(Ht, he, Qn);
                    let Xn;
                    const Ki = he.mipmaps
                      , Rr = f && he.isVideoTexture !== !0
                      , ds = Vn.__version === void 0 || Wt === !0
                      , Ue = ge(he, ft, Qn);
                    if (he.isDepthTexture)
                        Zn = u.DEPTH_COMPONENT,
                        f ? he.type === Js ? Zn = u.DEPTH_COMPONENT32F : he.type === uo ? Zn = u.DEPTH_COMPONENT24 : he.type === ti ? Zn = u.DEPTH24_STENCIL8 : Zn = u.DEPTH_COMPONENT16 : he.type === Js && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                        he.format === $s && Zn === u.DEPTH_COMPONENT && he.type !== ha && he.type !== uo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                        he.type = uo,
                        oi = c.convert(he.type)),
                        he.format === ho && Zn === u.DEPTH_COMPONENT && (Zn = u.DEPTH_STENCIL,
                        he.type !== ti && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                        he.type = ti,
                        oi = c.convert(he.type))),
                        ds && (Rr ? i.texStorage2D(u.TEXTURE_2D, 1, Zn, ft.width, ft.height) : i.texImage2D(u.TEXTURE_2D, 0, Zn, ft.width, ft.height, 0, Fn, oi, null));
                    else if (he.isDataTexture)
                        if (Ki.length > 0 && Qn) {
                            Rr && ds && i.texStorage2D(u.TEXTURE_2D, Ue, Zn, Ki[0].width, Ki[0].height);
                            for (let ot = 0, Dt = Ki.length; ot < Dt; ot++)
                                Xn = Ki[ot],
                                Rr ? i.texSubImage2D(u.TEXTURE_2D, ot, 0, 0, Xn.width, Xn.height, Fn, oi, Xn.data) : i.texImage2D(u.TEXTURE_2D, ot, Zn, Xn.width, Xn.height, 0, Fn, oi, Xn.data);
                            he.generateMipmaps = !1
                        } else
                            Rr ? (ds && i.texStorage2D(u.TEXTURE_2D, Ue, Zn, ft.width, ft.height),
                            i.texSubImage2D(u.TEXTURE_2D, 0, 0, 0, ft.width, ft.height, Fn, oi, ft.data)) : i.texImage2D(u.TEXTURE_2D, 0, Zn, ft.width, ft.height, 0, Fn, oi, ft.data);
                    else if (he.isCompressedTexture)
                        if (he.isCompressedArrayTexture) {
                            Rr && ds && i.texStorage3D(u.TEXTURE_2D_ARRAY, Ue, Zn, Ki[0].width, Ki[0].height, ft.depth);
                            for (let ot = 0, Dt = Ki.length; ot < Dt; ot++)
                                Xn = Ki[ot],
                                he.format !== Xr ? Fn !== null ? Rr ? i.compressedTexSubImage3D(u.TEXTURE_2D_ARRAY, ot, 0, 0, 0, Xn.width, Xn.height, ft.depth, Fn, Xn.data, 0, 0) : i.compressedTexImage3D(u.TEXTURE_2D_ARRAY, ot, Zn, Xn.width, Xn.height, ft.depth, 0, Xn.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Rr ? i.texSubImage3D(u.TEXTURE_2D_ARRAY, ot, 0, 0, 0, Xn.width, Xn.height, ft.depth, Fn, oi, Xn.data) : i.texImage3D(u.TEXTURE_2D_ARRAY, ot, Zn, Xn.width, Xn.height, ft.depth, 0, Fn, oi, Xn.data)
                        } else {
                            Rr && ds && i.texStorage2D(u.TEXTURE_2D, Ue, Zn, Ki[0].width, Ki[0].height);
                            for (let ot = 0, Dt = Ki.length; ot < Dt; ot++)
                                Xn = Ki[ot],
                                he.format !== Xr ? Fn !== null ? Rr ? i.compressedTexSubImage2D(u.TEXTURE_2D, ot, 0, 0, Xn.width, Xn.height, Fn, Xn.data) : i.compressedTexImage2D(u.TEXTURE_2D, ot, Zn, Xn.width, Xn.height, 0, Xn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Rr ? i.texSubImage2D(u.TEXTURE_2D, ot, 0, 0, Xn.width, Xn.height, Fn, oi, Xn.data) : i.texImage2D(u.TEXTURE_2D, ot, Zn, Xn.width, Xn.height, 0, Fn, oi, Xn.data)
                        }
                    else if (he.isDataArrayTexture)
                        Rr ? (ds && i.texStorage3D(u.TEXTURE_2D_ARRAY, Ue, Zn, ft.width, ft.height, ft.depth),
                        i.texSubImage3D(u.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ft.width, ft.height, ft.depth, Fn, oi, ft.data)) : i.texImage3D(u.TEXTURE_2D_ARRAY, 0, Zn, ft.width, ft.height, ft.depth, 0, Fn, oi, ft.data);
                    else if (he.isData3DTexture)
                        Rr ? (ds && i.texStorage3D(u.TEXTURE_3D, Ue, Zn, ft.width, ft.height, ft.depth),
                        i.texSubImage3D(u.TEXTURE_3D, 0, 0, 0, 0, ft.width, ft.height, ft.depth, Fn, oi, ft.data)) : i.texImage3D(u.TEXTURE_3D, 0, Zn, ft.width, ft.height, ft.depth, 0, Fn, oi, ft.data);
                    else if (he.isFramebufferTexture) {
                        if (ds)
                            if (Rr)
                                i.texStorage2D(u.TEXTURE_2D, Ue, Zn, ft.width, ft.height);
                            else {
                                let ot = ft.width
                                  , Dt = ft.height;
                                for (let bn = 0; bn < Ue; bn++)
                                    i.texImage2D(u.TEXTURE_2D, bn, Zn, ot, Dt, 0, Fn, oi, null),
                                    ot >>= 1,
                                    Dt >>= 1
                            }
                    } else if (Ki.length > 0 && Qn) {
                        Rr && ds && i.texStorage2D(u.TEXTURE_2D, Ue, Zn, Ki[0].width, Ki[0].height);
                        for (let ot = 0, Dt = Ki.length; ot < Dt; ot++)
                            Xn = Ki[ot],
                            Rr ? i.texSubImage2D(u.TEXTURE_2D, ot, 0, 0, Fn, oi, Xn) : i.texImage2D(u.TEXTURE_2D, ot, Zn, Fn, oi, Xn);
                        he.generateMipmaps = !1
                    } else
                        Rr ? (ds && i.texStorage2D(u.TEXTURE_2D, Ue, Zn, ft.width, ft.height),
                        i.texSubImage2D(u.TEXTURE_2D, 0, 0, 0, Fn, oi, ft)) : i.texImage2D(u.TEXTURE_2D, 0, Zn, Fn, oi, ft);
                    be(he, Qn) && Me(Ht),
                    Vn.__version = an.version,
                    he.onUpdate && he.onUpdate(he)
                }
                we.__version = he.version
            }
            function In(we, he, it) {
                if (he.image.length !== 6)
                    return;
                const Ht = on(we, he)
                  , Wt = he.source;
                i.bindTexture(u.TEXTURE_CUBE_MAP, we.__webglTexture, u.TEXTURE0 + it);
                const an = o.get(Wt);
                if (Wt.version !== an.__version || Ht === !0) {
                    i.activeTexture(u.TEXTURE0 + it),
                    u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL, he.flipY),
                    u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, he.premultiplyAlpha),
                    u.pixelStorei(u.UNPACK_ALIGNMENT, he.unpackAlignment),
                    u.pixelStorei(u.UNPACK_COLORSPACE_CONVERSION_WEBGL, u.NONE);
                    const Vn = he.isCompressedTexture || he.image[0].isCompressedTexture
                      , xn = he.image[0] && he.image[0].isDataTexture
                      , ft = [];
                    for (let ot = 0; ot < 6; ot++)
                        !Vn && !xn ? ft[ot] = X(he.image[ot], !1, !0, x) : ft[ot] = xn ? he.image[ot].image : he.image[ot],
                        ft[ot] = rr(he, ft[ot]);
                    const Qn = ft[0]
                      , Fn = K(Qn) || f
                      , oi = c.convert(he.format, he.encoding)
                      , Zn = c.convert(he.type)
                      , Xn = J(he.internalFormat, oi, Zn, he.encoding)
                      , Ki = f && he.isVideoTexture !== !0
                      , Rr = an.__version === void 0 || Ht === !0;
                    let ds = ge(he, Qn, Fn);
                    Cn(u.TEXTURE_CUBE_MAP, he, Fn);
                    let Ue;
                    if (Vn) {
                        Ki && Rr && i.texStorage2D(u.TEXTURE_CUBE_MAP, ds, Xn, Qn.width, Qn.height);
                        for (let ot = 0; ot < 6; ot++) {
                            Ue = ft[ot].mipmaps;
                            for (let Dt = 0; Dt < Ue.length; Dt++) {
                                const bn = Ue[Dt];
                                he.format !== Xr ? oi !== null ? Ki ? i.compressedTexSubImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, Dt, 0, 0, bn.width, bn.height, oi, bn.data) : i.compressedTexImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, Dt, Xn, bn.width, bn.height, 0, bn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ki ? i.texSubImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, Dt, 0, 0, bn.width, bn.height, oi, Zn, bn.data) : i.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, Dt, Xn, bn.width, bn.height, 0, oi, Zn, bn.data)
                            }
                        }
                    } else {
                        Ue = he.mipmaps,
                        Ki && Rr && (Ue.length > 0 && ds++,
                        i.texStorage2D(u.TEXTURE_CUBE_MAP, ds, Xn, ft[0].width, ft[0].height));
                        for (let ot = 0; ot < 6; ot++)
                            if (xn) {
                                Ki ? i.texSubImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, 0, 0, 0, ft[ot].width, ft[ot].height, oi, Zn, ft[ot].data) : i.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, 0, Xn, ft[ot].width, ft[ot].height, 0, oi, Zn, ft[ot].data);
                                for (let Dt = 0; Dt < Ue.length; Dt++) {
                                    const Gn = Ue[Dt].image[ot].image;
                                    Ki ? i.texSubImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, Dt + 1, 0, 0, Gn.width, Gn.height, oi, Zn, Gn.data) : i.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, Dt + 1, Xn, Gn.width, Gn.height, 0, oi, Zn, Gn.data)
                                }
                            } else {
                                Ki ? i.texSubImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, 0, 0, 0, oi, Zn, ft[ot]) : i.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, 0, Xn, oi, Zn, ft[ot]);
                                for (let Dt = 0; Dt < Ue.length; Dt++) {
                                    const bn = Ue[Dt];
                                    Ki ? i.texSubImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, Dt + 1, 0, 0, oi, Zn, bn.image[ot]) : i.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X + ot, Dt + 1, Xn, oi, Zn, bn.image[ot])
                                }
                            }
                    }
                    be(he, Fn) && Me(u.TEXTURE_CUBE_MAP),
                    an.__version = Wt.version,
                    he.onUpdate && he.onUpdate(he)
                }
                we.__version = he.version
            }
            function Un(we, he, it, Ht, Wt) {
                const an = c.convert(it.format, it.encoding)
                  , Vn = c.convert(it.type)
                  , xn = J(it.internalFormat, an, Vn, it.encoding);
                o.get(he).__hasExternalTextures || (Wt === u.TEXTURE_3D || Wt === u.TEXTURE_2D_ARRAY ? i.texImage3D(Wt, 0, xn, he.width, he.height, he.depth, 0, an, Vn, null) : i.texImage2D(Wt, 0, xn, he.width, he.height, 0, an, Vn, null)),
                i.bindFramebuffer(u.FRAMEBUFFER, we),
                si(he) ? M.framebufferTexture2DMultisampleEXT(u.FRAMEBUFFER, Ht, Wt, o.get(it).__webglTexture, 0, jn(he)) : (Wt === u.TEXTURE_2D || Wt >= u.TEXTURE_CUBE_MAP_POSITIVE_X && Wt <= u.TEXTURE_CUBE_MAP_NEGATIVE_Z) && u.framebufferTexture2D(u.FRAMEBUFFER, Ht, Wt, o.get(it).__webglTexture, 0),
                i.bindFramebuffer(u.FRAMEBUFFER, null)
            }
            function ei(we, he, it) {
                if (u.bindRenderbuffer(u.RENDERBUFFER, we),
                he.depthBuffer && !he.stencilBuffer) {
                    let Ht = u.DEPTH_COMPONENT16;
                    if (it || si(he)) {
                        const Wt = he.depthTexture;
                        Wt && Wt.isDepthTexture && (Wt.type === Js ? Ht = u.DEPTH_COMPONENT32F : Wt.type === uo && (Ht = u.DEPTH_COMPONENT24));
                        const an = jn(he);
                        si(he) ? M.renderbufferStorageMultisampleEXT(u.RENDERBUFFER, an, Ht, he.width, he.height) : u.renderbufferStorageMultisample(u.RENDERBUFFER, an, Ht, he.width, he.height)
                    } else
                        u.renderbufferStorage(u.RENDERBUFFER, Ht, he.width, he.height);
                    u.framebufferRenderbuffer(u.FRAMEBUFFER, u.DEPTH_ATTACHMENT, u.RENDERBUFFER, we)
                } else if (he.depthBuffer && he.stencilBuffer) {
                    const Ht = jn(he);
                    it && si(he) === !1 ? u.renderbufferStorageMultisample(u.RENDERBUFFER, Ht, u.DEPTH24_STENCIL8, he.width, he.height) : si(he) ? M.renderbufferStorageMultisampleEXT(u.RENDERBUFFER, Ht, u.DEPTH24_STENCIL8, he.width, he.height) : u.renderbufferStorage(u.RENDERBUFFER, u.DEPTH_STENCIL, he.width, he.height),
                    u.framebufferRenderbuffer(u.FRAMEBUFFER, u.DEPTH_STENCIL_ATTACHMENT, u.RENDERBUFFER, we)
                } else {
                    const Ht = he.isWebGLMultipleRenderTargets === !0 ? he.texture : [he.texture];
                    for (let Wt = 0; Wt < Ht.length; Wt++) {
                        const an = Ht[Wt]
                          , Vn = c.convert(an.format, an.encoding)
                          , xn = c.convert(an.type)
                          , ft = J(an.internalFormat, Vn, xn, an.encoding)
                          , Qn = jn(he);
                        it && si(he) === !1 ? u.renderbufferStorageMultisample(u.RENDERBUFFER, Qn, ft, he.width, he.height) : si(he) ? M.renderbufferStorageMultisampleEXT(u.RENDERBUFFER, Qn, ft, he.width, he.height) : u.renderbufferStorage(u.RENDERBUFFER, ft, he.width, he.height)
                    }
                }
                u.bindRenderbuffer(u.RENDERBUFFER, null)
            }
            function dt(we, he) {
                if (he && he.isWebGLCubeRenderTarget)
                    throw new Error("Depth Texture with cube render targets is not supported");
                if (i.bindFramebuffer(u.FRAMEBUFFER, we),
                !(he.depthTexture && he.depthTexture.isDepthTexture))
                    throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                (!o.get(he.depthTexture).__webglTexture || he.depthTexture.image.width !== he.width || he.depthTexture.image.height !== he.height) && (he.depthTexture.image.width = he.width,
                he.depthTexture.image.height = he.height,
                he.depthTexture.needsUpdate = !0),
                Mt(he.depthTexture, 0);
                const Ht = o.get(he.depthTexture).__webglTexture
                  , Wt = jn(he);
                if (he.depthTexture.format === $s)
                    si(he) ? M.framebufferTexture2DMultisampleEXT(u.FRAMEBUFFER, u.DEPTH_ATTACHMENT, u.TEXTURE_2D, Ht, 0, Wt) : u.framebufferTexture2D(u.FRAMEBUFFER, u.DEPTH_ATTACHMENT, u.TEXTURE_2D, Ht, 0);
                else if (he.depthTexture.format === ho)
                    si(he) ? M.framebufferTexture2DMultisampleEXT(u.FRAMEBUFFER, u.DEPTH_STENCIL_ATTACHMENT, u.TEXTURE_2D, Ht, 0, Wt) : u.framebufferTexture2D(u.FRAMEBUFFER, u.DEPTH_STENCIL_ATTACHMENT, u.TEXTURE_2D, Ht, 0);
                else
                    throw new Error("Unknown depthTexture format")
            }
            function Tt(we) {
                const he = o.get(we)
                  , it = we.isWebGLCubeRenderTarget === !0;
                if (we.depthTexture && !he.__autoAllocateDepthBuffer) {
                    if (it)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    dt(he.__webglFramebuffer, we)
                } else if (it) {
                    he.__webglDepthbuffer = [];
                    for (let Ht = 0; Ht < 6; Ht++)
                        i.bindFramebuffer(u.FRAMEBUFFER, he.__webglFramebuffer[Ht]),
                        he.__webglDepthbuffer[Ht] = u.createRenderbuffer(),
                        ei(he.__webglDepthbuffer[Ht], we, !1)
                } else
                    i.bindFramebuffer(u.FRAMEBUFFER, he.__webglFramebuffer),
                    he.__webglDepthbuffer = u.createRenderbuffer(),
                    ei(he.__webglDepthbuffer, we, !1);
                i.bindFramebuffer(u.FRAMEBUFFER, null)
            }
            function Kt(we, he, it) {
                const Ht = o.get(we);
                he !== void 0 && Un(Ht.__webglFramebuffer, we, we.texture, u.COLOR_ATTACHMENT0, u.TEXTURE_2D),
                it !== void 0 && Tt(we)
            }
            function zn(we) {
                const he = we.texture
                  , it = o.get(we)
                  , Ht = o.get(he);
                we.addEventListener("dispose", lt),
                we.isWebGLMultipleRenderTargets !== !0 && (Ht.__webglTexture === void 0 && (Ht.__webglTexture = u.createTexture()),
                Ht.__version = he.version,
                d.memory.textures++);
                const Wt = we.isWebGLCubeRenderTarget === !0
                  , an = we.isWebGLMultipleRenderTargets === !0
                  , Vn = K(we) || f;
                if (Wt) {
                    it.__webglFramebuffer = [];
                    for (let xn = 0; xn < 6; xn++)
                        it.__webglFramebuffer[xn] = u.createFramebuffer()
                } else {
                    if (it.__webglFramebuffer = u.createFramebuffer(),
                    an)
                        if (a.drawBuffers) {
                            const xn = we.texture;
                            for (let ft = 0, Qn = xn.length; ft < Qn; ft++) {
                                const Fn = o.get(xn[ft]);
                                Fn.__webglTexture === void 0 && (Fn.__webglTexture = u.createTexture(),
                                d.memory.textures++)
                            }
                        } else
                            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (f && we.samples > 0 && si(we) === !1) {
                        const xn = an ? he : [he];
                        it.__webglMultisampledFramebuffer = u.createFramebuffer(),
                        it.__webglColorRenderbuffer = [],
                        i.bindFramebuffer(u.FRAMEBUFFER, it.__webglMultisampledFramebuffer);
                        for (let ft = 0; ft < xn.length; ft++) {
                            const Qn = xn[ft];
                            it.__webglColorRenderbuffer[ft] = u.createRenderbuffer(),
                            u.bindRenderbuffer(u.RENDERBUFFER, it.__webglColorRenderbuffer[ft]);
                            const Fn = c.convert(Qn.format, Qn.encoding)
                              , oi = c.convert(Qn.type)
                              , Zn = J(Qn.internalFormat, Fn, oi, Qn.encoding, we.isXRRenderTarget === !0)
                              , Xn = jn(we);
                            u.renderbufferStorageMultisample(u.RENDERBUFFER, Xn, Zn, we.width, we.height),
                            u.framebufferRenderbuffer(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0 + ft, u.RENDERBUFFER, it.__webglColorRenderbuffer[ft])
                        }
                        u.bindRenderbuffer(u.RENDERBUFFER, null),
                        we.depthBuffer && (it.__webglDepthRenderbuffer = u.createRenderbuffer(),
                        ei(it.__webglDepthRenderbuffer, we, !0)),
                        i.bindFramebuffer(u.FRAMEBUFFER, null)
                    }
                }
                if (Wt) {
                    i.bindTexture(u.TEXTURE_CUBE_MAP, Ht.__webglTexture),
                    Cn(u.TEXTURE_CUBE_MAP, he, Vn);
                    for (let xn = 0; xn < 6; xn++)
                        Un(it.__webglFramebuffer[xn], we, he, u.COLOR_ATTACHMENT0, u.TEXTURE_CUBE_MAP_POSITIVE_X + xn);
                    be(he, Vn) && Me(u.TEXTURE_CUBE_MAP),
                    i.unbindTexture()
                } else if (an) {
                    const xn = we.texture;
                    for (let ft = 0, Qn = xn.length; ft < Qn; ft++) {
                        const Fn = xn[ft]
                          , oi = o.get(Fn);
                        i.bindTexture(u.TEXTURE_2D, oi.__webglTexture),
                        Cn(u.TEXTURE_2D, Fn, Vn),
                        Un(it.__webglFramebuffer, we, Fn, u.COLOR_ATTACHMENT0 + ft, u.TEXTURE_2D),
                        be(Fn, Vn) && Me(u.TEXTURE_2D)
                    }
                    i.unbindTexture()
                } else {
                    let xn = u.TEXTURE_2D;
                    (we.isWebGL3DRenderTarget || we.isWebGLArrayRenderTarget) && (f ? xn = we.isWebGL3DRenderTarget ? u.TEXTURE_3D : u.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
                    i.bindTexture(xn, Ht.__webglTexture),
                    Cn(xn, he, Vn),
                    Un(it.__webglFramebuffer, we, he, u.COLOR_ATTACHMENT0, xn),
                    be(he, Vn) && Me(xn),
                    i.unbindTexture()
                }
                we.depthBuffer && Tt(we)
            }
            function sn(we) {
                const he = K(we) || f
                  , it = we.isWebGLMultipleRenderTargets === !0 ? we.texture : [we.texture];
                for (let Ht = 0, Wt = it.length; Ht < Wt; Ht++) {
                    const an = it[Ht];
                    if (be(an, he)) {
                        const Vn = we.isWebGLCubeRenderTarget ? u.TEXTURE_CUBE_MAP : u.TEXTURE_2D
                          , xn = o.get(an).__webglTexture;
                        i.bindTexture(Vn, xn),
                        Me(Vn),
                        i.unbindTexture()
                    }
                }
            }
            function ri(we) {
                if (f && we.samples > 0 && si(we) === !1) {
                    const he = we.isWebGLMultipleRenderTargets ? we.texture : [we.texture]
                      , it = we.width
                      , Ht = we.height;
                    let Wt = u.COLOR_BUFFER_BIT;
                    const an = []
                      , Vn = we.stencilBuffer ? u.DEPTH_STENCIL_ATTACHMENT : u.DEPTH_ATTACHMENT
                      , xn = o.get(we)
                      , ft = we.isWebGLMultipleRenderTargets === !0;
                    if (ft)
                        for (let Qn = 0; Qn < he.length; Qn++)
                            i.bindFramebuffer(u.FRAMEBUFFER, xn.__webglMultisampledFramebuffer),
                            u.framebufferRenderbuffer(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0 + Qn, u.RENDERBUFFER, null),
                            i.bindFramebuffer(u.FRAMEBUFFER, xn.__webglFramebuffer),
                            u.framebufferTexture2D(u.DRAW_FRAMEBUFFER, u.COLOR_ATTACHMENT0 + Qn, u.TEXTURE_2D, null, 0);
                    i.bindFramebuffer(u.READ_FRAMEBUFFER, xn.__webglMultisampledFramebuffer),
                    i.bindFramebuffer(u.DRAW_FRAMEBUFFER, xn.__webglFramebuffer);
                    for (let Qn = 0; Qn < he.length; Qn++) {
                        an.push(u.COLOR_ATTACHMENT0 + Qn),
                        we.depthBuffer && an.push(Vn);
                        const Fn = xn.__ignoreDepthValues !== void 0 ? xn.__ignoreDepthValues : !1;
                        if (Fn === !1 && (we.depthBuffer && (Wt |= u.DEPTH_BUFFER_BIT),
                        we.stencilBuffer && (Wt |= u.STENCIL_BUFFER_BIT)),
                        ft && u.framebufferRenderbuffer(u.READ_FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.RENDERBUFFER, xn.__webglColorRenderbuffer[Qn]),
                        Fn === !0 && (u.invalidateFramebuffer(u.READ_FRAMEBUFFER, [Vn]),
                        u.invalidateFramebuffer(u.DRAW_FRAMEBUFFER, [Vn])),
                        ft) {
                            const oi = o.get(he[Qn]).__webglTexture;
                            u.framebufferTexture2D(u.DRAW_FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_2D, oi, 0)
                        }
                        u.blitFramebuffer(0, 0, it, Ht, 0, 0, it, Ht, Wt, u.NEAREST),
                        I && u.invalidateFramebuffer(u.READ_FRAMEBUFFER, an)
                    }
                    if (i.bindFramebuffer(u.READ_FRAMEBUFFER, null),
                    i.bindFramebuffer(u.DRAW_FRAMEBUFFER, null),
                    ft)
                        for (let Qn = 0; Qn < he.length; Qn++) {
                            i.bindFramebuffer(u.FRAMEBUFFER, xn.__webglMultisampledFramebuffer),
                            u.framebufferRenderbuffer(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0 + Qn, u.RENDERBUFFER, xn.__webglColorRenderbuffer[Qn]);
                            const Fn = o.get(he[Qn]).__webglTexture;
                            i.bindFramebuffer(u.FRAMEBUFFER, xn.__webglFramebuffer),
                            u.framebufferTexture2D(u.DRAW_FRAMEBUFFER, u.COLOR_ATTACHMENT0 + Qn, u.TEXTURE_2D, Fn, 0)
                        }
                    i.bindFramebuffer(u.DRAW_FRAMEBUFFER, xn.__webglMultisampledFramebuffer)
                }
            }
            function jn(we) {
                return Math.min(P, we.samples)
            }
            function si(we) {
                const he = o.get(we);
                return f && we.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && he.__useRenderToTexture !== !1
            }
            function mr(we) {
                const he = d.render.frame;
                z.get(we) !== he && (z.set(we, he),
                we.update())
            }
            function rr(we, he) {
                const it = we.encoding
                  , Ht = we.format
                  , Wt = we.type;
                return we.isCompressedTexture === !0 || we.isVideoTexture === !0 || we.format === Er || it !== nn && (it === cn ? f === !1 ? e.has("EXT_sRGB") === !0 && Ht === Xr ? (we.format = Er,
                we.minFilter = Hi,
                we.generateMipmaps = !1) : he = yn.sRGBToLinear(he) : (Ht !== Xr || Wt !== bs) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", it)),
                he
            }
            this.allocateTextureUnit = ht,
            this.resetTextureUnits = It,
            this.setTexture2D = Mt,
            this.setTexture2DArray = Ln,
            this.setTexture3D = Ye,
            this.setTextureCube = Pt,
            this.rebindTextures = Kt,
            this.setupRenderTarget = zn,
            this.updateRenderTargetMipmap = sn,
            this.updateMultisampleRenderTarget = ri,
            this.setupDepthRenderbuffer = Tt,
            this.setupFrameBufferTexture = Un,
            this.useMultisampledRTT = si
        }
        function f1(u, e, i) {
            const o = i.isWebGL2;
            function a(c, d=null) {
                let f;
                if (c === bs)
                    return u.UNSIGNED_BYTE;
                if (c === Fa)
                    return u.UNSIGNED_SHORT_4_4_4_4;
                if (c === Wl)
                    return u.UNSIGNED_SHORT_5_5_5_1;
                if (c === jo)
                    return u.BYTE;
                if (c === us)
                    return u.SHORT;
                if (c === ha)
                    return u.UNSIGNED_SHORT;
                if (c === da)
                    return u.INT;
                if (c === uo)
                    return u.UNSIGNED_INT;
                if (c === Js)
                    return u.FLOAT;
                if (c === So)
                    return o ? u.HALF_FLOAT : (f = e.get("OES_texture_half_float"),
                    f !== null ? f.HALF_FLOAT_OES : null);
                if (c === jl)
                    return u.ALPHA;
                if (c === Xr)
                    return u.RGBA;
                if (c === ol)
                    return u.LUMINANCE;
                if (c === al)
                    return u.LUMINANCE_ALPHA;
                if (c === $s)
                    return u.DEPTH_COMPONENT;
                if (c === ho)
                    return u.DEPTH_STENCIL;
                if (c === Er)
                    return f = e.get("EXT_sRGB"),
                    f !== null ? f.SRGB_ALPHA_EXT : null;
                if (c === Xl)
                    return u.RED;
                if (c === ll)
                    return u.RED_INTEGER;
                if (c === cl)
                    return u.RG;
                if (c === fa)
                    return u.RG_INTEGER;
                if (c === ul)
                    return u.RGBA_INTEGER;
                if (c === ka || c === Ua || c === Na || c === pa)
                    if (d === cn)
                        if (f = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                        f !== null) {
                            if (c === ka)
                                return f.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (c === Ua)
                                return f.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (c === Na)
                                return f.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (c === pa)
                                return f.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else
                            return null;
                    else if (f = e.get("WEBGL_compressed_texture_s3tc"),
                    f !== null) {
                        if (c === ka)
                            return f.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (c === Ua)
                            return f.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (c === Na)
                            return f.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (c === pa)
                            return f.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    } else
                        return null;
                if (c === hl || c === za || c === ma || c === nr)
                    if (f = e.get("WEBGL_compressed_texture_pvrtc"),
                    f !== null) {
                        if (c === hl)
                            return f.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (c === za)
                            return f.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (c === ma)
                            return f.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (c === nr)
                            return f.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    } else
                        return null;
                if (c === fo)
                    return f = e.get("WEBGL_compressed_texture_etc1"),
                    f !== null ? f.COMPRESSED_RGB_ETC1_WEBGL : null;
                if (c === Ga || c === dl)
                    if (f = e.get("WEBGL_compressed_texture_etc"),
                    f !== null) {
                        if (c === Ga)
                            return d === cn ? f.COMPRESSED_SRGB8_ETC2 : f.COMPRESSED_RGB8_ETC2;
                        if (c === dl)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : f.COMPRESSED_RGBA8_ETC2_EAC
                    } else
                        return null;
                if (c === fl || c === pl || c === ga || c === Ha || c === To || c === Eo || c === Yr || c === Qr || c === va || c === po || c === Mo || c === Xo || c === zs || c === _a)
                    if (f = e.get("WEBGL_compressed_texture_astc"),
                    f !== null) {
                        if (c === fl)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : f.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (c === pl)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : f.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (c === ga)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : f.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (c === Ha)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : f.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (c === To)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : f.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (c === Eo)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : f.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (c === Yr)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : f.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (c === Qr)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : f.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (c === va)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : f.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (c === po)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : f.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (c === Mo)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : f.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (c === Xo)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : f.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (c === zs)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : f.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (c === _a)
                            return d === cn ? f.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : f.COMPRESSED_RGBA_ASTC_12x12_KHR
                    } else
                        return null;
                if (c === Co)
                    if (f = e.get("EXT_texture_compression_bptc"),
                    f !== null) {
                        if (c === Co)
                            return d === cn ? f.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : f.COMPRESSED_RGBA_BPTC_UNORM_EXT
                    } else
                        return null;
                if (c === Va || c === eo || c === ns || c === Po)
                    if (f = e.get("EXT_texture_compression_rgtc"),
                    f !== null) {
                        if (c === Co)
                            return f.COMPRESSED_RED_RGTC1_EXT;
                        if (c === eo)
                            return f.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (c === ns)
                            return f.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (c === Po)
                            return f.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    } else
                        return null;
                return c === ti ? o ? u.UNSIGNED_INT_24_8 : (f = e.get("WEBGL_depth_texture"),
                f !== null ? f.UNSIGNED_INT_24_8_WEBGL : null) : u[c] !== void 0 ? u[c] : null
            }
            return {
                convert: a
            }
        }
        class p1 extends Ms {
            constructor(e=[]) {
                super(),
                this.isArrayCamera = !0,
                this.cameras = e
            }
        }
        class Nu extends Qi {
            constructor() {
                super(),
                this.isGroup = !0,
                this.type = "Group"
            }
        }
        const qP = {
            type: "move"
        };
        class c0 {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return this._hand === null && (this._hand = new Nu,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return this._targetRay === null && (this._targetRay = new Nu,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new me,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new me),
                this._targetRay
            }
            getGripSpace() {
                return this._grip === null && (this._grip = new Nu,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new me,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new me),
                this._grip
            }
            dispatchEvent(e) {
                return this._targetRay !== null && this._targetRay.dispatchEvent(e),
                this._grip !== null && this._grip.dispatchEvent(e),
                this._hand !== null && this._hand.dispatchEvent(e),
                this
            }
            connect(e) {
                if (e && e.hand) {
                    const i = this._hand;
                    if (i)
                        for (const o of e.hand.values())
                            this._getHandJoint(i, o)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: e
                }),
                this
            }
            disconnect(e) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: e
                }),
                this._targetRay !== null && (this._targetRay.visible = !1),
                this._grip !== null && (this._grip.visible = !1),
                this._hand !== null && (this._hand.visible = !1),
                this
            }
            update(e, i, o) {
                let a = null
                  , c = null
                  , d = null;
                const f = this._targetRay
                  , v = this._grip
                  , x = this._hand;
                if (e && i.session.visibilityState !== "visible-blurred") {
                    if (x && e.hand) {
                        d = !0;
                        for (const O of e.hand.values()) {
                            const k = i.getJointPose(O, o)
                              , Q = this._getHandJoint(x, O);
                            k !== null && (Q.matrix.fromArray(k.transform.matrix),
                            Q.matrix.decompose(Q.position, Q.rotation, Q.scale),
                            Q.jointRadius = k.radius),
                            Q.visible = k !== null
                        }
                        const w = x.joints["index-finger-tip"]
                          , P = x.joints["thumb-tip"]
                          , M = w.position.distanceTo(P.position)
                          , I = .02
                          , z = .005;
                        x.inputState.pinching && M > I + z ? (x.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: e.handedness,
                            target: this
                        })) : !x.inputState.pinching && M <= I - z && (x.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: e.handedness,
                            target: this
                        }))
                    } else
                        v !== null && e.gripSpace && (c = i.getPose(e.gripSpace, o),
                        c !== null && (v.matrix.fromArray(c.transform.matrix),
                        v.matrix.decompose(v.position, v.rotation, v.scale),
                        c.linearVelocity ? (v.hasLinearVelocity = !0,
                        v.linearVelocity.copy(c.linearVelocity)) : v.hasLinearVelocity = !1,
                        c.angularVelocity ? (v.hasAngularVelocity = !0,
                        v.angularVelocity.copy(c.angularVelocity)) : v.hasAngularVelocity = !1));
                    f !== null && (a = i.getPose(e.targetRaySpace, o),
                    a === null && c !== null && (a = c),
                    a !== null && (f.matrix.fromArray(a.transform.matrix),
                    f.matrix.decompose(f.position, f.rotation, f.scale),
                    a.linearVelocity ? (f.hasLinearVelocity = !0,
                    f.linearVelocity.copy(a.linearVelocity)) : f.hasLinearVelocity = !1,
                    a.angularVelocity ? (f.hasAngularVelocity = !0,
                    f.angularVelocity.copy(a.angularVelocity)) : f.hasAngularVelocity = !1,
                    this.dispatchEvent(qP)))
                }
                return f !== null && (f.visible = a !== null),
                v !== null && (v.visible = c !== null),
                x !== null && (x.visible = d !== null),
                this
            }
            _getHandJoint(e, i) {
                if (e.joints[i.jointName] === void 0) {
                    const o = new Nu;
                    o.matrixAutoUpdate = !1,
                    o.visible = !1,
                    e.joints[i.jointName] = o,
                    e.add(o)
                }
                return e.joints[i.jointName]
            }
        }
        class m1 extends $t {
            constructor(e, i, o, a, c, d, f, v, x, w) {
                if (w = w !== void 0 ? w : $s,
                w !== $s && w !== ho)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                o === void 0 && w === $s && (o = uo),
                o === void 0 && w === ho && (o = ti),
                super(null, a, c, d, f, v, w, o, x),
                this.isDepthTexture = !0,
                this.image = {
                    width: e,
                    height: i
                },
                this.magFilter = f !== void 0 ? f : gi,
                this.minFilter = v !== void 0 ? v : gi,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        class JP extends Kr {
            constructor(e, i) {
                super();
                const o = this;
                let a = null
                  , c = 1
                  , d = null
                  , f = "local-floor"
                  , v = 1
                  , x = null
                  , w = null
                  , P = null
                  , M = null
                  , I = null
                  , z = null;
                const O = i.getContextAttributes();
                let k = null
                  , Q = null;
                const Z = []
                  , X = []
                  , K = new Set
                  , de = new Map
                  , be = new Ms;
                be.layers.enable(1),
                be.viewport = new mn;
                const Me = new Ms;
                Me.layers.enable(2),
                Me.viewport = new mn;
                const J = [be, Me]
                  , ge = new p1;
                ge.layers.enable(1),
                ge.layers.enable(2);
                let Le = null
                  , tt = null;
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(Ye) {
                    let Pt = Z[Ye];
                    return Pt === void 0 && (Pt = new c0,
                    Z[Ye] = Pt),
                    Pt.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(Ye) {
                    let Pt = Z[Ye];
                    return Pt === void 0 && (Pt = new c0,
                    Z[Ye] = Pt),
                    Pt.getGripSpace()
                }
                ,
                this.getHand = function(Ye) {
                    let Pt = Z[Ye];
                    return Pt === void 0 && (Pt = new c0,
                    Z[Ye] = Pt),
                    Pt.getHandSpace()
                }
                ;
                function lt(Ye) {
                    const Pt = X.indexOf(Ye.inputSource);
                    if (Pt === -1)
                        return;
                    const tn = Z[Pt];
                    tn !== void 0 && tn.dispatchEvent({
                        type: Ye.type,
                        data: Ye.inputSource
                    })
                }
                function je() {
                    a.removeEventListener("select", lt),
                    a.removeEventListener("selectstart", lt),
                    a.removeEventListener("selectend", lt),
                    a.removeEventListener("squeeze", lt),
                    a.removeEventListener("squeezestart", lt),
                    a.removeEventListener("squeezeend", lt),
                    a.removeEventListener("end", je),
                    a.removeEventListener("inputsourceschange", ze);
                    for (let Ye = 0; Ye < Z.length; Ye++) {
                        const Pt = X[Ye];
                        Pt !== null && (X[Ye] = null,
                        Z[Ye].disconnect(Pt))
                    }
                    Le = null,
                    tt = null,
                    e.setRenderTarget(k),
                    I = null,
                    M = null,
                    P = null,
                    a = null,
                    Q = null,
                    Ln.stop(),
                    o.isPresenting = !1,
                    o.dispatchEvent({
                        type: "sessionend"
                    })
                }
                this.setFramebufferScaleFactor = function(Ye) {
                    c = Ye,
                    o.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(Ye) {
                    f = Ye,
                    o.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return x || d
                }
                ,
                this.setReferenceSpace = function(Ye) {
                    x = Ye
                }
                ,
                this.getBaseLayer = function() {
                    return M !== null ? M : I
                }
                ,
                this.getBinding = function() {
                    return P
                }
                ,
                this.getFrame = function() {
                    return z
                }
                ,
                this.getSession = function() {
                    return a
                }
                ,
                this.setSession = async function(Ye) {
                    if (a = Ye,
                    a !== null) {
                        if (k = e.getRenderTarget(),
                        a.addEventListener("select", lt),
                        a.addEventListener("selectstart", lt),
                        a.addEventListener("selectend", lt),
                        a.addEventListener("squeeze", lt),
                        a.addEventListener("squeezestart", lt),
                        a.addEventListener("squeezeend", lt),
                        a.addEventListener("end", je),
                        a.addEventListener("inputsourceschange", ze),
                        O.xrCompatible !== !0 && await i.makeXRCompatible(),
                        a.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                            const Pt = {
                                antialias: a.renderState.layers === void 0 ? O.antialias : !0,
                                alpha: O.alpha,
                                depth: O.depth,
                                stencil: O.stencil,
                                framebufferScaleFactor: c
                            };
                            I = new XRWebGLLayer(a,i,Pt),
                            a.updateRenderState({
                                baseLayer: I
                            }),
                            Q = new ki(I.framebufferWidth,I.framebufferHeight,{
                                format: Xr,
                                type: bs,
                                encoding: e.outputEncoding,
                                stencilBuffer: O.stencil
                            })
                        } else {
                            let Pt = null
                              , tn = null
                              , De = null;
                            O.depth && (De = O.stencil ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24,
                            Pt = O.stencil ? ho : $s,
                            tn = O.stencil ? ti : uo);
                            const Cn = {
                                colorFormat: i.RGBA8,
                                depthFormat: De,
                                scaleFactor: c
                            };
                            P = new XRWebGLBinding(a,i),
                            M = P.createProjectionLayer(Cn),
                            a.updateRenderState({
                                layers: [M]
                            }),
                            Q = new ki(M.textureWidth,M.textureHeight,{
                                format: Xr,
                                type: bs,
                                depthTexture: new m1(M.textureWidth,M.textureHeight,tn,void 0,void 0,void 0,void 0,void 0,void 0,Pt),
                                stencilBuffer: O.stencil,
                                encoding: e.outputEncoding,
                                samples: O.antialias ? 4 : 0
                            });
                            const on = e.properties.get(Q);
                            on.__ignoreDepthValues = M.ignoreDepthValues
                        }
                        Q.isXRRenderTarget = !0,
                        this.setFoveation(v),
                        x = null,
                        d = await a.requestReferenceSpace(f),
                        Ln.setContext(a),
                        Ln.start(),
                        o.isPresenting = !0,
                        o.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ;
                function ze(Ye) {
                    for (let Pt = 0; Pt < Ye.removed.length; Pt++) {
                        const tn = Ye.removed[Pt]
                          , De = X.indexOf(tn);
                        De >= 0 && (X[De] = null,
                        Z[De].disconnect(tn))
                    }
                    for (let Pt = 0; Pt < Ye.added.length; Pt++) {
                        const tn = Ye.added[Pt];
                        let De = X.indexOf(tn);
                        if (De === -1) {
                            for (let on = 0; on < Z.length; on++)
                                if (on >= X.length) {
                                    X.push(tn),
                                    De = on;
                                    break
                                } else if (X[on] === null) {
                                    X[on] = tn,
                                    De = on;
                                    break
                                }
                            if (De === -1)
                                break
                        }
                        const Cn = Z[De];
                        Cn && Cn.connect(tn)
                    }
                }
                const st = new me
                  , yt = new me;
                function It(Ye, Pt, tn) {
                    st.setFromMatrixPosition(Pt.matrixWorld),
                    yt.setFromMatrixPosition(tn.matrixWorld);
                    const De = st.distanceTo(yt)
                      , Cn = Pt.projectionMatrix.elements
                      , on = tn.projectionMatrix.elements
                      , Mn = Cn[14] / (Cn[10] - 1)
                      , In = Cn[14] / (Cn[10] + 1)
                      , Un = (Cn[9] + 1) / Cn[5]
                      , ei = (Cn[9] - 1) / Cn[5]
                      , dt = (Cn[8] - 1) / Cn[0]
                      , Tt = (on[8] + 1) / on[0]
                      , Kt = Mn * dt
                      , zn = Mn * Tt
                      , sn = De / (-dt + Tt)
                      , ri = sn * -dt;
                    Pt.matrixWorld.decompose(Ye.position, Ye.quaternion, Ye.scale),
                    Ye.translateX(ri),
                    Ye.translateZ(sn),
                    Ye.matrixWorld.compose(Ye.position, Ye.quaternion, Ye.scale),
                    Ye.matrixWorldInverse.copy(Ye.matrixWorld).invert();
                    const jn = Mn + sn
                      , si = In + sn
                      , mr = Kt - ri
                      , rr = zn + (De - ri)
                      , we = Un * In / si * jn
                      , he = ei * In / si * jn;
                    Ye.projectionMatrix.makePerspective(mr, rr, we, he, jn, si)
                }
                function ht(Ye, Pt) {
                    Pt === null ? Ye.matrixWorld.copy(Ye.matrix) : Ye.matrixWorld.multiplyMatrices(Pt.matrixWorld, Ye.matrix),
                    Ye.matrixWorldInverse.copy(Ye.matrixWorld).invert()
                }
                this.updateCamera = function(Ye) {
                    if (a === null)
                        return;
                    ge.near = Me.near = be.near = Ye.near,
                    ge.far = Me.far = be.far = Ye.far,
                    (Le !== ge.near || tt !== ge.far) && (a.updateRenderState({
                        depthNear: ge.near,
                        depthFar: ge.far
                    }),
                    Le = ge.near,
                    tt = ge.far);
                    const Pt = Ye.parent
                      , tn = ge.cameras;
                    ht(ge, Pt);
                    for (let Cn = 0; Cn < tn.length; Cn++)
                        ht(tn[Cn], Pt);
                    ge.matrixWorld.decompose(ge.position, ge.quaternion, ge.scale),
                    Ye.matrix.copy(ge.matrix),
                    Ye.matrix.decompose(Ye.position, Ye.quaternion, Ye.scale);
                    const De = Ye.children;
                    for (let Cn = 0, on = De.length; Cn < on; Cn++)
                        De[Cn].updateMatrixWorld(!0);
                    tn.length === 2 ? It(ge, be, Me) : ge.projectionMatrix.copy(be.projectionMatrix)
                }
                ,
                this.getCamera = function() {
                    return ge
                }
                ,
                this.getFoveation = function() {
                    if (!(M === null && I === null))
                        return v
                }
                ,
                this.setFoveation = function(Ye) {
                    v = Ye,
                    M !== null && (M.fixedFoveation = Ye),
                    I !== null && I.fixedFoveation !== void 0 && (I.fixedFoveation = Ye)
                }
                ,
                this.getPlanes = function() {
                    return K
                }
                ;
                let Ot = null;
                function Mt(Ye, Pt) {
                    if (w = Pt.getViewerPose(x || d),
                    z = Pt,
                    w !== null) {
                        const tn = w.views;
                        I !== null && (e.setRenderTargetFramebuffer(Q, I.framebuffer),
                        e.setRenderTarget(Q));
                        let De = !1;
                        tn.length !== ge.cameras.length && (ge.cameras.length = 0,
                        De = !0);
                        for (let Cn = 0; Cn < tn.length; Cn++) {
                            const on = tn[Cn];
                            let Mn = null;
                            if (I !== null)
                                Mn = I.getViewport(on);
                            else {
                                const Un = P.getViewSubImage(M, on);
                                Mn = Un.viewport,
                                Cn === 0 && (e.setRenderTargetTextures(Q, Un.colorTexture, M.ignoreDepthValues ? void 0 : Un.depthStencilTexture),
                                e.setRenderTarget(Q))
                            }
                            let In = J[Cn];
                            In === void 0 && (In = new Ms,
                            In.layers.enable(Cn),
                            In.viewport = new mn,
                            J[Cn] = In),
                            In.matrix.fromArray(on.transform.matrix),
                            In.projectionMatrix.fromArray(on.projectionMatrix),
                            In.viewport.set(Mn.x, Mn.y, Mn.width, Mn.height),
                            Cn === 0 && ge.matrix.copy(In.matrix),
                            De === !0 && ge.cameras.push(In)
                        }
                    }
                    for (let tn = 0; tn < Z.length; tn++) {
                        const De = X[tn]
                          , Cn = Z[tn];
                        De !== null && Cn !== void 0 && Cn.update(De, Pt, x || d)
                    }
                    if (Ot && Ot(Ye, Pt),
                    Pt.detectedPlanes) {
                        o.dispatchEvent({
                            type: "planesdetected",
                            data: Pt.detectedPlanes
                        });
                        let tn = null;
                        for (const De of K)
                            Pt.detectedPlanes.has(De) || (tn === null && (tn = []),
                            tn.push(De));
                        if (tn !== null)
                            for (const De of tn)
                                K.delete(De),
                                de.delete(De),
                                o.dispatchEvent({
                                    type: "planeremoved",
                                    data: De
                                });
                        for (const De of Pt.detectedPlanes)
                            if (!K.has(De))
                                K.add(De),
                                de.set(De, Pt.lastChangedTime),
                                o.dispatchEvent({
                                    type: "planeadded",
                                    data: De
                                });
                            else {
                                const Cn = de.get(De);
                                De.lastChangedTime > Cn && (de.set(De, De.lastChangedTime),
                                o.dispatchEvent({
                                    type: "planechanged",
                                    data: De
                                }))
                            }
                    }
                    z = null
                }
                const Ln = new Gx;
                Ln.setAnimationLoop(Mt),
                this.setAnimationLoop = function(Ye) {
                    Ot = Ye
                }
                ,
                this.dispose = function() {}
            }
        }
        function $P(u, e) {
            function i(O, k) {
                k.color.getRGB(O.fogColor.value, kx(u)),
                k.isFog ? (O.fogNear.value = k.near,
                O.fogFar.value = k.far) : k.isFogExp2 && (O.fogDensity.value = k.density)
            }
            function o(O, k, Q, Z, X) {
                k.isMeshBasicMaterial || k.isMeshLambertMaterial ? a(O, k) : k.isMeshToonMaterial ? (a(O, k),
                w(O, k)) : k.isMeshPhongMaterial ? (a(O, k),
                x(O, k)) : k.isMeshStandardMaterial ? (a(O, k),
                P(O, k),
                k.isMeshPhysicalMaterial && M(O, k, X)) : k.isMeshMatcapMaterial ? (a(O, k),
                I(O, k)) : k.isMeshDepthMaterial ? a(O, k) : k.isMeshDistanceMaterial ? (a(O, k),
                z(O, k)) : k.isMeshNormalMaterial ? a(O, k) : k.isLineBasicMaterial ? (c(O, k),
                k.isLineDashedMaterial && d(O, k)) : k.isPointsMaterial ? f(O, k, Q, Z) : k.isSpriteMaterial ? v(O, k) : k.isShadowMaterial ? (O.color.value.copy(k.color),
                O.opacity.value = k.opacity) : k.isShaderMaterial && (k.uniformsNeedUpdate = !1)
            }
            function a(O, k) {
                O.opacity.value = k.opacity,
                k.color && O.diffuse.value.copy(k.color),
                k.emissive && O.emissive.value.copy(k.emissive).multiplyScalar(k.emissiveIntensity),
                k.map && (O.map.value = k.map),
                k.alphaMap && (O.alphaMap.value = k.alphaMap),
                k.bumpMap && (O.bumpMap.value = k.bumpMap,
                O.bumpScale.value = k.bumpScale,
                k.side === $ && (O.bumpScale.value *= -1)),
                k.displacementMap && (O.displacementMap.value = k.displacementMap,
                O.displacementScale.value = k.displacementScale,
                O.displacementBias.value = k.displacementBias),
                k.emissiveMap && (O.emissiveMap.value = k.emissiveMap),
                k.normalMap && (O.normalMap.value = k.normalMap,
                O.normalScale.value.copy(k.normalScale),
                k.side === $ && O.normalScale.value.negate()),
                k.specularMap && (O.specularMap.value = k.specularMap),
                k.alphaTest > 0 && (O.alphaTest.value = k.alphaTest);
                const Q = e.get(k).envMap;
                if (Q && (O.envMap.value = Q,
                O.flipEnvMap.value = Q.isCubeTexture && Q.isRenderTargetTexture === !1 ? -1 : 1,
                O.reflectivity.value = k.reflectivity,
                O.ior.value = k.ior,
                O.refractionRatio.value = k.refractionRatio),
                k.lightMap) {
                    O.lightMap.value = k.lightMap;
                    const K = u.useLegacyLights === !0 ? Math.PI : 1;
                    O.lightMapIntensity.value = k.lightMapIntensity * K
                }
                k.aoMap && (O.aoMap.value = k.aoMap,
                O.aoMapIntensity.value = k.aoMapIntensity);
                let Z;
                k.map ? Z = k.map : k.specularMap ? Z = k.specularMap : k.displacementMap ? Z = k.displacementMap : k.normalMap ? Z = k.normalMap : k.bumpMap ? Z = k.bumpMap : k.roughnessMap ? Z = k.roughnessMap : k.metalnessMap ? Z = k.metalnessMap : k.alphaMap ? Z = k.alphaMap : k.emissiveMap ? Z = k.emissiveMap : k.clearcoatMap ? Z = k.clearcoatMap : k.clearcoatNormalMap ? Z = k.clearcoatNormalMap : k.clearcoatRoughnessMap ? Z = k.clearcoatRoughnessMap : k.iridescenceMap ? Z = k.iridescenceMap : k.iridescenceThicknessMap ? Z = k.iridescenceThicknessMap : k.specularIntensityMap ? Z = k.specularIntensityMap : k.specularColorMap ? Z = k.specularColorMap : k.transmissionMap ? Z = k.transmissionMap : k.thicknessMap ? Z = k.thicknessMap : k.sheenColorMap ? Z = k.sheenColorMap : k.sheenRoughnessMap && (Z = k.sheenRoughnessMap),
                Z !== void 0 && (Z.isWebGLRenderTarget && (Z = Z.texture),
                Z.matrixAutoUpdate === !0 && Z.updateMatrix(),
                O.uvTransform.value.copy(Z.matrix));
                let X;
                k.aoMap ? X = k.aoMap : k.lightMap && (X = k.lightMap),
                X !== void 0 && (X.isWebGLRenderTarget && (X = X.texture),
                X.matrixAutoUpdate === !0 && X.updateMatrix(),
                O.uv2Transform.value.copy(X.matrix))
            }
            function c(O, k) {
                O.diffuse.value.copy(k.color),
                O.opacity.value = k.opacity
            }
            function d(O, k) {
                O.dashSize.value = k.dashSize,
                O.totalSize.value = k.dashSize + k.gapSize,
                O.scale.value = k.scale
            }
            function f(O, k, Q, Z) {
                O.diffuse.value.copy(k.color),
                O.opacity.value = k.opacity,
                O.size.value = k.size * Q,
                O.scale.value = Z * .5,
                k.map && (O.map.value = k.map),
                k.alphaMap && (O.alphaMap.value = k.alphaMap),
                k.alphaTest > 0 && (O.alphaTest.value = k.alphaTest);
                let X;
                k.map ? X = k.map : k.alphaMap && (X = k.alphaMap),
                X !== void 0 && (X.matrixAutoUpdate === !0 && X.updateMatrix(),
                O.uvTransform.value.copy(X.matrix))
            }
            function v(O, k) {
                O.diffuse.value.copy(k.color),
                O.opacity.value = k.opacity,
                O.rotation.value = k.rotation,
                k.map && (O.map.value = k.map),
                k.alphaMap && (O.alphaMap.value = k.alphaMap),
                k.alphaTest > 0 && (O.alphaTest.value = k.alphaTest);
                let Q;
                k.map ? Q = k.map : k.alphaMap && (Q = k.alphaMap),
                Q !== void 0 && (Q.matrixAutoUpdate === !0 && Q.updateMatrix(),
                O.uvTransform.value.copy(Q.matrix))
            }
            function x(O, k) {
                O.specular.value.copy(k.specular),
                O.shininess.value = Math.max(k.shininess, 1e-4)
            }
            function w(O, k) {
                k.gradientMap && (O.gradientMap.value = k.gradientMap)
            }
            function P(O, k) {
                O.roughness.value = k.roughness,
                O.metalness.value = k.metalness,
                k.roughnessMap && (O.roughnessMap.value = k.roughnessMap),
                k.metalnessMap && (O.metalnessMap.value = k.metalnessMap),
                e.get(k).envMap && (O.envMapIntensity.value = k.envMapIntensity)
            }
            function M(O, k, Q) {
                O.ior.value = k.ior,
                k.sheen > 0 && (O.sheenColor.value.copy(k.sheenColor).multiplyScalar(k.sheen),
                O.sheenRoughness.value = k.sheenRoughness,
                k.sheenColorMap && (O.sheenColorMap.value = k.sheenColorMap),
                k.sheenRoughnessMap && (O.sheenRoughnessMap.value = k.sheenRoughnessMap)),
                k.clearcoat > 0 && (O.clearcoat.value = k.clearcoat,
                O.clearcoatRoughness.value = k.clearcoatRoughness,
                k.clearcoatMap && (O.clearcoatMap.value = k.clearcoatMap),
                k.clearcoatRoughnessMap && (O.clearcoatRoughnessMap.value = k.clearcoatRoughnessMap),
                k.clearcoatNormalMap && (O.clearcoatNormalScale.value.copy(k.clearcoatNormalScale),
                O.clearcoatNormalMap.value = k.clearcoatNormalMap,
                k.side === $ && O.clearcoatNormalScale.value.negate())),
                k.iridescence > 0 && (O.iridescence.value = k.iridescence,
                O.iridescenceIOR.value = k.iridescenceIOR,
                O.iridescenceThicknessMinimum.value = k.iridescenceThicknessRange[0],
                O.iridescenceThicknessMaximum.value = k.iridescenceThicknessRange[1],
                k.iridescenceMap && (O.iridescenceMap.value = k.iridescenceMap),
                k.iridescenceThicknessMap && (O.iridescenceThicknessMap.value = k.iridescenceThicknessMap)),
                k.transmission > 0 && (O.transmission.value = k.transmission,
                O.transmissionSamplerMap.value = Q.texture,
                O.transmissionSamplerSize.value.set(Q.width, Q.height),
                k.transmissionMap && (O.transmissionMap.value = k.transmissionMap),
                O.thickness.value = k.thickness,
                k.thicknessMap && (O.thicknessMap.value = k.thicknessMap),
                O.attenuationDistance.value = k.attenuationDistance,
                O.attenuationColor.value.copy(k.attenuationColor)),
                O.specularIntensity.value = k.specularIntensity,
                O.specularColor.value.copy(k.specularColor),
                k.specularIntensityMap && (O.specularIntensityMap.value = k.specularIntensityMap),
                k.specularColorMap && (O.specularColorMap.value = k.specularColorMap)
            }
            function I(O, k) {
                k.matcap && (O.matcap.value = k.matcap)
            }
            function z(O, k) {
                O.referencePosition.value.copy(k.referencePosition),
                O.nearDistance.value = k.nearDistance,
                O.farDistance.value = k.farDistance
            }
            return {
                refreshFogUniforms: i,
                refreshMaterialUniforms: o
            }
        }
        function eR(u, e, i, o) {
            let a = {}
              , c = {}
              , d = [];
            const f = i.isWebGL2 ? u.getParameter(u.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
            function v(Z, X) {
                const K = X.program;
                o.uniformBlockBinding(Z, K)
            }
            function x(Z, X) {
                let K = a[Z.id];
                K === void 0 && (z(Z),
                K = w(Z),
                a[Z.id] = K,
                Z.addEventListener("dispose", k));
                const de = X.program;
                o.updateUBOMapping(Z, de);
                const be = e.render.frame;
                c[Z.id] !== be && (M(Z),
                c[Z.id] = be)
            }
            function w(Z) {
                const X = P();
                Z.__bindingPointIndex = X;
                const K = u.createBuffer()
                  , de = Z.__size
                  , be = Z.usage;
                return u.bindBuffer(u.UNIFORM_BUFFER, K),
                u.bufferData(u.UNIFORM_BUFFER, de, be),
                u.bindBuffer(u.UNIFORM_BUFFER, null),
                u.bindBufferBase(u.UNIFORM_BUFFER, X, K),
                K
            }
            function P() {
                for (let Z = 0; Z < f; Z++)
                    if (d.indexOf(Z) === -1)
                        return d.push(Z),
                        Z;
                return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                0
            }
            function M(Z) {
                const X = a[Z.id]
                  , K = Z.uniforms
                  , de = Z.__cache;
                u.bindBuffer(u.UNIFORM_BUFFER, X);
                for (let be = 0, Me = K.length; be < Me; be++) {
                    const J = K[be];
                    if (I(J, be, de) === !0) {
                        const ge = J.__offset
                          , Le = Array.isArray(J.value) ? J.value : [J.value];
                        let tt = 0;
                        for (let lt = 0; lt < Le.length; lt++) {
                            const je = Le[lt]
                              , ze = O(je);
                            typeof je == "number" ? (J.__data[0] = je,
                            u.bufferSubData(u.UNIFORM_BUFFER, ge + tt, J.__data)) : je.isMatrix3 ? (J.__data[0] = je.elements[0],
                            J.__data[1] = je.elements[1],
                            J.__data[2] = je.elements[2],
                            J.__data[3] = je.elements[0],
                            J.__data[4] = je.elements[3],
                            J.__data[5] = je.elements[4],
                            J.__data[6] = je.elements[5],
                            J.__data[7] = je.elements[0],
                            J.__data[8] = je.elements[6],
                            J.__data[9] = je.elements[7],
                            J.__data[10] = je.elements[8],
                            J.__data[11] = je.elements[0]) : (je.toArray(J.__data, tt),
                            tt += ze.storage / Float32Array.BYTES_PER_ELEMENT)
                        }
                        u.bufferSubData(u.UNIFORM_BUFFER, ge, J.__data)
                    }
                }
                u.bindBuffer(u.UNIFORM_BUFFER, null)
            }
            function I(Z, X, K) {
                const de = Z.value;
                if (K[X] === void 0) {
                    if (typeof de == "number")
                        K[X] = de;
                    else {
                        const be = Array.isArray(de) ? de : [de]
                          , Me = [];
                        for (let J = 0; J < be.length; J++)
                            Me.push(be[J].clone());
                        K[X] = Me
                    }
                    return !0
                } else if (typeof de == "number") {
                    if (K[X] !== de)
                        return K[X] = de,
                        !0
                } else {
                    const be = Array.isArray(K[X]) ? K[X] : [K[X]]
                      , Me = Array.isArray(de) ? de : [de];
                    for (let J = 0; J < be.length; J++) {
                        const ge = be[J];
                        if (ge.equals(Me[J]) === !1)
                            return ge.copy(Me[J]),
                            !0
                    }
                }
                return !1
            }
            function z(Z) {
                const X = Z.uniforms;
                let K = 0;
                const de = 16;
                let be = 0;
                for (let Me = 0, J = X.length; Me < J; Me++) {
                    const ge = X[Me]
                      , Le = {
                        boundary: 0,
                        storage: 0
                    }
                      , tt = Array.isArray(ge.value) ? ge.value : [ge.value];
                    for (let lt = 0, je = tt.length; lt < je; lt++) {
                        const ze = tt[lt]
                          , st = O(ze);
                        Le.boundary += st.boundary,
                        Le.storage += st.storage
                    }
                    if (ge.__data = new Float32Array(Le.storage / Float32Array.BYTES_PER_ELEMENT),
                    ge.__offset = K,
                    Me > 0) {
                        be = K % de;
                        const lt = de - be;
                        be !== 0 && lt - Le.boundary < 0 && (K += de - be,
                        ge.__offset = K)
                    }
                    K += Le.storage
                }
                return be = K % de,
                be > 0 && (K += de - be),
                Z.__size = K,
                Z.__cache = {},
                this
            }
            function O(Z) {
                const X = {
                    boundary: 0,
                    storage: 0
                };
                return typeof Z == "number" ? (X.boundary = 4,
                X.storage = 4) : Z.isVector2 ? (X.boundary = 8,
                X.storage = 8) : Z.isVector3 || Z.isColor ? (X.boundary = 16,
                X.storage = 12) : Z.isVector4 ? (X.boundary = 16,
                X.storage = 16) : Z.isMatrix3 ? (X.boundary = 48,
                X.storage = 48) : Z.isMatrix4 ? (X.boundary = 64,
                X.storage = 64) : Z.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", Z),
                X
            }
            function k(Z) {
                const X = Z.target;
                X.removeEventListener("dispose", k);
                const K = d.indexOf(X.__bindingPointIndex);
                d.splice(K, 1),
                u.deleteBuffer(a[X.id]),
                delete a[X.id],
                delete c[X.id]
            }
            function Q() {
                for (const Z in a)
                    u.deleteBuffer(a[Z]);
                d = [],
                a = {},
                c = {}
            }
            return {
                bind: v,
                update: x,
                dispose: Q
            }
        }
        function tR() {
            const u = Y("canvas");
            return u.style.display = "block",
            u
        }
        function u0(u={}) {
            this.isWebGLRenderer = !0;
            const e = u.canvas !== void 0 ? u.canvas : tR()
              , i = u.context !== void 0 ? u.context : null
              , o = u.depth !== void 0 ? u.depth : !0
              , a = u.stencil !== void 0 ? u.stencil : !0
              , c = u.antialias !== void 0 ? u.antialias : !1
              , d = u.premultipliedAlpha !== void 0 ? u.premultipliedAlpha : !0
              , f = u.preserveDrawingBuffer !== void 0 ? u.preserveDrawingBuffer : !1
              , v = u.powerPreference !== void 0 ? u.powerPreference : "default"
              , x = u.failIfMajorPerformanceCaveat !== void 0 ? u.failIfMajorPerformanceCaveat : !1;
            let w;
            i !== null ? w = i.getContextAttributes().alpha : w = u.alpha !== void 0 ? u.alpha : !1;
            let P = null
              , M = null;
            const I = []
              , z = [];
            this.globalUniforms = {},
            this.domElement = e,
            this.debug = {
                checkShaderErrors: !0
            },
            this.autoClear = !0,
            this.autoClearColor = !0,
            this.autoClearDepth = !0,
            this.autoClearStencil = !0,
            this.sortObjects = !0,
            this.clippingPlanes = [],
            this.localClippingEnabled = !1,
            this.outputEncoding = nn,
            this.useLegacyLights = !0,
            this.toneMapping = Gt,
            this.toneMappingExposure = 1;
            const O = this;
            let k = !1
              , Q = 0
              , Z = 0
              , X = null
              , K = -1
              , de = null;
            const be = new mn
              , Me = new mn;
            let J = null
              , ge = e.width
              , Le = e.height
              , tt = 1
              , lt = null
              , je = null;
            const ze = new mn(0,0,ge,Le)
              , st = new mn(0,0,ge,Le);
            let yt = !1;
            const It = new sp;
            let ht = !1
              , Ot = !1
              , Mt = null;
            const Ln = new pi
              , Ye = new me
              , Pt = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            function tn() {
                return X === null ? tt : 1
            }
            let De = i;
            function Cn(pe, We) {
                for (let Je = 0; Je < pe.length; Je++) {
                    const Ke = pe[Je]
                      , rt = e.getContext(Ke, We);
                    if (rt !== null)
                        return rt
                }
                return null
            }
            try {
                const pe = {
                    alpha: !0,
                    depth: o,
                    stencil: a,
                    antialias: c,
                    premultipliedAlpha: d,
                    preserveDrawingBuffer: f,
                    powerPreference: v,
                    failIfMajorPerformanceCaveat: x
                };
                if ("setAttribute"in e && e.setAttribute("data-engine", `three.js r${l}`),
                e.addEventListener("webglcontextlost", oi, !1),
                e.addEventListener("webglcontextrestored", Zn, !1),
                e.addEventListener("webglcontextcreationerror", Xn, !1),
                De === null) {
                    const We = ["webgl2", "webgl", "experimental-webgl"];
                    if (O.isWebGL1Renderer === !0 && We.shift(),
                    De = Cn(We, pe),
                    De === null)
                        throw Cn(We) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                De.getShaderPrecisionFormat === void 0 && (De.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                }
                )
            } catch (pe) {
                throw console.error("THREE.WebGLRenderer: " + pe.message),
                pe
            }
            let on, Mn, In, Un, ei, dt, Tt, Kt, zn, sn, ri, jn, si, mr, rr, we, he, it, Ht, Wt, an, Vn, xn, ft;
            function Qn() {
                on = new v2(De),
                Mn = new h2(De,on,u),
                on.init(Mn),
                Vn = new f1(De,on,Mn),
                In = new KP(De,on,Mn),
                Un = new x2(De),
                ei = new kP,
                dt = new ZP(De,on,In,ei,Mn,Vn,Un),
                Tt = new f2(O),
                Kt = new g2(O),
                zn = new a2(De,Mn),
                xn = new c2(De,on,zn,Mn),
                sn = new _2(De,zn,Un,xn),
                ri = new S2(De,sn,zn,Un),
                Ht = new A2(De,Mn,dt),
                we = new d2(ei),
                jn = new FP(O,Tt,Kt,on,Mn,xn,we),
                si = new $P(O,ei),
                mr = new NP,
                rr = new jP(on,Mn),
                it = new l2(O,Tt,Kt,In,ri,w,d),
                he = new QP(O,ri,Mn),
                ft = new eR(De,Un,Mn,In),
                Wt = new u2(De,on,Un,Mn),
                an = new y2(De,on,Un,Mn),
                Un.programs = jn.programs,
                O.capabilities = Mn,
                O.extensions = on,
                O.properties = ei,
                O.renderLists = mr,
                O.shadowMap = he,
                O.state = In,
                O.info = Un
            }
            Qn();
            window.renderer = this;
            window.renderer.properties = ei;


            const Fn = new JP(O,De);
            this.xr = Fn,
            this.getContext = function() {
                return De
            }
            ,
            this.getContextAttributes = function() {
                return De.getContextAttributes()
            }
            ,
            this.forceContextLoss = function() {
                const pe = on.get("WEBGL_lose_context");
                pe && pe.loseContext()
            }
            ,
            this.forceContextRestore = function() {
                const pe = on.get("WEBGL_lose_context");
                pe && pe.restoreContext()
            }
            ,
            this.getPixelRatio = function() {
                return tt
            }
            ,
            this.setPixelRatio = function(pe) {
                pe !== void 0 && (tt = pe,
                this.setSize(ge, Le, !1))
            }
            ,
            this.getSize = function(pe) {
                return pe.set(ge, Le)
            }
            ,
            this.setSize = function(pe, We, Je=!0) {
                if (Fn.isPresenting) {
                    console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                    return
                }
                ge = pe,
                Le = We,
                e.width = Math.floor(pe * tt),
                e.height = Math.floor(We * tt),
                Je === !0 && (e.style.width = pe + "px",
                e.style.height = We + "px"),
                this.setViewport(0, 0, pe, We)
            }
            ,
            this.getDrawingBufferSize = function(pe) {
                return pe.set(ge * tt, Le * tt).floor()
            }
            ,
            this.setDrawingBufferSize = function(pe, We, Je) {
                ge = pe,
                Le = We,
                tt = Je,
                e.width = Math.floor(pe * Je),
                e.height = Math.floor(We * Je),
                this.setViewport(0, 0, pe, We)
            }
            ,
            this.getCurrentViewport = function(pe) {
                return pe.copy(be)
            }
            ,
            this.getViewport = function(pe) {
                return pe.copy(ze)
            }
            ,
            this.setViewport = function(pe, We, Je, Ke) {
                pe.isVector4 ? ze.set(pe.x, pe.y, pe.z, pe.w) : ze.set(pe, We, Je, Ke),
                In.viewport(be.copy(ze).multiplyScalar(tt).floor())
            }
            ,
            this.getScissor = function(pe) {
                return pe.copy(st)
            }
            ,
            this.setScissor = function(pe, We, Je, Ke) {
                pe.isVector4 ? st.set(pe.x, pe.y, pe.z, pe.w) : st.set(pe, We, Je, Ke),
                In.scissor(Me.copy(st).multiplyScalar(tt).floor())
            }
            ,
            this.getScissorTest = function() {
                return yt
            }
            ,
            this.setScissorTest = function(pe) {
                In.setScissorTest(yt = pe)
            }
            ,
            this.setOpaqueSort = function(pe) {
                lt = pe
            }
            ,
            this.setTransparentSort = function(pe) {
                je = pe
            }
            ,
            this.getClearColor = function(pe) {
                return pe.copy(it.getClearColor())
            }
            ,
            this.setClearColor = function() {
                it.setClearColor.apply(it, arguments)
            }
            ,
            this.getClearAlpha = function() {
                return it.getClearAlpha()
            }
            ,
            this.setClearAlpha = function() {
                it.setClearAlpha.apply(it, arguments)
            }
            ,
            this.clear = function(pe=!0, We=!0, Je=!0) {
                let Ke = 0;
                pe && (Ke |= De.COLOR_BUFFER_BIT),
                We && (Ke |= De.DEPTH_BUFFER_BIT),
                Je && (Ke |= De.STENCIL_BUFFER_BIT),
                De.clear(Ke)
            }
            ,
            this.clearColor = function() {
                this.clear(!0, !1, !1)
            }
            ,
            this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }
            ,
            this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }
            ,
            this.dispose = function() {
                e.removeEventListener("webglcontextlost", oi, !1),
                e.removeEventListener("webglcontextrestored", Zn, !1),
                e.removeEventListener("webglcontextcreationerror", Xn, !1),
                mr.dispose(),
                rr.dispose(),
                ei.dispose(),
                Tt.dispose(),
                Kt.dispose(),
                ri.dispose(),
                xn.dispose(),
                ft.dispose(),
                jn.dispose(),
                Fn.dispose(),
                Fn.removeEventListener("sessionstart", bn),
                Fn.removeEventListener("sessionend", Gn),
                Mt && (Mt.dispose(),
                Mt = null),
                tr.stop()
            }
            ;
            function oi(pe) {
                pe.preventDefault(),
                console.log("THREE.WebGLRenderer: Context Lost."),
                k = !0
            }
            function Zn() {
                console.log("THREE.WebGLRenderer: Context Restored."),
                k = !1;
                const pe = Un.autoReset
                  , We = he.enabled
                  , Je = he.autoUpdate
                  , Ke = he.needsUpdate
                  , rt = he.type;
                Qn(),
                Un.autoReset = pe,
                he.enabled = We,
                he.autoUpdate = Je,
                he.needsUpdate = Ke,
                he.type = rt
            }
            function Xn(pe) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", pe.statusMessage)
            }
            function Ki(pe) {
                const We = pe.target;
                We.removeEventListener("dispose", Ki),
                Rr(We)
            }
            function Rr(pe) {
                ds(pe),
                ei.remove(pe)
            }
            function ds(pe) {
                const We = ei.get(pe).programs;
                We !== void 0 && (We.forEach(function(Je) {
                    jn.releaseProgram(Je)
                }),
                pe.isShaderMaterial && jn.releaseShaderCache(pe))
            }
            this.renderBufferDirect = function(pe, We, Je, Ke, rt, Yn) {
                We === null && (We = Pt);
                const $n = rt.isMesh && rt.matrixWorld.determinant() < 0
                  , _i = pL(pe, We, Je, Ke, rt);
                In.setMaterial(Ke, $n);
                let Di = Je.index
                  , Zi = 1;
                Ke.wireframe === !0 && (Di = sn.getWireframeAttribute(Je),
                Zi = 2);
                const Ui = Je.drawRange
                  , Ni = Je.attributes.position;
                let Jr = Ui.start * Zi
                  , Bo = (Ui.start + Ui.count) * Zi;
                Yn !== null && (Jr = Math.max(Jr, Yn.start * Zi),
                Bo = Math.min(Bo, (Yn.start + Yn.count) * Zi)),
                Di !== null ? (Jr = Math.max(Jr, 0),
                Bo = Math.min(Bo, Di.count)) : Ni != null && (Jr = Math.max(Jr, 0),
                Bo = Math.min(Bo, Ni.count));
                const El = Bo - Jr;
                if (El < 0 || El === 1 / 0)
                    return;
                xn.setup(rt, Ke, _i, Je, Di);
                let tu, $r = Wt;
                if (Di !== null && (tu = zn.get(Di),
                $r = an,
                $r.setIndex(tu)),
                rt.isMesh)
                    Ke.wireframe === !0 ? (In.setLineWidth(Ke.wireframeLinewidth * tn()),
                    $r.setMode(De.LINES)) : $r.setMode(De.TRIANGLES);
                else if (rt.isLine) {
                    let zi = Ke.linewidth;
                    zi === void 0 && (zi = 1),
                    In.setLineWidth(zi * tn()),
                    rt.isLineSegments ? $r.setMode(De.LINES) : rt.isLineLoop ? $r.setMode(De.LINE_LOOP) : $r.setMode(De.LINE_STRIP)
                } else
                    rt.isPoints ? $r.setMode(De.POINTS) : rt.isSprite && $r.setMode(De.TRIANGLES);
                if (rt.isInstancedMesh)
                    $r.renderInstances(Jr, El, rt.count);
                else if (Je.isInstancedBufferGeometry) {
                    const zi = Je._maxInstanceCount !== void 0 ? Je._maxInstanceCount : 1 / 0
                      , Q0 = Math.min(Je.instanceCount, zi);
                    $r.renderInstances(Jr, El, Q0)
                } else
                    $r.render(Jr, El)
            }
            ;
            function Ue(pe, We, Je) {
                pe.transparent === !0 && pe.side === q && pe.forceSinglePass === !1 ? (pe.side = $,
                pe.needsUpdate = !0,
                ea(pe, We, Je),
                pe.side = Se,
                pe.needsUpdate = !0,
                ea(pe, We, Je),
                pe.side = q) : ea(pe, We, Je)
            }
            this.compile = function(pe, We, Je=null) {
                Je === null && (Je = pe),
                M = rr.get(Je),
                M.init(),
                z.push(M),
                Je.traverseVisible(function(rt) {
                    rt.isLight && rt.layers.test(We.layers) && (M.pushLight(rt),
                    rt.castShadow && M.pushShadow(rt))
                }),
                pe !== Je && pe.traverseVisible(function(rt) {
                    rt.isLight && rt.layers.test(We.layers) && (M.pushLight(rt),
                    rt.castShadow && M.pushShadow(rt))
                }),
                M.setupLights(O._useLegacyLights);
                const Ke = new Set;
                return pe.traverse(function(rt) {
                    const Yn = rt.material;
                    if (Yn)
                        if (Array.isArray(Yn))
                            for (let $n = 0; $n < Yn.length; $n++) {
                                const _i = Yn[$n];
                                Ue(_i, Je, rt),
                                Ke.add(_i)
                            }
                        else
                            Ue(Yn, Je, rt),
                            Ke.add(Yn)
                }),
                z.pop(),
                M = null,
                Ke
            }
            ;
            let ot = null;
            function Dt(pe) {
                ot && ot(pe)
            }
            function bn() {
                tr.stop()
            }
            function Gn() {
                tr.start()
            }
            const tr = new Gx;
            tr.setAnimationLoop(Dt),
            typeof self < "u" && tr.setContext(self),
            this.setAnimationLoop = function(pe) {
                ot = pe,
                Fn.setAnimationLoop(pe),
                pe === null ? tr.stop() : tr.start()
            }
            ,
            Fn.addEventListener("sessionstart", bn),
            Fn.addEventListener("sessionend", Gn),
            this.render = function(pe, We) {
                if (We !== void 0 && We.isCamera !== !0) {
                    console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    return
                }
                if (k === !0)
                    return;
                pe.matrixWorldAutoUpdate === !0 && pe.updateMatrixWorld(),
                We.parent === null && We.matrixWorldAutoUpdate === !0 && We.updateMatrixWorld(),
                Fn.enabled === !0 && Fn.isPresenting === !0 && (Fn.cameraAutoUpdate === !0 && Fn.updateCamera(We),
                We = Fn.getCamera()),
                pe.isScene === !0 && pe.onBeforeRender(O, pe, We, X),
                M = rr.get(pe, z.length),
                M.init(),
                z.push(M),
                Ln.multiplyMatrices(We.projectionMatrix, We.matrixWorldInverse),
                It.setFromProjectionMatrix(Ln),
                Ot = this.localClippingEnabled,
                ht = we.init(this.clippingPlanes, Ot),
                P = mr.get(pe, I.length),
                P.init(),
                I.push(P),
                fs(pe, We, 0, O.sortObjects),
                P.finish(),
                O.sortObjects === !0 && P.sort(lt, je),
                ht === !0 && we.beginShadows();
                const Je = M.state.shadowsArray;
                if (he.render(Je, pe, We),
                ht === !0 && we.endShadows(),
                this.info.autoReset === !0 && this.info.reset(),
                it.render(P, pe),
                M.setupLights(O.useLegacyLights),
                We.isArrayCamera) {
                    const Ke = We.cameras;
                    for (let rt = 0, Yn = Ke.length; rt < Yn; rt++) {
                        const $n = Ke[rt];
                        js(P, pe, $n, $n.viewport)
                    }
                } else
                    js(P, pe, We);
                X !== null && (dt.updateMultisampleRenderTarget(X),
                dt.updateRenderTargetMipmap(X)),
                pe.isScene === !0 && pe.onAfterRender(O, pe, We),
                xn.resetDefaultState(),
                K = -1,
                de = null,
                z.pop(),
                z.length > 0 ? M = z[z.length - 1] : M = null,
                I.pop(),
                I.length > 0 ? P = I[I.length - 1] : P = null
            }
            ;
            function fs(pe, We, Je, Ke) {
                if (pe.visible === !1)
                    return;
                if (pe.layers.test(We.layers)) {
                    if (pe.isGroup)
                        Je = pe.renderOrder;
                    else if (pe.isLOD)
                        pe.autoUpdate === !0 && pe.update(We);
                    else if (pe.isLight)
                        M.pushLight(pe),
                        pe.castShadow && M.pushShadow(pe);
                    else if (pe.isSprite) {
                        if (!pe.frustumCulled || It.intersectsSprite(pe)) {
                            Ke && Ye.setFromMatrixPosition(pe.matrixWorld).applyMatrix4(Ln);
                            const $n = ri.update(pe)
                              , _i = pe.material;
                            _i.visible && P.push(pe, $n, _i, Je, Ye.z, null)
                        }
                    } else if ((pe.isMesh || pe.isLine || pe.isPoints) && (pe.isSkinnedMesh && pe.skeleton.frame !== Un.render.frame && (pe.skeleton.update(),
                    pe.skeleton.frame = Un.render.frame),
                    !pe.frustumCulled || It.intersectsObject(pe))) {
                        Ke && Ye.setFromMatrixPosition(pe.matrixWorld).applyMatrix4(Ln);
                        const $n = ri.update(pe)
                          , _i = pe.material;
                        if (Array.isArray(_i)) {
                            const Di = $n.groups;
                            for (let Zi = 0, Ui = Di.length; Zi < Ui; Zi++) {
                                const Ni = Di[Zi]
                                  , Jr = _i[Ni.materialIndex];
                                Jr && Jr.visible && P.push(pe, $n, Jr, Je, Ye.z, Ni)
                            }
                        } else
                            _i.visible && P.push(pe, $n, _i, Je, Ye.z, null)
                    }
                }
                const Yn = pe.children;
                for (let $n = 0, _i = Yn.length; $n < _i; $n++)
                    fs(Yn[$n], We, Je, Ke)
            }
            function js(pe, We, Je, Ke) {
                const rt = pe.opaque
                  , Yn = pe.transmissive
                  , $n = pe.transparent;
                M.setupLightsView(Je),
                ht === !0 && we.setGlobalState(O.clippingPlanes, Je),
                Yn.length > 0 && eu(rt, We, Je),
                Ke && In.viewport(be.copy(Ke)),
                rt.length > 0 && Ar(rt, We, Je),
                Yn.length > 0 && Ar(Yn, We, Je),
                $n.length > 0 && Ar($n, We, Je),
                In.buffers.depth.setTest(!0),
                In.buffers.depth.setMask(!0),
                In.buffers.color.setMask(!0),
                In.setPolygonOffset(!1)
            }
            function eu(pe, We, Je) {
                const Ke = Mn.isWebGL2;
                Mt === null && (Mt = new ki(1024,1024,{
                    generateMipmaps: !0,
                    type: on.has("EXT_color_buffer_half_float") ? So : bs,
                    minFilter: Fr,
                    samples: Ke && c === !0 ? 4 : 0
                }));
                const rt = O.getRenderTarget();
                O.setRenderTarget(Mt),
                O.clear();
                const Yn = O.toneMapping;
                O.toneMapping = Gt,
                Ar(pe, We, Je),
                O.toneMapping = Yn,
                dt.updateMultisampleRenderTarget(Mt),
                dt.updateRenderTargetMipmap(Mt),
                O.setRenderTarget(rt)
            }
            function Ar(pe, We, Je) {
                const Ke = We.isScene === !0 ? We.overrideMaterial : null;
                for (let rt = 0, Yn = pe.length; rt < Yn; rt++) {
                    const $n = pe[rt]
                      , _i = $n.object
                      , Di = $n.geometry
                      , Zi = Ke === null ? $n.material : Ke
                      , Ui = $n.group;
                    _i.layers.test(Je.layers) && Tl(_i, We, Je, Di, Zi, Ui)
                }
            }
            function Tl(pe, We, Je, Ke, rt, Yn) {
                pe.onBeforeRender(O, We, Je, Ke, rt, Yn),
                pe.modelViewMatrix.multiplyMatrices(Je.matrixWorldInverse, pe.matrixWorld),
                pe.normalMatrix.getNormalMatrix(pe.modelViewMatrix),
                rt.onBeforeRender(O, We, Je, Ke, pe, Yn),
                rt.transparent === !0 && rt.side === q && rt.forceSinglePass === !1 ? (rt.side = $,
                rt.needsUpdate = !0,
                O.renderBufferDirect(Je, We, Ke, rt, pe, Yn),
                rt.side = Se,
                rt.needsUpdate = !0,
                O.renderBufferDirect(Je, We, Ke, rt, pe, Yn),
                rt.side = q) : O.renderBufferDirect(Je, We, Ke, rt, pe, Yn),
                pe.onAfterRender(O, We, Je, Ke, rt, Yn)
            }
            function ea(pe, We, Je) {
                We.isScene !== !0 && (We = Pt);
                const Ke = ei.get(pe)
                  , rt = M.state.lights
                  , Yn = M.state.shadowsArray
                  , $n = rt.state.version
                  , _i = jn.getParameters(pe, rt.state, Yn, We, Je)
                  , Di = jn.getProgramCacheKey(_i);
                let Zi = Ke.programs;
                Ke.environment = pe.isMeshStandardMaterial ? We.environment : null,
                Ke.fog = We.fog,
                Ke.envMap = (pe.isMeshStandardMaterial ? Kt : Tt).get(pe.envMap || Ke.environment),
                Zi === void 0 && (pe.addEventListener("dispose", Ki),
                Zi = new Map,
                Ke.programs = Zi);
                let Ui = Zi.get(Di);
                if (Ui !== void 0) {
                    if (Ke.currentProgram === Ui && Ke.lightsStateVersion === $n)
                        return Kb(pe, _i),
                        Ui
                } else
                    _i.uniforms = jn.getUniforms(pe),
                    pe.onBuild(Je, _i, O),
                    pe.onBeforeCompile(_i, O),
                    Ui = jn.acquireProgram(_i, Di),
                    Zi.set(Di, Ui),
                    Ke.uniforms = _i.uniforms;
                const Ni = Ke.uniforms;
                (!pe.isShaderMaterial && !pe.isRawShaderMaterial || pe.clipping === !0) && (Ni.clippingPlanes = we.uniform),
                Kb(pe, _i),
                Ke.needsLights = gL(pe),
                Ke.lightsStateVersion = $n,
                Ke.needsLights && (Ni.ambientLightColor.value = rt.state.ambient,
                Ni.lightProbe.value = rt.state.probe,
                Ni.directionalLights.value = rt.state.directional,
                Ni.directionalLightShadows.value = rt.state.directionalShadow,
                Ni.spotLights.value = rt.state.spot,
                Ni.spotLightShadows.value = rt.state.spotShadow,
                Ni.rectAreaLights.value = rt.state.rectArea,
                Ni.ltc_1.value = rt.state.rectAreaLTC1,
                Ni.ltc_2.value = rt.state.rectAreaLTC2,
                Ni.pointLights.value = rt.state.point,
                Ni.pointLightShadows.value = rt.state.pointShadow,
                Ni.hemisphereLights.value = rt.state.hemi,
                Ni.directionalShadowMap.value = rt.state.directionalShadowMap,
                Ni.directionalShadowMatrix.value = rt.state.directionalShadowMatrix,
                Ni.spotShadowMap.value = rt.state.spotShadowMap,
                Ni.spotLightMatrix.value = rt.state.spotLightMatrix,
                Ni.spotLightMap.value = rt.state.spotLightMap,
                Ni.pointShadowMap.value = rt.state.pointShadowMap,
                Ni.pointShadowMatrix.value = rt.state.pointShadowMatrix);
                const Jr = Ui.getUniforms()
                  , Bo = up.seqWithValue(Jr.seq, Ni);
                return Ke.currentProgram = Ui,
                Ke.uniformsList = Bo,
                Ui
            }
            function Kb(pe, We) {
                const Je = ei.get(pe);
                Je.outputEncoding = We.outputEncoding,
                Je.instancing = We.instancing,
                Je.skinning = We.skinning,
                Je.morphTargets = We.morphTargets,
                Je.morphNormals = We.morphNormals,
                Je.morphColors = We.morphColors,
                Je.morphTargetsCount = We.morphTargetsCount,
                Je.numClippingPlanes = We.numClippingPlanes,
                Je.numIntersection = We.numClipIntersection,
                Je.vertexAlphas = We.vertexAlphas,
                Je.vertexTangents = We.vertexTangents,
                Je.toneMapping = We.toneMapping
            }
            function pL(pe, We, Je, Ke, rt) {
                We.isScene !== !0 && (We = Pt),
                dt.resetTextureUnits();
                const Yn = We.fog
                  , $n = Ke.isMeshStandardMaterial ? We.environment : null
                  , _i = X === null ? O.outputEncoding : X.isXRRenderTarget === !0 ? X.texture.encoding : nn
                  , Di = (Ke.isMeshStandardMaterial ? Kt : Tt).get(Ke.envMap || $n)
                  , Zi = Ke.vertexColors === !0 && !!Je.attributes.color && Je.attributes.color.itemSize === 4
                  , Ui = !!Ke.normalMap && !!Je.attributes.tangent
                  , Ni = !!Je.morphAttributes.position
                  , Jr = !!Je.morphAttributes.normal
                  , Bo = !!Je.morphAttributes.color
                  , El = Ke.toneMapped ? O.toneMapping : Gt
                  , tu = Je.morphAttributes.position || Je.morphAttributes.normal || Je.morphAttributes.color
                  , $r = tu !== void 0 ? tu.length : 0
                  , zi = ei.get(Ke)
                  , Q0 = M.state.lights;
                if (ht === !0 && (Ot === !0 || pe !== de)) {
                    const as = pe === de && Ke.id === K;
                    we.setState(Ke, pe, as)
                }
                let ps = !1;
                Ke.version === zi.__version ? (zi.needsLights && zi.lightsStateVersion !== Q0.state.version || zi.outputEncoding !== _i || rt.isInstancedMesh && zi.instancing === !1 || !rt.isInstancedMesh && zi.instancing === !0 || rt.isSkinnedMesh && zi.skinning === !1 || !rt.isSkinnedMesh && zi.skinning === !0 || zi.envMap !== Di || Ke.fog === !0 && zi.fog !== Yn || zi.numClippingPlanes !== void 0 && (zi.numClippingPlanes !== we.numPlanes || zi.numIntersection !== we.numIntersection) || zi.vertexAlphas !== Zi || zi.vertexTangents !== Ui || zi.morphTargets !== Ni || zi.morphNormals !== Jr || zi.morphColors !== Bo || zi.toneMapping !== El || Mn.isWebGL2 === !0 && zi.morphTargetsCount !== $r) && (ps = !0) : (ps = !0,
                zi.__version = Ke.version);
                let nu = zi.currentProgram;
                ps === !0 && (nu = ea(Ke, We, rt));
                let Zb = !1
                  , Ed = !1
                  , K0 = !1;
                const Cs = nu.getUniforms()
                  , iu = zi.uniforms;
                if (In.useProgram(nu.program) && (Zb = !0,
                Ed = !0,
                K0 = !0),
                Ke.id !== K && (K = Ke.id,
                Ed = !0),
                Zb || de !== pe) {
                    if (Cs.setValue(De, "projectionMatrix", pe.projectionMatrix),
                    Mn.logarithmicDepthBuffer && Cs.setValue(De, "logDepthBufFC", 2 / (Math.log(pe.far + 1) / Math.LN2)),
                    de !== pe && (de = pe,
                    Ed = !0,
                    K0 = !0),
                    Ke.isShaderMaterial || Ke.isMeshPhongMaterial || Ke.isMeshToonMaterial || Ke.isMeshStandardMaterial || Ke.envMap) {
                        const as = Cs.map.cameraPosition;
                        as !== void 0 && as.setValue(De, Ye.setFromMatrixPosition(pe.matrixWorld))
                    }
                    (Ke.isMeshPhongMaterial || Ke.isMeshToonMaterial || Ke.isMeshLambertMaterial || Ke.isMeshBasicMaterial || Ke.isMeshStandardMaterial || Ke.isShaderMaterial) && Cs.setValue(De, "isOrthographic", pe.isOrthographicCamera === !0),
                    (Ke.isMeshPhongMaterial || Ke.isMeshToonMaterial || Ke.isMeshLambertMaterial || Ke.isMeshBasicMaterial || Ke.isMeshStandardMaterial || Ke.isShaderMaterial || Ke.isShadowMaterial || rt.isSkinnedMesh) && Cs.setValue(De, "viewMatrix", pe.matrixWorldInverse)
                }
                if (rt.isSkinnedMesh) {
                    Cs.setOptional(De, rt, "bindMatrix"),
                    Cs.setOptional(De, rt, "bindMatrixInverse");
                    const as = rt.skeleton;
                    as && (Mn.floatVertexTextures ? (as.boneTexture === null && as.computeBoneTexture(),
                    Cs.setValue(De, "boneTexture", as.boneTexture, dt),
                    Cs.setValue(De, "boneTextureSize", as.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                }
                const Z0 = Je.morphAttributes;
                (Z0.position !== void 0 || Z0.normal !== void 0 || Z0.color !== void 0 && Mn.isWebGL2 === !0) && Ht.update(rt, Je, nu),
                (Ed || zi.receiveShadow !== rt.receiveShadow) && (zi.receiveShadow = rt.receiveShadow,
                Cs.setValue(De, "receiveShadow", rt.receiveShadow)),
                Ke.isMeshGouraudMaterial && Ke.envMap !== null && (iu.envMap.value = Di,
                iu.flipEnvMap.value = Di.isCubeTexture && Di.isRenderTargetTexture === !1 ? -1 : 1),
                Ed && (Cs.setValue(De, "toneMappingExposure", O.toneMappingExposure),
                zi.needsLights && mL(iu, K0),
                Yn && Ke.fog === !0 && si.refreshFogUniforms(iu, Yn),
                si.refreshMaterialUniforms(iu, Ke, tt, Le, Mt),
                up.upload(De, zi.uniformsList, iu, dt)),
                Ke.isShaderMaterial && Ke.uniformsNeedUpdate === !0 && (up.upload(De, zi.uniformsList, iu, dt),
                Ke.uniformsNeedUpdate = !1),
                Ke.isSpriteMaterial && Cs.setValue(De, "center", rt.center),
                Cs.setValue(De, "modelViewMatrix", rt.modelViewMatrix),
                Cs.setValue(De, "normalMatrix", rt.normalMatrix),
                Cs.setValue(De, "modelMatrix", rt.matrixWorld);
                const qb = O.globalUniforms;
                for (let as in qb)
                    Cs.setValue(De, as, qb[as], dt);
                const Jb = rt.localUniforms;
                for (let as in Jb)
                    Cs.setValue(De, as, Jb[as], dt);
                if (Ke.isShaderMaterial || Ke.isRawShaderMaterial) {
                    const as = Ke.uniformsGroups;
                    for (let q0 = 0, vL = as.length; q0 < vL; q0++)
                        if (Mn.isWebGL2) {
                            const $b = as[q0];
                            ft.update($b, nu),
                            ft.bind($b, nu)
                        } else
                            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                }
                return nu
            }
            function mL(pe, We) {
                pe.ambientLightColor.needsUpdate = We,
                pe.lightProbe.needsUpdate = We,
                pe.directionalLights.needsUpdate = We,
                pe.directionalLightShadows.needsUpdate = We,
                pe.pointLights.needsUpdate = We,
                pe.pointLightShadows.needsUpdate = We,
                pe.spotLights.needsUpdate = We,
                pe.spotLightShadows.needsUpdate = We,
                pe.rectAreaLights.needsUpdate = We,
                pe.hemisphereLights.needsUpdate = We
            }
            function gL(pe) {
                return pe.isMeshLambertMaterial || pe.isMeshToonMaterial || pe.isMeshPhongMaterial || pe.isMeshStandardMaterial || pe.isShadowMaterial || pe.isShaderMaterial && pe.lights === !0
            }
            this.getActiveCubeFace = function() {
                return Q
            }
            ,
            this.getActiveMipmapLevel = function() {
                return Z
            }
            ,
            this.getRenderTarget = function() {
                return X
            }
            ,
            this.setRenderTargetTextures = function(pe, We, Je) {
                ei.get(pe.texture).__webglTexture = We,
                ei.get(pe.depthTexture).__webglTexture = Je;
                const Ke = ei.get(pe);
                Ke.__hasExternalTextures = !0,
                Ke.__hasExternalTextures && (Ke.__autoAllocateDepthBuffer = Je === void 0,
                Ke.__autoAllocateDepthBuffer || on.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                Ke.__useRenderToTexture = !1))
            }
            ,
            this.setRenderTargetFramebuffer = function(pe, We) {
                const Je = ei.get(pe);
                Je.__webglFramebuffer = We,
                Je.__useDefaultFramebuffer = We === void 0
            }
            ,
            this.setRenderTarget = function(pe, We=0, Je=0) {
                X = pe,
                Q = We,
                Z = Je;
                let Ke = !0
                  , rt = null
                  , Yn = !1
                  , $n = !1;
                if (pe) {
                    const Di = ei.get(pe);
                    Di.__useDefaultFramebuffer !== void 0 ? (In.bindFramebuffer(De.FRAMEBUFFER, null),
                    Ke = !1) : Di.__webglFramebuffer === void 0 ? dt.setupRenderTarget(pe) : Di.__hasExternalTextures && dt.rebindTextures(pe, ei.get(pe.texture).__webglTexture, ei.get(pe.depthTexture).__webglTexture);
                    const Zi = pe.texture;
                    (Zi.isData3DTexture || Zi.isDataArrayTexture || Zi.isCompressedArrayTexture) && ($n = !0);
                    const Ui = ei.get(pe).__webglFramebuffer;
                    pe.isWebGLCubeRenderTarget ? (rt = Ui[We],
                    Yn = !0) : Mn.isWebGL2 && pe.samples > 0 && dt.useMultisampledRTT(pe) === !1 ? rt = ei.get(pe).__webglMultisampledFramebuffer : rt = Ui,
                    be.copy(pe.viewport),
                    Me.copy(pe.scissor),
                    J = pe.scissorTest
                } else
                    be.copy(ze).multiplyScalar(tt).floor(),
                    Me.copy(st).multiplyScalar(tt).floor(),
                    J = yt;
                if (In.bindFramebuffer(De.FRAMEBUFFER, rt) && Mn.drawBuffers && Ke && In.drawBuffers(pe, rt),
                In.viewport(be),
                In.scissor(Me),
                In.setScissorTest(J),
                Yn) {
                    const Di = ei.get(pe.texture);
                    De.framebufferTexture2D(De.FRAMEBUFFER, De.COLOR_ATTACHMENT0, De.TEXTURE_CUBE_MAP_POSITIVE_X + We, Di.__webglTexture, Je)
                } else if ($n) {
                    const Di = ei.get(pe.texture)
                      , Zi = We || 0;
                    De.framebufferTextureLayer(De.FRAMEBUFFER, De.COLOR_ATTACHMENT0, Di.__webglTexture, Je || 0, Zi)
                }
                K = -1
            }
            ,
            this.readRenderTargetPixels = function(pe, We, Je, Ke, rt, Yn, $n) {
                if (!(pe && pe.isWebGLRenderTarget)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    return
                }
                let _i = ei.get(pe).__webglFramebuffer;
                if (pe.isWebGLCubeRenderTarget && $n !== void 0 && (_i = _i[$n]),
                _i) {
                    In.bindFramebuffer(De.FRAMEBUFFER, _i);
                    try {
                        const Di = pe.texture
                          , Zi = Di.format
                          , Ui = Di.type;
                        if (Zi !== Xr && Vn.convert(Zi) !== De.getParameter(De.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            return
                        }
                        const Ni = Ui === So && (on.has("EXT_color_buffer_half_float") || Mn.isWebGL2 && on.has("EXT_color_buffer_float"));
                        if (Ui !== bs && Vn.convert(Ui) !== De.getParameter(De.IMPLEMENTATION_COLOR_READ_TYPE) && !(Ui === Js && (Mn.isWebGL2 || on.has("OES_texture_float") || on.has("WEBGL_color_buffer_float"))) && !Ni) {
                            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            return
                        }
                        We >= 0 && We <= pe.width - Ke && Je >= 0 && Je <= pe.height - rt && De.readPixels(We, Je, Ke, rt, Vn.convert(Zi), Vn.convert(Ui), Yn)
                    } finally {
                        const Di = X !== null ? ei.get(X).__webglFramebuffer : null;
                        In.bindFramebuffer(De.FRAMEBUFFER, Di)
                    }
                }
            }
            ,
            this.copyFramebufferToTexture = function(pe, We, Je=0, Ke=-1) {
                const rt = Math.pow(2, -Je)
                  , Yn = Math.floor(We.image.width * rt)
                  , $n = Math.floor(We.image.height * rt);
                Ke > -1 ? (dt.setTextureCube(We, 0),
                De.copyTexSubImage2D(De.TEXTURE_CUBE_MAP_POSITIVE_X + Ke, Je, 0, 0, pe.x, pe.y, Yn, $n),
                Je === 0 && Ke >= 5 && We.generateMipmaps && De.generateMipmap(De.TEXTURE_CUBE_MAP)) : (dt.setTexture2D(We, 0),
                De.copyTexSubImage2D(De.TEXTURE_2D, Je, 0, 0, pe.x, pe.y, Yn, $n),
                Je === 0 && We.generateMipmaps && De.generateMipmap(De.TEXTURE_2D)),
                In.unbindTexture()
            }
            ,
            this.copyTextureToTexture = function(pe, We, Je, Ke=0) {
                const rt = We.image.width
                  , Yn = We.image.height
                  , $n = Vn.convert(Je.format)
                  , _i = Vn.convert(Je.type);
                dt.setTexture2D(Je, 0),
                De.pixelStorei(De.UNPACK_FLIP_Y_WEBGL, Je.flipY),
                De.pixelStorei(De.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Je.premultiplyAlpha),
                De.pixelStorei(De.UNPACK_ALIGNMENT, Je.unpackAlignment),
                We.isDataTexture ? De.texSubImage2D(De.TEXTURE_2D, Ke, pe.x, pe.y, rt, Yn, $n, _i, We.image.data) : We.isCompressedTexture ? De.compressedTexSubImage2D(De.TEXTURE_2D, Ke, pe.x, pe.y, We.mipmaps[0].width, We.mipmaps[0].height, $n, We.mipmaps[0].data) : De.texSubImage2D(De.TEXTURE_2D, Ke, pe.x, pe.y, $n, _i, We.image),
                Ke === 0 && Je.generateMipmaps && De.generateMipmap(De.TEXTURE_2D),
                In.unbindTexture()
            }
            ,
            this.copyTextureToTexture3D = function(pe, We, Je, Ke, rt=0) {
                if (O.isWebGL1Renderer) {
                    console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    return
                }
                const Yn = pe.max.x - pe.min.x + 1
                  , $n = pe.max.y - pe.min.y + 1
                  , _i = pe.max.z - pe.min.z + 1
                  , Di = Vn.convert(Ke.format)
                  , Zi = Vn.convert(Ke.type);
                let Ui;
                if (Ke.isData3DTexture)
                    dt.setTexture3D(Ke, 0),
                    Ui = De.TEXTURE_3D;
                else if (Ke.isDataArrayTexture)
                    dt.setTexture2DArray(Ke, 0),
                    Ui = De.TEXTURE_2D_ARRAY;
                else {
                    console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    return
                }
                De.pixelStorei(De.UNPACK_FLIP_Y_WEBGL, Ke.flipY),
                De.pixelStorei(De.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Ke.premultiplyAlpha),
                De.pixelStorei(De.UNPACK_ALIGNMENT, Ke.unpackAlignment);
                const Ni = De.getParameter(De.UNPACK_ROW_LENGTH)
                  , Jr = De.getParameter(De.UNPACK_IMAGE_HEIGHT)
                  , Bo = De.getParameter(De.UNPACK_SKIP_PIXELS)
                  , El = De.getParameter(De.UNPACK_SKIP_ROWS)
                  , tu = De.getParameter(De.UNPACK_SKIP_IMAGES)
                  , $r = Je.isCompressedTexture ? Je.mipmaps[0] : Je.image;
                De.pixelStorei(De.UNPACK_ROW_LENGTH, $r.width),
                De.pixelStorei(De.UNPACK_IMAGE_HEIGHT, $r.height),
                De.pixelStorei(De.UNPACK_SKIP_PIXELS, pe.min.x),
                De.pixelStorei(De.UNPACK_SKIP_ROWS, pe.min.y),
                De.pixelStorei(De.UNPACK_SKIP_IMAGES, pe.min.z),
                Je.isDataTexture || Je.isData3DTexture ? De.texSubImage3D(Ui, rt, We.x, We.y, We.z, Yn, $n, _i, Di, Zi, $r.data) : Je.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
                De.compressedTexSubImage3D(Ui, rt, We.x, We.y, We.z, Yn, $n, _i, Di, $r.data)) : De.texSubImage3D(Ui, rt, We.x, We.y, We.z, Yn, $n, _i, Di, Zi, $r),
                De.pixelStorei(De.UNPACK_ROW_LENGTH, Ni),
                De.pixelStorei(De.UNPACK_IMAGE_HEIGHT, Jr),
                De.pixelStorei(De.UNPACK_SKIP_PIXELS, Bo),
                De.pixelStorei(De.UNPACK_SKIP_ROWS, El),
                De.pixelStorei(De.UNPACK_SKIP_IMAGES, tu),
                rt === 0 && Ke.generateMipmaps && De.generateMipmap(Ui),
                In.unbindTexture()
            }
            ,
            this.initTexture = function(pe) {
                pe.isCubeTexture ? dt.setTextureCube(pe, 0) : pe.isData3DTexture ? dt.setTexture3D(pe, 0) : pe.isDataArrayTexture || pe.isCompressedArrayTexture ? dt.setTexture2DArray(pe, 0) : dt.setTexture2D(pe, 0),
                In.unbindTexture()
            }
            ,
            this.resetState = function() {
                Q = 0,
                Z = 0,
                X = null,
                In.reset(),
                xn.reset()
            }
            ,
            typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        Object.defineProperties(u0.prototype, {
            physicallyCorrectLights: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
                    !this.useLegacyLights
                },
                set: function(u) {
                    console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
                    this.useLegacyLights = !u
                }
            }
        });
        class g1 extends u0 {
        }
        g1.prototype.isWebGL1Renderer = !0;
        class hp {
            constructor(e, i=25e-5) {
                this.isFogExp2 = !0,
                this.name = "",
                this.color = new gn(e),
                this.density = i
            }
            clone() {
                return new hp(this.color,this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        class dp {
            constructor(e, i=1, o=1e3) {
                this.isFog = !0,
                this.name = "",
                this.color = new gn(e),
                this.near = i,
                this.far = o
            }
            clone() {
                return new dp(this.color,this.near,this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        class v1 extends Qi {
            constructor() {
                super(),
                this.isScene = !0,
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.backgroundBlurriness = 0,
                this.backgroundIntensity = 1,
                this.overrideMaterial = null,
                typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(e, i) {
                return super.copy(e, i),
                e.background !== null && (this.background = e.background.clone()),
                e.environment !== null && (this.environment = e.environment.clone()),
                e.fog !== null && (this.fog = e.fog.clone()),
                this.backgroundBlurriness = e.backgroundBlurriness,
                this.backgroundIntensity = e.backgroundIntensity,
                e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this
            }
            toJSON(e) {
                const i = super.toJSON(e);
                return this.fog !== null && (i.object.fog = this.fog.toJSON()),
                this.backgroundBlurriness > 0 && (i.object.backgroundBlurriness = this.backgroundBlurriness),
                this.backgroundIntensity !== 1 && (i.object.backgroundIntensity = this.backgroundIntensity),
                i
            }
            get autoUpdate() {
                return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
                this.matrixWorldAutoUpdate
            }
            set autoUpdate(e) {
                console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
                this.matrixWorldAutoUpdate = e
            }
        }
        class fp {
            constructor(e, i) {
                this.isInterleavedBuffer = !0,
                this.array = e,
                this.stride = i,
                this.count = e !== void 0 ? e.length / i : 0,
                this.usage = ln,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0,
                this.uuid = yr()
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                e === !0 && this.version++
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            copy(e) {
                return this.array = new e.array.constructor(e.array),
                this.count = e.count,
                this.stride = e.stride,
                this.usage = e.usage,
                this
            }
            copyAt(e, i, o) {
                e *= this.stride,
                o *= i.stride;
                for (let a = 0, c = this.stride; a < c; a++)
                    this.array[e + a] = i.array[o + a];
                return this
            }
            set(e, i=0) {
                return this.array.set(e, i),
                this
            }
            clone(e) {
                e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
                this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = yr()),
                e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const i = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
                  , o = new this.constructor(i,this.stride);
                return o.setUsage(this.usage),
                o
            }
            onUpload(e) {
                return this.onUploadCallback = e,
                this
            }
            toJSON(e) {
                return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
                this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = yr()),
                e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const io = new me;
        class Hc {
            constructor(e, i, o, a=!1) {
                this.isInterleavedBufferAttribute = !0,
                this.name = "",
                this.data = e,
                this.itemSize = i,
                this.offset = o,
                this.normalized = a
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(e) {
                this.data.needsUpdate = e
            }
            applyMatrix4(e) {
                for (let i = 0, o = this.data.count; i < o; i++)
                    io.fromBufferAttribute(this, i),
                    io.applyMatrix4(e),
                    this.setXYZ(i, io.x, io.y, io.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let i = 0, o = this.count; i < o; i++)
                    io.fromBufferAttribute(this, i),
                    io.applyNormalMatrix(e),
                    this.setXYZ(i, io.x, io.y, io.z);
                return this
            }
            transformDirection(e) {
                for (let i = 0, o = this.count; i < o; i++)
                    io.fromBufferAttribute(this, i),
                    io.transformDirection(e),
                    this.setXYZ(i, io.x, io.y, io.z);
                return this
            }
            setX(e, i) {
                return this.normalized && (i = fi(i, this.array)),
                this.data.array[e * this.data.stride + this.offset] = i,
                this
            }
            setY(e, i) {
                return this.normalized && (i = fi(i, this.array)),
                this.data.array[e * this.data.stride + this.offset + 1] = i,
                this
            }
            setZ(e, i) {
                return this.normalized && (i = fi(i, this.array)),
                this.data.array[e * this.data.stride + this.offset + 2] = i,
                this
            }
            setW(e, i) {
                return this.normalized && (i = fi(i, this.array)),
                this.data.array[e * this.data.stride + this.offset + 3] = i,
                this
            }
            getX(e) {
                let i = this.data.array[e * this.data.stride + this.offset];
                return this.normalized && (i = ur(i, this.array)),
                i
            }
            getY(e) {
                let i = this.data.array[e * this.data.stride + this.offset + 1];
                return this.normalized && (i = ur(i, this.array)),
                i
            }
            getZ(e) {
                let i = this.data.array[e * this.data.stride + this.offset + 2];
                return this.normalized && (i = ur(i, this.array)),
                i
            }
            getW(e) {
                let i = this.data.array[e * this.data.stride + this.offset + 3];
                return this.normalized && (i = ur(i, this.array)),
                i
            }
            setXY(e, i, o) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (i = fi(i, this.array),
                o = fi(o, this.array)),
                this.data.array[e + 0] = i,
                this.data.array[e + 1] = o,
                this
            }
            setXYZ(e, i, o, a) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (i = fi(i, this.array),
                o = fi(o, this.array),
                a = fi(a, this.array)),
                this.data.array[e + 0] = i,
                this.data.array[e + 1] = o,
                this.data.array[e + 2] = a,
                this
            }
            setXYZW(e, i, o, a, c) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (i = fi(i, this.array),
                o = fi(o, this.array),
                a = fi(a, this.array),
                c = fi(c, this.array)),
                this.data.array[e + 0] = i,
                this.data.array[e + 1] = o,
                this.data.array[e + 2] = a,
                this.data.array[e + 3] = c,
                this
            }
            clone(e) {
                if (e === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const i = [];
                    for (let o = 0; o < this.count; o++) {
                        const a = o * this.data.stride + this.offset;
                        for (let c = 0; c < this.itemSize; c++)
                            i.push(this.data.array[a + c])
                    }
                    return new dr(new this.array.constructor(i),this.itemSize,this.normalized)
                } else
                    return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
                    e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                    new Hc(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(e) {
                if (e === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const i = [];
                    for (let o = 0; o < this.count; o++) {
                        const a = o * this.data.stride + this.offset;
                        for (let c = 0; c < this.itemSize; c++)
                            i.push(this.data.array[a + c])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: i,
                        normalized: this.normalized
                    }
                } else
                    return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
                    e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
                    {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
            }
        }
        class h0 extends Vs {
            constructor(e) {
                super(),
                this.isSpriteMaterial = !0,
                this.type = "SpriteMaterial",
                this.color = new gn(16777215),
                this.map = null,
                this.alphaMap = null,
                this.rotation = 0,
                this.sizeAttenuation = !0,
                this.transparent = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.rotation = e.rotation,
                this.sizeAttenuation = e.sizeAttenuation,
                this.fog = e.fog,
                this
            }
        }
        let zu;
        const Jh = new me
          , Gu = new me
          , Hu = new me
          , Vu = new _t
          , $h = new _t
          , _1 = new pi
          , pp = new me
          , ed = new me
          , mp = new me
          , y1 = new _t
          , d0 = new _t
          , x1 = new _t;
        class b1 extends Qi {
            constructor(e) {
                if (super(),
                this.isSprite = !0,
                this.type = "Sprite",
                zu === void 0) {
                    zu = new Ai;
                    const i = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                      , o = new fp(i,5);
                    zu.setIndex([0, 1, 2, 0, 2, 3]),
                    zu.setAttribute("position", new Hc(o,3,0,!1)),
                    zu.setAttribute("uv", new Hc(o,2,3,!1))
                }
                this.geometry = zu,
                this.material = e !== void 0 ? e : new h0,
                this.center = new _t(.5,.5)
            }
            raycast(e, i) {
                e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                Gu.setFromMatrixScale(this.matrixWorld),
                _1.copy(e.camera.matrixWorld),
                this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
                Hu.setFromMatrixPosition(this.modelViewMatrix),
                e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Gu.multiplyScalar(-Hu.z);
                const o = this.material.rotation;
                let a, c;
                o !== 0 && (c = Math.cos(o),
                a = Math.sin(o));
                const d = this.center;
                gp(pp.set(-.5, -.5, 0), Hu, d, Gu, a, c),
                gp(ed.set(.5, -.5, 0), Hu, d, Gu, a, c),
                gp(mp.set(.5, .5, 0), Hu, d, Gu, a, c),
                y1.set(0, 0),
                d0.set(1, 0),
                x1.set(1, 1);
                let f = e.ray.intersectTriangle(pp, ed, mp, !1, Jh);
                if (f === null && (gp(ed.set(-.5, .5, 0), Hu, d, Gu, a, c),
                d0.set(0, 1),
                f = e.ray.intersectTriangle(pp, mp, ed, !1, Jh),
                f === null))
                    return;
                const v = e.ray.origin.distanceTo(Jh);
                v < e.near || v > e.far || i.push({
                    distance: v,
                    point: Jh.clone(),
                    uv: qo.getUV(Jh, pp, ed, mp, y1, d0, x1, new _t),
                    face: null,
                    object: this
                })
            }
            copy(e, i) {
                return super.copy(e, i),
                e.center !== void 0 && this.center.copy(e.center),
                this.material = e.material,
                this
            }
        }
        function gp(u, e, i, o, a, c) {
            Vu.subVectors(u, i).addScalar(.5).multiply(o),
            a !== void 0 ? ($h.x = c * Vu.x - a * Vu.y,
            $h.y = a * Vu.x + c * Vu.y) : $h.copy(Vu),
            u.copy(e),
            u.x += $h.x,
            u.y += $h.y,
            u.applyMatrix4(_1)
        }
        const vp = new me
          , w1 = new me;
        class A1 extends Qi {
            constructor() {
                super(),
                this._currentLevel = 0,
                this.type = "LOD",
                Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    },
                    isLOD: {
                        value: !0
                    }
                }),
                this.autoUpdate = !0
            }
            copy(e) {
                super.copy(e, !1);
                const i = e.levels;
                for (let o = 0, a = i.length; o < a; o++) {
                    const c = i[o];
                    this.addLevel(c.object.clone(), c.distance, c.hysteresis)
                }
                return this.autoUpdate = e.autoUpdate,
                this
            }
            addLevel(e, i=0, o=0) {
                i = Math.abs(i);
                const a = this.levels;
                let c;
                for (c = 0; c < a.length && !(i < a[c].distance); c++)
                    ;
                return a.splice(c, 0, {
                    distance: i,
                    hysteresis: o,
                    object: e
                }),
                this.add(e),
                this
            }
            getCurrentLevel() {
                return this._currentLevel
            }
            getObjectForDistance(e) {
                const i = this.levels;
                if (i.length > 0) {
                    let o, a;
                    for (o = 1,
                    a = i.length; o < a; o++) {
                        let c = i[o].distance;
                        if (i[o].object.visible && (c -= c * i[o].hysteresis),
                        e < c)
                            break
                    }
                    return i[o - 1].object
                }
                return null
            }
            raycast(e, i) {
                if (this.levels.length > 0) {
                    vp.setFromMatrixPosition(this.matrixWorld);
                    const a = e.ray.origin.distanceTo(vp);
                    this.getObjectForDistance(a).raycast(e, i)
                }
            }
            update(e) {
                const i = this.levels;
                if (i.length > 1) {
                    vp.setFromMatrixPosition(e.matrixWorld),
                    w1.setFromMatrixPosition(this.matrixWorld);
                    const o = vp.distanceTo(w1) / e.zoom;
                    i[0].object.visible = !0;
                    let a, c;
                    for (a = 1,
                    c = i.length; a < c; a++) {
                        let d = i[a].distance;
                        if (i[a].object.visible && (d -= d * i[a].hysteresis),
                        o >= d)
                            i[a - 1].object.visible = !1,
                            i[a].object.visible = !0;
                        else
                            break
                    }
                    for (this._currentLevel = a - 1; a < c; a++)
                        i[a].object.visible = !1
                }
            }
            toJSON(e) {
                const i = super.toJSON(e);
                this.autoUpdate === !1 && (i.object.autoUpdate = !1),
                i.object.levels = [];
                const o = this.levels;
                for (let a = 0, c = o.length; a < c; a++) {
                    const d = o[a];
                    i.object.levels.push({
                        object: d.object.uuid,
                        distance: d.distance,
                        hysteresis: d.hysteresis
                    })
                }
                return i
            }
        }
        const S1 = new me
          , T1 = new mn
          , E1 = new mn
          , nR = new me
          , M1 = new pi;
        class C1 extends Es {
            constructor(e, i) {
                super(e, i),
                this.isSkinnedMesh = !0,
                this.type = "SkinnedMesh",
                this.bindMode = "attached",
                this.bindMatrix = new pi,
                this.bindMatrixInverse = new pi
            }
            copy(e, i) {
                return super.copy(e, i),
                this.bindMode = e.bindMode,
                this.bindMatrix.copy(e.bindMatrix),
                this.bindMatrixInverse.copy(e.bindMatrixInverse),
                this.skeleton = e.skeleton,
                this
            }
            bind(e, i) {
                this.skeleton = e,
                i === void 0 && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                i = this.matrixWorld),
                this.bindMatrix.copy(i),
                this.bindMatrixInverse.copy(i).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const e = new mn
                  , i = this.geometry.attributes.skinWeight;
                for (let o = 0, a = i.count; o < a; o++) {
                    e.fromBufferAttribute(i, o);
                    const c = 1 / e.manhattanLength();
                    c !== 1 / 0 ? e.multiplyScalar(c) : e.set(1, 0, 0, 0),
                    i.setXYZW(o, e.x, e.y, e.z, e.w)
                }
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e),
                this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            boneTransform(e, i) {
                const o = this.skeleton
                  , a = this.geometry;
                T1.fromBufferAttribute(a.attributes.skinIndex, e),
                E1.fromBufferAttribute(a.attributes.skinWeight, e),
                S1.copy(i).applyMatrix4(this.bindMatrix),
                i.set(0, 0, 0);
                for (let c = 0; c < 4; c++) {
                    const d = E1.getComponent(c);
                    if (d !== 0) {
                        const f = T1.getComponent(c);
                        M1.multiplyMatrices(o.bones[f].matrixWorld, o.boneInverses[f]),
                        i.addScaledVector(nR.copy(S1).applyMatrix4(M1), d)
                    }
                }
                return i.applyMatrix4(this.bindMatrixInverse)
            }
        }
        class f0 extends Qi {
            constructor() {
                super(),
                this.isBone = !0,
                this.type = "Bone"
            }
        }
        class Wu extends $t {
            constructor(e=null, i=1, o=1, a, c, d, f, v, x=gi, w=gi, P, M) {
                super(null, d, f, v, x, w, a, c, P, M),
                this.isDataTexture = !0,
                this.image = {
                    data: e,
                    width: i,
                    height: o
                },
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        const P1 = new pi
          , iR = new pi;
        class _p {
            constructor(e=[], i=[]) {
                this.uuid = yr(),
                this.bones = e.slice(0),
                this.boneInverses = i,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.boneTextureSize = 0,
                this.frame = -1,
                this.init()
            }
            init() {
                const e = this.bones
                  , i = this.boneInverses;
                if (this.boneMatrices = new Float32Array(e.length * 16),
                i.length === 0)
                    this.calculateInverses();
                else if (e.length !== i.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let o = 0, a = this.bones.length; o < a; o++)
                        this.boneInverses.push(new pi)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let e = 0, i = this.bones.length; e < i; e++) {
                    const o = new pi;
                    this.bones[e] && o.copy(this.bones[e].matrixWorld).invert(),
                    this.boneInverses.push(o)
                }
            }
            pose() {
                for (let e = 0, i = this.bones.length; e < i; e++) {
                    const o = this.bones[e];
                    o && o.matrixWorld.copy(this.boneInverses[e]).invert()
                }
                for (let e = 0, i = this.bones.length; e < i; e++) {
                    const o = this.bones[e];
                    o && (o.parent && o.parent.isBone ? (o.matrix.copy(o.parent.matrixWorld).invert(),
                    o.matrix.multiply(o.matrixWorld)) : o.matrix.copy(o.matrixWorld),
                    o.matrix.decompose(o.position, o.quaternion, o.scale))
                }
            }
            update() {
                const e = this.bones
                  , i = this.boneInverses
                  , o = this.boneMatrices
                  , a = this.boneTexture;
                for (let c = 0, d = e.length; c < d; c++) {
                    const f = e[c] ? e[c].matrixWorld : iR;
                    P1.multiplyMatrices(f, i[c]),
                    P1.toArray(o, c * 16)
                }
                a !== null && (a.needsUpdate = !0)
            }
            clone() {
                return new _p(this.bones,this.boneInverses)
            }
            computeBoneTexture() {
                let e = Math.sqrt(this.bones.length * 4);
                e = Mi(e),
                e = Math.max(e, 4);
                const i = new Float32Array(e * e * 4);
                i.set(this.boneMatrices);
                const o = new Wu(i,e,e,Xr,Js);
                return o.needsUpdate = !0,
                this.boneMatrices = i,
                this.boneTexture = o,
                this.boneTextureSize = e,
                this
            }
            getBoneByName(e) {
                for (let i = 0, o = this.bones.length; i < o; i++) {
                    const a = this.bones[i];
                    if (a.name === e)
                        return a
                }
            }
            dispose() {
                this.boneTexture !== null && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(e, i) {
                this.uuid = e.uuid;
                for (let o = 0, a = e.bones.length; o < a; o++) {
                    const c = e.bones[o];
                    let d = i[c];
                    d === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", c),
                    d = new f0),
                    this.bones.push(d),
                    this.boneInverses.push(new pi().fromArray(e.boneInverses[o]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                e.uuid = this.uuid;
                const i = this.bones
                  , o = this.boneInverses;
                for (let a = 0, c = i.length; a < c; a++) {
                    const d = i[a];
                    e.bones.push(d.uuid);
                    const f = o[a];
                    e.boneInverses.push(f.toArray())
                }
                return e
            }
        }
        class ju extends dr {
            constructor(e, i, o, a=1) {
                super(e, i, o),
                this.isInstancedBufferAttribute = !0,
                this.meshPerAttribute = a
            }
            copy(e) {
                return super.copy(e),
                this.meshPerAttribute = e.meshPerAttribute,
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.meshPerAttribute = this.meshPerAttribute,
                e.isInstancedBufferAttribute = !0,
                e
            }
        }
        const R1 = new pi
          , D1 = new pi
          , yp = []
          , rR = new pi
          , td = new Es;
        class L1 extends Es {
            constructor(e, i, o) {
                super(e, i),
                this.isInstancedMesh = !0,
                this.instanceMatrix = new ju(new Float32Array(o * 16),16),
                this.instanceColor = null,
                this.count = o,
                this.frustumCulled = !1;
                for (let a = 0; a < o; a++)
                    this.setMatrixAt(a, rR)
            }
            copy(e, i) {
                return super.copy(e, i),
                this.instanceMatrix.copy(e.instanceMatrix),
                e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
                this.count = e.count,
                this
            }
            getColorAt(e, i) {
                i.fromArray(this.instanceColor.array, e * 3)
            }
            getMatrixAt(e, i) {
                i.fromArray(this.instanceMatrix.array, e * 16)
            }
            raycast(e, i) {
                const o = this.matrixWorld
                  , a = this.count;
                if (td.geometry = this.geometry,
                td.material = this.material,
                td.material !== void 0)
                    for (let c = 0; c < a; c++) {
                        this.getMatrixAt(c, R1),
                        D1.multiplyMatrices(o, R1),
                        td.matrixWorld = D1,
                        td.raycast(e, yp);
                        for (let d = 0, f = yp.length; d < f; d++) {
                            const v = yp[d];
                            v.instanceId = c,
                            v.object = this,
                            i.push(v)
                        }
                        yp.length = 0
                    }
            }
            setColorAt(e, i) {
                this.instanceColor === null && (this.instanceColor = new ju(new Float32Array(this.instanceMatrix.count * 3),3)),
                i.toArray(this.instanceColor.array, e * 3)
            }
            setMatrixAt(e, i) {
                i.toArray(this.instanceMatrix.array, e * 16)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class ro extends Vs {
            constructor(e) {
                super(),
                this.isLineBasicMaterial = !0,
                this.type = "LineBasicMaterial",
                this.color = new gn(16777215),
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.linewidth = e.linewidth,
                this.linecap = e.linecap,
                this.linejoin = e.linejoin,
                this.fog = e.fog,
                this
            }
        }
        const I1 = new me
          , O1 = new me
          , B1 = new pi
          , p0 = new Vh
          , xp = new Nc;
        class ec extends Qi {
            constructor(e=new Ai, i=new ro) {
                super(),
                this.isLine = !0,
                this.type = "Line",
                this.geometry = e,
                this.material = i,
                this.updateMorphTargets()
            }
            copy(e, i) {
                return super.copy(e, i),
                this.material = e.material,
                this.geometry = e.geometry,
                this
            }
            computeLineDistances() {
                const e = this.geometry;
                if (e.index === null) {
                    const i = e.attributes.position
                      , o = [0];
                    for (let a = 1, c = i.count; a < c; a++)
                        I1.fromBufferAttribute(i, a - 1),
                        O1.fromBufferAttribute(i, a),
                        o[a] = o[a - 1],
                        o[a] += I1.distanceTo(O1);
                    e.setAttribute("lineDistance", new Rn(o,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(e, i) {
                const o = this.geometry
                  , a = this.matrixWorld
                  , c = e.params.Line.threshold
                  , d = o.drawRange;
                if (o.boundingSphere === null && o.computeBoundingSphere(),
                xp.copy(o.boundingSphere),
                xp.applyMatrix4(a),
                xp.radius += c,
                e.ray.intersectsSphere(xp) === !1)
                    return;
                B1.copy(a).invert(),
                p0.copy(e.ray).applyMatrix4(B1);
                const f = c / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , v = f * f
                  , x = new me
                  , w = new me
                  , P = new me
                  , M = new me
                  , I = this.isLineSegments ? 2 : 1
                  , z = o.index
                  , k = o.attributes.position;
                if (z !== null) {
                    const Q = Math.max(0, d.start)
                      , Z = Math.min(z.count, d.start + d.count);
                    for (let X = Q, K = Z - 1; X < K; X += I) {
                        const de = z.getX(X)
                          , be = z.getX(X + 1);
                        if (x.fromBufferAttribute(k, de),
                        w.fromBufferAttribute(k, be),
                        p0.distanceSqToSegment(x, w, M, P) > v)
                            continue;
                        M.applyMatrix4(this.matrixWorld);
                        const J = e.ray.origin.distanceTo(M);
                        J < e.near || J > e.far || i.push({
                            distance: J,
                            point: P.clone().applyMatrix4(this.matrixWorld),
                            index: X,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else {
                    const Q = Math.max(0, d.start)
                      , Z = Math.min(k.count, d.start + d.count);
                    for (let X = Q, K = Z - 1; X < K; X += I) {
                        if (x.fromBufferAttribute(k, X),
                        w.fromBufferAttribute(k, X + 1),
                        p0.distanceSqToSegment(x, w, M, P) > v)
                            continue;
                        M.applyMatrix4(this.matrixWorld);
                        const be = e.ray.origin.distanceTo(M);
                        be < e.near || be > e.far || i.push({
                            distance: be,
                            point: P.clone().applyMatrix4(this.matrixWorld),
                            index: X,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            }
            updateMorphTargets() {
                const i = this.geometry.morphAttributes
                  , o = Object.keys(i);
                if (o.length > 0) {
                    const a = i[o[0]];
                    if (a !== void 0) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let c = 0, d = a.length; c < d; c++) {
                            const f = a[c].name || String(c);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[f] = c
                        }
                    }
                }
            }
        }
        const F1 = new me
          , k1 = new me;
        class Xa extends ec {
            constructor(e, i) {
                super(e, i),
                this.isLineSegments = !0,
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const e = this.geometry;
                if (e.index === null) {
                    const i = e.attributes.position
                      , o = [];
                    for (let a = 0, c = i.count; a < c; a += 2)
                        F1.fromBufferAttribute(i, a),
                        k1.fromBufferAttribute(i, a + 1),
                        o[a] = a === 0 ? 0 : o[a - 1],
                        o[a + 1] = o[a] + F1.distanceTo(k1);
                    e.setAttribute("lineDistance", new Rn(o,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class U1 extends ec {
            constructor(e, i) {
                super(e, i),
                this.isLineLoop = !0,
                this.type = "LineLoop"
            }
        }
        class m0 extends Vs {
            constructor(e) {
                super(),
                this.isPointsMaterial = !0,
                this.type = "PointsMaterial",
                this.color = new gn(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.size = e.size,
                this.sizeAttenuation = e.sizeAttenuation,
                this.fog = e.fog,
                this
            }
        }
        const N1 = new pi
          , g0 = new Vh
          , bp = new Nc
          , wp = new me;
        class z1 extends Qi {
            constructor(e=new Ai, i=new m0) {
                super(),
                this.isPoints = !0,
                this.type = "Points",
                this.geometry = e,
                this.material = i,
                this.updateMorphTargets()
            }
            copy(e, i) {
                return super.copy(e, i),
                this.material = e.material,
                this.geometry = e.geometry,
                this
            }
            raycast(e, i) {
                const o = this.geometry
                  , a = this.matrixWorld
                  , c = e.params.Points.threshold
                  , d = o.drawRange;
                if (o.boundingSphere === null && o.computeBoundingSphere(),
                bp.copy(o.boundingSphere),
                bp.applyMatrix4(a),
                bp.radius += c,
                e.ray.intersectsSphere(bp) === !1)
                    return;
                N1.copy(a).invert(),
                g0.copy(e.ray).applyMatrix4(N1);
                const f = c / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , v = f * f
                  , x = o.index
                  , P = o.attributes.position;
                if (x !== null) {
                    const M = Math.max(0, d.start)
                      , I = Math.min(x.count, d.start + d.count);
                    for (let z = M, O = I; z < O; z++) {
                        const k = x.getX(z);
                        wp.fromBufferAttribute(P, k),
                        G1(wp, k, v, a, e, i, this)
                    }
                } else {
                    const M = Math.max(0, d.start)
                      , I = Math.min(P.count, d.start + d.count);
                    for (let z = M, O = I; z < O; z++)
                        wp.fromBufferAttribute(P, z),
                        G1(wp, z, v, a, e, i, this)
                }
            }
            updateMorphTargets() {
                const i = this.geometry.morphAttributes
                  , o = Object.keys(i);
                if (o.length > 0) {
                    const a = i[o[0]];
                    if (a !== void 0) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let c = 0, d = a.length; c < d; c++) {
                            const f = a[c].name || String(c);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[f] = c
                        }
                    }
                }
            }
        }
        function G1(u, e, i, o, a, c, d) {
            const f = g0.distanceSqToPoint(u);
            if (f < i) {
                const v = new me;
                g0.closestPointToPoint(u, v),
                v.applyMatrix4(o);
                const x = a.ray.origin.distanceTo(v);
                if (x < a.near || x > a.far)
                    return;
                c.push({
                    distance: x,
                    distanceToRay: Math.sqrt(f),
                    point: v,
                    index: e,
                    face: null,
                    object: d
                })
            }
        }
        class sR extends $t {
            constructor(e, i, o, a, c, d, f, v, x) {
                super(e, i, o, a, c, d, f, v, x),
                this.isVideoTexture = !0,
                this.minFilter = d !== void 0 ? d : Hi,
                this.magFilter = c !== void 0 ? c : Hi,
                this.generateMipmaps = !1;
                const w = this;
                function P() {
                    w.needsUpdate = !0,
                    e.requestVideoFrameCallback(P)
                }
                "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(P)
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const e = this.image;
                "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        class oR extends $t {
            constructor(e, i, o) {
                super({
                    width: e,
                    height: i
                }),
                this.isFramebufferTexture = !0,
                this.format = o,
                this.magFilter = gi,
                this.minFilter = gi,
                this.generateMipmaps = !1,
                this.needsUpdate = !0
            }
        }
        class v0 extends $t {
            constructor(e, i, o, a, c, d, f, v, x, w, P, M) {
                super(null, d, f, v, x, w, a, c, P, M),
                this.isCompressedTexture = !0,
                this.image = {
                    width: i,
                    height: o
                },
                this.mipmaps = e,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        class aR extends v0 {
            constructor(e, i, o, a, c, d) {
                super(e, i, o, c, d),
                this.isCompressedArrayTexture = !0,
                this.image.depth = a,
                this.wrapR = hi
            }
        }
        class lR extends $t {
            constructor(e, i, o, a, c, d, f, v, x) {
                super(e, i, o, a, c, d, f, v, x),
                this.isCanvasTexture = !0,
                this.needsUpdate = !0
            }
        }
        class Ta {
            constructor() {
                this.type = "Curve",
                this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            }
            getPointAt(e, i) {
                const o = this.getUtoTmapping(e);
                return this.getPoint(o, i)
            }
            getPoints(e=5) {
                const i = [];
                for (let o = 0; o <= e; o++)
                    i.push(this.getPoint(o / e));
                return i
            }
            getSpacedPoints(e=5) {
                const i = [];
                for (let o = 0; o <= e; o++)
                    i.push(this.getPointAt(o / e));
                return i
            }
            getLength() {
                const e = this.getLengths();
                return e[e.length - 1]
            }
            getLengths(e=this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                const i = [];
                let o, a = this.getPoint(0), c = 0;
                i.push(0);
                for (let d = 1; d <= e; d++)
                    o = this.getPoint(d / e),
                    c += o.distanceTo(a),
                    i.push(c),
                    a = o;
                return this.cacheArcLengths = i,
                i
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.getLengths()
            }
            getUtoTmapping(e, i) {
                const o = this.getLengths();
                let a = 0;
                const c = o.length;
                let d;
                i ? d = i : d = e * o[c - 1];
                let f = 0, v = c - 1, x;
                for (; f <= v; )
                    if (a = Math.floor(f + (v - f) / 2),
                    x = o[a] - d,
                    x < 0)
                        f = a + 1;
                    else if (x > 0)
                        v = a - 1;
                    else {
                        v = a;
                        break
                    }
                if (a = v,
                o[a] === d)
                    return a / (c - 1);
                const w = o[a]
                  , M = o[a + 1] - w
                  , I = (d - w) / M;
                return (a + I) / (c - 1)
            }
            getTangent(e, i) {
                let a = e - 1e-4
                  , c = e + 1e-4;
                a < 0 && (a = 0),
                c > 1 && (c = 1);
                const d = this.getPoint(a)
                  , f = this.getPoint(c)
                  , v = i || (d.isVector2 ? new _t : new me);
                return v.copy(f).sub(d).normalize(),
                v
            }
            getTangentAt(e, i) {
                const o = this.getUtoTmapping(e);
                return this.getTangent(o, i)
            }
            computeFrenetFrames(e, i) {
                const o = new me
                  , a = []
                  , c = []
                  , d = []
                  , f = new me
                  , v = new pi;
                for (let I = 0; I <= e; I++) {
                    const z = I / e;
                    a[I] = this.getTangentAt(z, new me)
                }
                c[0] = new me,
                d[0] = new me;
                let x = Number.MAX_VALUE;
                const w = Math.abs(a[0].x)
                  , P = Math.abs(a[0].y)
                  , M = Math.abs(a[0].z);
                w <= x && (x = w,
                o.set(1, 0, 0)),
                P <= x && (x = P,
                o.set(0, 1, 0)),
                M <= x && o.set(0, 0, 1),
                f.crossVectors(a[0], o).normalize(),
                c[0].crossVectors(a[0], f),
                d[0].crossVectors(a[0], c[0]);
                for (let I = 1; I <= e; I++) {
                    if (c[I] = c[I - 1].clone(),
                    d[I] = d[I - 1].clone(),
                    f.crossVectors(a[I - 1], a[I]),
                    f.length() > Number.EPSILON) {
                        f.normalize();
                        const z = Math.acos(Wi(a[I - 1].dot(a[I]), -1, 1));
                        c[I].applyMatrix4(v.makeRotationAxis(f, z))
                    }
                    d[I].crossVectors(a[I], c[I])
                }
                if (i === !0) {
                    let I = Math.acos(Wi(c[0].dot(c[e]), -1, 1));
                    I /= e,
                    a[0].dot(f.crossVectors(c[0], c[e])) > 0 && (I = -I);
                    for (let z = 1; z <= e; z++)
                        c[z].applyMatrix4(v.makeRotationAxis(a[z], I * z)),
                        d[z].crossVectors(a[z], c[z])
                }
                return {
                    tangents: a,
                    normals: c,
                    binormals: d
                }
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions,
                this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return e.arcLengthDivisions = this.arcLengthDivisions,
                e.type = this.type,
                e
            }
            fromJSON(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions,
                this
            }
        }
        class Ap extends Ta {
            constructor(e=0, i=0, o=1, a=1, c=0, d=Math.PI * 2, f=!1, v=0) {
                super(),
                this.isEllipseCurve = !0,
                this.type = "EllipseCurve",
                this.aX = e,
                this.aY = i,
                this.xRadius = o,
                this.yRadius = a,
                this.aStartAngle = c,
                this.aEndAngle = d,
                this.aClockwise = f,
                this.aRotation = v
            }
            getPoint(e, i) {
                const o = i || new _t
                  , a = Math.PI * 2;
                let c = this.aEndAngle - this.aStartAngle;
                const d = Math.abs(c) < Number.EPSILON;
                for (; c < 0; )
                    c += a;
                for (; c > a; )
                    c -= a;
                c < Number.EPSILON && (d ? c = 0 : c = a),
                this.aClockwise === !0 && !d && (c === a ? c = -a : c = c - a);
                const f = this.aStartAngle + e * c;
                let v = this.aX + this.xRadius * Math.cos(f)
                  , x = this.aY + this.yRadius * Math.sin(f);
                if (this.aRotation !== 0) {
                    const w = Math.cos(this.aRotation)
                      , P = Math.sin(this.aRotation)
                      , M = v - this.aX
                      , I = x - this.aY;
                    v = M * w - I * P + this.aX,
                    x = M * P + I * w + this.aY
                }
                return o.set(v, x)
            }
            copy(e) {
                return super.copy(e),
                this.aX = e.aX,
                this.aY = e.aY,
                this.xRadius = e.xRadius,
                this.yRadius = e.yRadius,
                this.aStartAngle = e.aStartAngle,
                this.aEndAngle = e.aEndAngle,
                this.aClockwise = e.aClockwise,
                this.aRotation = e.aRotation,
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.aX = this.aX,
                e.aY = this.aY,
                e.xRadius = this.xRadius,
                e.yRadius = this.yRadius,
                e.aStartAngle = this.aStartAngle,
                e.aEndAngle = this.aEndAngle,
                e.aClockwise = this.aClockwise,
                e.aRotation = this.aRotation,
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.aX = e.aX,
                this.aY = e.aY,
                this.xRadius = e.xRadius,
                this.yRadius = e.yRadius,
                this.aStartAngle = e.aStartAngle,
                this.aEndAngle = e.aEndAngle,
                this.aClockwise = e.aClockwise,
                this.aRotation = e.aRotation,
                this
            }
        }
        class H1 extends Ap {
            constructor(e, i, o, a, c, d) {
                super(e, i, o, o, a, c, d),
                this.isArcCurve = !0,
                this.type = "ArcCurve"
            }
        }
        function _0() {
            let u = 0
              , e = 0
              , i = 0
              , o = 0;
            function a(c, d, f, v) {
                u = c,
                e = f,
                i = -3 * c + 3 * d - 2 * f - v,
                o = 2 * c - 2 * d + f + v
            }
            return {
                initCatmullRom: function(c, d, f, v, x) {
                    a(d, f, x * (f - c), x * (v - d))
                },
                initNonuniformCatmullRom: function(c, d, f, v, x, w, P) {
                    let M = (d - c) / x - (f - c) / (x + w) + (f - d) / w
                      , I = (f - d) / w - (v - d) / (w + P) + (v - f) / P;
                    M *= w,
                    I *= w,
                    a(d, f, M, I)
                },
                calc: function(c) {
                    const d = c * c
                      , f = d * c;
                    return u + e * c + i * d + o * f
                }
            }
        }
        const Sp = new me
          , y0 = new _0
          , x0 = new _0
          , b0 = new _0;
        class V1 extends Ta {
            constructor(e=[], i=!1, o="centripetal", a=.5) {
                super(),
                this.isCatmullRomCurve3 = !0,
                this.type = "CatmullRomCurve3",
                this.points = e,
                this.closed = i,
                this.curveType = o,
                this.tension = a
            }
            getPoint(e, i=new me) {
                const o = i
                  , a = this.points
                  , c = a.length
                  , d = (c - (this.closed ? 0 : 1)) * e;
                let f = Math.floor(d)
                  , v = d - f;
                this.closed ? f += f > 0 ? 0 : (Math.floor(Math.abs(f) / c) + 1) * c : v === 0 && f === c - 1 && (f = c - 2,
                v = 1);
                let x, w;
                this.closed || f > 0 ? x = a[(f - 1) % c] : (Sp.subVectors(a[0], a[1]).add(a[0]),
                x = Sp);
                const P = a[f % c]
                  , M = a[(f + 1) % c];
                if (this.closed || f + 2 < c ? w = a[(f + 2) % c] : (Sp.subVectors(a[c - 1], a[c - 2]).add(a[c - 1]),
                w = Sp),
                this.curveType === "centripetal" || this.curveType === "chordal") {
                    const I = this.curveType === "chordal" ? .5 : .25;
                    let z = Math.pow(x.distanceToSquared(P), I)
                      , O = Math.pow(P.distanceToSquared(M), I)
                      , k = Math.pow(M.distanceToSquared(w), I);
                    O < 1e-4 && (O = 1),
                    z < 1e-4 && (z = O),
                    k < 1e-4 && (k = O),
                    y0.initNonuniformCatmullRom(x.x, P.x, M.x, w.x, z, O, k),
                    x0.initNonuniformCatmullRom(x.y, P.y, M.y, w.y, z, O, k),
                    b0.initNonuniformCatmullRom(x.z, P.z, M.z, w.z, z, O, k)
                } else
                    this.curveType === "catmullrom" && (y0.initCatmullRom(x.x, P.x, M.x, w.x, this.tension),
                    x0.initCatmullRom(x.y, P.y, M.y, w.y, this.tension),
                    b0.initCatmullRom(x.z, P.z, M.z, w.z, this.tension));
                return o.set(y0.calc(v), x0.calc(v), b0.calc(v)),
                o
            }
            copy(e) {
                super.copy(e),
                this.points = [];
                for (let i = 0, o = e.points.length; i < o; i++) {
                    const a = e.points[i];
                    this.points.push(a.clone())
                }
                return this.closed = e.closed,
                this.curveType = e.curveType,
                this.tension = e.tension,
                this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let i = 0, o = this.points.length; i < o; i++) {
                    const a = this.points[i];
                    e.points.push(a.toArray())
                }
                return e.closed = this.closed,
                e.curveType = this.curveType,
                e.tension = this.tension,
                e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.points = [];
                for (let i = 0, o = e.points.length; i < o; i++) {
                    const a = e.points[i];
                    this.points.push(new me().fromArray(a))
                }
                return this.closed = e.closed,
                this.curveType = e.curveType,
                this.tension = e.tension,
                this
            }
        }
        function W1(u, e, i, o, a) {
            const c = (o - e) * .5
              , d = (a - i) * .5
              , f = u * u
              , v = u * f;
            return (2 * i - 2 * o + c + d) * v + (-3 * i + 3 * o - 2 * c - d) * f + c * u + i
        }
        function cR(u, e) {
            const i = 1 - u;
            return i * i * e
        }
        function uR(u, e) {
            return 2 * (1 - u) * u * e
        }
        function hR(u, e) {
            return u * u * e
        }
        function nd(u, e, i, o) {
            return cR(u, e) + uR(u, i) + hR(u, o)
        }
        function dR(u, e) {
            const i = 1 - u;
            return i * i * i * e
        }
        function fR(u, e) {
            const i = 1 - u;
            return 3 * i * i * u * e
        }
        function pR(u, e) {
            return 3 * (1 - u) * u * u * e
        }
        function mR(u, e) {
            return u * u * u * e
        }
        function id(u, e, i, o, a) {
            return dR(u, e) + fR(u, i) + pR(u, o) + mR(u, a)
        }
        class w0 extends Ta {
            constructor(e=new _t, i=new _t, o=new _t, a=new _t) {
                super(),
                this.isCubicBezierCurve = !0,
                this.type = "CubicBezierCurve",
                this.v0 = e,
                this.v1 = i,
                this.v2 = o,
                this.v3 = a
            }
            getPoint(e, i=new _t) {
                const o = i
                  , a = this.v0
                  , c = this.v1
                  , d = this.v2
                  , f = this.v3;
                return o.set(id(e, a.x, c.x, d.x, f.x), id(e, a.y, c.y, d.y, f.y)),
                o
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this.v3.copy(e.v3),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e.v3 = this.v3.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this.v3.fromArray(e.v3),
                this
            }
        }
        class j1 extends Ta {
            constructor(e=new me, i=new me, o=new me, a=new me) {
                super(),
                this.isCubicBezierCurve3 = !0,
                this.type = "CubicBezierCurve3",
                this.v0 = e,
                this.v1 = i,
                this.v2 = o,
                this.v3 = a
            }
            getPoint(e, i=new me) {
                const o = i
                  , a = this.v0
                  , c = this.v1
                  , d = this.v2
                  , f = this.v3;
                return o.set(id(e, a.x, c.x, d.x, f.x), id(e, a.y, c.y, d.y, f.y), id(e, a.z, c.z, d.z, f.z)),
                o
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this.v3.copy(e.v3),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e.v3 = this.v3.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this.v3.fromArray(e.v3),
                this
            }
        }
        class Tp extends Ta {
            constructor(e=new _t, i=new _t) {
                super(),
                this.isLineCurve = !0,
                this.type = "LineCurve",
                this.v1 = e,
                this.v2 = i
            }
            getPoint(e, i=new _t) {
                const o = i;
                return e === 1 ? o.copy(this.v2) : (o.copy(this.v2).sub(this.v1),
                o.multiplyScalar(e).add(this.v1)),
                o
            }
            getPointAt(e, i) {
                return this.getPoint(e, i)
            }
            getTangent(e, i=new _t) {
                return i.subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(e, i) {
                return this.getTangent(e, i)
            }
            copy(e) {
                return super.copy(e),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class X1 extends Ta {
            constructor(e=new me, i=new me) {
                super(),
                this.isLineCurve3 = !0,
                this.type = "LineCurve3",
                this.v1 = e,
                this.v2 = i
            }
            getPoint(e, i=new me) {
                const o = i;
                return e === 1 ? o.copy(this.v2) : (o.copy(this.v2).sub(this.v1),
                o.multiplyScalar(e).add(this.v1)),
                o
            }
            getPointAt(e, i) {
                return this.getPoint(e, i)
            }
            getTangent(e, i=new me) {
                return i.subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(e, i) {
                return this.getTangent(e, i)
            }
            copy(e) {
                return super.copy(e),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class A0 extends Ta {
            constructor(e=new _t, i=new _t, o=new _t) {
                super(),
                this.isQuadraticBezierCurve = !0,
                this.type = "QuadraticBezierCurve",
                this.v0 = e,
                this.v1 = i,
                this.v2 = o
            }
            getPoint(e, i=new _t) {
                const o = i
                  , a = this.v0
                  , c = this.v1
                  , d = this.v2;
                return o.set(nd(e, a.x, c.x, d.x), nd(e, a.y, c.y, d.y)),
                o
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class S0 extends Ta {
            constructor(e=new me, i=new me, o=new me) {
                super(),
                this.isQuadraticBezierCurve3 = !0,
                this.type = "QuadraticBezierCurve3",
                this.v0 = e,
                this.v1 = i,
                this.v2 = o
            }
            getPoint(e, i=new me) {
                const o = i
                  , a = this.v0
                  , c = this.v1
                  , d = this.v2;
                return o.set(nd(e, a.x, c.x, d.x), nd(e, a.y, c.y, d.y), nd(e, a.z, c.z, d.z)),
                o
            }
            copy(e) {
                return super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(),
                e.v1 = this.v1.toArray(),
                e.v2 = this.v2.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            }
        }
        class T0 extends Ta {
            constructor(e=[]) {
                super(),
                this.isSplineCurve = !0,
                this.type = "SplineCurve",
                this.points = e
            }
            getPoint(e, i=new _t) {
                const o = i
                  , a = this.points
                  , c = (a.length - 1) * e
                  , d = Math.floor(c)
                  , f = c - d
                  , v = a[d === 0 ? d : d - 1]
                  , x = a[d]
                  , w = a[d > a.length - 2 ? a.length - 1 : d + 1]
                  , P = a[d > a.length - 3 ? a.length - 1 : d + 2];
                return o.set(W1(f, v.x, x.x, w.x, P.x), W1(f, v.y, x.y, w.y, P.y)),
                o
            }
            copy(e) {
                super.copy(e),
                this.points = [];
                for (let i = 0, o = e.points.length; i < o; i++) {
                    const a = e.points[i];
                    this.points.push(a.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let i = 0, o = this.points.length; i < o; i++) {
                    const a = this.points[i];
                    e.points.push(a.toArray())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.points = [];
                for (let i = 0, o = e.points.length; i < o; i++) {
                    const a = e.points[i];
                    this.points.push(new _t().fromArray(a))
                }
                return this
            }
        }
        class Y1 extends Ta {
            constructor() {
                super(),
                this.type = "CurvePath",
                this.curves = [],
                this.autoClose = !1
            }
            add(e) {
                this.curves.push(e)
            }
            closePath() {
                const e = this.curves[0].getPoint(0)
                  , i = this.curves[this.curves.length - 1].getPoint(1);
                e.equals(i) || this.curves.push(new Tp(i,e))
            }
            getPoint(e, i) {
                const o = e * this.getLength()
                  , a = this.getCurveLengths();
                let c = 0;
                for (; c < a.length; ) {
                    if (a[c] >= o) {
                        const d = a[c] - o
                          , f = this.curves[c]
                          , v = f.getLength()
                          , x = v === 0 ? 0 : 1 - d / v;
                        return f.getPointAt(x, i)
                    }
                    c++
                }
                return null
            }
            getLength() {
                const e = this.getCurveLengths();
                return e[e.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.cacheLengths = null,
                this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                const e = [];
                let i = 0;
                for (let o = 0, a = this.curves.length; o < a; o++)
                    i += this.curves[o].getLength(),
                    e.push(i);
                return this.cacheLengths = e,
                e
            }
            getSpacedPoints(e=40) {
                const i = [];
                for (let o = 0; o <= e; o++)
                    i.push(this.getPoint(o / e));
                return this.autoClose && i.push(i[0]),
                i
            }
            getPoints(e=12) {
                const i = [];
                let o;
                for (let a = 0, c = this.curves; a < c.length; a++) {
                    const d = c[a]
                      , f = d.isEllipseCurve ? e * 2 : d.isLineCurve || d.isLineCurve3 ? 1 : d.isSplineCurve ? e * d.points.length : e
                      , v = d.getPoints(f);
                    for (let x = 0; x < v.length; x++) {
                        const w = v[x];
                        o && o.equals(w) || (i.push(w),
                        o = w)
                    }
                }
                return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]),
                i
            }
            copy(e) {
                super.copy(e),
                this.curves = [];
                for (let i = 0, o = e.curves.length; i < o; i++) {
                    const a = e.curves[i];
                    this.curves.push(a.clone())
                }
                return this.autoClose = e.autoClose,
                this
            }
            toJSON() {
                const e = super.toJSON();
                e.autoClose = this.autoClose,
                e.curves = [];
                for (let i = 0, o = this.curves.length; i < o; i++) {
                    const a = this.curves[i];
                    e.curves.push(a.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.autoClose = e.autoClose,
                this.curves = [];
                for (let i = 0, o = e.curves.length; i < o; i++) {
                    const a = e.curves[i];
                    this.curves.push(new s[a.type]().fromJSON(a))
                }
                return this
            }
        }
        class rd extends Y1 {
            constructor(e) {
                super(),
                this.type = "Path",
                this.currentPoint = new _t,
                e && this.setFromPoints(e)
            }
            setFromPoints(e) {
                this.moveTo(e[0].x, e[0].y);
                for (let i = 1, o = e.length; i < o; i++)
                    this.lineTo(e[i].x, e[i].y);
                return this
            }
            moveTo(e, i) {
                return this.currentPoint.set(e, i),
                this
            }
            lineTo(e, i) {
                const o = new Tp(this.currentPoint.clone(),new _t(e,i));
                return this.curves.push(o),
                this.currentPoint.set(e, i),
                this
            }
            quadraticCurveTo(e, i, o, a) {
                const c = new A0(this.currentPoint.clone(),new _t(e,i),new _t(o,a));
                return this.curves.push(c),
                this.currentPoint.set(o, a),
                this
            }
            bezierCurveTo(e, i, o, a, c, d) {
                const f = new w0(this.currentPoint.clone(),new _t(e,i),new _t(o,a),new _t(c,d));
                return this.curves.push(f),
                this.currentPoint.set(c, d),
                this
            }
            splineThru(e) {
                const i = [this.currentPoint.clone()].concat(e)
                  , o = new T0(i);
                return this.curves.push(o),
                this.currentPoint.copy(e[e.length - 1]),
                this
            }
            arc(e, i, o, a, c, d) {
                const f = this.currentPoint.x
                  , v = this.currentPoint.y;
                return this.absarc(e + f, i + v, o, a, c, d),
                this
            }
            absarc(e, i, o, a, c, d) {
                return this.absellipse(e, i, o, o, a, c, d),
                this
            }
            ellipse(e, i, o, a, c, d, f, v) {
                const x = this.currentPoint.x
                  , w = this.currentPoint.y;
                return this.absellipse(e + x, i + w, o, a, c, d, f, v),
                this
            }
            absellipse(e, i, o, a, c, d, f, v) {
                const x = new Ap(e,i,o,a,c,d,f,v);
                if (this.curves.length > 0) {
                    const P = x.getPoint(0);
                    P.equals(this.currentPoint) || this.lineTo(P.x, P.y)
                }
                this.curves.push(x);
                const w = x.getPoint(1);
                return this.currentPoint.copy(w),
                this
            }
            copy(e) {
                return super.copy(e),
                this.currentPoint.copy(e.currentPoint),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.currentPoint = this.currentPoint.toArray(),
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.currentPoint.fromArray(e.currentPoint),
                this
            }
        }
        class Xu extends Ai {
            constructor(e=[new _t(0,-.5), new _t(.5,0), new _t(0,.5)], i=12, o=0, a=Math.PI * 2) {
                super(),
                this.type = "LatheGeometry",
                this.parameters = {
                    points: e,
                    segments: i,
                    phiStart: o,
                    phiLength: a
                },
                i = Math.floor(i),
                a = Wi(a, 0, Math.PI * 2);
                const c = []
                  , d = []
                  , f = []
                  , v = []
                  , x = []
                  , w = 1 / i
                  , P = new me
                  , M = new _t
                  , I = new me
                  , z = new me
                  , O = new me;
                let k = 0
                  , Q = 0;
                for (let Z = 0; Z <= e.length - 1; Z++)
                    switch (Z) {
                    case 0:
                        k = e[Z + 1].x - e[Z].x,
                        Q = e[Z + 1].y - e[Z].y,
                        I.x = Q * 1,
                        I.y = -k,
                        I.z = Q * 0,
                        O.copy(I),
                        I.normalize(),
                        v.push(I.x, I.y, I.z);
                        break;
                    case e.length - 1:
                        v.push(O.x, O.y, O.z);
                        break;
                    default:
                        k = e[Z + 1].x - e[Z].x,
                        Q = e[Z + 1].y - e[Z].y,
                        I.x = Q * 1,
                        I.y = -k,
                        I.z = Q * 0,
                        z.copy(I),
                        I.x += O.x,
                        I.y += O.y,
                        I.z += O.z,
                        I.normalize(),
                        v.push(I.x, I.y, I.z),
                        O.copy(z)
                    }
                for (let Z = 0; Z <= i; Z++) {
                    const X = o + Z * w * a
                      , K = Math.sin(X)
                      , de = Math.cos(X);
                    for (let be = 0; be <= e.length - 1; be++) {
                        P.x = e[be].x * K,
                        P.y = e[be].y,
                        P.z = e[be].x * de,
                        d.push(P.x, P.y, P.z),
                        M.x = Z / i,
                        M.y = be / (e.length - 1),
                        f.push(M.x, M.y);
                        const Me = v[3 * be + 0] * K
                          , J = v[3 * be + 1]
                          , ge = v[3 * be + 0] * de;
                        x.push(Me, J, ge)
                    }
                }
                for (let Z = 0; Z < i; Z++)
                    for (let X = 0; X < e.length - 1; X++) {
                        const K = X + Z * e.length
                          , de = K
                          , be = K + e.length
                          , Me = K + e.length + 1
                          , J = K + 1;
                        c.push(de, be, J),
                        c.push(Me, J, be)
                    }
                this.setIndex(c),
                this.setAttribute("position", new Rn(d,3)),
                this.setAttribute("uv", new Rn(f,2)),
                this.setAttribute("normal", new Rn(x,3))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Xu(e.points,e.segments,e.phiStart,e.phiLength)
            }
        }
        class sd extends Xu {
            constructor(e=1, i=1, o=4, a=8) {
                const c = new rd;
                c.absarc(0, -i / 2, e, Math.PI * 1.5, 0),
                c.absarc(0, i / 2, e, 0, Math.PI * .5),
                super(c.getPoints(o), a),
                this.type = "CapsuleGeometry",
                this.parameters = {
                    radius: e,
                    height: i,
                    capSegments: o,
                    radialSegments: a
                }
            }
            static fromJSON(e) {
                return new sd(e.radius,e.length,e.capSegments,e.radialSegments)
            }
        }
        class od extends Ai {
            constructor(e=1, i=32, o=0, a=Math.PI * 2) {
                super(),
                this.type = "CircleGeometry",
                this.parameters = {
                    radius: e,
                    segments: i,
                    thetaStart: o,
                    thetaLength: a
                },
                i = Math.max(3, i);
                const c = []
                  , d = []
                  , f = []
                  , v = []
                  , x = new me
                  , w = new _t;
                d.push(0, 0, 0),
                f.push(0, 0, 1),
                v.push(.5, .5);
                for (let P = 0, M = 3; P <= i; P++,
                M += 3) {
                    const I = o + P / i * a;
                    x.x = e * Math.cos(I),
                    x.y = e * Math.sin(I),
                    d.push(x.x, x.y, x.z),
                    f.push(0, 0, 1),
                    w.x = (d[M] / e + 1) / 2,
                    w.y = (d[M + 1] / e + 1) / 2,
                    v.push(w.x, w.y)
                }
                for (let P = 1; P <= i; P++)
                    c.push(P, P + 1, 0);
                this.setIndex(c),
                this.setAttribute("position", new Rn(d,3)),
                this.setAttribute("normal", new Rn(f,3)),
                this.setAttribute("uv", new Rn(v,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new od(e.radius,e.segments,e.thetaStart,e.thetaLength)
            }
        }
        class Vc extends Ai {
            constructor(e=1, i=1, o=1, a=32, c=1, d=!1, f=0, v=Math.PI * 2) {
                super(),
                this.type = "CylinderGeometry",
                this.parameters = {
                    radiusTop: e,
                    radiusBottom: i,
                    height: o,
                    radialSegments: a,
                    heightSegments: c,
                    openEnded: d,
                    thetaStart: f,
                    thetaLength: v
                };
                const x = this;
                a = Math.floor(a),
                c = Math.floor(c);
                const w = []
                  , P = []
                  , M = []
                  , I = [];
                let z = 0;
                const O = []
                  , k = o / 2;
                let Q = 0;
                Z(),
                d === !1 && (e > 0 && X(!0),
                i > 0 && X(!1)),
                this.setIndex(w),
                this.setAttribute("position", new Rn(P,3)),
                this.setAttribute("normal", new Rn(M,3)),
                this.setAttribute("uv", new Rn(I,2));
                function Z() {
                    const K = new me
                      , de = new me;
                    let be = 0;
                    const Me = (i - e) / o;
                    for (let J = 0; J <= c; J++) {
                        const ge = []
                          , Le = J / c
                          , tt = Le * (i - e) + e;
                        for (let lt = 0; lt <= a; lt++) {
                            const je = lt / a
                              , ze = je * v + f
                              , st = Math.sin(ze)
                              , yt = Math.cos(ze);
                            de.x = tt * st,
                            de.y = -Le * o + k,
                            de.z = tt * yt,
                            P.push(de.x, de.y, de.z),
                            K.set(st, Me, yt).normalize(),
                            M.push(K.x, K.y, K.z),
                            I.push(je, 1 - Le),
                            ge.push(z++)
                        }
                        O.push(ge)
                    }
                    for (let J = 0; J < a; J++)
                        for (let ge = 0; ge < c; ge++) {
                            const Le = O[ge][J]
                              , tt = O[ge + 1][J]
                              , lt = O[ge + 1][J + 1]
                              , je = O[ge][J + 1];
                            w.push(Le, tt, je),
                            w.push(tt, lt, je),
                            be += 6
                        }
                    x.addGroup(Q, be, 0),
                    Q += be
                }
                function X(K) {
                    const de = z
                      , be = new _t
                      , Me = new me;
                    let J = 0;
                    const ge = K === !0 ? e : i
                      , Le = K === !0 ? 1 : -1;
                    for (let lt = 1; lt <= a; lt++)
                        P.push(0, k * Le, 0),
                        M.push(0, Le, 0),
                        I.push(.5, .5),
                        z++;
                    const tt = z;
                    for (let lt = 0; lt <= a; lt++) {
                        const ze = lt / a * v + f
                          , st = Math.cos(ze)
                          , yt = Math.sin(ze);
                        Me.x = ge * yt,
                        Me.y = k * Le,
                        Me.z = ge * st,
                        P.push(Me.x, Me.y, Me.z),
                        M.push(0, Le, 0),
                        be.x = st * .5 + .5,
                        be.y = yt * .5 * Le + .5,
                        I.push(be.x, be.y),
                        z++
                    }
                    for (let lt = 0; lt < a; lt++) {
                        const je = de + lt
                          , ze = tt + lt;
                        K === !0 ? w.push(ze, ze + 1, je) : w.push(ze + 1, ze, je),
                        J += 3
                    }
                    x.addGroup(Q, J, K === !0 ? 1 : 2),
                    Q += J
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Vc(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
            }
        }
        class ad extends Vc {
            constructor(e=1, i=1, o=32, a=1, c=!1, d=0, f=Math.PI * 2) {
                super(0, e, i, o, a, c, d, f),
                this.type = "ConeGeometry",
                this.parameters = {
                    radius: e,
                    height: i,
                    radialSegments: o,
                    heightSegments: a,
                    openEnded: c,
                    thetaStart: d,
                    thetaLength: f
                }
            }
            static fromJSON(e) {
                return new ad(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
            }
        }
        class bl extends Ai {
            constructor(e=[], i=[], o=1, a=0) {
                super(),
                this.type = "PolyhedronGeometry",
                this.parameters = {
                    vertices: e,
                    indices: i,
                    radius: o,
                    detail: a
                };
                const c = []
                  , d = [];
                f(a),
                x(o),
                w(),
                this.setAttribute("position", new Rn(c,3)),
                this.setAttribute("normal", new Rn(c.slice(),3)),
                this.setAttribute("uv", new Rn(d,2)),
                a === 0 ? this.computeVertexNormals() : this.normalizeNormals();
                function f(Z) {
                    const X = new me
                      , K = new me
                      , de = new me;
                    for (let be = 0; be < i.length; be += 3)
                        I(i[be + 0], X),
                        I(i[be + 1], K),
                        I(i[be + 2], de),
                        v(X, K, de, Z)
                }
                function v(Z, X, K, de) {
                    const be = de + 1
                      , Me = [];
                    for (let J = 0; J <= be; J++) {
                        Me[J] = [];
                        const ge = Z.clone().lerp(K, J / be)
                          , Le = X.clone().lerp(K, J / be)
                          , tt = be - J;
                        for (let lt = 0; lt <= tt; lt++)
                            lt === 0 && J === be ? Me[J][lt] = ge : Me[J][lt] = ge.clone().lerp(Le, lt / tt)
                    }
                    for (let J = 0; J < be; J++)
                        for (let ge = 0; ge < 2 * (be - J) - 1; ge++) {
                            const Le = Math.floor(ge / 2);
                            ge % 2 === 0 ? (M(Me[J][Le + 1]),
                            M(Me[J + 1][Le]),
                            M(Me[J][Le])) : (M(Me[J][Le + 1]),
                            M(Me[J + 1][Le + 1]),
                            M(Me[J + 1][Le]))
                        }
                }
                function x(Z) {
                    const X = new me;
                    for (let K = 0; K < c.length; K += 3)
                        X.x = c[K + 0],
                        X.y = c[K + 1],
                        X.z = c[K + 2],
                        X.normalize().multiplyScalar(Z),
                        c[K + 0] = X.x,
                        c[K + 1] = X.y,
                        c[K + 2] = X.z
                }
                function w() {
                    const Z = new me;
                    for (let X = 0; X < c.length; X += 3) {
                        Z.x = c[X + 0],
                        Z.y = c[X + 1],
                        Z.z = c[X + 2];
                        const K = k(Z) / 2 / Math.PI + .5
                          , de = Q(Z) / Math.PI + .5;
                        d.push(K, 1 - de)
                    }
                    z(),
                    P()
                }
                function P() {
                    for (let Z = 0; Z < d.length; Z += 6) {
                        const X = d[Z + 0]
                          , K = d[Z + 2]
                          , de = d[Z + 4]
                          , be = Math.max(X, K, de)
                          , Me = Math.min(X, K, de);
                        be > .9 && Me < .1 && (X < .2 && (d[Z + 0] += 1),
                        K < .2 && (d[Z + 2] += 1),
                        de < .2 && (d[Z + 4] += 1))
                    }
                }
                function M(Z) {
                    c.push(Z.x, Z.y, Z.z)
                }
                function I(Z, X) {
                    const K = Z * 3;
                    X.x = e[K + 0],
                    X.y = e[K + 1],
                    X.z = e[K + 2]
                }
                function z() {
                    const Z = new me
                      , X = new me
                      , K = new me
                      , de = new me
                      , be = new _t
                      , Me = new _t
                      , J = new _t;
                    for (let ge = 0, Le = 0; ge < c.length; ge += 9,
                    Le += 6) {
                        Z.set(c[ge + 0], c[ge + 1], c[ge + 2]),
                        X.set(c[ge + 3], c[ge + 4], c[ge + 5]),
                        K.set(c[ge + 6], c[ge + 7], c[ge + 8]),
                        be.set(d[Le + 0], d[Le + 1]),
                        Me.set(d[Le + 2], d[Le + 3]),
                        J.set(d[Le + 4], d[Le + 5]),
                        de.copy(Z).add(X).add(K).divideScalar(3);
                        const tt = k(de);
                        O(be, Le + 0, Z, tt),
                        O(Me, Le + 2, X, tt),
                        O(J, Le + 4, K, tt)
                    }
                }
                function O(Z, X, K, de) {
                    de < 0 && Z.x === 1 && (d[X] = Z.x - 1),
                    K.x === 0 && K.z === 0 && (d[X] = de / 2 / Math.PI + .5)
                }
                function k(Z) {
                    return Math.atan2(Z.z, -Z.x)
                }
                function Q(Z) {
                    return Math.atan2(-Z.y, Math.sqrt(Z.x * Z.x + Z.z * Z.z))
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new bl(e.vertices,e.indices,e.radius,e.details)
            }
        }
        class ld extends bl {
            constructor(e=1, i=0) {
                const o = (1 + Math.sqrt(5)) / 2
                  , a = 1 / o
                  , c = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -a, -o, 0, -a, o, 0, a, -o, 0, a, o, -a, -o, 0, -a, o, 0, a, -o, 0, a, o, 0, -o, 0, -a, o, 0, -a, -o, 0, a, o, 0, a]
                  , d = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                super(c, d, e, i),
                this.type = "DodecahedronGeometry",
                this.parameters = {
                    radius: e,
                    detail: i
                }
            }
            static fromJSON(e) {
                return new ld(e.radius,e.detail)
            }
        }
        const Ep = new me
          , Mp = new me
          , E0 = new me
          , Cp = new qo;
        class Q1 extends Ai {
            constructor(e=null, i=1) {
                if (super(),
                this.type = "EdgesGeometry",
                this.parameters = {
                    geometry: e,
                    thresholdAngle: i
                },
                e !== null) {
                    const a = Math.pow(10, 4)
                      , c = Math.cos(wi * i)
                      , d = e.getIndex()
                      , f = e.getAttribute("position")
                      , v = d ? d.count : f.count
                      , x = [0, 0, 0]
                      , w = ["a", "b", "c"]
                      , P = new Array(3)
                      , M = {}
                      , I = [];
                    for (let z = 0; z < v; z += 3) {
                        d ? (x[0] = d.getX(z),
                        x[1] = d.getX(z + 1),
                        x[2] = d.getX(z + 2)) : (x[0] = z,
                        x[1] = z + 1,
                        x[2] = z + 2);
                        const {a: O, b: k, c: Q} = Cp;
                        if (O.fromBufferAttribute(f, x[0]),
                        k.fromBufferAttribute(f, x[1]),
                        Q.fromBufferAttribute(f, x[2]),
                        Cp.getNormal(E0),
                        P[0] = `${Math.round(O.x * a)},${Math.round(O.y * a)},${Math.round(O.z * a)}`,
                        P[1] = `${Math.round(k.x * a)},${Math.round(k.y * a)},${Math.round(k.z * a)}`,
                        P[2] = `${Math.round(Q.x * a)},${Math.round(Q.y * a)},${Math.round(Q.z * a)}`,
                        !(P[0] === P[1] || P[1] === P[2] || P[2] === P[0]))
                            for (let Z = 0; Z < 3; Z++) {
                                const X = (Z + 1) % 3
                                  , K = P[Z]
                                  , de = P[X]
                                  , be = Cp[w[Z]]
                                  , Me = Cp[w[X]]
                                  , J = `${K}_${de}`
                                  , ge = `${de}_${K}`;
                                ge in M && M[ge] ? (E0.dot(M[ge].normal) <= c && (I.push(be.x, be.y, be.z),
                                I.push(Me.x, Me.y, Me.z)),
                                M[ge] = null) : J in M || (M[J] = {
                                    index0: x[Z],
                                    index1: x[X],
                                    normal: E0.clone()
                                })
                            }
                    }
                    for (const z in M)
                        if (M[z]) {
                            const {index0: O, index1: k} = M[z];
                            Ep.fromBufferAttribute(f, O),
                            Mp.fromBufferAttribute(f, k),
                            I.push(Ep.x, Ep.y, Ep.z),
                            I.push(Mp.x, Mp.y, Mp.z)
                        }
                    this.setAttribute("position", new Rn(I,3))
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
        }
        class Wc extends rd {
            constructor(e) {
                super(e),
                this.uuid = yr(),
                this.type = "Shape",
                this.holes = []
            }
            getPointsHoles(e) {
                const i = [];
                for (let o = 0, a = this.holes.length; o < a; o++)
                    i[o] = this.holes[o].getPoints(e);
                return i
            }
            extractPoints(e) {
                return {
                    shape: this.getPoints(e),
                    holes: this.getPointsHoles(e)
                }
            }
            copy(e) {
                super.copy(e),
                this.holes = [];
                for (let i = 0, o = e.holes.length; i < o; i++) {
                    const a = e.holes[i];
                    this.holes.push(a.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.uuid = this.uuid,
                e.holes = [];
                for (let i = 0, o = this.holes.length; i < o; i++) {
                    const a = this.holes[i];
                    e.holes.push(a.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e),
                this.uuid = e.uuid,
                this.holes = [];
                for (let i = 0, o = e.holes.length; i < o; i++) {
                    const a = e.holes[i];
                    this.holes.push(new rd().fromJSON(a))
                }
                return this
            }
        }
        const gR = {
            triangulate: function(u, e, i=2) {
                const o = e && e.length
                  , a = o ? e[0] * i : u.length;
                let c = K1(u, 0, a, i, !0);
                const d = [];
                if (!c || c.next === c.prev)
                    return d;
                let f, v, x, w, P, M, I;
                if (o && (c = bR(u, e, c, i)),
                u.length > 80 * i) {
                    f = x = u[0],
                    v = w = u[1];
                    for (let z = i; z < a; z += i)
                        P = u[z],
                        M = u[z + 1],
                        P < f && (f = P),
                        M < v && (v = M),
                        P > x && (x = P),
                        M > w && (w = M);
                    I = Math.max(x - f, w - v),
                    I = I !== 0 ? 32767 / I : 0
                }
                return cd(c, d, i, f, v, I, 0),
                d
            }
        };
        function K1(u, e, i, o, a) {
            let c, d;
            if (a === LR(u, e, i, o) > 0)
                for (c = e; c < i; c += o)
                    d = J1(c, u[c], u[c + 1], d);
            else
                for (c = i - o; c >= e; c -= o)
                    d = J1(c, u[c], u[c + 1], d);
            return d && Pp(d, d.next) && (hd(d),
            d = d.next),
            d
        }
        function jc(u, e) {
            if (!u)
                return u;
            e || (e = u);
            let i = u, o;
            do
                if (o = !1,
                !i.steiner && (Pp(i, i.next) || Pr(i.prev, i, i.next) === 0)) {
                    if (hd(i),
                    i = e = i.prev,
                    i === i.next)
                        break;
                    o = !0
                } else
                    i = i.next;
            while (o || i !== e);
            return e
        }
        function cd(u, e, i, o, a, c, d) {
            if (!u)
                return;
            !d && c && ER(u, o, a, c);
            let f = u, v, x;
            for (; u.prev !== u.next; ) {
                if (v = u.prev,
                x = u.next,
                c ? _R(u, o, a, c) : vR(u)) {
                    e.push(v.i / i | 0),
                    e.push(u.i / i | 0),
                    e.push(x.i / i | 0),
                    hd(u),
                    u = x.next,
                    f = x.next;
                    continue
                }
                if (u = x,
                u === f) {
                    d ? d === 1 ? (u = yR(jc(u), e, i),
                    cd(u, e, i, o, a, c, 2)) : d === 2 && xR(u, e, i, o, a, c) : cd(jc(u), e, i, o, a, c, 1);
                    break
                }
            }
        }
        function vR(u) {
            const e = u.prev
              , i = u
              , o = u.next;
            if (Pr(e, i, o) >= 0)
                return !1;
            const a = e.x
              , c = i.x
              , d = o.x
              , f = e.y
              , v = i.y
              , x = o.y
              , w = a < c ? a < d ? a : d : c < d ? c : d
              , P = f < v ? f < x ? f : x : v < x ? v : x
              , M = a > c ? a > d ? a : d : c > d ? c : d
              , I = f > v ? f > x ? f : x : v > x ? v : x;
            let z = o.next;
            for (; z !== e; ) {
                if (z.x >= w && z.x <= M && z.y >= P && z.y <= I && Yu(a, f, c, v, d, x, z.x, z.y) && Pr(z.prev, z, z.next) >= 0)
                    return !1;
                z = z.next
            }
            return !0
        }
        function _R(u, e, i, o) {
            const a = u.prev
              , c = u
              , d = u.next;
            if (Pr(a, c, d) >= 0)
                return !1;
            const f = a.x
              , v = c.x
              , x = d.x
              , w = a.y
              , P = c.y
              , M = d.y
              , I = f < v ? f < x ? f : x : v < x ? v : x
              , z = w < P ? w < M ? w : M : P < M ? P : M
              , O = f > v ? f > x ? f : x : v > x ? v : x
              , k = w > P ? w > M ? w : M : P > M ? P : M
              , Q = M0(I, z, e, i, o)
              , Z = M0(O, k, e, i, o);
            let X = u.prevZ
              , K = u.nextZ;
            for (; X && X.z >= Q && K && K.z <= Z; ) {
                if (X.x >= I && X.x <= O && X.y >= z && X.y <= k && X !== a && X !== d && Yu(f, w, v, P, x, M, X.x, X.y) && Pr(X.prev, X, X.next) >= 0 || (X = X.prevZ,
                K.x >= I && K.x <= O && K.y >= z && K.y <= k && K !== a && K !== d && Yu(f, w, v, P, x, M, K.x, K.y) && Pr(K.prev, K, K.next) >= 0))
                    return !1;
                K = K.nextZ
            }
            for (; X && X.z >= Q; ) {
                if (X.x >= I && X.x <= O && X.y >= z && X.y <= k && X !== a && X !== d && Yu(f, w, v, P, x, M, X.x, X.y) && Pr(X.prev, X, X.next) >= 0)
                    return !1;
                X = X.prevZ
            }
            for (; K && K.z <= Z; ) {
                if (K.x >= I && K.x <= O && K.y >= z && K.y <= k && K !== a && K !== d && Yu(f, w, v, P, x, M, K.x, K.y) && Pr(K.prev, K, K.next) >= 0)
                    return !1;
                K = K.nextZ
            }
            return !0
        }
        function yR(u, e, i) {
            let o = u;
            do {
                const a = o.prev
                  , c = o.next.next;
                !Pp(a, c) && Z1(a, o, o.next, c) && ud(a, c) && ud(c, a) && (e.push(a.i / i | 0),
                e.push(o.i / i | 0),
                e.push(c.i / i | 0),
                hd(o),
                hd(o.next),
                o = u = c),
                o = o.next
            } while (o !== u);
            return jc(o)
        }
        function xR(u, e, i, o, a, c) {
            let d = u;
            do {
                let f = d.next.next;
                for (; f !== d.prev; ) {
                    if (d.i !== f.i && PR(d, f)) {
                        let v = q1(d, f);
                        d = jc(d, d.next),
                        v = jc(v, v.next),
                        cd(d, e, i, o, a, c, 0),
                        cd(v, e, i, o, a, c, 0);
                        return
                    }
                    f = f.next
                }
                d = d.next
            } while (d !== u)
        }
        function bR(u, e, i, o) {
            const a = [];
            let c, d, f, v, x;
            for (c = 0,
            d = e.length; c < d; c++)
                f = e[c] * o,
                v = c < d - 1 ? e[c + 1] * o : u.length,
                x = K1(u, f, v, o, !1),
                x === x.next && (x.steiner = !0),
                a.push(CR(x));
            for (a.sort(wR),
            c = 0; c < a.length; c++)
                i = AR(a[c], i);
            return i
        }
        function wR(u, e) {
            return u.x - e.x
        }
        function AR(u, e) {
            const i = SR(u, e);
            if (!i)
                return e;
            const o = q1(i, u);
            return jc(o, o.next),
            jc(i, i.next)
        }
        function SR(u, e) {
            let i = e, o = -1 / 0, a;
            const c = u.x
              , d = u.y;
            do {
                if (d <= i.y && d >= i.next.y && i.next.y !== i.y) {
                    const M = i.x + (d - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                    if (M <= c && M > o && (o = M,
                    a = i.x < i.next.x ? i : i.next,
                    M === c))
                        return a
                }
                i = i.next
            } while (i !== e);
            if (!a)
                return null;
            const f = a
              , v = a.x
              , x = a.y;
            let w = 1 / 0, P;
            i = a;
            do
                c >= i.x && i.x >= v && c !== i.x && Yu(d < x ? c : o, d, v, x, d < x ? o : c, d, i.x, i.y) && (P = Math.abs(d - i.y) / (c - i.x),
                ud(i, u) && (P < w || P === w && (i.x > a.x || i.x === a.x && TR(a, i))) && (a = i,
                w = P)),
                i = i.next;
            while (i !== f);
            return a
        }
        function TR(u, e) {
            return Pr(u.prev, u, e.prev) < 0 && Pr(e.next, u, u.next) < 0
        }
        function ER(u, e, i, o) {
            let a = u;
            do
                a.z === 0 && (a.z = M0(a.x, a.y, e, i, o)),
                a.prevZ = a.prev,
                a.nextZ = a.next,
                a = a.next;
            while (a !== u);
            a.prevZ.nextZ = null,
            a.prevZ = null,
            MR(a)
        }
        function MR(u) {
            let e, i, o, a, c, d, f, v, x = 1;
            do {
                for (i = u,
                u = null,
                c = null,
                d = 0; i; ) {
                    for (d++,
                    o = i,
                    f = 0,
                    e = 0; e < x && (f++,
                    o = o.nextZ,
                    !!o); e++)
                        ;
                    for (v = x; f > 0 || v > 0 && o; )
                        f !== 0 && (v === 0 || !o || i.z <= o.z) ? (a = i,
                        i = i.nextZ,
                        f--) : (a = o,
                        o = o.nextZ,
                        v--),
                        c ? c.nextZ = a : u = a,
                        a.prevZ = c,
                        c = a;
                    i = o
                }
                c.nextZ = null,
                x *= 2
            } while (d > 1);
            return u
        }
        function M0(u, e, i, o, a) {
            return u = (u - i) * a | 0,
            e = (e - o) * a | 0,
            u = (u | u << 8) & 16711935,
            u = (u | u << 4) & 252645135,
            u = (u | u << 2) & 858993459,
            u = (u | u << 1) & 1431655765,
            e = (e | e << 8) & 16711935,
            e = (e | e << 4) & 252645135,
            e = (e | e << 2) & 858993459,
            e = (e | e << 1) & 1431655765,
            u | e << 1
        }
        function CR(u) {
            let e = u
              , i = u;
            do
                (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e),
                e = e.next;
            while (e !== u);
            return i
        }
        function Yu(u, e, i, o, a, c, d, f) {
            return (a - d) * (e - f) >= (u - d) * (c - f) && (u - d) * (o - f) >= (i - d) * (e - f) && (i - d) * (c - f) >= (a - d) * (o - f)
        }
        function PR(u, e) {
            return u.next.i !== e.i && u.prev.i !== e.i && !RR(u, e) && (ud(u, e) && ud(e, u) && DR(u, e) && (Pr(u.prev, u, e.prev) || Pr(u, e.prev, e)) || Pp(u, e) && Pr(u.prev, u, u.next) > 0 && Pr(e.prev, e, e.next) > 0)
        }
        function Pr(u, e, i) {
            return (e.y - u.y) * (i.x - e.x) - (e.x - u.x) * (i.y - e.y)
        }
        function Pp(u, e) {
            return u.x === e.x && u.y === e.y
        }
        function Z1(u, e, i, o) {
            const a = Dp(Pr(u, e, i))
              , c = Dp(Pr(u, e, o))
              , d = Dp(Pr(i, o, u))
              , f = Dp(Pr(i, o, e));
            return !!(a !== c && d !== f || a === 0 && Rp(u, i, e) || c === 0 && Rp(u, o, e) || d === 0 && Rp(i, u, o) || f === 0 && Rp(i, e, o))
        }
        function Rp(u, e, i) {
            return e.x <= Math.max(u.x, i.x) && e.x >= Math.min(u.x, i.x) && e.y <= Math.max(u.y, i.y) && e.y >= Math.min(u.y, i.y)
        }
        function Dp(u) {
            return u > 0 ? 1 : u < 0 ? -1 : 0
        }
        function RR(u, e) {
            let i = u;
            do {
                if (i.i !== u.i && i.next.i !== u.i && i.i !== e.i && i.next.i !== e.i && Z1(i, i.next, u, e))
                    return !0;
                i = i.next
            } while (i !== u);
            return !1
        }
        function ud(u, e) {
            return Pr(u.prev, u, u.next) < 0 ? Pr(u, e, u.next) >= 0 && Pr(u, u.prev, e) >= 0 : Pr(u, e, u.prev) < 0 || Pr(u, u.next, e) < 0
        }
        function DR(u, e) {
            let i = u
              , o = !1;
            const a = (u.x + e.x) / 2
              , c = (u.y + e.y) / 2;
            do
                i.y > c != i.next.y > c && i.next.y !== i.y && a < (i.next.x - i.x) * (c - i.y) / (i.next.y - i.y) + i.x && (o = !o),
                i = i.next;
            while (i !== u);
            return o
        }
        function q1(u, e) {
            const i = new C0(u.i,u.x,u.y)
              , o = new C0(e.i,e.x,e.y)
              , a = u.next
              , c = e.prev;
            return u.next = e,
            e.prev = u,
            i.next = a,
            a.prev = i,
            o.next = i,
            i.prev = o,
            c.next = o,
            o.prev = c,
            o
        }
        function J1(u, e, i, o) {
            const a = new C0(u,e,i);
            return o ? (a.next = o.next,
            a.prev = o,
            o.next.prev = a,
            o.next = a) : (a.prev = a,
            a.next = a),
            a
        }
        function hd(u) {
            u.next.prev = u.prev,
            u.prev.next = u.next,
            u.prevZ && (u.prevZ.nextZ = u.nextZ),
            u.nextZ && (u.nextZ.prevZ = u.prevZ)
        }
        function C0(u, e, i) {
            this.i = u,
            this.x = e,
            this.y = i,
            this.prev = null,
            this.next = null,
            this.z = 0,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        function LR(u, e, i, o) {
            let a = 0;
            for (let c = e, d = i - o; c < i; c += o)
                a += (u[d] - u[c]) * (u[c + 1] + u[d + 1]),
                d = c;
            return a
        }
        class Ya {
            static area(e) {
                const i = e.length;
                let o = 0;
                for (let a = i - 1, c = 0; c < i; a = c++)
                    o += e[a].x * e[c].y - e[c].x * e[a].y;
                return o * .5
            }
            static isClockWise(e) {
                return Ya.area(e) < 0
            }
            static triangulateShape(e, i) {
                const o = []
                  , a = []
                  , c = [];
                $1(e),
                eb(o, e);
                let d = e.length;
                i.forEach($1);
                for (let v = 0; v < i.length; v++)
                    a.push(d),
                    d += i[v].length,
                    eb(o, i[v]);
                const f = gR.triangulate(o, a);
                for (let v = 0; v < f.length; v += 3)
                    c.push(f.slice(v, v + 3));
                return c
            }
        }
        function $1(u) {
            const e = u.length;
            e > 2 && u[e - 1].equals(u[0]) && u.pop()
        }
        function eb(u, e) {
            for (let i = 0; i < e.length; i++)
                u.push(e[i].x),
                u.push(e[i].y)
        }
        class dd extends Ai {
            constructor(e=new Wc([new _t(.5,.5), new _t(-.5,.5), new _t(-.5,-.5), new _t(.5,-.5)]), i={}) {
                super(),
                this.type = "ExtrudeGeometry",
                this.parameters = {
                    shapes: e,
                    options: i
                },
                e = Array.isArray(e) ? e : [e];
                const o = this
                  , a = []
                  , c = [];
                for (let f = 0, v = e.length; f < v; f++) {
                    const x = e[f];
                    d(x)
                }
                this.setAttribute("position", new Rn(a,3)),
                this.setAttribute("uv", new Rn(c,2)),
                this.computeVertexNormals();
                function d(f) {
                    const v = []
                      , x = i.curveSegments !== void 0 ? i.curveSegments : 12
                      , w = i.steps !== void 0 ? i.steps : 1
                      , P = i.depth !== void 0 ? i.depth : 1;
                    let M = i.bevelEnabled !== void 0 ? i.bevelEnabled : !0
                      , I = i.bevelThickness !== void 0 ? i.bevelThickness : .2
                      , z = i.bevelSize !== void 0 ? i.bevelSize : I - .1
                      , O = i.bevelOffset !== void 0 ? i.bevelOffset : 0
                      , k = i.bevelSegments !== void 0 ? i.bevelSegments : 3;
                    const Q = i.extrudePath
                      , Z = i.UVGenerator !== void 0 ? i.UVGenerator : IR;
                    let X, K = !1, de, be, Me, J;
                    Q && (X = Q.getSpacedPoints(w),
                    K = !0,
                    M = !1,
                    de = Q.computeFrenetFrames(w, !1),
                    be = new me,
                    Me = new me,
                    J = new me),
                    M || (k = 0,
                    I = 0,
                    z = 0,
                    O = 0);
                    const ge = f.extractPoints(x);
                    let Le = ge.shape;
                    const tt = ge.holes;
                    if (!Ya.isClockWise(Le)) {
                        Le = Le.reverse();
                        for (let dt = 0, Tt = tt.length; dt < Tt; dt++) {
                            const Kt = tt[dt];
                            Ya.isClockWise(Kt) && (tt[dt] = Kt.reverse())
                        }
                    }
                    const je = Ya.triangulateShape(Le, tt)
                      , ze = Le;
                    for (let dt = 0, Tt = tt.length; dt < Tt; dt++) {
                        const Kt = tt[dt];
                        Le = Le.concat(Kt)
                    }
                    function st(dt, Tt, Kt) {
                        return Tt || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                        dt.clone().addScaledVector(Tt, Kt)
                    }
                    const yt = Le.length
                      , It = je.length;
                    function ht(dt, Tt, Kt) {
                        let zn, sn, ri;
                        const jn = dt.x - Tt.x
                          , si = dt.y - Tt.y
                          , mr = Kt.x - dt.x
                          , rr = Kt.y - dt.y
                          , we = jn * jn + si * si
                          , he = jn * rr - si * mr;
                        if (Math.abs(he) > Number.EPSILON) {
                            const it = Math.sqrt(we)
                              , Ht = Math.sqrt(mr * mr + rr * rr)
                              , Wt = Tt.x - si / it
                              , an = Tt.y + jn / it
                              , Vn = Kt.x - rr / Ht
                              , xn = Kt.y + mr / Ht
                              , ft = ((Vn - Wt) * rr - (xn - an) * mr) / (jn * rr - si * mr);
                            zn = Wt + jn * ft - dt.x,
                            sn = an + si * ft - dt.y;
                            const Qn = zn * zn + sn * sn;
                            if (Qn <= 2)
                                return new _t(zn,sn);
                            ri = Math.sqrt(Qn / 2)
                        } else {
                            let it = !1;
                            jn > Number.EPSILON ? mr > Number.EPSILON && (it = !0) : jn < -Number.EPSILON ? mr < -Number.EPSILON && (it = !0) : Math.sign(si) === Math.sign(rr) && (it = !0),
                            it ? (zn = -si,
                            sn = jn,
                            ri = Math.sqrt(we)) : (zn = jn,
                            sn = si,
                            ri = Math.sqrt(we / 2))
                        }
                        return new _t(zn / ri,sn / ri)
                    }
                    const Ot = [];
                    for (let dt = 0, Tt = ze.length, Kt = Tt - 1, zn = dt + 1; dt < Tt; dt++,
                    Kt++,
                    zn++)
                        Kt === Tt && (Kt = 0),
                        zn === Tt && (zn = 0),
                        Ot[dt] = ht(ze[dt], ze[Kt], ze[zn]);
                    const Mt = [];
                    let Ln, Ye = Ot.concat();
                    for (let dt = 0, Tt = tt.length; dt < Tt; dt++) {
                        const Kt = tt[dt];
                        Ln = [];
                        for (let zn = 0, sn = Kt.length, ri = sn - 1, jn = zn + 1; zn < sn; zn++,
                        ri++,
                        jn++)
                            ri === sn && (ri = 0),
                            jn === sn && (jn = 0),
                            Ln[zn] = ht(Kt[zn], Kt[ri], Kt[jn]);
                        Mt.push(Ln),
                        Ye = Ye.concat(Ln)
                    }
                    for (let dt = 0; dt < k; dt++) {
                        const Tt = dt / k
                          , Kt = I * Math.cos(Tt * Math.PI / 2)
                          , zn = z * Math.sin(Tt * Math.PI / 2) + O;
                        for (let sn = 0, ri = ze.length; sn < ri; sn++) {
                            const jn = st(ze[sn], Ot[sn], zn);
                            on(jn.x, jn.y, -Kt)
                        }
                        for (let sn = 0, ri = tt.length; sn < ri; sn++) {
                            const jn = tt[sn];
                            Ln = Mt[sn];
                            for (let si = 0, mr = jn.length; si < mr; si++) {
                                const rr = st(jn[si], Ln[si], zn);
                                on(rr.x, rr.y, -Kt)
                            }
                        }
                    }
                    const Pt = z + O;
                    for (let dt = 0; dt < yt; dt++) {
                        const Tt = M ? st(Le[dt], Ye[dt], Pt) : Le[dt];
                        K ? (Me.copy(de.normals[0]).multiplyScalar(Tt.x),
                        be.copy(de.binormals[0]).multiplyScalar(Tt.y),
                        J.copy(X[0]).add(Me).add(be),
                        on(J.x, J.y, J.z)) : on(Tt.x, Tt.y, 0)
                    }
                    for (let dt = 1; dt <= w; dt++)
                        for (let Tt = 0; Tt < yt; Tt++) {
                            const Kt = M ? st(Le[Tt], Ye[Tt], Pt) : Le[Tt];
                            K ? (Me.copy(de.normals[dt]).multiplyScalar(Kt.x),
                            be.copy(de.binormals[dt]).multiplyScalar(Kt.y),
                            J.copy(X[dt]).add(Me).add(be),
                            on(J.x, J.y, J.z)) : on(Kt.x, Kt.y, P / w * dt)
                        }
                    for (let dt = k - 1; dt >= 0; dt--) {
                        const Tt = dt / k
                          , Kt = I * Math.cos(Tt * Math.PI / 2)
                          , zn = z * Math.sin(Tt * Math.PI / 2) + O;
                        for (let sn = 0, ri = ze.length; sn < ri; sn++) {
                            const jn = st(ze[sn], Ot[sn], zn);
                            on(jn.x, jn.y, P + Kt)
                        }
                        for (let sn = 0, ri = tt.length; sn < ri; sn++) {
                            const jn = tt[sn];
                            Ln = Mt[sn];
                            for (let si = 0, mr = jn.length; si < mr; si++) {
                                const rr = st(jn[si], Ln[si], zn);
                                K ? on(rr.x, rr.y + X[w - 1].y, X[w - 1].x + Kt) : on(rr.x, rr.y, P + Kt)
                            }
                        }
                    }
                    tn(),
                    De();
                    function tn() {
                        const dt = a.length / 3;
                        if (M) {
                            let Tt = 0
                              , Kt = yt * Tt;
                            for (let zn = 0; zn < It; zn++) {
                                const sn = je[zn];
                                Mn(sn[2] + Kt, sn[1] + Kt, sn[0] + Kt)
                            }
                            Tt = w + k * 2,
                            Kt = yt * Tt;
                            for (let zn = 0; zn < It; zn++) {
                                const sn = je[zn];
                                Mn(sn[0] + Kt, sn[1] + Kt, sn[2] + Kt)
                            }
                        } else {
                            for (let Tt = 0; Tt < It; Tt++) {
                                const Kt = je[Tt];
                                Mn(Kt[2], Kt[1], Kt[0])
                            }
                            for (let Tt = 0; Tt < It; Tt++) {
                                const Kt = je[Tt];
                                Mn(Kt[0] + yt * w, Kt[1] + yt * w, Kt[2] + yt * w)
                            }
                        }
                        o.addGroup(dt, a.length / 3 - dt, 0)
                    }
                    function De() {
                        const dt = a.length / 3;
                        let Tt = 0;
                        Cn(ze, Tt),
                        Tt += ze.length;
                        for (let Kt = 0, zn = tt.length; Kt < zn; Kt++) {
                            const sn = tt[Kt];
                            Cn(sn, Tt),
                            Tt += sn.length
                        }
                        o.addGroup(dt, a.length / 3 - dt, 1)
                    }
                    function Cn(dt, Tt) {
                        let Kt = dt.length;
                        for (; --Kt >= 0; ) {
                            const zn = Kt;
                            let sn = Kt - 1;
                            sn < 0 && (sn = dt.length - 1);
                            for (let ri = 0, jn = w + k * 2; ri < jn; ri++) {
                                const si = yt * ri
                                  , mr = yt * (ri + 1)
                                  , rr = Tt + zn + si
                                  , we = Tt + sn + si
                                  , he = Tt + sn + mr
                                  , it = Tt + zn + mr;
                                In(rr, we, he, it)
                            }
                        }
                    }
                    function on(dt, Tt, Kt) {
                        v.push(dt),
                        v.push(Tt),
                        v.push(Kt)
                    }
                    function Mn(dt, Tt, Kt) {
                        Un(dt),
                        Un(Tt),
                        Un(Kt);
                        const zn = a.length / 3
                          , sn = Z.generateTopUV(o, a, zn - 3, zn - 2, zn - 1);
                        ei(sn[0]),
                        ei(sn[1]),
                        ei(sn[2])
                    }
                    function In(dt, Tt, Kt, zn) {
                        Un(dt),
                        Un(Tt),
                        Un(zn),
                        Un(Tt),
                        Un(Kt),
                        Un(zn);
                        const sn = a.length / 3
                          , ri = Z.generateSideWallUV(o, a, sn - 6, sn - 3, sn - 2, sn - 1);
                        ei(ri[0]),
                        ei(ri[1]),
                        ei(ri[3]),
                        ei(ri[1]),
                        ei(ri[2]),
                        ei(ri[3])
                    }
                    function Un(dt) {
                        a.push(v[dt * 3 + 0]),
                        a.push(v[dt * 3 + 1]),
                        a.push(v[dt * 3 + 2])
                    }
                    function ei(dt) {
                        c.push(dt.x),
                        c.push(dt.y)
                    }
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            toJSON() {
                const e = super.toJSON()
                  , i = this.parameters.shapes
                  , o = this.parameters.options;
                return OR(i, o, e)
            }
            static fromJSON(e, i) {
                const o = [];
                for (let c = 0, d = e.shapes.length; c < d; c++) {
                    const f = i[e.shapes[c]];
                    o.push(f)
                }
                const a = e.options.extrudePath;
                return a !== void 0 && (e.options.extrudePath = new s[a.type]().fromJSON(a)),
                new dd(o,e.options)
            }
        }
        const IR = {
            generateTopUV: function(u, e, i, o, a) {
                const c = e[i * 3]
                  , d = e[i * 3 + 1]
                  , f = e[o * 3]
                  , v = e[o * 3 + 1]
                  , x = e[a * 3]
                  , w = e[a * 3 + 1];
                return [new _t(c,d), new _t(f,v), new _t(x,w)]
            },
            generateSideWallUV: function(u, e, i, o, a, c) {
                const d = e[i * 3]
                  , f = e[i * 3 + 1]
                  , v = e[i * 3 + 2]
                  , x = e[o * 3]
                  , w = e[o * 3 + 1]
                  , P = e[o * 3 + 2]
                  , M = e[a * 3]
                  , I = e[a * 3 + 1]
                  , z = e[a * 3 + 2]
                  , O = e[c * 3]
                  , k = e[c * 3 + 1]
                  , Q = e[c * 3 + 2];
                return Math.abs(f - w) < Math.abs(d - x) ? [new _t(d,1 - v), new _t(x,1 - P), new _t(M,1 - z), new _t(O,1 - Q)] : [new _t(f,1 - v), new _t(w,1 - P), new _t(I,1 - z), new _t(k,1 - Q)]
            }
        };
        function OR(u, e, i) {
            if (i.shapes = [],
            Array.isArray(u))
                for (let o = 0, a = u.length; o < a; o++) {
                    const c = u[o];
                    i.shapes.push(c.uuid)
                }
            else
                i.shapes.push(u.uuid);
            return i.options = Object.assign({}, e),
            e.extrudePath !== void 0 && (i.options.extrudePath = e.extrudePath.toJSON()),
            i
        }
        class fd extends bl {
            constructor(e=1, i=0) {
                const o = (1 + Math.sqrt(5)) / 2
                  , a = [-1, o, 0, 1, o, 0, -1, -o, 0, 1, -o, 0, 0, -1, o, 0, 1, o, 0, -1, -o, 0, 1, -o, o, 0, -1, o, 0, 1, -o, 0, -1, -o, 0, 1]
                  , c = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                super(a, c, e, i),
                this.type = "IcosahedronGeometry",
                this.parameters = {
                    radius: e,
                    detail: i
                }
            }
            static fromJSON(e) {
                return new fd(e.radius,e.detail)
            }
        }
        class Qu extends bl {
            constructor(e=1, i=0) {
                const o = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
                  , a = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                super(o, a, e, i),
                this.type = "OctahedronGeometry",
                this.parameters = {
                    radius: e,
                    detail: i
                }
            }
            static fromJSON(e) {
                return new Qu(e.radius,e.detail)
            }
        }
        class pd extends Ai {
            constructor(e=.5, i=1, o=32, a=1, c=0, d=Math.PI * 2) {
                super(),
                this.type = "RingGeometry",
                this.parameters = {
                    innerRadius: e,
                    outerRadius: i,
                    thetaSegments: o,
                    phiSegments: a,
                    thetaStart: c,
                    thetaLength: d
                },
                o = Math.max(3, o),
                a = Math.max(1, a);
                const f = []
                  , v = []
                  , x = []
                  , w = [];
                let P = e;
                const M = (i - e) / a
                  , I = new me
                  , z = new _t;
                for (let O = 0; O <= a; O++) {
                    for (let k = 0; k <= o; k++) {
                        const Q = c + k / o * d;
                        I.x = P * Math.cos(Q),
                        I.y = P * Math.sin(Q),
                        v.push(I.x, I.y, I.z),
                        x.push(0, 0, 1),
                        z.x = (I.x / i + 1) / 2,
                        z.y = (I.y / i + 1) / 2,
                        w.push(z.x, z.y)
                    }
                    P += M
                }
                for (let O = 0; O < a; O++) {
                    const k = O * (o + 1);
                    for (let Q = 0; Q < o; Q++) {
                        const Z = Q + k
                          , X = Z
                          , K = Z + o + 1
                          , de = Z + o + 2
                          , be = Z + 1;
                        f.push(X, K, be),
                        f.push(K, de, be)
                    }
                }
                this.setIndex(f),
                this.setAttribute("position", new Rn(v,3)),
                this.setAttribute("normal", new Rn(x,3)),
                this.setAttribute("uv", new Rn(w,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new pd(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
            }
        }
        class md extends Ai {
            constructor(e=new Wc([new _t(0,.5), new _t(-.5,-.5), new _t(.5,-.5)]), i=12) {
                super(),
                this.type = "ShapeGeometry",
                this.parameters = {
                    shapes: e,
                    curveSegments: i
                };
                const o = []
                  , a = []
                  , c = []
                  , d = [];
                let f = 0
                  , v = 0;
                if (Array.isArray(e) === !1)
                    x(e);
                else
                    for (let w = 0; w < e.length; w++)
                        x(e[w]),
                        this.addGroup(f, v, w),
                        f += v,
                        v = 0;
                this.setIndex(o),
                this.setAttribute("position", new Rn(a,3)),
                this.setAttribute("normal", new Rn(c,3)),
                this.setAttribute("uv", new Rn(d,2));
                function x(w) {
                    const P = a.length / 3
                      , M = w.extractPoints(i);
                    let I = M.shape;
                    const z = M.holes;
                    Ya.isClockWise(I) === !1 && (I = I.reverse());
                    for (let k = 0, Q = z.length; k < Q; k++) {
                        const Z = z[k];
                        Ya.isClockWise(Z) === !0 && (z[k] = Z.reverse())
                    }
                    const O = Ya.triangulateShape(I, z);
                    for (let k = 0, Q = z.length; k < Q; k++) {
                        const Z = z[k];
                        I = I.concat(Z)
                    }
                    for (let k = 0, Q = I.length; k < Q; k++) {
                        const Z = I[k];
                        a.push(Z.x, Z.y, 0),
                        c.push(0, 0, 1),
                        d.push(Z.x, Z.y)
                    }
                    for (let k = 0, Q = O.length; k < Q; k++) {
                        const Z = O[k]
                          , X = Z[0] + P
                          , K = Z[1] + P
                          , de = Z[2] + P;
                        o.push(X, K, de),
                        v += 3
                    }
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            toJSON() {
                const e = super.toJSON()
                  , i = this.parameters.shapes;
                return BR(i, e)
            }
            static fromJSON(e, i) {
                const o = [];
                for (let a = 0, c = e.shapes.length; a < c; a++) {
                    const d = i[e.shapes[a]];
                    o.push(d)
                }
                return new md(o,e.curveSegments)
            }
        }
        function BR(u, e) {
            if (e.shapes = [],
            Array.isArray(u))
                for (let i = 0, o = u.length; i < o; i++) {
                    const a = u[i];
                    e.shapes.push(a.uuid)
                }
            else
                e.shapes.push(u.uuid);
            return e
        }
        class Ku extends Ai {
            constructor(e=1, i=32, o=16, a=0, c=Math.PI * 2, d=0, f=Math.PI) {
                super(),
                this.type = "SphereGeometry",
                this.parameters = {
                    radius: e,
                    widthSegments: i,
                    heightSegments: o,
                    phiStart: a,
                    phiLength: c,
                    thetaStart: d,
                    thetaLength: f
                },
                i = Math.max(3, Math.floor(i)),
                o = Math.max(2, Math.floor(o));
                const v = Math.min(d + f, Math.PI);
                let x = 0;
                const w = []
                  , P = new me
                  , M = new me
                  , I = []
                  , z = []
                  , O = []
                  , k = [];
                for (let Q = 0; Q <= o; Q++) {
                    const Z = []
                      , X = Q / o;
                    let K = 0;
                    Q == 0 && d == 0 ? K = .5 / i : Q == o && v == Math.PI && (K = -.5 / i);
                    for (let de = 0; de <= i; de++) {
                        const be = de / i;
                        P.x = -e * Math.cos(a + be * c) * Math.sin(d + X * f),
                        P.y = e * Math.cos(d + X * f),
                        P.z = e * Math.sin(a + be * c) * Math.sin(d + X * f),
                        z.push(P.x, P.y, P.z),
                        M.copy(P).normalize(),
                        O.push(M.x, M.y, M.z),
                        k.push(be + K, 1 - X),
                        Z.push(x++)
                    }
                    w.push(Z)
                }
                for (let Q = 0; Q < o; Q++)
                    for (let Z = 0; Z < i; Z++) {
                        const X = w[Q][Z + 1]
                          , K = w[Q][Z]
                          , de = w[Q + 1][Z]
                          , be = w[Q + 1][Z + 1];
                        (Q !== 0 || d > 0) && I.push(X, K, be),
                        (Q !== o - 1 || v < Math.PI) && I.push(K, de, be)
                    }
                this.setIndex(I),
                this.setAttribute("position", new Rn(z,3)),
                this.setAttribute("normal", new Rn(O,3)),
                this.setAttribute("uv", new Rn(k,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Ku(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
            }
        }
        class gd extends bl {
            constructor(e=1, i=0) {
                const o = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
                  , a = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                super(o, a, e, i),
                this.type = "TetrahedronGeometry",
                this.parameters = {
                    radius: e,
                    detail: i
                }
            }
            static fromJSON(e) {
                return new gd(e.radius,e.detail)
            }
        }
        class vd extends Ai {
            constructor(e=1, i=.4, o=12, a=48, c=Math.PI * 2) {
                super(),
                this.type = "TorusGeometry",
                this.parameters = {
                    radius: e,
                    tube: i,
                    radialSegments: o,
                    tubularSegments: a,
                    arc: c
                },
                o = Math.floor(o),
                a = Math.floor(a);
                const d = []
                  , f = []
                  , v = []
                  , x = []
                  , w = new me
                  , P = new me
                  , M = new me;
                for (let I = 0; I <= o; I++)
                    for (let z = 0; z <= a; z++) {
                        const O = z / a * c
                          , k = I / o * Math.PI * 2;
                        P.x = (e + i * Math.cos(k)) * Math.cos(O),
                        P.y = (e + i * Math.cos(k)) * Math.sin(O),
                        P.z = i * Math.sin(k),
                        f.push(P.x, P.y, P.z),
                        w.x = e * Math.cos(O),
                        w.y = e * Math.sin(O),
                        M.subVectors(P, w).normalize(),
                        v.push(M.x, M.y, M.z),
                        x.push(z / a),
                        x.push(I / o)
                    }
                for (let I = 1; I <= o; I++)
                    for (let z = 1; z <= a; z++) {
                        const O = (a + 1) * I + z - 1
                          , k = (a + 1) * (I - 1) + z - 1
                          , Q = (a + 1) * (I - 1) + z
                          , Z = (a + 1) * I + z;
                        d.push(O, k, Z),
                        d.push(k, Q, Z)
                    }
                this.setIndex(d),
                this.setAttribute("position", new Rn(f,3)),
                this.setAttribute("normal", new Rn(v,3)),
                this.setAttribute("uv", new Rn(x,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new vd(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
            }
        }
        class _d extends Ai {
            constructor(e=1, i=.4, o=64, a=8, c=2, d=3) {
                super(),
                this.type = "TorusKnotGeometry",
                this.parameters = {
                    radius: e,
                    tube: i,
                    tubularSegments: o,
                    radialSegments: a,
                    p: c,
                    q: d
                },
                o = Math.floor(o),
                a = Math.floor(a);
                const f = []
                  , v = []
                  , x = []
                  , w = []
                  , P = new me
                  , M = new me
                  , I = new me
                  , z = new me
                  , O = new me
                  , k = new me
                  , Q = new me;
                for (let X = 0; X <= o; ++X) {
                    const K = X / o * c * Math.PI * 2;
                    Z(K, c, d, e, I),
                    Z(K + .01, c, d, e, z),
                    k.subVectors(z, I),
                    Q.addVectors(z, I),
                    O.crossVectors(k, Q),
                    Q.crossVectors(O, k),
                    O.normalize(),
                    Q.normalize();
                    for (let de = 0; de <= a; ++de) {
                        const be = de / a * Math.PI * 2
                          , Me = -i * Math.cos(be)
                          , J = i * Math.sin(be);
                        P.x = I.x + (Me * Q.x + J * O.x),
                        P.y = I.y + (Me * Q.y + J * O.y),
                        P.z = I.z + (Me * Q.z + J * O.z),
                        v.push(P.x, P.y, P.z),
                        M.subVectors(P, I).normalize(),
                        x.push(M.x, M.y, M.z),
                        w.push(X / o),
                        w.push(de / a)
                    }
                }
                for (let X = 1; X <= o; X++)
                    for (let K = 1; K <= a; K++) {
                        const de = (a + 1) * (X - 1) + (K - 1)
                          , be = (a + 1) * X + (K - 1)
                          , Me = (a + 1) * X + K
                          , J = (a + 1) * (X - 1) + K;
                        f.push(de, be, J),
                        f.push(be, Me, J)
                    }
                this.setIndex(f),
                this.setAttribute("position", new Rn(v,3)),
                this.setAttribute("normal", new Rn(x,3)),
                this.setAttribute("uv", new Rn(w,2));
                function Z(X, K, de, be, Me) {
                    const J = Math.cos(X)
                      , ge = Math.sin(X)
                      , Le = de / K * X
                      , tt = Math.cos(Le);
                    Me.x = be * (2 + tt) * .5 * J,
                    Me.y = be * (2 + tt) * ge * .5,
                    Me.z = be * Math.sin(Le) * .5
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new _d(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
            }
        }
        class yd extends Ai {
            constructor(e=new S0(new me(-1,-1,0),new me(-1,1,0),new me(1,1,0)), i=64, o=1, a=8, c=!1) {
                super(),
                this.type = "TubeGeometry",
                this.parameters = {
                    path: e,
                    tubularSegments: i,
                    radius: o,
                    radialSegments: a,
                    closed: c
                };
                const d = e.computeFrenetFrames(i, c);
                this.tangents = d.tangents,
                this.normals = d.normals,
                this.binormals = d.binormals;
                const f = new me
                  , v = new me
                  , x = new _t;
                let w = new me;
                const P = []
                  , M = []
                  , I = []
                  , z = [];
                O(),
                this.setIndex(z),
                this.setAttribute("position", new Rn(P,3)),
                this.setAttribute("normal", new Rn(M,3)),
                this.setAttribute("uv", new Rn(I,2));
                function O() {
                    for (let X = 0; X < i; X++)
                        k(X);
                    k(c === !1 ? i : 0),
                    Z(),
                    Q()
                }
                function k(X) {
                    w = e.getPointAt(X / i, w);
                    const K = d.normals[X]
                      , de = d.binormals[X];
                    for (let be = 0; be <= a; be++) {
                        const Me = be / a * Math.PI * 2
                          , J = Math.sin(Me)
                          , ge = -Math.cos(Me);
                        v.x = ge * K.x + J * de.x,
                        v.y = ge * K.y + J * de.y,
                        v.z = ge * K.z + J * de.z,
                        v.normalize(),
                        M.push(v.x, v.y, v.z),
                        f.x = w.x + o * v.x,
                        f.y = w.y + o * v.y,
                        f.z = w.z + o * v.z,
                        P.push(f.x, f.y, f.z)
                    }
                }
                function Q() {
                    for (let X = 1; X <= i; X++)
                        for (let K = 1; K <= a; K++) {
                            const de = (a + 1) * (X - 1) + (K - 1)
                              , be = (a + 1) * X + (K - 1)
                              , Me = (a + 1) * X + K
                              , J = (a + 1) * (X - 1) + K;
                            z.push(de, be, J),
                            z.push(be, Me, J)
                        }
                }
                function Z() {
                    for (let X = 0; X <= i; X++)
                        for (let K = 0; K <= a; K++)
                            x.x = X / i,
                            x.y = K / a,
                            I.push(x.x, x.y)
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.path = this.parameters.path.toJSON(),
                e
            }
            static fromJSON(e) {
                return new yd(new s[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
            }
        }
        class tb extends Ai {
            constructor(e=null) {
                if (super(),
                this.type = "WireframeGeometry",
                this.parameters = {
                    geometry: e
                },
                e !== null) {
                    const i = []
                      , o = new Set
                      , a = new me
                      , c = new me;
                    if (e.index !== null) {
                        const d = e.attributes.position
                          , f = e.index;
                        let v = e.groups;
                        v.length === 0 && (v = [{
                            start: 0,
                            count: f.count,
                            materialIndex: 0
                        }]);
                        for (let x = 0, w = v.length; x < w; ++x) {
                            const P = v[x]
                              , M = P.start
                              , I = P.count;
                            for (let z = M, O = M + I; z < O; z += 3)
                                for (let k = 0; k < 3; k++) {
                                    const Q = f.getX(z + k)
                                      , Z = f.getX(z + (k + 1) % 3);
                                    a.fromBufferAttribute(d, Q),
                                    c.fromBufferAttribute(d, Z),
                                    nb(a, c, o) === !0 && (i.push(a.x, a.y, a.z),
                                    i.push(c.x, c.y, c.z))
                                }
                        }
                    } else {
                        const d = e.attributes.position;
                        for (let f = 0, v = d.count / 3; f < v; f++)
                            for (let x = 0; x < 3; x++) {
                                const w = 3 * f + x
                                  , P = 3 * f + (x + 1) % 3;
                                a.fromBufferAttribute(d, w),
                                c.fromBufferAttribute(d, P),
                                nb(a, c, o) === !0 && (i.push(a.x, a.y, a.z),
                                i.push(c.x, c.y, c.z))
                            }
                    }
                    this.setAttribute("position", new Rn(i,3))
                }
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
        }
        function nb(u, e, i) {
            const o = `${u.x},${u.y},${u.z}-${e.x},${e.y},${e.z}`
              , a = `${e.x},${e.y},${e.z}-${u.x},${u.y},${u.z}`;
            return i.has(o) === !0 || i.has(a) === !0 ? !1 : (i.add(o),
            i.add(a),
            !0)
        }
        class ib extends Vs {
            constructor(e) {
                super(),
                this.isShadowMaterial = !0,
                this.type = "ShadowMaterial",
                this.color = new gn(0),
                this.transparent = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.fog = e.fog,
                this
            }
        }
        class rb extends ja {
            constructor(e) {
                super(e),
                this.isRawShaderMaterial = !0,
                this.type = "RawShaderMaterial"
            }
        }
        class P0 extends Vs {
            constructor(e) {
                super(),
                this.isMeshStandardMaterial = !0,
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new gn(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = y,
                this.normalScale = new _t(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(e.color),
                this.roughness = e.roughness,
                this.metalness = e.metalness,
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.roughnessMap = e.roughnessMap,
                this.metalnessMap = e.metalnessMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.envMapIntensity = e.envMapIntensity,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class sb extends P0 {
            constructor(e) {
                super(),
                this.isMeshPhysicalMaterial = !0,
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new _t(1,1),
                this.clearcoatNormalMap = null,
                this.ior = 1.5,
                Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return Wi(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(i) {
                        this.ior = (1 + .4 * i) / (1 - .4 * i)
                    }
                }),
                this.iridescenceMap = null,
                this.iridescenceIOR = 1.3,
                this.iridescenceThicknessRange = [100, 400],
                this.iridescenceThicknessMap = null,
                this.sheenColor = new gn(0),
                this.sheenColorMap = null,
                this.sheenRoughness = 1,
                this.sheenRoughnessMap = null,
                this.transmissionMap = null,
                this.thickness = 0,
                this.thicknessMap = null,
                this.attenuationDistance = 1 / 0,
                this.attenuationColor = new gn(1,1,1),
                this.specularIntensity = 1,
                this.specularIntensityMap = null,
                this.specularColor = new gn(1,1,1),
                this.specularColorMap = null,
                this._sheen = 0,
                this._clearcoat = 0,
                this._iridescence = 0,
                this._transmission = 0,
                this.setValues(e)
            }
            get sheen() {
                return this._sheen
            }
            set sheen(e) {
                this._sheen > 0 != e > 0 && this.version++,
                this._sheen = e
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(e) {
                this._clearcoat > 0 != e > 0 && this.version++,
                this._clearcoat = e
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(e) {
                this._iridescence > 0 != e > 0 && this.version++,
                this._iridescence = e
            }
            get transmission() {
                return this._transmission
            }
            set transmission(e) {
                this._transmission > 0 != e > 0 && this.version++,
                this._transmission = e
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.clearcoat = e.clearcoat,
                this.clearcoatMap = e.clearcoatMap,
                this.clearcoatRoughness = e.clearcoatRoughness,
                this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                this.clearcoatNormalMap = e.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                this.ior = e.ior,
                this.iridescence = e.iridescence,
                this.iridescenceMap = e.iridescenceMap,
                this.iridescenceIOR = e.iridescenceIOR,
                this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
                this.iridescenceThicknessMap = e.iridescenceThicknessMap,
                this.sheen = e.sheen,
                this.sheenColor.copy(e.sheenColor),
                this.sheenColorMap = e.sheenColorMap,
                this.sheenRoughness = e.sheenRoughness,
                this.sheenRoughnessMap = e.sheenRoughnessMap,
                this.transmission = e.transmission,
                this.transmissionMap = e.transmissionMap,
                this.thickness = e.thickness,
                this.thicknessMap = e.thicknessMap,
                this.attenuationDistance = e.attenuationDistance,
                this.attenuationColor.copy(e.attenuationColor),
                this.specularIntensity = e.specularIntensity,
                this.specularIntensityMap = e.specularIntensityMap,
                this.specularColor.copy(e.specularColor),
                this.specularColorMap = e.specularColorMap,
                this
            }
        }
        class ob extends Vs {
            constructor(e) {
                super(),
                this.isMeshPhongMaterial = !0,
                this.type = "MeshPhongMaterial",
                this.color = new gn(16777215),
                this.specular = new gn(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = y,
                this.normalScale = new _t(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = ui,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.specular.copy(e.specular),
                this.shininess = e.shininess,
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class ab extends Vs {
            constructor(e) {
                super(),
                this.isMeshToonMaterial = !0,
                this.defines = {
                    TOON: ""
                },
                this.type = "MeshToonMaterial",
                this.color = new gn(16777215),
                this.map = null,
                this.gradientMap = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = y,
                this.normalScale = new _t(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.gradientMap = e.gradientMap,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.alphaMap = e.alphaMap,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.fog = e.fog,
                this
            }
        }
        class lb extends Vs {
            constructor(e) {
                super(),
                this.isMeshNormalMaterial = !0,
                this.type = "MeshNormalMaterial",
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = y,
                this.normalScale = new _t(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.flatShading = !1,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.flatShading = e.flatShading,
                this
            }
        }
        class cb extends Vs {
            constructor(e) {
                super(),
                this.isMeshLambertMaterial = !0,
                this.type = "MeshLambertMaterial",
                this.color = new gn(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = y,
                this.normalScale = new _t(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = ui,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class ub extends Vs {
            constructor(e) {
                super(),
                this.isMeshMatcapMaterial = !0,
                this.defines = {
                    MATCAP: ""
                },
                this.type = "MeshMatcapMaterial",
                this.color = new gn(16777215),
                this.matcap = null,
                this.map = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = y,
                this.normalScale = new _t(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    MATCAP: ""
                },
                this.color.copy(e.color),
                this.matcap = e.matcap,
                this.map = e.map,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.alphaMap = e.alphaMap,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class hb extends ro {
            constructor(e) {
                super(),
                this.isLineDashedMaterial = !0,
                this.type = "LineDashedMaterial",
                this.scale = 1,
                this.dashSize = 3,
                this.gapSize = 1,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.scale = e.scale,
                this.dashSize = e.dashSize,
                this.gapSize = e.gapSize,
                this
            }
        }
        function $o(u, e, i) {
            return R0(u) ? new u.constructor(u.subarray(e, i !== void 0 ? i : u.length)) : u.slice(e, i)
        }
        function Xc(u, e, i) {
            return !u || !i && u.constructor === e ? u : typeof e.BYTES_PER_ELEMENT == "number" ? new e(u) : Array.prototype.slice.call(u)
        }
        function R0(u) {
            return ArrayBuffer.isView(u) && !(u instanceof DataView)
        }
        function db(u) {
            function e(a, c) {
                return u[a] - u[c]
            }
            const i = u.length
              , o = new Array(i);
            for (let a = 0; a !== i; ++a)
                o[a] = a;
            return o.sort(e),
            o
        }
        function D0(u, e, i) {
            const o = u.length
              , a = new u.constructor(o);
            for (let c = 0, d = 0; d !== o; ++c) {
                const f = i[c] * e;
                for (let v = 0; v !== e; ++v)
                    a[d++] = u[f + v]
            }
            return a
        }
        function L0(u, e, i, o) {
            let a = 1
              , c = u[0];
            for (; c !== void 0 && c[o] === void 0; )
                c = u[a++];
            if (c === void 0)
                return;
            let d = c[o];
            if (d !== void 0)
                if (Array.isArray(d))
                    do
                        d = c[o],
                        d !== void 0 && (e.push(c.time),
                        i.push.apply(i, d)),
                        c = u[a++];
                    while (c !== void 0);
                else if (d.toArray !== void 0)
                    do
                        d = c[o],
                        d !== void 0 && (e.push(c.time),
                        d.toArray(i, i.length)),
                        c = u[a++];
                    while (c !== void 0);
                else
                    do
                        d = c[o],
                        d !== void 0 && (e.push(c.time),
                        i.push(d)),
                        c = u[a++];
                    while (c !== void 0)
        }
        function FR(u, e, i, o, a=30) {
            const c = u.clone();
            c.name = e;
            const d = [];
            for (let v = 0; v < c.tracks.length; ++v) {
                const x = c.tracks[v]
                  , w = x.getValueSize()
                  , P = []
                  , M = [];
                for (let I = 0; I < x.times.length; ++I) {
                    const z = x.times[I] * a;
                    if (!(z < i || z >= o)) {
                        P.push(x.times[I]);
                        for (let O = 0; O < w; ++O)
                            M.push(x.values[I * w + O])
                    }
                }
                P.length !== 0 && (x.times = Xc(P, x.times.constructor),
                x.values = Xc(M, x.values.constructor),
                d.push(x))
            }
            c.tracks = d;
            let f = 1 / 0;
            for (let v = 0; v < c.tracks.length; ++v)
                f > c.tracks[v].times[0] && (f = c.tracks[v].times[0]);
            for (let v = 0; v < c.tracks.length; ++v)
                c.tracks[v].shift(-1 * f);
            return c.resetDuration(),
            c
        }
        function kR(u, e=0, i=u, o=30) {
            o <= 0 && (o = 30);
            const a = i.tracks.length
              , c = e / o;
            for (let d = 0; d < a; ++d) {
                const f = i.tracks[d]
                  , v = f.ValueTypeName;
                if (v === "bool" || v === "string")
                    continue;
                const x = u.tracks.find(function(Q) {
                    return Q.name === f.name && Q.ValueTypeName === v
                });
                if (x === void 0)
                    continue;
                let w = 0;
                const P = f.getValueSize();
                f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (w = P / 3);
                let M = 0;
                const I = x.getValueSize();
                x.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (M = I / 3);
                const z = f.times.length - 1;
                let O;
                if (c <= f.times[0]) {
                    const Q = w
                      , Z = P - w;
                    O = $o(f.values, Q, Z)
                } else if (c >= f.times[z]) {
                    const Q = z * P + w
                      , Z = Q + P - w;
                    O = $o(f.values, Q, Z)
                } else {
                    const Q = f.createInterpolant()
                      , Z = w
                      , X = P - w;
                    Q.evaluate(c),
                    O = $o(Q.resultBuffer, Z, X)
                }
                v === "quaternion" && new Vi().fromArray(O).normalize().conjugate().toArray(O);
                const k = x.times.length;
                for (let Q = 0; Q < k; ++Q) {
                    const Z = Q * I + M;
                    if (v === "quaternion")
                        Vi.multiplyQuaternionsFlat(x.values, Z, O, 0, x.values, Z);
                    else {
                        const X = I - M * 2;
                        for (let K = 0; K < X; ++K)
                            x.values[Z + K] -= O[K]
                    }
                }
            }
            return u.blendMode = ye,
            u
        }
        const UR = {
            arraySlice: $o,
            convertArray: Xc,
            isTypedArray: R0,
            getKeyframeOrder: db,
            sortedArray: D0,
            flattenJSON: L0,
            subclip: FR,
            makeClipAdditive: kR
        };
        class xd {
            constructor(e, i, o, a) {
                this.parameterPositions = e,
                this._cachedIndex = 0,
                this.resultBuffer = a !== void 0 ? a : new i.constructor(o),
                this.sampleValues = i,
                this.valueSize = o,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(e) {
                const i = this.parameterPositions;
                let o = this._cachedIndex
                  , a = i[o]
                  , c = i[o - 1];
                e: {
                    t: {
                        let d;
                        n: {
                            i: if (!(e < a)) {
                                for (let f = o + 2; ; ) {
                                    if (a === void 0) {
                                        if (e < c)
                                            break i;
                                        return o = i.length,
                                        this._cachedIndex = o,
                                        this.copySampleValue_(o - 1)
                                    }
                                    if (o === f)
                                        break;
                                    if (c = a,
                                    a = i[++o],
                                    e < a)
                                        break t
                                }
                                d = i.length;
                                break n
                            }
                            if (!(e >= c)) {
                                const f = i[1];
                                e < f && (o = 2,
                                c = f);
                                for (let v = o - 2; ; ) {
                                    if (c === void 0)
                                        return this._cachedIndex = 0,
                                        this.copySampleValue_(0);
                                    if (o === v)
                                        break;
                                    if (a = c,
                                    c = i[--o - 1],
                                    e >= c)
                                        break t
                                }
                                d = o,
                                o = 0;
                                break n
                            }
                            break e
                        }
                        for (; o < d; ) {
                            const f = o + d >>> 1;
                            e < i[f] ? d = f : o = f + 1
                        }
                        if (a = i[o],
                        c = i[o - 1],
                        c === void 0)
                            return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                        if (a === void 0)
                            return o = i.length,
                            this._cachedIndex = o,
                            this.copySampleValue_(o - 1)
                    }
                    this._cachedIndex = o,
                    this.intervalChanged_(o, c, a)
                }
                return this.interpolate_(o, c, e, a)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(e) {
                const i = this.resultBuffer
                  , o = this.sampleValues
                  , a = this.valueSize
                  , c = e * a;
                for (let d = 0; d !== a; ++d)
                    i[d] = o[c + d];
                return i
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class fb extends xd {
            constructor(e, i, o, a) {
                super(e, i, o, a),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: p,
                    endingEnd: p
                }
            }
            intervalChanged_(e, i, o) {
                const a = this.parameterPositions;
                let c = e - 2
                  , d = e + 1
                  , f = a[c]
                  , v = a[d];
                if (f === void 0)
                    switch (this.getSettings_().endingStart) {
                    case C:
                        c = e,
                        f = 2 * i - o;
                        break;
                    case V:
                        c = a.length - 2,
                        f = i + a[c] - a[c + 1];
                        break;
                    default:
                        c = e,
                        f = o
                    }
                if (v === void 0)
                    switch (this.getSettings_().endingEnd) {
                    case C:
                        d = e,
                        v = 2 * o - i;
                        break;
                    case V:
                        d = 1,
                        v = o + a[1] - a[0];
                        break;
                    default:
                        d = e - 1,
                        v = i
                    }
                const x = (o - i) * .5
                  , w = this.valueSize;
                this._weightPrev = x / (i - f),
                this._weightNext = x / (v - o),
                this._offsetPrev = c * w,
                this._offsetNext = d * w
            }
            interpolate_(e, i, o, a) {
                const c = this.resultBuffer
                  , d = this.sampleValues
                  , f = this.valueSize
                  , v = e * f
                  , x = v - f
                  , w = this._offsetPrev
                  , P = this._offsetNext
                  , M = this._weightPrev
                  , I = this._weightNext
                  , z = (o - i) / (a - i)
                  , O = z * z
                  , k = O * z
                  , Q = -M * k + 2 * M * O - M * z
                  , Z = (1 + M) * k + (-1.5 - 2 * M) * O + (-.5 + M) * z + 1
                  , X = (-1 - I) * k + (1.5 + I) * O + .5 * z
                  , K = I * k - I * O;
                for (let de = 0; de !== f; ++de)
                    c[de] = Q * d[w + de] + Z * d[x + de] + X * d[v + de] + K * d[P + de];
                return c
            }
        }
        class I0 extends xd {
            constructor(e, i, o, a) {
                super(e, i, o, a)
            }
            interpolate_(e, i, o, a) {
                const c = this.resultBuffer
                  , d = this.sampleValues
                  , f = this.valueSize
                  , v = e * f
                  , x = v - f
                  , w = (o - i) / (a - i)
                  , P = 1 - w;
                for (let M = 0; M !== f; ++M)
                    c[M] = d[x + M] * P + d[v + M] * w;
                return c
            }
        }
        class pb extends xd {
            constructor(e, i, o, a) {
                super(e, i, o, a)
            }
            interpolate_(e) {
                return this.copySampleValue_(e - 1)
            }
        }
        class Ea {
            constructor(e, i, o, a) {
                if (e === void 0)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (i === void 0 || i.length === 0)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e,
                this.times = Xc(i, this.TimeBufferType),
                this.values = Xc(o, this.ValueBufferType),
                this.setInterpolation(a || this.DefaultInterpolation)
            }
            static toJSON(e) {
                const i = e.constructor;
                let o;
                if (i.toJSON !== this.toJSON)
                    o = i.toJSON(e);
                else {
                    o = {
                        name: e.name,
                        times: Xc(e.times, Array),
                        values: Xc(e.values, Array)
                    };
                    const a = e.getInterpolation();
                    a !== e.DefaultInterpolation && (o.interpolation = a)
                }
                return o.type = e.ValueTypeName,
                o
            }
            InterpolantFactoryMethodDiscrete(e) {
                return new pb(this.times,this.values,this.getValueSize(),e)
            }
            InterpolantFactoryMethodLinear(e) {
                return new I0(this.times,this.values,this.getValueSize(),e)
            }
            InterpolantFactoryMethodSmooth(e) {
                return new fb(this.times,this.values,this.getValueSize(),e)
            }
            setInterpolation(e) {
                let i;
                switch (e) {
                case ws:
                    i = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Gs:
                    i = this.InterpolantFactoryMethodLinear;
                    break;
                case S:
                    i = this.InterpolantFactoryMethodSmooth;
                    break
                }
                if (i === void 0) {
                    const o = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (this.createInterpolant === void 0)
                        if (e !== this.DefaultInterpolation)
                            this.setInterpolation(this.DefaultInterpolation);
                        else
                            throw new Error(o);
                    return console.warn("THREE.KeyframeTrack:", o),
                    this
                }
                return this.createInterpolant = i,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return ws;
                case this.InterpolantFactoryMethodLinear:
                    return Gs;
                case this.InterpolantFactoryMethodSmooth:
                    return S
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(e) {
                if (e !== 0) {
                    const i = this.times;
                    for (let o = 0, a = i.length; o !== a; ++o)
                        i[o] += e
                }
                return this
            }
            scale(e) {
                if (e !== 1) {
                    const i = this.times;
                    for (let o = 0, a = i.length; o !== a; ++o)
                        i[o] *= e
                }
                return this
            }
            trim(e, i) {
                const o = this.times
                  , a = o.length;
                let c = 0
                  , d = a - 1;
                for (; c !== a && o[c] < e; )
                    ++c;
                for (; d !== -1 && o[d] > i; )
                    --d;
                if (++d,
                c !== 0 || d !== a) {
                    c >= d && (d = Math.max(d, 1),
                    c = d - 1);
                    const f = this.getValueSize();
                    this.times = $o(o, c, d),
                    this.values = $o(this.values, c * f, d * f)
                }
                return this
            }
            validate() {
                let e = !0;
                const i = this.getValueSize();
                i - Math.floor(i) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                e = !1);
                const o = this.times
                  , a = this.values
                  , c = o.length;
                c === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                e = !1);
                let d = null;
                for (let f = 0; f !== c; f++) {
                    const v = o[f];
                    if (typeof v == "number" && isNaN(v)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, v),
                        e = !1;
                        break
                    }
                    if (d !== null && d > v) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, f, v, d),
                        e = !1;
                        break
                    }
                    d = v
                }
                if (a !== void 0 && R0(a))
                    for (let f = 0, v = a.length; f !== v; ++f) {
                        const x = a[f];
                        if (isNaN(x)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, x),
                            e = !1;
                            break
                        }
                    }
                return e
            }
            optimize() {
                const e = $o(this.times)
                  , i = $o(this.values)
                  , o = this.getValueSize()
                  , a = this.getInterpolation() === S
                  , c = e.length - 1;
                let d = 1;
                for (let f = 1; f < c; ++f) {
                    let v = !1;
                    const x = e[f]
                      , w = e[f + 1];
                    if (x !== w && (f !== 1 || x !== e[0]))
                        if (a)
                            v = !0;
                        else {
                            const P = f * o
                              , M = P - o
                              , I = P + o;
                            for (let z = 0; z !== o; ++z) {
                                const O = i[P + z];
                                if (O !== i[M + z] || O !== i[I + z]) {
                                    v = !0;
                                    break
                                }
                            }
                        }
                    if (v) {
                        if (f !== d) {
                            e[d] = e[f];
                            const P = f * o
                              , M = d * o;
                            for (let I = 0; I !== o; ++I)
                                i[M + I] = i[P + I]
                        }
                        ++d
                    }
                }
                if (c > 0) {
                    e[d] = e[c];
                    for (let f = c * o, v = d * o, x = 0; x !== o; ++x)
                        i[v + x] = i[f + x];
                    ++d
                }
                return d !== e.length ? (this.times = $o(e, 0, d),
                this.values = $o(i, 0, d * o)) : (this.times = e,
                this.values = i),
                this
            }
            clone() {
                const e = $o(this.times, 0)
                  , i = $o(this.values, 0)
                  , o = this.constructor
                  , a = new o(this.name,e,i);
                return a.createInterpolant = this.createInterpolant,
                a
            }
        }
        Ea.prototype.TimeBufferType = Float32Array,
        Ea.prototype.ValueBufferType = Float32Array,
        Ea.prototype.DefaultInterpolation = Gs;
        class Yc extends Ea {
        }
        Yc.prototype.ValueTypeName = "bool",
        Yc.prototype.ValueBufferType = Array,
        Yc.prototype.DefaultInterpolation = ws,
        Yc.prototype.InterpolantFactoryMethodLinear = void 0,
        Yc.prototype.InterpolantFactoryMethodSmooth = void 0;
        class O0 extends Ea {
        }
        O0.prototype.ValueTypeName = "color";
        class bd extends Ea {
        }
        bd.prototype.ValueTypeName = "number";
        class mb extends xd {
            constructor(e, i, o, a) {
                super(e, i, o, a)
            }
            interpolate_(e, i, o, a) {
                const c = this.resultBuffer
                  , d = this.sampleValues
                  , f = this.valueSize
                  , v = (o - i) / (a - i);
                let x = e * f;
                for (let w = x + f; x !== w; x += 4)
                    Vi.slerpFlat(c, 0, d, x - f, d, x, v);
                return c
            }
        }
        class Zu extends Ea {
            InterpolantFactoryMethodLinear(e) {
                return new mb(this.times,this.values,this.getValueSize(),e)
            }
        }
        Zu.prototype.ValueTypeName = "quaternion",
        Zu.prototype.DefaultInterpolation = Gs,
        Zu.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Qc extends Ea {
        }
        Qc.prototype.ValueTypeName = "string",
        Qc.prototype.ValueBufferType = Array,
        Qc.prototype.DefaultInterpolation = ws,
        Qc.prototype.InterpolantFactoryMethodLinear = void 0,
        Qc.prototype.InterpolantFactoryMethodSmooth = void 0;
        class wd extends Ea {
        }
        wd.prototype.ValueTypeName = "vector";
        class Ad {
            constructor(e, i=-1, o, a=se) {
                this.name = e,
                this.tracks = o,
                this.duration = i,
                this.blendMode = a,
                this.uuid = yr(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(e) {
                const i = []
                  , o = e.tracks
                  , a = 1 / (e.fps || 1);
                for (let d = 0, f = o.length; d !== f; ++d)
                    i.push(zR(o[d]).scale(a));
                const c = new this(e.name,e.duration,i,e.blendMode);
                return c.uuid = e.uuid,
                c
            }
            static toJSON(e) {
                const i = []
                  , o = e.tracks
                  , a = {
                    name: e.name,
                    duration: e.duration,
                    tracks: i,
                    uuid: e.uuid,
                    blendMode: e.blendMode
                };
                for (let c = 0, d = o.length; c !== d; ++c)
                    i.push(Ea.toJSON(o[c]));
                return a
            }
            static CreateFromMorphTargetSequence(e, i, o, a) {
                const c = i.length
                  , d = [];
                for (let f = 0; f < c; f++) {
                    let v = []
                      , x = [];
                    v.push((f + c - 1) % c, f, (f + 1) % c),
                    x.push(0, 1, 0);
                    const w = db(v);
                    v = D0(v, 1, w),
                    x = D0(x, 1, w),
                    !a && v[0] === 0 && (v.push(c),
                    x.push(x[0])),
                    d.push(new bd(".morphTargetInfluences[" + i[f].name + "]",v,x).scale(1 / o))
                }
                return new this(e,-1,d)
            }
            static findByName(e, i) {
                let o = e;
                if (!Array.isArray(e)) {
                    const a = e;
                    o = a.geometry && a.geometry.animations || a.animations
                }
                for (let a = 0; a < o.length; a++)
                    if (o[a].name === i)
                        return o[a];
                return null
            }
            static CreateClipsFromMorphTargetSequences(e, i, o) {
                const a = {}
                  , c = /^([\w-]*?)([\d]+)$/;
                for (let f = 0, v = e.length; f < v; f++) {
                    const x = e[f]
                      , w = x.name.match(c);
                    if (w && w.length > 1) {
                        const P = w[1];
                        let M = a[P];
                        M || (a[P] = M = []),
                        M.push(x)
                    }
                }
                const d = [];
                for (const f in a)
                    d.push(this.CreateFromMorphTargetSequence(f, a[f], i, o));
                return d
            }
            static parseAnimation(e, i) {
                if (!e)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const o = function(P, M, I, z, O) {
                    if (I.length !== 0) {
                        const k = []
                          , Q = [];
                        L0(I, k, Q, z),
                        k.length !== 0 && O.push(new P(M,k,Q))
                    }
                }
                  , a = []
                  , c = e.name || "default"
                  , d = e.fps || 30
                  , f = e.blendMode;
                let v = e.length || -1;
                const x = e.hierarchy || [];
                for (let P = 0; P < x.length; P++) {
                    const M = x[P].keys;
                    if (!(!M || M.length === 0))
                        if (M[0].morphTargets) {
                            const I = {};
                            let z;
                            for (z = 0; z < M.length; z++)
                                if (M[z].morphTargets)
                                    for (let O = 0; O < M[z].morphTargets.length; O++)
                                        I[M[z].morphTargets[O]] = -1;
                            for (const O in I) {
                                const k = []
                                  , Q = [];
                                for (let Z = 0; Z !== M[z].morphTargets.length; ++Z) {
                                    const X = M[z];
                                    k.push(X.time),
                                    Q.push(X.morphTarget === O ? 1 : 0)
                                }
                                a.push(new bd(".morphTargetInfluence[" + O + "]",k,Q))
                            }
                            v = I.length * d
                        } else {
                            const I = ".bones[" + i[P].name + "]";
                            o(wd, I + ".position", M, "pos", a),
                            o(Zu, I + ".quaternion", M, "rot", a),
                            o(wd, I + ".scale", M, "scl", a)
                        }
                }
                return a.length === 0 ? null : new this(c,v,a,f)
            }
            resetDuration() {
                const e = this.tracks;
                let i = 0;
                for (let o = 0, a = e.length; o !== a; ++o) {
                    const c = this.tracks[o];
                    i = Math.max(i, c.times[c.times.length - 1])
                }
                return this.duration = i,
                this
            }
            trim() {
                for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].trim(0, this.duration);
                return this
            }
            validate() {
                let e = !0;
                for (let i = 0; i < this.tracks.length; i++)
                    e = e && this.tracks[i].validate();
                return e
            }
            optimize() {
                for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].optimize();
                return this
            }
            clone() {
                const e = [];
                for (let i = 0; i < this.tracks.length; i++)
                    e.push(this.tracks[i].clone());
                return new this.constructor(this.name,this.duration,e,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function NR(u) {
            switch (u.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return bd;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return wd;
            case "color":
                return O0;
            case "quaternion":
                return Zu;
            case "bool":
            case "boolean":
                return Yc;
            case "string":
                return Qc
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + u)
        }
        function zR(u) {
            if (u.type === void 0)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = NR(u.type);
            if (u.times === void 0) {
                const i = []
                  , o = [];
                L0(u.keys, i, o, "value"),
                u.times = i,
                u.values = o
            }
            return e.parse !== void 0 ? e.parse(u) : new e(u.name,u.times,u.values,u.interpolation)
        }
        const tc = {
            enabled: !1,
            files: {},
            add: function(u, e) {
                this.enabled !== !1 && (this.files[u] = e)
            },
            get: function(u) {
                if (this.enabled !== !1)
                    return this.files[u]
            },
            remove: function(u) {
                delete this.files[u]
            },
            clear: function() {
                this.files = {}
            }
        };
        class B0 {
            constructor(e, i, o) {
                const a = this;
                let c = !1, d = 0, f = 0, v;
                const x = [];
                this.onStart = void 0,
                this.onLoad = e,
                this.onProgress = i,
                this.onError = o,
                this.itemStart = function(w) {
                    f++,
                    c === !1 && a.onStart !== void 0 && a.onStart(w, d, f),
                    c = !0
                }
                ,
                this.itemEnd = function(w) {
                    d++,
                    a.onProgress !== void 0 && a.onProgress(w, d, f),
                    d === f && (c = !1,
                    a.onLoad !== void 0 && a.onLoad())
                }
                ,
                this.itemError = function(w) {
                    a.onError !== void 0 && a.onError(w)
                }
                ,
                this.resolveURL = function(w) {
                    return v ? v(w) : w
                }
                ,
                this.setURLModifier = function(w) {
                    return v = w,
                    this
                }
                ,
                this.addHandler = function(w, P) {
                    return x.push(w, P),
                    this
                }
                ,
                this.removeHandler = function(w) {
                    const P = x.indexOf(w);
                    return P !== -1 && x.splice(P, 2),
                    this
                }
                ,
                this.getHandler = function(w) {
                    for (let P = 0, M = x.length; P < M; P += 2) {
                        const I = x[P]
                          , z = x[P + 1];
                        if (I.global && (I.lastIndex = 0),
                        I.test(w))
                            return z
                    }
                    return null
                }
            }
        }
        const gb = new B0;
        class Oo {
            constructor(e) {
                this.manager = e !== void 0 ? e : gb,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(e, i) {
                const o = this;
                return new Promise(function(a, c) {
                    o.load(e, a, i, c)
                }
                )
            }
            parse() {}
            setCrossOrigin(e) {
                return this.crossOrigin = e,
                this
            }
            setWithCredentials(e) {
                return this.withCredentials = e,
                this
            }
            setPath(e) {
                return this.path = e,
                this
            }
            setResourcePath(e) {
                return this.resourcePath = e,
                this
            }
            setRequestHeader(e) {
                return this.requestHeader = e,
                this
            }
        }
        var F0 = r(980);
        const wl = {};
        class GR extends Error {
            constructor(e, i) {
                super(e),
                this.response = i
            }
        }
        class Al extends Oo {
            constructor(e) {
                super(e)
            }
            load(e, i, o, a, c) {
                e === void 0 && (e = ""),
                this.path !== void 0 && (e = this.path + e),
                e = this.manager.resolveURL(e);
                let d = tc.get(e);
                if (d === void 0 && c) {
                    this.manager.itemStart(e),
                    (this.responseType === "arraybuffer" ? (0,
                    F0.LX)(c) : (0,
                    F0.Vu)(c)).then(P=>{
                        tc.add(e, P),
                        i && i(P),
                        this.manager.itemEnd(e)
                    }
                    );
                    return
                }
                if (d !== void 0)
                    return this.manager.itemStart(e),
                    setTimeout(()=>{
                        i && i(d),
                        this.manager.itemEnd(e)
                    }
                    , 0),
                    d;
                if (wl[e] !== void 0) {
                    wl[e].push({
                        onLoad: i,
                        onProgress: o,
                        onError: a
                    });
                    return
                }
                wl[e] = [],
                wl[e].push({
                    onLoad: i,
                    onProgress: o,
                    onError: a
                });
                const f = new Request(e,{
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                })
                  , v = this.mimeType
                  , x = this.responseType;
                fetch(f).then(w=>{
                    if (w.status === 200 || w.status === 0) {
                        if (w.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        typeof ReadableStream > "u" || w.body === void 0 || w.body.getReader === void 0)
                            return w;
                        const P = wl[e]
                          , M = w.body.getReader()
                          , I = w.headers.get("Content-Length") || w.headers.get("X-File-Size")
                          , z = I ? parseInt(I) : 0
                          , O = z !== 0;
                        let k = 0;
                        const Q = new ReadableStream({
                            start(Z) {
                                X();
                                function X() {
                                    M.read().then(({done: K, value: de})=>{
                                        if (K)
                                            Z.close();
                                        else {
                                            k += de.byteLength;
                                            const be = new ProgressEvent("progress",{
                                                lengthComputable: O,
                                                loaded: k,
                                                total: z
                                            });
                                            for (let Me = 0, J = P.length; Me < J; Me++) {
                                                const ge = P[Me];
                                                ge.onProgress && ge.onProgress(be)
                                            }
                                            Z.enqueue(de),
                                            X()
                                        }
                                    }
                                    )
                                }
                            }
                        });
                        return new Response(Q)
                    } else
                        throw new GR(`fetch for "${w.url}" responded with ${w.status}: ${w.statusText}`,w)
                }
                ).then(w=>{
                    switch (x) {
                    case "arraybuffer":
                        return w.arrayBuffer();
                    case "blob":
                        return w.blob();
                    case "document":
                        return w.text().then(P=>new DOMParser().parseFromString(P, v));
                    case "json":
                        return w.json();
                    default:
                        if (v === void 0)
                            return w.text();
                        {
                            const M = /charset="?([^;"\s]*)"?/i.exec(v)
                              , I = M && M[1] ? M[1].toLowerCase() : void 0
                              , z = new TextDecoder(I);
                            return w.arrayBuffer().then(O=>z.decode(O))
                        }
                    }
                }
                ).then(w=>{
                    tc.add(e, w);
                    const P = wl[e];
                    delete wl[e];
                    for (let M = 0, I = P.length; M < I; M++) {
                        const z = P[M];
                        z.onLoad && z.onLoad(w)
                    }
                }
                ).catch(w=>{
                    const P = wl[e];
                    if (P === void 0)
                        throw this.manager.itemError(e),
                        w;
                    delete wl[e];
                    for (let M = 0, I = P.length; M < I; M++) {
                        const z = P[M];
                        z.onError && z.onError(w)
                    }
                    this.manager.itemError(e)
                }
                ).finally(()=>{
                    this.manager.itemEnd(e)
                }
                ),
                this.manager.itemStart(e)
            }
            setResponseType(e) {
                return this.responseType = e,
                this
            }
            setMimeType(e) {
                return this.mimeType = e,
                this
            }
        }
        class HR extends Oo {
            constructor(e) {
                super(e)
            }
            load(e, i, o, a) {
                const c = this
                  , d = new Al(this.manager);
                d.setPath(this.path),
                d.setRequestHeader(this.requestHeader),
                d.setWithCredentials(this.withCredentials),
                d.load(e, function(f) {
                    try {
                        i(c.parse(JSON.parse(f)))
                    } catch (v) {
                        a ? a(v) : console.error(v),
                        c.manager.itemError(e)
                    }
                }, o, a)
            }
            parse(e) {
                const i = [];
                for (let o = 0; o < e.length; o++) {
                    const a = Ad.parse(e[o]);
                    i.push(a)
                }
                return i
            }
        }
        class VR extends Oo {
            constructor(e) {
                super(e)
            }
            load(e, i, o, a) {
                const c = this
                  , d = []
                  , f = new v0
                  , v = new Al(this.manager);
                v.setPath(this.path),
                v.setResponseType("arraybuffer"),
                v.setRequestHeader(this.requestHeader),
                v.setWithCredentials(c.withCredentials);
                let x = 0;
                function w(P) {
                    v.load(e[P], function(M) {
                        const I = c.parse(M, !0);
                        d[P] = {
                            width: I.width,
                            height: I.height,
                            format: I.format,
                            mipmaps: I.mipmaps
                        },
                        x += 1,
                        x === 6 && (I.mipmapCount === 1 && (f.minFilter = Hi),
                        f.image = d,
                        f.format = I.format,
                        f.needsUpdate = !0,
                        i && i(f))
                    }, o, a)
                }
                if (Array.isArray(e))
                    for (let P = 0, M = e.length; P < M; ++P)
                        w(P);
                else
                    v.load(e, function(P) {
                        const M = c.parse(P, !0);
                        if (M.isCubemap) {
                            const I = M.mipmaps.length / M.mipmapCount;
                            for (let z = 0; z < I; z++) {
                                d[z] = {
                                    mipmaps: []
                                };
                                for (let O = 0; O < M.mipmapCount; O++)
                                    d[z].mipmaps.push(M.mipmaps[z * M.mipmapCount + O]),
                                    d[z].format = M.format,
                                    d[z].width = M.width,
                                    d[z].height = M.height
                            }
                            f.image = d
                        } else
                            f.image.width = M.width,
                            f.image.height = M.height,
                            f.mipmaps = M.mipmaps;
                        M.mipmapCount === 1 && (f.minFilter = Hi),
                        f.format = M.format,
                        f.needsUpdate = !0,
                        i && i(f)
                    }, o, a);
                return f
            }
        }
        class Sd extends Oo {
            constructor(e) {
                super(e)
            }
            load(e, i, o, a, c) {
                this.path !== void 0 && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const d = this
                  , f = tc.get(e);
                if (f !== void 0)
                    return d.manager.itemStart(e),
                    setTimeout(function() {
                        i && i(f),
                        d.manager.itemEnd(e)
                    }, 0),
                    f;
                const v = Y("img");
                function x() {
                    P(),
                    tc.add(e, this),
                    i && i(this),
                    d.manager.itemEnd(e)
                }
                function w(M) {
                    P(),
                    a && a(M),
                    d.manager.itemError(e),
                    d.manager.itemEnd(e)
                }
                function P() {
                    v.removeEventListener("load", x, !1),
                    v.removeEventListener("error", w, !1)
                }
                return v.addEventListener("load", x, !1),
                v.addEventListener("error", w, !1),
                e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (v.crossOrigin = this.crossOrigin),
                d.manager.itemStart(e),
                c ? (0,
                F0.hR)(c).then(M=>{
                    v.src = M
                }
                ) : v.src = e,
                v
            }
        }
        class WR extends Oo {
            constructor(e) {
                super(e)
            }
            load(e, i, o, a) {
                const c = new Zh
                  , d = new Sd(this.manager);
                d.setCrossOrigin(this.crossOrigin),
                d.setPath(this.path);
                let f = 0;
                function v(x) {
                    d.load(e[x], function(w) {
                        c.images[x] = w,
                        f++,
                        f === 6 && (c.needsUpdate = !0,
                        i && i(c))
                    }, void 0, a)
                }
                for (let x = 0; x < e.length; ++x)
                    v(x);
                return c
            }
        }
        class jR extends Oo {
            constructor(e) {
                super(e)
            }
            load(e, i, o, a, c) {
                const d = this
                  , f = new Wu
                  , v = new Al(this.manager);
                return v.setResponseType("arraybuffer"),
                v.setRequestHeader(this.requestHeader),
                v.setPath(this.path),
                v.setWithCredentials(d.withCredentials),
                v.load(e, function(x) {
                    const w = d.parse(x);
                    w && (w.image !== void 0 ? f.image = w.image : w.data !== void 0 && (f.image.width = w.width,
                    f.image.height = w.height,
                    f.image.data = w.data),
                    f.wrapS = w.wrapS !== void 0 ? w.wrapS : hi,
                    f.wrapT = w.wrapT !== void 0 ? w.wrapT : hi,
                    f.magFilter = w.magFilter !== void 0 ? w.magFilter : Hi,
                    f.minFilter = w.minFilter !== void 0 ? w.minFilter : Hi,
                    f.anisotropy = w.anisotropy !== void 0 ? w.anisotropy : 1,
                    w.encoding !== void 0 && (f.encoding = w.encoding),
                    w.flipY !== void 0 && (f.flipY = w.flipY),
                    w.format !== void 0 && (f.format = w.format),
                    w.type !== void 0 && (f.type = w.type),
                    w.mipmaps !== void 0 && (f.mipmaps = w.mipmaps,
                    f.minFilter = Fr),
                    w.mipmapCount === 1 && (f.minFilter = Hi),
                    w.generateMipmaps !== void 0 && (f.generateMipmaps = w.generateMipmaps),
                    f.needsUpdate = !0,
                    i && i(f, w))
                }, o, a, c),
                f
            }
        }
        class XR extends Oo {
            constructor(e) {
                super(e)
            }
            load(e, i, o, a, c) {
                const d = new $t
                  , f = new Sd(this.manager);
                return f.setCrossOrigin(this.crossOrigin),
                f.setPath(this.path),
                f.load(e, function(v) {
                    d.image = v,
                    d.needsUpdate = !0,
                    i !== void 0 && i(d)
                }, o, a, c),
                d
            }
        }
        class nc extends Qi {
            constructor(e, i=1) {
                super(),
                this.isLight = !0,
                this.type = "Light",
                this.color = new gn(e),
                this.intensity = i
            }
            dispose() {}
            copy(e, i) {
                return super.copy(e, i),
                this.color.copy(e.color),
                this.intensity = e.intensity,
                this
            }
            toJSON(e) {
                const i = super.toJSON(e);
                return i.object.color = this.color.getHex(),
                i.object.intensity = this.intensity,
                this.groundColor !== void 0 && (i.object.groundColor = this.groundColor.getHex()),
                this.distance !== void 0 && (i.object.distance = this.distance),
                this.angle !== void 0 && (i.object.angle = this.angle),
                this.decay !== void 0 && (i.object.decay = this.decay),
                this.penumbra !== void 0 && (i.object.penumbra = this.penumbra),
                this.shadow !== void 0 && (i.object.shadow = this.shadow.toJSON()),
                i
            }
        }
        class vb extends nc {
            constructor(e, i, o) {
                super(e, o),
                this.isHemisphereLight = !0,
                this.type = "HemisphereLight",
                this.position.copy(Qi.DEFAULT_UP),
                this.updateMatrix(),
                this.groundColor = new gn(i)
            }
            copy(e, i) {
                return super.copy(e, i),
                this.groundColor.copy(e.groundColor),
                this
            }
        }
        const k0 = new pi
          , _b = new me
          , yb = new me;
        class U0 {
            constructor(e) {
                this.camera = e,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new _t(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new pi,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new sp,
                this._frameExtents = new _t(1,1),
                this._viewportCount = 1,
                this._viewports = [new mn(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(e) {
                const i = this.camera
                  , o = this.matrix;
                _b.setFromMatrixPosition(e.matrixWorld),
                i.position.copy(_b),
                yb.setFromMatrixPosition(e.target.matrixWorld),
                i.lookAt(yb),
                i.updateMatrixWorld(),
                k0.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(k0),
                o.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                o.multiply(k0)
            }
            getViewport(e) {
                return this._viewports[e]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(e) {
                return this.camera = e.camera.clone(),
                this.bias = e.bias,
                this.radius = e.radius,
                this.mapSize.copy(e.mapSize),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            toJSON() {
                const e = {};
                return this.bias !== 0 && (e.bias = this.bias),
                this.normalBias !== 0 && (e.normalBias = this.normalBias),
                this.radius !== 1 && (e.radius = this.radius),
                (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
                e.camera = this.camera.toJSON(!1).object,
                delete e.camera.matrix,
                e
            }
        }
        class YR extends U0 {
            constructor() {
                super(new Ms(50,1,.5,500)),
                this.isSpotLightShadow = !0,
                this.focus = 1
            }
            updateMatrices(e) {
                const i = this.camera
                  , o = Mr * 2 * e.angle * this.focus
                  , a = this.mapSize.width / this.mapSize.height
                  , c = e.distance || i.far;
                (o !== i.fov || a !== i.aspect || c !== i.far) && (i.fov = o,
                i.aspect = a,
                i.far = c,
                i.updateProjectionMatrix()),
                super.updateMatrices(e)
            }
            copy(e) {
                return super.copy(e),
                this.focus = e.focus,
                this
            }
        }
        class xb extends nc {
            constructor(e, i, o=0, a=Math.PI / 3, c=0, d=2) {
                super(e, i),
                this.isSpotLight = !0,
                this.type = "SpotLight",
                this.position.copy(Qi.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new Qi,
                this.distance = o,
                this.angle = a,
                this.penumbra = c,
                this.decay = d,
                this.map = null,
                this.shadow = new YR
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, i) {
                return super.copy(e, i),
                this.distance = e.distance,
                this.angle = e.angle,
                this.penumbra = e.penumbra,
                this.decay = e.decay,
                this.target = e.target.clone(),
                this.shadow = e.shadow.clone(),
                this
            }
        }
        const bb = new pi
          , Td = new me
          , N0 = new me;
        class QR extends U0 {
            constructor() {
                super(new Ms(90,1,.5,500)),
                this.isPointLightShadow = !0,
                this._frameExtents = new _t(4,2),
                this._viewportCount = 6,
                this._viewports = [new mn(2,1,1,1), new mn(0,1,1,1), new mn(3,1,1,1), new mn(1,1,1,1), new mn(3,0,1,1), new mn(1,0,1,1)],
                this._cubeDirections = [new me(1,0,0), new me(-1,0,0), new me(0,0,1), new me(0,0,-1), new me(0,1,0), new me(0,-1,0)],
                this._cubeUps = [new me(0,1,0), new me(0,1,0), new me(0,1,0), new me(0,1,0), new me(0,0,1), new me(0,0,-1)]
            }
            updateMatrices(e, i=0) {
                const o = this.camera
                  , a = this.matrix
                  , c = e.distance || o.far;
                c !== o.far && (o.far = c,
                o.updateProjectionMatrix()),
                Td.setFromMatrixPosition(e.matrixWorld),
                o.position.copy(Td),
                N0.copy(o.position),
                N0.add(this._cubeDirections[i]),
                o.up.copy(this._cubeUps[i]),
                o.lookAt(N0),
                o.updateMatrixWorld(),
                a.makeTranslation(-Td.x, -Td.y, -Td.z),
                bb.multiplyMatrices(o.projectionMatrix, o.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(bb)
            }
        }
        class wb extends nc {
            constructor(e, i, o=0, a=2) {
                super(e, i),
                this.isPointLight = !0,
                this.type = "PointLight",
                this.distance = o,
                this.decay = a,
                this.shadow = new QR
            }
            get power() {
                return this.intensity * 4 * Math.PI
            }
            set power(e) {
                this.intensity = e / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, i) {
                return super.copy(e, i),
                this.distance = e.distance,
                this.decay = e.decay,
                this.shadow = e.shadow.clone(),
                this
            }
        }
        class KR extends U0 {
            constructor() {
                super(new ap(-5,5,5,-5,.5,500)),
                this.isDirectionalLightShadow = !0
            }
        }
        class Ab extends nc {
            constructor(e, i) {
                super(e, i),
                this.isDirectionalLight = !0,
                this.type = "DirectionalLight",
                this.position.copy(Qi.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new Qi,
                this.shadow = new KR
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e),
                this.target = e.target.clone(),
                this.shadow = e.shadow.clone(),
                this
            }
        }
        class Sb extends nc {
            constructor(e, i) {
                super(e, i),
                this.isAmbientLight = !0,
                this.type = "AmbientLight"
            }
        }
        class Tb extends nc {
            constructor(e, i, o=10, a=10) {
                super(e, i),
                this.isRectAreaLight = !0,
                this.type = "RectAreaLight",
                this.width = o,
                this.height = a
            }
            get power() {
                return this.intensity * this.width * this.height * Math.PI
            }
            set power(e) {
                this.intensity = e / (this.width * this.height * Math.PI)
            }
            copy(e) {
                return super.copy(e),
                this.width = e.width,
                this.height = e.height,
                this
            }
            toJSON(e) {
                const i = super.toJSON(e);
                return i.object.width = this.width,
                i.object.height = this.height,
                i
            }
        }
        class Eb {
            constructor() {
                this.isSphericalHarmonics3 = !0,
                this.coefficients = [];
                for (let e = 0; e < 9; e++)
                    this.coefficients.push(new me)
            }
            set(e) {
                for (let i = 0; i < 9; i++)
                    this.coefficients[i].copy(e[i]);
                return this
            }
            zero() {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].set(0, 0, 0);
                return this
            }
            getAt(e, i) {
                const o = e.x
                  , a = e.y
                  , c = e.z
                  , d = this.coefficients;
                return i.copy(d[0]).multiplyScalar(.282095),
                i.addScaledVector(d[1], .488603 * a),
                i.addScaledVector(d[2], .488603 * c),
                i.addScaledVector(d[3], .488603 * o),
                i.addScaledVector(d[4], 1.092548 * (o * a)),
                i.addScaledVector(d[5], 1.092548 * (a * c)),
                i.addScaledVector(d[6], .315392 * (3 * c * c - 1)),
                i.addScaledVector(d[7], 1.092548 * (o * c)),
                i.addScaledVector(d[8], .546274 * (o * o - a * a)),
                i
            }
            getIrradianceAt(e, i) {
                const o = e.x
                  , a = e.y
                  , c = e.z
                  , d = this.coefficients;
                return i.copy(d[0]).multiplyScalar(.886227),
                i.addScaledVector(d[1], 2 * .511664 * a),
                i.addScaledVector(d[2], 2 * .511664 * c),
                i.addScaledVector(d[3], 2 * .511664 * o),
                i.addScaledVector(d[4], 2 * .429043 * o * a),
                i.addScaledVector(d[5], 2 * .429043 * a * c),
                i.addScaledVector(d[6], .743125 * c * c - .247708),
                i.addScaledVector(d[7], 2 * .429043 * o * c),
                i.addScaledVector(d[8], .429043 * (o * o - a * a)),
                i
            }
            add(e) {
                for (let i = 0; i < 9; i++)
                    this.coefficients[i].add(e.coefficients[i]);
                return this
            }
            addScaledSH(e, i) {
                for (let o = 0; o < 9; o++)
                    this.coefficients[o].addScaledVector(e.coefficients[o], i);
                return this
            }
            scale(e) {
                for (let i = 0; i < 9; i++)
                    this.coefficients[i].multiplyScalar(e);
                return this
            }
            lerp(e, i) {
                for (let o = 0; o < 9; o++)
                    this.coefficients[o].lerp(e.coefficients[o], i);
                return this
            }
            equals(e) {
                for (let i = 0; i < 9; i++)
                    if (!this.coefficients[i].equals(e.coefficients[i]))
                        return !1;
                return !0
            }
            copy(e) {
                return this.set(e.coefficients)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            fromArray(e, i=0) {
                const o = this.coefficients;
                for (let a = 0; a < 9; a++)
                    o[a].fromArray(e, i + a * 3);
                return this
            }
            toArray(e=[], i=0) {
                const o = this.coefficients;
                for (let a = 0; a < 9; a++)
                    o[a].toArray(e, i + a * 3);
                return e
            }
            static getBasisAt(e, i) {
                const o = e.x
                  , a = e.y
                  , c = e.z;
                i[0] = .282095,
                i[1] = .488603 * a,
                i[2] = .488603 * c,
                i[3] = .488603 * o,
                i[4] = 1.092548 * o * a,
                i[5] = 1.092548 * a * c,
                i[6] = .315392 * (3 * c * c - 1),
                i[7] = 1.092548 * o * c,
                i[8] = .546274 * (o * o - a * a)
            }
        }
        class Lp extends nc {
            constructor(e=new Eb, i=1) {
                super(void 0, i),
                this.isLightProbe = !0,
                this.sh = e
            }
            copy(e) {
                return super.copy(e),
                this.sh.copy(e.sh),
                this
            }
            fromJSON(e) {
                return this.intensity = e.intensity,
                this.sh.fromArray(e.sh),
                this
            }
            toJSON(e) {
                const i = super.toJSON(e);
                return i.object.sh = this.sh.toArray(),
                i
            }
        }
        class Ip extends Oo {
            constructor(e) {
                super(e),
                this.textures = {}
            }
            load(e, i, o, a) {
                const c = this
                  , d = new Al(c.manager);
                d.setPath(c.path),
                d.setRequestHeader(c.requestHeader),
                d.setWithCredentials(c.withCredentials),
                d.load(e, function(f) {
                    try {
                        i(c.parse(JSON.parse(f)))
                    } catch (v) {
                        a ? a(v) : console.error(v),
                        c.manager.itemError(e)
                    }
                }, o, a)
            }
            parse(e) {
                const i = this.textures;
                function o(c) {
                    return i[c] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", c),
                    i[c]
                }
                const a = Ip.createMaterialFromType(e.type);
                if (e.uuid !== void 0 && (a.uuid = e.uuid),
                e.name !== void 0 && (a.name = e.name),
                e.color !== void 0 && a.color !== void 0 && a.color.setHex(e.color),
                e.roughness !== void 0 && (a.roughness = e.roughness),
                e.metalness !== void 0 && (a.metalness = e.metalness),
                e.sheen !== void 0 && (a.sheen = e.sheen),
                e.sheenColor !== void 0 && (a.sheenColor = new gn().setHex(e.sheenColor)),
                e.sheenRoughness !== void 0 && (a.sheenRoughness = e.sheenRoughness),
                e.emissive !== void 0 && a.emissive !== void 0 && a.emissive.setHex(e.emissive),
                e.specular !== void 0 && a.specular !== void 0 && a.specular.setHex(e.specular),
                e.specularIntensity !== void 0 && (a.specularIntensity = e.specularIntensity),
                e.specularColor !== void 0 && a.specularColor !== void 0 && a.specularColor.setHex(e.specularColor),
                e.shininess !== void 0 && (a.shininess = e.shininess),
                e.clearcoat !== void 0 && (a.clearcoat = e.clearcoat),
                e.clearcoatRoughness !== void 0 && (a.clearcoatRoughness = e.clearcoatRoughness),
                e.iridescence !== void 0 && (a.iridescence = e.iridescence),
                e.iridescenceIOR !== void 0 && (a.iridescenceIOR = e.iridescenceIOR),
                e.iridescenceThicknessRange !== void 0 && (a.iridescenceThicknessRange = e.iridescenceThicknessRange),
                e.transmission !== void 0 && (a.transmission = e.transmission),
                e.thickness !== void 0 && (a.thickness = e.thickness),
                e.attenuationDistance !== void 0 && (a.attenuationDistance = e.attenuationDistance),
                e.attenuationColor !== void 0 && a.attenuationColor !== void 0 && a.attenuationColor.setHex(e.attenuationColor),
                e.fog !== void 0 && (a.fog = e.fog),
                e.flatShading !== void 0 && (a.flatShading = e.flatShading),
                e.blending !== void 0 && (a.blending = e.blending),
                e.combine !== void 0 && (a.combine = e.combine),
                e.side !== void 0 && (a.side = e.side),
                e.shadowSide !== void 0 && (a.shadowSide = e.shadowSide),
                e.opacity !== void 0 && (a.opacity = e.opacity),
                e.transparent !== void 0 && (a.transparent = e.transparent),
                e.alphaTest !== void 0 && (a.alphaTest = e.alphaTest),
                e.depthTest !== void 0 && (a.depthTest = e.depthTest),
                e.depthWrite !== void 0 && (a.depthWrite = e.depthWrite),
                e.colorWrite !== void 0 && (a.colorWrite = e.colorWrite),
                e.stencilWrite !== void 0 && (a.stencilWrite = e.stencilWrite),
                e.stencilWriteMask !== void 0 && (a.stencilWriteMask = e.stencilWriteMask),
                e.stencilFunc !== void 0 && (a.stencilFunc = e.stencilFunc),
                e.stencilRef !== void 0 && (a.stencilRef = e.stencilRef),
                e.stencilFuncMask !== void 0 && (a.stencilFuncMask = e.stencilFuncMask),
                e.stencilFail !== void 0 && (a.stencilFail = e.stencilFail),
                e.stencilZFail !== void 0 && (a.stencilZFail = e.stencilZFail),
                e.stencilZPass !== void 0 && (a.stencilZPass = e.stencilZPass),
                e.wireframe !== void 0 && (a.wireframe = e.wireframe),
                e.wireframeLinewidth !== void 0 && (a.wireframeLinewidth = e.wireframeLinewidth),
                e.wireframeLinecap !== void 0 && (a.wireframeLinecap = e.wireframeLinecap),
                e.wireframeLinejoin !== void 0 && (a.wireframeLinejoin = e.wireframeLinejoin),
                e.rotation !== void 0 && (a.rotation = e.rotation),
                e.linewidth !== 1 && (a.linewidth = e.linewidth),
                e.dashSize !== void 0 && (a.dashSize = e.dashSize),
                e.gapSize !== void 0 && (a.gapSize = e.gapSize),
                e.scale !== void 0 && (a.scale = e.scale),
                e.polygonOffset !== void 0 && (a.polygonOffset = e.polygonOffset),
                e.polygonOffsetFactor !== void 0 && (a.polygonOffsetFactor = e.polygonOffsetFactor),
                e.polygonOffsetUnits !== void 0 && (a.polygonOffsetUnits = e.polygonOffsetUnits),
                e.dithering !== void 0 && (a.dithering = e.dithering),
                e.alphaToCoverage !== void 0 && (a.alphaToCoverage = e.alphaToCoverage),
                e.premultipliedAlpha !== void 0 && (a.premultipliedAlpha = e.premultipliedAlpha),
                e.forceSinglePass !== void 0 && (a.forceSinglePass = e.forceSinglePass),
                e.visible !== void 0 && (a.visible = e.visible),
                e.toneMapped !== void 0 && (a.toneMapped = e.toneMapped),
                e.userData !== void 0 && (a.userData = e.userData),
                e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? a.vertexColors = e.vertexColors > 0 : a.vertexColors = e.vertexColors),
                e.uniforms !== void 0)
                    for (const c in e.uniforms) {
                        const d = e.uniforms[c];
                        switch (a.uniforms[c] = {},
                        d.type) {
                        case "t":
                            a.uniforms[c].value = o(d.value);
                            break;
                        case "c":
                            a.uniforms[c].value = new gn().setHex(d.value);
                            break;
                        case "v2":
                            a.uniforms[c].value = new _t().fromArray(d.value);
                            break;
                        case "v3":
                            a.uniforms[c].value = new me().fromArray(d.value);
                            break;
                        case "v4":
                            a.uniforms[c].value = new mn().fromArray(d.value);
                            break;
                        case "m3":
                            a.uniforms[c].value = new Cr().fromArray(d.value);
                            break;
                        case "m4":
                            a.uniforms[c].value = new pi().fromArray(d.value);
                            break;
                        default:
                            a.uniforms[c].value = d.value
                        }
                    }
                if (e.defines !== void 0 && (a.defines = e.defines),
                e.vertexShader !== void 0 && (a.vertexShader = e.vertexShader),
                e.fragmentShader !== void 0 && (a.fragmentShader = e.fragmentShader),
                e.glslVersion !== void 0 && (a.glslVersion = e.glslVersion),
                e.extensions !== void 0)
                    for (const c in e.extensions)
                        a.extensions[c] = e.extensions[c];
                if (e.size !== void 0 && (a.size = e.size),
                e.sizeAttenuation !== void 0 && (a.sizeAttenuation = e.sizeAttenuation),
                e.map !== void 0 && (a.map = o(e.map)),
                e.matcap !== void 0 && (a.matcap = o(e.matcap)),
                e.alphaMap !== void 0 && (a.alphaMap = o(e.alphaMap)),
                e.bumpMap !== void 0 && (a.bumpMap = o(e.bumpMap)),
                e.bumpScale !== void 0 && (a.bumpScale = e.bumpScale),
                e.normalMap !== void 0 && (a.normalMap = o(e.normalMap)),
                e.normalMapType !== void 0 && (a.normalMapType = e.normalMapType),
                e.normalScale !== void 0) {
                    let c = e.normalScale;
                    Array.isArray(c) === !1 && (c = [c, c]),
                    a.normalScale = new _t().fromArray(c)
                }
                return e.displacementMap !== void 0 && (a.displacementMap = o(e.displacementMap)),
                e.displacementScale !== void 0 && (a.displacementScale = e.displacementScale),
                e.displacementBias !== void 0 && (a.displacementBias = e.displacementBias),
                e.roughnessMap !== void 0 && (a.roughnessMap = o(e.roughnessMap)),
                e.metalnessMap !== void 0 && (a.metalnessMap = o(e.metalnessMap)),
                e.emissiveMap !== void 0 && (a.emissiveMap = o(e.emissiveMap)),
                e.emissiveIntensity !== void 0 && (a.emissiveIntensity = e.emissiveIntensity),
                e.specularMap !== void 0 && (a.specularMap = o(e.specularMap)),
                e.specularIntensityMap !== void 0 && (a.specularIntensityMap = o(e.specularIntensityMap)),
                e.specularColorMap !== void 0 && (a.specularColorMap = o(e.specularColorMap)),
                e.envMap !== void 0 && (a.envMap = o(e.envMap)),
                e.envMapIntensity !== void 0 && (a.envMapIntensity = e.envMapIntensity),
                e.reflectivity !== void 0 && (a.reflectivity = e.reflectivity),
                e.refractionRatio !== void 0 && (a.refractionRatio = e.refractionRatio),
                e.lightMap !== void 0 && (a.lightMap = o(e.lightMap)),
                e.lightMapIntensity !== void 0 && (a.lightMapIntensity = e.lightMapIntensity),
                e.aoMap !== void 0 && (a.aoMap = o(e.aoMap)),
                e.aoMapIntensity !== void 0 && (a.aoMapIntensity = e.aoMapIntensity),
                e.gradientMap !== void 0 && (a.gradientMap = o(e.gradientMap)),
                e.clearcoatMap !== void 0 && (a.clearcoatMap = o(e.clearcoatMap)),
                e.clearcoatRoughnessMap !== void 0 && (a.clearcoatRoughnessMap = o(e.clearcoatRoughnessMap)),
                e.clearcoatNormalMap !== void 0 && (a.clearcoatNormalMap = o(e.clearcoatNormalMap)),
                e.clearcoatNormalScale !== void 0 && (a.clearcoatNormalScale = new _t().fromArray(e.clearcoatNormalScale)),
                e.iridescenceMap !== void 0 && (a.iridescenceMap = o(e.iridescenceMap)),
                e.iridescenceThicknessMap !== void 0 && (a.iridescenceThicknessMap = o(e.iridescenceThicknessMap)),
                e.transmissionMap !== void 0 && (a.transmissionMap = o(e.transmissionMap)),
                e.thicknessMap !== void 0 && (a.thicknessMap = o(e.thicknessMap)),
                e.sheenColorMap !== void 0 && (a.sheenColorMap = o(e.sheenColorMap)),
                e.sheenRoughnessMap !== void 0 && (a.sheenRoughnessMap = o(e.sheenRoughnessMap)),
                a
            }
            setTextures(e) {
                return this.textures = e,
                this
            }
            static createMaterialFromType(e) {
                const i = {
                    ShadowMaterial: ib,
                    SpriteMaterial: h0,
                    RawShaderMaterial: rb,
                    ShaderMaterial: ja,
                    PointsMaterial: m0,
                    MeshPhysicalMaterial: sb,
                    MeshStandardMaterial: P0,
                    MeshPhongMaterial: ob,
                    MeshToonMaterial: ab,
                    MeshNormalMaterial: lb,
                    MeshLambertMaterial: cb,
                    MeshDepthMaterial: a0,
                    MeshDistanceMaterial: l0,
                    MeshBasicMaterial: ql,
                    MeshMatcapMaterial: ub,
                    LineDashedMaterial: hb,
                    LineBasicMaterial: ro,
                    Material: Vs
                };
                return new i[e]
            }
        }
        class z0 {
            static decodeText(e) {
                if (typeof TextDecoder < "u")
                    return new TextDecoder().decode(e);
                let i = "";
                for (let o = 0, a = e.length; o < a; o++)
                    i += String.fromCharCode(e[o]);
                try {
                    return decodeURIComponent(escape(i))
                } catch {
                    return i
                }
            }
            static extractUrlBase(e) {
                const i = e.lastIndexOf("/");
                return i === -1 ? "./" : e.slice(0, i + 1)
            }
            static resolveURL(e, i) {
                return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(i) && /^\//.test(e) && (i = i.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : i + e)
            }
        }
        class Mb extends Ai {
            constructor() {
                super(),
                this.isInstancedBufferGeometry = !0,
                this.type = "InstancedBufferGeometry",
                this.instanceCount = 1 / 0
            }
            copy(e) {
                return super.copy(e),
                this.instanceCount = e.instanceCount,
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.instanceCount = this.instanceCount,
                e.isInstancedBufferGeometry = !0,
                e
            }
        }
        class Cb extends Oo {
            constructor(e) {
                super(e)
            }
            load(e, i, o, a) {
                const c = this
                  , d = new Al(c.manager);
                d.setPath(c.path),
                d.setRequestHeader(c.requestHeader),
                d.setWithCredentials(c.withCredentials),
                d.load(e, function(f) {
                    try {
                        i(c.parse(JSON.parse(f)))
                    } catch (v) {
                        a ? a(v) : console.error(v),
                        c.manager.itemError(e)
                    }
                }, o, a)
            }
            parse(e) {
                const i = {}
                  , o = {};
                function a(I, z) {
                    if (i[z] !== void 0)
                        return i[z];
                    const k = I.interleavedBuffers[z]
                      , Q = c(I, k.buffer)
                      , Z = Yl(k.type, Q)
                      , X = new fp(Z,k.stride);
                    return X.uuid = k.uuid,
                    i[z] = X,
                    X
                }
                function c(I, z) {
                    if (o[z] !== void 0)
                        return o[z];
                    const k = I.arrayBuffers[z]
                      , Q = new Uint32Array(k).buffer;
                    return o[z] = Q,
                    Q
                }
                const d = e.isInstancedBufferGeometry ? new Mb : new Ai
                  , f = e.data.index;
                if (f !== void 0) {
                    const I = Yl(f.type, f.array);
                    d.setIndex(new dr(I,1))
                }
                const v = e.data.attributes;
                for (const I in v) {
                    const z = v[I];
                    let O;
                    if (z.isInterleavedBufferAttribute) {
                        const k = a(e.data, z.data);
                        O = new Hc(k,z.itemSize,z.offset,z.normalized)
                    } else {
                        const k = Yl(z.type, z.array)
                          , Q = z.isInstancedBufferAttribute ? ju : dr;
                        O = new Q(k,z.itemSize,z.normalized)
                    }
                    z.name !== void 0 && (O.name = z.name),
                    z.usage !== void 0 && O.setUsage(z.usage),
                    z.updateRange !== void 0 && (O.updateRange.offset = z.updateRange.offset,
                    O.updateRange.count = z.updateRange.count),
                    d.setAttribute(I, O)
                }
                const x = e.data.morphAttributes;
                if (x)
                    for (const I in x) {
                        const z = x[I]
                          , O = [];
                        for (let k = 0, Q = z.length; k < Q; k++) {
                            const Z = z[k];
                            let X;
                            if (Z.isInterleavedBufferAttribute) {
                                const K = a(e.data, Z.data);
                                X = new Hc(K,Z.itemSize,Z.offset,Z.normalized)
                            } else {
                                const K = Yl(Z.type, Z.array);
                                X = new dr(K,Z.itemSize,Z.normalized)
                            }
                            Z.name !== void 0 && (X.name = Z.name),
                            O.push(X)
                        }
                        d.morphAttributes[I] = O
                    }
                e.data.morphTargetsRelative && (d.morphTargetsRelative = !0);
                const P = e.data.groups || e.data.drawcalls || e.data.offsets;
                if (P !== void 0)
                    for (let I = 0, z = P.length; I !== z; ++I) {
                        const O = P[I];
                        d.addGroup(O.start, O.count, O.materialIndex)
                    }
                const M = e.data.boundingSphere;
                if (M !== void 0) {
                    const I = new me;
                    M.center !== void 0 && I.fromArray(M.center),
                    d.boundingSphere = new Nc(I,M.radius)
                }
                return e.name && (d.name = e.name),
                e.userData && (d.userData = e.userData),
                d
            }
        }
        class ZR extends Oo {
            constructor(e) {
                super(e)
            }
            load(e, i, o, a) {
                const c = this
                  , d = this.path === "" ? z0.extractUrlBase(e) : this.path;
                this.resourcePath = this.resourcePath || d;
                const f = new Al(this.manager);
                f.setPath(this.path),
                f.setRequestHeader(this.requestHeader),
                f.setWithCredentials(this.withCredentials),
                f.load(e, function(v) {
                    let x = null;
                    try {
                        x = JSON.parse(v)
                    } catch (P) {
                        a !== void 0 && a(P),
                        console.error("THREE:ObjectLoader: Can't parse " + e + ".", P.message);
                        return
                    }
                    const w = x.metadata;
                    if (w === void 0 || w.type === void 0 || w.type.toLowerCase() === "geometry") {
                        a !== void 0 && a(new Error("THREE.ObjectLoader: Can't load " + e)),
                        console.error("THREE.ObjectLoader: Can't load " + e);
                        return
                    }
                    c.parse(x, i)
                }, o, a)
            }
            async loadAsync(e, i) {
                const o = this
                  , a = this.path === "" ? z0.extractUrlBase(e) : this.path;
                this.resourcePath = this.resourcePath || a;
                const c = new Al(this.manager);
                c.setPath(this.path),
                c.setRequestHeader(this.requestHeader),
                c.setWithCredentials(this.withCredentials);
                const d = await c.loadAsync(e, i)
                  , f = JSON.parse(d)
                  , v = f.metadata;
                if (v === void 0 || v.type === void 0 || v.type.toLowerCase() === "geometry")
                    throw new Error("THREE.ObjectLoader: Can't load " + e);
                return await o.parseAsync(f)
            }
            parse(e, i) {
                const o = this.parseAnimations(e.animations)
                  , a = this.parseShapes(e.shapes)
                  , c = this.parseGeometries(e.geometries, a)
                  , d = this.parseImages(e.images, function() {
                    i !== void 0 && i(x)
                })
                  , f = this.parseTextures(e.textures, d)
                  , v = this.parseMaterials(e.materials, f)
                  , x = this.parseObject(e.object, c, v, f, o)
                  , w = this.parseSkeletons(e.skeletons, x);
                if (this.bindSkeletons(x, w),
                i !== void 0) {
                    let P = !1;
                    for (const M in d)
                        if (d[M].data instanceof HTMLImageElement) {
                            P = !0;
                            break
                        }
                    P === !1 && i(x)
                }
                return x
            }
            async parseAsync(e) {
                const i = this.parseAnimations(e.animations)
                  , o = this.parseShapes(e.shapes)
                  , a = this.parseGeometries(e.geometries, o)
                  , c = await this.parseImagesAsync(e.images)
                  , d = this.parseTextures(e.textures, c)
                  , f = this.parseMaterials(e.materials, d)
                  , v = this.parseObject(e.object, a, f, d, i)
                  , x = this.parseSkeletons(e.skeletons, v);
                return this.bindSkeletons(v, x),
                v
            }
            parseShapes(e) {
                const i = {};
                if (e !== void 0)
                    for (let o = 0, a = e.length; o < a; o++) {
                        const c = new Wc().fromJSON(e[o]);
                        i[c.uuid] = c
                    }
                return i
            }
            parseSkeletons(e, i) {
                const o = {}
                  , a = {};
                if (i.traverse(function(c) {
                    c.isBone && (a[c.uuid] = c)
                }),
                e !== void 0)
                    for (let c = 0, d = e.length; c < d; c++) {
                        const f = new _p().fromJSON(e[c], a);
                        o[f.uuid] = f
                    }
                return o
            }
            parseGeometries(e, i) {
                const o = {};
                if (e !== void 0) {
                    const a = new Cb;
                    for (let c = 0, d = e.length; c < d; c++) {
                        let f;
                        const v = e[c];
                        switch (v.type) {
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            f = a.parse(v);
                            break;
                        default:
                            v.type in h ? f = h[v.type].fromJSON(v, i) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${v.type}"`)
                        }
                        f.uuid = v.uuid,
                        v.name !== void 0 && (f.name = v.name),
                        v.userData !== void 0 && (f.userData = v.userData),
                        o[v.uuid] = f
                    }
                }
                return o
            }
            parseMaterials(e, i) {
                const o = {}
                  , a = {};
                if (e !== void 0) {
                    const c = new Ip;
                    c.setTextures(i);
                    for (let d = 0, f = e.length; d < f; d++) {
                        const v = e[d];
                        o[v.uuid] === void 0 && (o[v.uuid] = c.parse(v)),
                        a[v.uuid] = o[v.uuid]
                    }
                }
                return a
            }
            parseAnimations(e) {
                const i = {};
                if (e !== void 0)
                    for (let o = 0; o < e.length; o++) {
                        const a = e[o]
                          , c = Ad.parse(a);
                        i[c.uuid] = c
                    }
                return i
            }
            parseImages(e, i) {
                const o = this
                  , a = {};
                let c;
                function d(v) {
                    return o.manager.itemStart(v),
                    c.load(v, function() {
                        o.manager.itemEnd(v)
                    }, void 0, function() {
                        o.manager.itemError(v),
                        o.manager.itemEnd(v)
                    })
                }
                function f(v) {
                    if (typeof v == "string") {
                        const x = v
                          , w = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(x) ? x : o.resourcePath + x;
                        return d(w)
                    } else
                        return v.data ? {
                            data: Yl(v.type, v.data),
                            width: v.width,
                            height: v.height
                        } : null
                }
                if (e !== void 0 && e.length > 0) {
                    const v = new B0(i);
                    c = new Sd(v),
                    c.setCrossOrigin(this.crossOrigin);
                    for (let x = 0, w = e.length; x < w; x++) {
                        const P = e[x]
                          , M = P.url;
                        if (Array.isArray(M)) {
                            const I = [];
                            for (let z = 0, O = M.length; z < O; z++) {
                                const k = M[z]
                                  , Q = f(k);
                                Q !== null && (Q instanceof HTMLImageElement ? I.push(Q) : I.push(new Wu(Q.data,Q.width,Q.height)))
                            }
                            a[P.uuid] = new Nn(I)
                        } else {
                            const I = f(P.url);
                            a[P.uuid] = new Nn(I)
                        }
                    }
                }
                return a
            }
            async parseImagesAsync(e) {
                const i = this
                  , o = {};
                let a;
                async function c(d) {
                    if (typeof d == "string") {
                        const f = d
                          , v = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : i.resourcePath + f;
                        return await a.loadAsync(v)
                    } else
                        return d.data ? {
                            data: Yl(d.type, d.data),
                            width: d.width,
                            height: d.height
                        } : null
                }
                if (e !== void 0 && e.length > 0) {
                    a = new Sd(this.manager),
                    a.setCrossOrigin(this.crossOrigin);
                    for (let d = 0, f = e.length; d < f; d++) {
                        const v = e[d]
                          , x = v.url;
                        if (Array.isArray(x)) {
                            const w = [];
                            for (let P = 0, M = x.length; P < M; P++) {
                                const I = x[P]
                                  , z = await c(I);
                                z !== null && (z instanceof HTMLImageElement ? w.push(z) : w.push(new Wu(z.data,z.width,z.height)))
                            }
                            o[v.uuid] = new Nn(w)
                        } else {
                            const w = await c(v.url);
                            o[v.uuid] = new Nn(w)
                        }
                    }
                }
                return o
            }
            parseTextures(e, i) {
                function o(c, d) {
                    return typeof c == "number" ? c : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", c),
                    d[c])
                }
                const a = {};
                if (e !== void 0)
                    for (let c = 0, d = e.length; c < d; c++) {
                        const f = e[c];
                        f.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', f.uuid),
                        i[f.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", f.image);
                        const v = i[f.image]
                          , x = v.data;
                        let w;
                        Array.isArray(x) ? (w = new Zh,
                        x.length === 6 && (w.needsUpdate = !0)) : (x && x.data ? w = new Wu : w = new $t,
                        x && (w.needsUpdate = !0)),
                        w.source = v,
                        w.uuid = f.uuid,
                        f.name !== void 0 && (w.name = f.name),
                        f.mapping !== void 0 && (w.mapping = o(f.mapping, qR)),
                        f.offset !== void 0 && w.offset.fromArray(f.offset),
                        f.repeat !== void 0 && w.repeat.fromArray(f.repeat),
                        f.center !== void 0 && w.center.fromArray(f.center),
                        f.rotation !== void 0 && (w.rotation = f.rotation),
                        f.wrap !== void 0 && (w.wrapS = o(f.wrap[0], Pb),
                        w.wrapT = o(f.wrap[1], Pb)),
                        f.format !== void 0 && (w.format = f.format),
                        f.internalFormat !== void 0 && (w.internalFormat = f.internalFormat),
                        f.type !== void 0 && (w.type = f.type),
                        f.encoding !== void 0 && (w.encoding = f.encoding),
                        f.minFilter !== void 0 && (w.minFilter = o(f.minFilter, Rb)),
                        f.magFilter !== void 0 && (w.magFilter = o(f.magFilter, Rb)),
                        f.anisotropy !== void 0 && (w.anisotropy = f.anisotropy),
                        f.flipY !== void 0 && (w.flipY = f.flipY),
                        f.generateMipmaps !== void 0 && (w.generateMipmaps = f.generateMipmaps),
                        f.premultiplyAlpha !== void 0 && (w.premultiplyAlpha = f.premultiplyAlpha),
                        f.unpackAlignment !== void 0 && (w.unpackAlignment = f.unpackAlignment),
                        f.userData !== void 0 && (w.userData = f.userData),
                        a[f.uuid] = w
                    }
                return a
            }
            parseObject(e, i, o, a, c) {
                let d;
                function f(M) {
                    return i[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", M),
                    i[M]
                }
                function v(M) {
                    if (M !== void 0) {
                        if (Array.isArray(M)) {
                            const I = [];
                            for (let z = 0, O = M.length; z < O; z++) {
                                const k = M[z];
                                o[k] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", k),
                                I.push(o[k])
                            }
                            return I
                        }
                        return o[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", M),
                        o[M]
                    }
                }
                function x(M) {
                    return a[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", M),
                    a[M]
                }
                let w, P;
                switch (e.type) {
                case "Scene":
                    d = new v1,
                    e.background !== void 0 && (Number.isInteger(e.background) ? d.background = new gn(e.background) : d.background = x(e.background)),
                    e.environment !== void 0 && (d.environment = x(e.environment)),
                    e.fog !== void 0 && (e.fog.type === "Fog" ? d.fog = new dp(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (d.fog = new hp(e.fog.color,e.fog.density))),
                    e.backgroundBlurriness !== void 0 && (d.backgroundBlurriness = e.backgroundBlurriness),
                    e.backgroundIntensity !== void 0 && (d.backgroundIntensity = e.backgroundIntensity);
                    break;
                case "PerspectiveCamera":
                    d = new Ms(e.fov,e.aspect,e.near,e.far),
                    e.focus !== void 0 && (d.focus = e.focus),
                    e.zoom !== void 0 && (d.zoom = e.zoom),
                    e.filmGauge !== void 0 && (d.filmGauge = e.filmGauge),
                    e.filmOffset !== void 0 && (d.filmOffset = e.filmOffset),
                    e.view !== void 0 && (d.view = Object.assign({}, e.view));
                    break;
                case "OrthographicCamera":
                    d = new ap(e.left,e.right,e.top,e.bottom,e.near,e.far),
                    e.zoom !== void 0 && (d.zoom = e.zoom),
                    e.view !== void 0 && (d.view = Object.assign({}, e.view));
                    break;
                case "AmbientLight":
                    d = new Sb(e.color,e.intensity);
                    break;
                case "DirectionalLight":
                    d = new Ab(e.color,e.intensity);
                    break;
                case "PointLight":
                    d = new wb(e.color,e.intensity,e.distance,e.decay);
                    break;
                case "RectAreaLight":
                    d = new Tb(e.color,e.intensity,e.width,e.height);
                    break;
                case "SpotLight":
                    d = new xb(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
                    break;
                case "HemisphereLight":
                    d = new vb(e.color,e.groundColor,e.intensity);
                    break;
                case "LightProbe":
                    d = new Lp().fromJSON(e);
                    break;
                case "SkinnedMesh":
                    w = f(e.geometry),
                    P = v(e.material),
                    d = new C1(w,P),
                    e.bindMode !== void 0 && (d.bindMode = e.bindMode),
                    e.bindMatrix !== void 0 && d.bindMatrix.fromArray(e.bindMatrix),
                    e.skeleton !== void 0 && (d.skeleton = e.skeleton);
                    break;
                case "Mesh":
                    w = f(e.geometry),
                    P = v(e.material),
                    d = new Es(w,P);
                    break;
                case "InstancedMesh":
                    w = f(e.geometry),
                    P = v(e.material);
                    const M = e.count
                      , I = e.instanceMatrix
                      , z = e.instanceColor;
                    d = new L1(w,P,M),
                    d.instanceMatrix = new ju(new Float32Array(I.array),16),
                    z !== void 0 && (d.instanceColor = new ju(new Float32Array(z.array),z.itemSize));
                    break;
                case "LOD":
                    d = new A1;
                    break;
                case "Line":
                    d = new ec(f(e.geometry),v(e.material));
                    break;
                case "LineLoop":
                    d = new U1(f(e.geometry),v(e.material));
                    break;
                case "LineSegments":
                    d = new Xa(f(e.geometry),v(e.material));
                    break;
                case "PointCloud":
                case "Points":
                    d = new z1(f(e.geometry),v(e.material));
                    break;
                case "Sprite":
                    d = new b1(v(e.material));
                    break;
                case "Group":
                    d = new Nu;
                    break;
                case "Bone":
                    d = new f0;
                    break;
                default:
                    d = new Qi
                }
                if (d.uuid = e.uuid,
                e.name !== void 0 && (d.name = e.name),
                e.matrix !== void 0 ? (d.matrix.fromArray(e.matrix),
                e.matrixAutoUpdate !== void 0 && (d.matrixAutoUpdate = e.matrixAutoUpdate),
                d.matrixAutoUpdate && d.matrix.decompose(d.position, d.quaternion, d.scale)) : (e.position !== void 0 && d.position.fromArray(e.position),
                e.rotation !== void 0 && d.rotation.fromArray(e.rotation),
                e.quaternion !== void 0 && d.quaternion.fromArray(e.quaternion),
                e.scale !== void 0 && d.scale.fromArray(e.scale)),
                e.castShadow !== void 0 && (d.castShadow = e.castShadow),
                e.receiveShadow !== void 0 && (d.receiveShadow = e.receiveShadow),
                e.shadow && (e.shadow.bias !== void 0 && (d.shadow.bias = e.shadow.bias),
                e.shadow.normalBias !== void 0 && (d.shadow.normalBias = e.shadow.normalBias),
                e.shadow.radius !== void 0 && (d.shadow.radius = e.shadow.radius),
                e.shadow.mapSize !== void 0 && d.shadow.mapSize.fromArray(e.shadow.mapSize),
                e.shadow.camera !== void 0 && (d.shadow.camera = this.parseObject(e.shadow.camera))),
                e.visible !== void 0 && (d.visible = e.visible),
                e.frustumCulled !== void 0 && (d.frustumCulled = e.frustumCulled),
                e.renderOrder !== void 0 && (d.renderOrder = e.renderOrder),
                e.userData !== void 0 && (d.userData = e.userData),
                e.layers !== void 0 && (d.layers.mask = e.layers),
                e.children !== void 0) {
                    const M = e.children;
                    for (let I = 0; I < M.length; I++)
                        d.add(this.parseObject(M[I], i, o, a, c))
                }
                if (e.animations !== void 0) {
                    const M = e.animations;
                    for (let I = 0; I < M.length; I++) {
                        const z = M[I];
                        d.animations.push(c[z])
                    }
                }
                if (e.type === "LOD") {
                    e.autoUpdate !== void 0 && (d.autoUpdate = e.autoUpdate);
                    const M = e.levels;
                    for (let I = 0; I < M.length; I++) {
                        const z = M[I]
                          , O = d.getObjectByProperty("uuid", z.object);
                        O !== void 0 && d.addLevel(O, z.distance, z.hysteresis)
                    }
                }
                return d
            }
            bindSkeletons(e, i) {
                Object.keys(i).length !== 0 && e.traverse(function(o) {
                    if (o.isSkinnedMesh === !0 && o.skeleton !== void 0) {
                        const a = i[o.skeleton];
                        a === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", o.skeleton) : o.bind(a, o.bindMatrix)
                    }
                })
            }
        }
        const qR = {
            UVMapping: Fi,
            CubeReflectionMapping: vr,
            CubeRefractionMapping: Oi,
            EquirectangularReflectionMapping: ts,
            EquirectangularRefractionMapping: Gr,
            CubeUVReflectionMapping: ys
        }
          , Pb = {
            RepeatWrapping: xs,
            ClampToEdgeWrapping: hi,
            MirroredRepeatWrapping: Ti
        }
          , Rb = {
            NearestFilter: gi,
            NearestMipmapNearestFilter: qi,
            NearestMipmapLinearFilter: Gi,
            LinearFilter: Hi,
            LinearMipmapNearestFilter: Us,
            LinearMipmapLinearFilter: Fr
        };
        class JR extends Oo {
            constructor(e) {
                super(e),
                this.isImageBitmapLoader = !0,
                typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(e) {
                return this.options = e,
                this
            }
            load(e, i, o, a) {
                e === void 0 && (e = ""),
                this.path !== void 0 && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const c = this
                  , d = tc.get(e);
                if (d !== void 0)
                    return c.manager.itemStart(e),
                    setTimeout(function() {
                        i && i(d),
                        c.manager.itemEnd(e)
                    }, 0),
                    d;
                const f = {};
                f.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
                f.headers = this.requestHeader,
                fetch(e, f).then(function(v) {
                    return v.blob()
                }).then(function(v) {
                    return createImageBitmap(v, Object.assign(c.options, {
                        colorSpaceConversion: "none"
                    }))
                }).then(function(v) {
                    tc.add(e, v),
                    i && i(v),
                    c.manager.itemEnd(e)
                }).catch(function(v) {
                    a && a(v),
                    c.manager.itemError(e),
                    c.manager.itemEnd(e)
                }),
                c.manager.itemStart(e)
            }
        }
        let Op;
        class G0 {
            static getContext() {
                return Op === void 0 && (Op = new (window.AudioContext || window.webkitAudioContext)),
                Op
            }
            static setContext(e) {
                Op = e
            }
        }
        class $R extends Oo {
            constructor(e) {
                super(e)
            }
            load(e, i, o, a, c) {
                const d = this
                  , f = new Al(this.manager);
                f.setResponseType("arraybuffer"),
                f.setPath(this.path),
                f.setRequestHeader(this.requestHeader),
                f.setWithCredentials(this.withCredentials),
                f.load(e, function(v) {
                    try {
                        const x = v.slice(0);
                        G0.getContext().decodeAudioData(x, function(P) {
                            i(P)
                        })
                    } catch (x) {
                        a ? a(x) : console.error(x),
                        d.manager.itemError(e)
                    }
                }, o, a, c == null ? void 0 : c.mainFile)
            }
        }
        class eD extends Lp {
            constructor(e, i, o=1) {
                super(void 0, o),
                this.isHemisphereLightProbe = !0;
                const a = new gn().set(e)
                  , c = new gn().set(i)
                  , d = new me(a.r,a.g,a.b)
                  , f = new me(c.r,c.g,c.b)
                  , v = Math.sqrt(Math.PI)
                  , x = v * Math.sqrt(.75);
                this.sh.coefficients[0].copy(d).add(f).multiplyScalar(v),
                this.sh.coefficients[1].copy(d).sub(f).multiplyScalar(x)
            }
        }
        class tD extends Lp {
            constructor(e, i=1) {
                super(void 0, i),
                this.isAmbientLightProbe = !0;
                const o = new gn().set(e);
                this.sh.coefficients[0].set(o.r, o.g, o.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
        }
        const Db = new pi
          , Lb = new pi
          , Kc = new pi;
        class nD {
            constructor() {
                this.type = "StereoCamera",
                this.aspect = 1,
                this.eyeSep = .064,
                this.cameraL = new Ms,
                this.cameraL.layers.enable(1),
                this.cameraL.matrixAutoUpdate = !1,
                this.cameraR = new Ms,
                this.cameraR.layers.enable(2),
                this.cameraR.matrixAutoUpdate = !1,
                this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }
            update(e) {
                const i = this._cache;
                if (i.focus !== e.focus || i.fov !== e.fov || i.aspect !== e.aspect * this.aspect || i.near !== e.near || i.far !== e.far || i.zoom !== e.zoom || i.eyeSep !== this.eyeSep) {
                    i.focus = e.focus,
                    i.fov = e.fov,
                    i.aspect = e.aspect * this.aspect,
                    i.near = e.near,
                    i.far = e.far,
                    i.zoom = e.zoom,
                    i.eyeSep = this.eyeSep,
                    Kc.copy(e.projectionMatrix);
                    const a = i.eyeSep / 2
                      , c = a * i.near / i.focus
                      , d = i.near * Math.tan(wi * i.fov * .5) / i.zoom;
                    let f, v;
                    Lb.elements[12] = -a,
                    Db.elements[12] = a,
                    f = -d * i.aspect + c,
                    v = d * i.aspect + c,
                    Kc.elements[0] = 2 * i.near / (v - f),
                    Kc.elements[8] = (v + f) / (v - f),
                    this.cameraL.projectionMatrix.copy(Kc),
                    f = -d * i.aspect - c,
                    v = d * i.aspect - c,
                    Kc.elements[0] = 2 * i.near / (v - f),
                    Kc.elements[8] = (v + f) / (v - f),
                    this.cameraR.projectionMatrix.copy(Kc)
                }
                this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Lb),
                this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Db)
            }
        }
        class Ib {
            constructor(e=!0) {
                this.autoStart = e,
                this.startTime = 0,
                this.oldTime = 0,
                this.elapsedTime = 0,
                this.running = !1
            }
            start() {
                this.startTime = Ob(),
                this.oldTime = this.startTime,
                this.elapsedTime = 0,
                this.running = !0
            }
            stop() {
                this.getElapsedTime(),
                this.running = !1,
                this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(),
                this.elapsedTime
            }
            getDelta() {
                let e = 0;
                if (this.autoStart && !this.running)
                    return this.start(),
                    0;
                if (this.running) {
                    const i = Ob();
                    e = (i - this.oldTime) / 1e3,
                    this.oldTime = i,
                    this.elapsedTime += e
                }
                return e
            }
        }
        function Ob() {
            return (typeof performance > "u" ? Date : performance).now()
        }
        const Zc = new me
          , Bb = new Vi
          , iD = new me
          , qc = new me;
        class rD extends Qi {
            constructor() {
                super(),
                this.type = "AudioListener",
                this.context = G0.getContext(),
                this.gain = this.context.createGain(),
                this.gain.connect(this.context.destination),
                this.filter = null,
                this.timeDelta = 0,
                this._clock = new Ib
            }
            getInput() {
                return this.gain
            }
            removeFilter() {
                return this.filter !== null && (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                this.filter = null),
                this
            }
            getFilter() {
                return this.filter
            }
            setFilter(e) {
                return this.filter !== null ? (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                this.filter = e,
                this.gain.connect(this.filter),
                this.filter.connect(this.context.destination),
                this
            }
            getMasterVolume() {
                return this.gain.gain.value
            }
            setMasterVolume(e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                this
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e);
                const i = this.context.listener
                  , o = this.up;
                if (this.timeDelta = this._clock.getDelta(),
                this.matrixWorld.decompose(Zc, Bb, iD),
                qc.set(0, 0, -1).applyQuaternion(Bb),
                i.positionX) {
                    const a = this.context.currentTime + this.timeDelta;
                    i.positionX.linearRampToValueAtTime(Zc.x, a),
                    i.positionY.linearRampToValueAtTime(Zc.y, a),
                    i.positionZ.linearRampToValueAtTime(Zc.z, a),
                    i.forwardX.linearRampToValueAtTime(qc.x, a),
                    i.forwardY.linearRampToValueAtTime(qc.y, a),
                    i.forwardZ.linearRampToValueAtTime(qc.z, a),
                    i.upX.linearRampToValueAtTime(o.x, a),
                    i.upY.linearRampToValueAtTime(o.y, a),
                    i.upZ.linearRampToValueAtTime(o.z, a)
                } else
                    i.setPosition(Zc.x, Zc.y, Zc.z),
                    i.setOrientation(qc.x, qc.y, qc.z, o.x, o.y, o.z)
            }
        }
        class Fb extends Qi {
            constructor(e) {
                super(),
                this.type = "Audio",
                this.listener = e,
                this.context = e.context,
                this.gain = this.context.createGain(),
                this.gain.connect(e.getInput()),
                this.autoplay = !1,
                this.buffer = null,
                this.detune = 0,
                this.loop = !1,
                this.loopStart = 0,
                this.loopEnd = 0,
                this.offset = 0,
                this.duration = void 0,
                this.playbackRate = 1,
                this.isPlaying = !1,
                this.hasPlaybackControl = !0,
                this.source = null,
                this.sourceType = "empty",
                this._startedAt = 0,
                this._progress = 0,
                this._connected = !1,
                this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(e) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "audioNode",
                this.source = e,
                this.connect(),
                this
            }
            setMediaElementSource(e) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaNode",
                this.source = this.context.createMediaElementSource(e),
                this.connect(),
                this
            }
            setMediaStreamSource(e) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaStreamNode",
                this.source = this.context.createMediaStreamSource(e),
                this.connect(),
                this
            }
            setBuffer(e) {
                return this.buffer = e,
                this.sourceType = "buffer",
                this.autoplay && this.play(),
                this
            }
            play(e=0) {
                if (this.isPlaying === !0) {
                    console.warn("THREE.Audio: Audio is already playing.");
                    return
                }
                if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return
                }
                this._startedAt = this.context.currentTime + e;
                const i = this.context.createBufferSource();
                return i.buffer = this.buffer,
                i.loop = this.loop,
                i.loopStart = this.loopStart,
                i.loopEnd = this.loopEnd,
                i.onended = this.onEnded.bind(this),
                i.start(this._startedAt, this._progress + this.offset, this.duration),
                this.isPlaying = !0,
                this.source = i,
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            }
            pause() {
                if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return
                }
                return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1),
                this
            }
            stop() {
                if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return
                }
                return this._progress = 0,
                this.source !== null && (this.source.stop(),
                this.source.onended = null),
                this.isPlaying = !1,
                this
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let e = 1, i = this.filters.length; e < i; e++)
                        this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else
                    this.source.connect(this.getOutput());
                return this._connected = !0,
                this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let e = 1, i = this.filters.length; e < i; e++)
                        this.filters[e - 1].disconnect(this.filters[e]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else
                    this.source.disconnect(this.getOutput());
                return this._connected = !1,
                this
            }
            getFilters() {
                return this.filters
            }
            setFilters(e) {
                return e || (e = []),
                this._connected === !0 ? (this.disconnect(),
                this.filters = e.slice(),
                this.connect()) : this.filters = e.slice(),
                this
            }
            setDetune(e) {
                if (this.detune = e,
                this.source.detune !== void 0)
                    return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                    this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(e) {
                return this.setFilters(e ? [e] : [])
            }
            setPlaybackRate(e) {
                if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return
                }
                return this.playbackRate = e,
                this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
                !1) : this.loop
            }
            setLoop(e) {
                if (this.hasPlaybackControl === !1) {
                    console.warn("THREE.Audio: this Audio has no playback control.");
                    return
                }
                return this.loop = e,
                this.isPlaying === !0 && (this.source.loop = this.loop),
                this
            }
            setLoopStart(e) {
                return this.loopStart = e,
                this
            }
            setLoopEnd(e) {
                return this.loopEnd = e,
                this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
                this
            }
        }
        const Jc = new me
          , kb = new Vi
          , sD = new me
          , $c = new me;
        class oD extends Fb {
            constructor(e) {
                super(e),
                this.panner = this.context.createPanner(),
                this.panner.panningModel = "HRTF",
                this.panner.connect(this.gain)
            }
            disconnect() {
                super.disconnect(),
                this.panner.disconnect(this.gain)
            }
            getOutput() {
                return this.panner
            }
            getRefDistance() {
                return this.panner.refDistance
            }
            setRefDistance(e) {
                return this.panner.refDistance = e,
                this
            }
            getRolloffFactor() {
                return this.panner.rolloffFactor
            }
            setRolloffFactor(e) {
                return this.panner.rolloffFactor = e,
                this
            }
            getDistanceModel() {
                return this.panner.distanceModel
            }
            setDistanceModel(e) {
                return this.panner.distanceModel = e,
                this
            }
            getMaxDistance() {
                return this.panner.maxDistance
            }
            setMaxDistance(e) {
                return this.panner.maxDistance = e,
                this
            }
            setDirectionalCone(e, i, o) {
                return this.panner.coneInnerAngle = e,
                this.panner.coneOuterAngle = i,
                this.panner.coneOuterGain = o,
                this
            }
            updateMatrixWorld(e) {
                if (super.updateMatrixWorld(e),
                this.hasPlaybackControl === !0 && this.isPlaying === !1)
                    return;
                this.matrixWorld.decompose(Jc, kb, sD),
                $c.set(0, 0, 1).applyQuaternion(kb);
                const i = this.panner;
                if (i.positionX) {
                    const o = this.context.currentTime + this.listener.timeDelta;
                    i.positionX.linearRampToValueAtTime(Jc.x, o),
                    i.positionY.linearRampToValueAtTime(Jc.y, o),
                    i.positionZ.linearRampToValueAtTime(Jc.z, o),
                    i.orientationX.linearRampToValueAtTime($c.x, o),
                    i.orientationY.linearRampToValueAtTime($c.y, o),
                    i.orientationZ.linearRampToValueAtTime($c.z, o)
                } else
                    i.setPosition(Jc.x, Jc.y, Jc.z),
                    i.setOrientation($c.x, $c.y, $c.z)
            }
        }
        class aD {
            constructor(e, i=2048) {
                this.analyser = e.context.createAnalyser(),
                this.analyser.fftSize = i,
                this.data = new Uint8Array(this.analyser.frequencyBinCount),
                e.getOutput().connect(this.analyser)
            }
            getFrequencyData() {
                return this.analyser.getByteFrequencyData(this.data),
                this.data
            }
            getAverageFrequency() {
                let e = 0;
                const i = this.getFrequencyData();
                for (let o = 0; o < i.length; o++)
                    e += i[o];
                return e / i.length
            }
        }
        class Ub {
            constructor(e, i, o) {
                this.binding = e,
                this.valueSize = o;
                let a, c, d;
                switch (i) {
                case "quaternion":
                    a = this._slerp,
                    c = this._slerpAdditive,
                    d = this._setAdditiveIdentityQuaternion,
                    this.buffer = new Float64Array(o * 6),
                    this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    a = this._select,
                    c = this._select,
                    d = this._setAdditiveIdentityOther,
                    this.buffer = new Array(o * 5);
                    break;
                default:
                    a = this._lerp,
                    c = this._lerpAdditive,
                    d = this._setAdditiveIdentityNumeric,
                    this.buffer = new Float64Array(o * 5)
                }
                this._mixBufferRegion = a,
                this._mixBufferRegionAdditive = c,
                this._setIdentity = d,
                this._origIndex = 3,
                this._addIndex = 4,
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                this.useCount = 0,
                this.referenceCount = 0
            }
            accumulate(e, i) {
                const o = this.buffer
                  , a = this.valueSize
                  , c = e * a + a;
                let d = this.cumulativeWeight;
                if (d === 0) {
                    for (let f = 0; f !== a; ++f)
                        o[c + f] = o[f];
                    d = i
                } else {
                    d += i;
                    const f = i / d;
                    this._mixBufferRegion(o, c, 0, f, a)
                }
                this.cumulativeWeight = d
            }
            accumulateAdditive(e) {
                const i = this.buffer
                  , o = this.valueSize
                  , a = o * this._addIndex;
                this.cumulativeWeightAdditive === 0 && this._setIdentity(),
                this._mixBufferRegionAdditive(i, a, 0, e, o),
                this.cumulativeWeightAdditive += e
            }
            apply(e) {
                const i = this.valueSize
                  , o = this.buffer
                  , a = e * i + i
                  , c = this.cumulativeWeight
                  , d = this.cumulativeWeightAdditive
                  , f = this.binding;
                if (this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                c < 1) {
                    const v = i * this._origIndex;
                    this._mixBufferRegion(o, a, v, 1 - c, i)
                }
                d > 0 && this._mixBufferRegionAdditive(o, a, this._addIndex * i, 1, i);
                for (let v = i, x = i + i; v !== x; ++v)
                    if (o[v] !== o[v + i]) {
                        f.setValue(o, a);
                        break
                    }
            }
            saveOriginalState() {
                const e = this.binding
                  , i = this.buffer
                  , o = this.valueSize
                  , a = o * this._origIndex;
                e.getValue(i, a);
                for (let c = o, d = a; c !== d; ++c)
                    i[c] = i[a + c % o];
                this._setIdentity(),
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const e = this.valueSize * 3;
                this.binding.setValue(this.buffer, e)
            }
            _setAdditiveIdentityNumeric() {
                const e = this._addIndex * this.valueSize
                  , i = e + this.valueSize;
                for (let o = e; o < i; o++)
                    this.buffer[o] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(),
                this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const e = this._origIndex * this.valueSize
                  , i = this._addIndex * this.valueSize;
                for (let o = 0; o < this.valueSize; o++)
                    this.buffer[i + o] = this.buffer[e + o]
            }
            _select(e, i, o, a, c) {
                if (a >= .5)
                    for (let d = 0; d !== c; ++d)
                        e[i + d] = e[o + d]
            }
            _slerp(e, i, o, a) {
                Vi.slerpFlat(e, i, e, i, e, o, a)
            }
            _slerpAdditive(e, i, o, a, c) {
                const d = this._workIndex * c;
                Vi.multiplyQuaternionsFlat(e, d, e, i, e, o),
                Vi.slerpFlat(e, i, e, i, e, d, a)
            }
            _lerp(e, i, o, a, c) {
                const d = 1 - a;
                for (let f = 0; f !== c; ++f) {
                    const v = i + f;
                    e[v] = e[v] * d + e[o + f] * a
                }
            }
            _lerpAdditive(e, i, o, a, c) {
                for (let d = 0; d !== c; ++d) {
                    const f = i + d;
                    e[f] = e[f] + e[o + d] * a
                }
            }
        }
        const H0 = "\\[\\]\\.:\\/"
          , lD = new RegExp("[" + H0 + "]","g")
          , V0 = "[^" + H0 + "]"
          , cD = "[^" + H0.replace("\\.", "") + "]"
          , uD = /((?:WC+[\/:])*)/.source.replace("WC", V0)
          , hD = /(WCOD+)?/.source.replace("WCOD", cD)
          , dD = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", V0)
          , fD = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", V0)
          , pD = new RegExp("^" + uD + hD + dD + fD + "$")
          , mD = ["material", "materials", "bones", "map"];
        class gD {
            constructor(e, i, o) {
                const a = o || ji.parseTrackName(i);
                this._targetGroup = e,
                this._bindings = e.subscribe_(i, a)
            }
            getValue(e, i) {
                this.bind();
                const o = this._targetGroup.nCachedObjects_
                  , a = this._bindings[o];
                a !== void 0 && a.getValue(e, i)
            }
            setValue(e, i) {
                const o = this._bindings;
                for (let a = this._targetGroup.nCachedObjects_, c = o.length; a !== c; ++a)
                    o[a].setValue(e, i)
            }
            bind() {
                const e = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, o = e.length; i !== o; ++i)
                    e[i].bind()
            }
            unbind() {
                const e = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, o = e.length; i !== o; ++i)
                    e[i].unbind()
            }
        }
        class ji {
            constructor(e, i, o) {
                this.path = i,
                this.parsedPath = o || ji.parseTrackName(i),
                this.node = ji.findNode(e, this.parsedPath.nodeName),
                this.rootNode = e,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(e, i, o) {
                return e && e.isAnimationObjectGroup ? new ji.Composite(e,i,o) : new ji(e,i,o)
            }
            static sanitizeNodeName(e) {
                return e.replace(/\s/g, "_").replace(lD, "")
            }
            static parseTrackName(e) {
                const i = pD.exec(e);
                if (i === null)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                const o = {
                    nodeName: i[2],
                    objectName: i[3],
                    objectIndex: i[4],
                    propertyName: i[5],
                    propertyIndex: i[6]
                }
                  , a = o.nodeName && o.nodeName.lastIndexOf(".");
                if (a !== void 0 && a !== -1) {
                    const c = o.nodeName.substring(a + 1);
                    mD.indexOf(c) !== -1 && (o.nodeName = o.nodeName.substring(0, a),
                    o.objectName = c)
                }
                if (o.propertyName === null || o.propertyName.length === 0)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return o
            }
            static findNode(e, i) {
                if (i === void 0 || i === "" || i === "." || i === -1 || i === e.name || i === e.uuid)
                    return e;
                if (e.skeleton) {
                    const o = e.skeleton.getBoneByName(i);
                    if (o !== void 0)
                        return o
                }
                if (e.children) {
                    const o = function(c) {
                        for (let d = 0; d < c.length; d++) {
                            const f = c[d];
                            if (f.name === i || f.uuid === i)
                                return f;
                            const v = o(f.children);
                            if (v)
                                return v
                        }
                        return null
                    }
                      , a = o(e.children);
                    if (a)
                        return a
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(e, i) {
                e[i] = this.targetObject[this.propertyName]
            }
            _getValue_array(e, i) {
                const o = this.resolvedProperty;
                for (let a = 0, c = o.length; a !== c; ++a)
                    e[i++] = o[a]
            }
            _getValue_arrayElement(e, i) {
                e[i] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(e, i) {
                this.resolvedProperty.toArray(e, i)
            }
            _setValue_direct(e, i) {
                this.targetObject[this.propertyName] = e[i]
            }
            _setValue_direct_setNeedsUpdate(e, i) {
                this.targetObject[this.propertyName] = e[i],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(e, i) {
                this.targetObject[this.propertyName] = e[i],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(e, i) {
                const o = this.resolvedProperty;
                for (let a = 0, c = o.length; a !== c; ++a)
                    o[a] = e[i++]
            }
            _setValue_array_setNeedsUpdate(e, i) {
                const o = this.resolvedProperty;
                for (let a = 0, c = o.length; a !== c; ++a)
                    o[a] = e[i++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(e, i) {
                const o = this.resolvedProperty;
                for (let a = 0, c = o.length; a !== c; ++a)
                    o[a] = e[i++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(e, i) {
                this.resolvedProperty[this.propertyIndex] = e[i]
            }
            _setValue_arrayElement_setNeedsUpdate(e, i) {
                this.resolvedProperty[this.propertyIndex] = e[i],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, i) {
                this.resolvedProperty[this.propertyIndex] = e[i],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(e, i) {
                this.resolvedProperty.fromArray(e, i)
            }
            _setValue_fromArray_setNeedsUpdate(e, i) {
                this.resolvedProperty.fromArray(e, i),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(e, i) {
                this.resolvedProperty.fromArray(e, i),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(e, i) {
                this.bind(),
                this.getValue(e, i)
            }
            _setValue_unbound(e, i) {
                this.bind(),
                this.setValue(e, i)
            }
            bind() {
                let e = this.node;
                const i = this.parsedPath
                  , o = i.objectName
                  , a = i.propertyName;
                let c = i.propertyIndex;
                if (e || (e = ji.findNode(this.rootNode, i.nodeName),
                this.node = e),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !e) {
                    console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    return
                }
                if (o) {
                    let x = i.objectIndex;
                    switch (o) {
                    case "materials":
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return
                        }
                        if (!e.material.materials) {
                            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            return
                        }
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton) {
                            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            return
                        }
                        e = e.skeleton.bones;
                        for (let w = 0; w < e.length; w++)
                            if (e[w].name === x) {
                                x = w;
                                break
                            }
                        break;
                    case "map":
                        if ("map"in e) {
                            e = e.map;
                            break
                        }
                        if (!e.material) {
                            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            return
                        }
                        if (!e.material.map) {
                            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            return
                        }
                        e = e.material.map;
                        break;
                    default:
                        if (e[o] === void 0) {
                            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            return
                        }
                        e = e[o]
                    }
                    if (x !== void 0) {
                        if (e[x] === void 0) {
                            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            return
                        }
                        e = e[x]
                    }
                }
                const d = e[a];
                if (d === void 0) {
                    const x = i.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + x + "." + a + " but it wasn't found.", e);
                    return
                }
                let f = this.Versioning.None;
                this.targetObject = e,
                e.needsUpdate !== void 0 ? f = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (f = this.Versioning.MatrixWorldNeedsUpdate);
                let v = this.BindingType.Direct;
                if (c !== void 0) {
                    if (a === "morphTargetInfluences") {
                        if (!e.geometry) {
                            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            return
                        }
                        if (!e.geometry.morphAttributes) {
                            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            return
                        }
                        e.morphTargetDictionary[c] !== void 0 && (c = e.morphTargetDictionary[c])
                    }
                    v = this.BindingType.ArrayElement,
                    this.resolvedProperty = d,
                    this.propertyIndex = c
                } else
                    d.fromArray !== void 0 && d.toArray !== void 0 ? (v = this.BindingType.HasFromToArray,
                    this.resolvedProperty = d) : Array.isArray(d) ? (v = this.BindingType.EntireArray,
                    this.resolvedProperty = d) : this.propertyName = a;
                this.getValue = this.GetterByBindingType[v],
                this.setValue = this.SetterByBindingTypeAndVersioning[v][f]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        ji.Composite = gD,
        ji.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        ji.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        ji.prototype.GetterByBindingType = [ji.prototype._getValue_direct, ji.prototype._getValue_array, ji.prototype._getValue_arrayElement, ji.prototype._getValue_toArray],
        ji.prototype.SetterByBindingTypeAndVersioning = [[ji.prototype._setValue_direct, ji.prototype._setValue_direct_setNeedsUpdate, ji.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [ji.prototype._setValue_array, ji.prototype._setValue_array_setNeedsUpdate, ji.prototype._setValue_array_setMatrixWorldNeedsUpdate], [ji.prototype._setValue_arrayElement, ji.prototype._setValue_arrayElement_setNeedsUpdate, ji.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [ji.prototype._setValue_fromArray, ji.prototype._setValue_fromArray_setNeedsUpdate, ji.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        class vD {
            constructor() {
                this.isAnimationObjectGroup = !0,
                this.uuid = yr(),
                this._objects = Array.prototype.slice.call(arguments),
                this.nCachedObjects_ = 0;
                const e = {};
                this._indicesByUUID = e;
                for (let o = 0, a = arguments.length; o !== a; ++o)
                    e[arguments[o].uuid] = o;
                this._paths = [],
                this._parsedPaths = [],
                this._bindings = [],
                this._bindingsIndicesByPath = {};
                const i = this;
                this.stats = {
                    objects: {
                        get total() {
                            return i._objects.length
                        },
                        get inUse() {
                            return this.total - i.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return i._bindings.length
                    }
                }
            }
            add() {
                const e = this._objects
                  , i = this._indicesByUUID
                  , o = this._paths
                  , a = this._parsedPaths
                  , c = this._bindings
                  , d = c.length;
                let f, v = e.length, x = this.nCachedObjects_;
                for (let w = 0, P = arguments.length; w !== P; ++w) {
                    const M = arguments[w]
                      , I = M.uuid;
                    let z = i[I];
                    if (z === void 0) {
                        z = v++,
                        i[I] = z,
                        e.push(M);
                        for (let O = 0, k = d; O !== k; ++O)
                            c[O].push(new ji(M,o[O],a[O]))
                    } else if (z < x) {
                        f = e[z];
                        const O = --x
                          , k = e[O];
                        i[k.uuid] = z,
                        e[z] = k,
                        i[I] = O,
                        e[O] = M;
                        for (let Q = 0, Z = d; Q !== Z; ++Q) {
                            const X = c[Q]
                              , K = X[O];
                            let de = X[z];
                            X[z] = K,
                            de === void 0 && (de = new ji(M,o[Q],a[Q])),
                            X[O] = de
                        }
                    } else
                        e[z] !== f && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = x
            }
            remove() {
                const e = this._objects
                  , i = this._indicesByUUID
                  , o = this._bindings
                  , a = o.length;
                let c = this.nCachedObjects_;
                for (let d = 0, f = arguments.length; d !== f; ++d) {
                    const v = arguments[d]
                      , x = v.uuid
                      , w = i[x];
                    if (w !== void 0 && w >= c) {
                        const P = c++
                          , M = e[P];
                        i[M.uuid] = w,
                        e[w] = M,
                        i[x] = P,
                        e[P] = v;
                        for (let I = 0, z = a; I !== z; ++I) {
                            const O = o[I]
                              , k = O[P]
                              , Q = O[w];
                            O[w] = k,
                            O[P] = Q
                        }
                    }
                }
                this.nCachedObjects_ = c
            }
            uncache() {
                const e = this._objects
                  , i = this._indicesByUUID
                  , o = this._bindings
                  , a = o.length;
                let c = this.nCachedObjects_
                  , d = e.length;
                for (let f = 0, v = arguments.length; f !== v; ++f) {
                    const x = arguments[f]
                      , w = x.uuid
                      , P = i[w];
                    if (P !== void 0)
                        if (delete i[w],
                        P < c) {
                            const M = --c
                              , I = e[M]
                              , z = --d
                              , O = e[z];
                            i[I.uuid] = P,
                            e[P] = I,
                            i[O.uuid] = M,
                            e[M] = O,
                            e.pop();
                            for (let k = 0, Q = a; k !== Q; ++k) {
                                const Z = o[k]
                                  , X = Z[M]
                                  , K = Z[z];
                                Z[P] = X,
                                Z[M] = K,
                                Z.pop()
                            }
                        } else {
                            const M = --d
                              , I = e[M];
                            M > 0 && (i[I.uuid] = P),
                            e[P] = I,
                            e.pop();
                            for (let z = 0, O = a; z !== O; ++z) {
                                const k = o[z];
                                k[P] = k[M],
                                k.pop()
                            }
                        }
                }
                this.nCachedObjects_ = c
            }
            subscribe_(e, i) {
                const o = this._bindingsIndicesByPath;
                let a = o[e];
                const c = this._bindings;
                if (a !== void 0)
                    return c[a];
                const d = this._paths
                  , f = this._parsedPaths
                  , v = this._objects
                  , x = v.length
                  , w = this.nCachedObjects_
                  , P = new Array(x);
                a = c.length,
                o[e] = a,
                d.push(e),
                f.push(i),
                c.push(P);
                for (let M = w, I = v.length; M !== I; ++M) {
                    const z = v[M];
                    P[M] = new ji(z,e,i)
                }
                return P
            }
            unsubscribe_(e) {
                const i = this._bindingsIndicesByPath
                  , o = i[e];
                if (o !== void 0) {
                    const a = this._paths
                      , c = this._parsedPaths
                      , d = this._bindings
                      , f = d.length - 1
                      , v = d[f]
                      , x = e[f];
                    i[x] = o,
                    d[o] = v,
                    d.pop(),
                    c[o] = c[f],
                    c.pop(),
                    a[o] = a[f],
                    a.pop()
                }
            }
        }
        class _D {
            constructor(e, i, o=null, a=i.blendMode) {
                this._mixer = e,
                this._clip = i,
                this._localRoot = o,
                this.blendMode = a;
                const c = i.tracks
                  , d = c.length
                  , f = new Array(d)
                  , v = {
                    endingStart: p,
                    endingEnd: p
                };
                for (let x = 0; x !== d; ++x) {
                    const w = c[x].createInterpolant(null);
                    f[x] = w,
                    w.settings = v
                }
                this._interpolantSettings = v,
                this._interpolants = f,
                this._propertyBindings = new Array(d),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = Yo,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this),
                this
            }
            stop() {
                return this._mixer._deactivateAction(this),
                this.reset()
            }
            reset() {
                return this.paused = !1,
                this.enabled = !0,
                this.time = 0,
                this._loopCount = -1,
                this._startTime = null,
                this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(e) {
                return this._startTime = e,
                this
            }
            setLoop(e, i) {
                return this.loop = e,
                this.repetitions = i,
                this
            }
            setEffectiveWeight(e) {
                return this.weight = e,
                this._effectiveWeight = this.enabled ? e : 0,
                this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(e) {
                return this._scheduleFading(e, 0, 1)
            }
            fadeOut(e) {
                return this._scheduleFading(e, 1, 0)
            }
            crossFadeFrom(e, i, o) {
                if (e.fadeOut(i),
                this.fadeIn(i),
                o) {
                    const a = this._clip.duration
                      , c = e._clip.duration
                      , d = c / a
                      , f = a / c;
                    e.warp(1, d, i),
                    this.warp(f, 1, i)
                }
                return this
            }
            crossFadeTo(e, i, o) {
                return e.crossFadeFrom(this, i, o)
            }
            stopFading() {
                const e = this._weightInterpolant;
                return e !== null && (this._weightInterpolant = null,
                this._mixer._takeBackControlInterpolant(e)),
                this
            }
            setEffectiveTimeScale(e) {
                return this.timeScale = e,
                this._effectiveTimeScale = this.paused ? 0 : e,
                this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(e) {
                return this.timeScale = this._clip.duration / e,
                this.stopWarping()
            }
            syncWith(e) {
                return this.time = e.time,
                this.timeScale = e.timeScale,
                this.stopWarping()
            }
            halt(e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            }
            warp(e, i, o) {
                const a = this._mixer
                  , c = a.time
                  , d = this.timeScale;
                let f = this._timeScaleInterpolant;
                f === null && (f = a._lendControlInterpolant(),
                this._timeScaleInterpolant = f);
                const v = f.parameterPositions
                  , x = f.sampleValues;
                return v[0] = c,
                v[1] = c + o,
                x[0] = e / d,
                x[1] = i / d,
                this
            }
            stopWarping() {
                const e = this._timeScaleInterpolant;
                return e !== null && (this._timeScaleInterpolant = null,
                this._mixer._takeBackControlInterpolant(e)),
                this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(e, i, o, a) {
                if (!this.enabled) {
                    this._updateWeight(e);
                    return
                }
                const c = this._startTime;
                if (c !== null) {
                    const v = (e - c) * o;
                    v < 0 || o === 0 ? i = 0 : (this._startTime = null,
                    i = o * v)
                }
                i *= this._updateTimeScale(e);
                const d = this._updateTime(i)
                  , f = this._updateWeight(e);
                if (f > 0) {
                    const v = this._interpolants
                      , x = this._propertyBindings;
                    switch (this.blendMode) {
                    case ye:
                        for (let w = 0, P = v.length; w !== P; ++w)
                            v[w].evaluate(d),
                            x[w].accumulateAdditive(f);
                        break;
                    case se:
                    default:
                        for (let w = 0, P = v.length; w !== P; ++w)
                            v[w].evaluate(d),
                            x[w].accumulate(a, f)
                    }
                }
            }
            _updateWeight(e) {
                let i = 0;
                if (this.enabled) {
                    i = this.weight;
                    const o = this._weightInterpolant;
                    if (o !== null) {
                        const a = o.evaluate(e)[0];
                        i *= a,
                        e > o.parameterPositions[1] && (this.stopFading(),
                        a === 0 && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = i,
                i
            }
            _updateTimeScale(e) {
                let i = 0;
                if (!this.paused) {
                    i = this.timeScale;
                    const o = this._timeScaleInterpolant;
                    if (o !== null) {
                        const a = o.evaluate(e)[0];
                        i *= a,
                        e > o.parameterPositions[1] && (this.stopWarping(),
                        i === 0 ? this.paused = !0 : this.timeScale = i)
                    }
                }
                return this._effectiveTimeScale = i,
                i
            }
            _updateTime(e) {
                const i = this._clip.duration
                  , o = this.loop;
                let a = this.time + e
                  , c = this._loopCount;
                const d = o === mo;
                if (e === 0)
                    return c === -1 ? a : d && (c & 1) === 1 ? i - a : a;
                if (o === ya) {
                    c === -1 && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1));
                    e: {
                        if (a >= i)
                            a = i;
                        else if (a < 0)
                            a = 0;
                        else {
                            this.time = a;
                            break e
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = a,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (c === -1 && (e >= 0 ? (c = 0,
                    this._setEndings(!0, this.repetitions === 0, d)) : this._setEndings(this.repetitions === 0, !0, d)),
                    a >= i || a < 0) {
                        const f = Math.floor(a / i);
                        a -= i * f,
                        c += Math.abs(f);
                        const v = this.repetitions - c;
                        if (v <= 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            a = e > 0 ? i : 0,
                            this.time = a,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                        else {
                            if (v === 1) {
                                const x = e < 0;
                                this._setEndings(x, !x, d)
                            } else
                                this._setEndings(!1, !1, d);
                            this._loopCount = c,
                            this.time = a,
                            this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: f
                            })
                        }
                    } else
                        this.time = a;
                    if (d && (c & 1) === 1)
                        return i - a
                }
                return a
            }
            _setEndings(e, i, o) {
                const a = this._interpolantSettings;
                o ? (a.endingStart = C,
                a.endingEnd = C) : (e ? a.endingStart = this.zeroSlopeAtStart ? C : p : a.endingStart = V,
                i ? a.endingEnd = this.zeroSlopeAtEnd ? C : p : a.endingEnd = V)
            }
            _scheduleFading(e, i, o) {
                const a = this._mixer
                  , c = a.time;
                let d = this._weightInterpolant;
                d === null && (d = a._lendControlInterpolant(),
                this._weightInterpolant = d);
                const f = d.parameterPositions
                  , v = d.sampleValues;
                return f[0] = c,
                v[0] = i,
                f[1] = c + e,
                v[1] = o,
                this
            }
        }
        const yD = new Float32Array(1);
        class xD extends Kr {
            constructor(e) {
                super(),
                this._root = e,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
            }
            _bindAction(e, i) {
                const o = e._localRoot || this._root
                  , a = e._clip.tracks
                  , c = a.length
                  , d = e._propertyBindings
                  , f = e._interpolants
                  , v = o.uuid
                  , x = this._bindingsByRootAndName;
                let w = x[v];
                w === void 0 && (w = {},
                x[v] = w);
                for (let P = 0; P !== c; ++P) {
                    const M = a[P]
                      , I = M.name;
                    let z = w[I];
                    if (z !== void 0)
                        ++z.referenceCount,
                        d[P] = z;
                    else {
                        if (z = d[P],
                        z !== void 0) {
                            z._cacheIndex === null && (++z.referenceCount,
                            this._addInactiveBinding(z, v, I));
                            continue
                        }
                        const O = i && i._propertyBindings[P].binding.parsedPath;
                        z = new Ub(ji.create(o, I, O),M.ValueTypeName,M.getValueSize()),
                        ++z.referenceCount,
                        this._addInactiveBinding(z, v, I),
                        d[P] = z
                    }
                    f[P].resultBuffer = z.buffer
                }
            }
            _activateAction(e) {
                if (!this._isActiveAction(e)) {
                    if (e._cacheIndex === null) {
                        const o = (e._localRoot || this._root).uuid
                          , a = e._clip.uuid
                          , c = this._actionsByClip[a];
                        this._bindAction(e, c && c.knownActions[0]),
                        this._addInactiveAction(e, a, o)
                    }
                    const i = e._propertyBindings;
                    for (let o = 0, a = i.length; o !== a; ++o) {
                        const c = i[o];
                        c.useCount++ === 0 && (this._lendBinding(c),
                        c.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            }
            _deactivateAction(e) {
                if (this._isActiveAction(e)) {
                    const i = e._propertyBindings;
                    for (let o = 0, a = i.length; o !== a; ++o) {
                        const c = i[o];
                        --c.useCount === 0 && (c.restoreOriginalState(),
                        this._takeBackBinding(c))
                    }
                    this._takeBackAction(e)
                }
            }
            _initMemoryManager() {
                this._actions = [],
                this._nActiveActions = 0,
                this._actionsByClip = {},
                this._bindings = [],
                this._nActiveBindings = 0,
                this._bindingsByRootAndName = {},
                this._controlInterpolants = [],
                this._nActiveControlInterpolants = 0;
                const e = this;
                this.stats = {
                    actions: {
                        get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(e) {
                const i = e._cacheIndex;
                return i !== null && i < this._nActiveActions
            }
            _addInactiveAction(e, i, o) {
                const a = this._actions
                  , c = this._actionsByClip;
                let d = c[i];
                if (d === void 0)
                    d = {
                        knownActions: [e],
                        actionByRoot: {}
                    },
                    e._byClipCacheIndex = 0,
                    c[i] = d;
                else {
                    const f = d.knownActions;
                    e._byClipCacheIndex = f.length,
                    f.push(e)
                }
                e._cacheIndex = a.length,
                a.push(e),
                d.actionByRoot[o] = e
            }
            _removeInactiveAction(e) {
                const i = this._actions
                  , o = i[i.length - 1]
                  , a = e._cacheIndex;
                o._cacheIndex = a,
                i[a] = o,
                i.pop(),
                e._cacheIndex = null;
                const c = e._clip.uuid
                  , d = this._actionsByClip
                  , f = d[c]
                  , v = f.knownActions
                  , x = v[v.length - 1]
                  , w = e._byClipCacheIndex;
                x._byClipCacheIndex = w,
                v[w] = x,
                v.pop(),
                e._byClipCacheIndex = null;
                const P = f.actionByRoot
                  , M = (e._localRoot || this._root).uuid;
                delete P[M],
                v.length === 0 && delete d[c],
                this._removeInactiveBindingsForAction(e)
            }
            _removeInactiveBindingsForAction(e) {
                const i = e._propertyBindings;
                for (let o = 0, a = i.length; o !== a; ++o) {
                    const c = i[o];
                    --c.referenceCount === 0 && this._removeInactiveBinding(c)
                }
            }
            _lendAction(e) {
                const i = this._actions
                  , o = e._cacheIndex
                  , a = this._nActiveActions++
                  , c = i[a];
                e._cacheIndex = a,
                i[a] = e,
                c._cacheIndex = o,
                i[o] = c
            }
            _takeBackAction(e) {
                const i = this._actions
                  , o = e._cacheIndex
                  , a = --this._nActiveActions
                  , c = i[a];
                e._cacheIndex = a,
                i[a] = e,
                c._cacheIndex = o,
                i[o] = c
            }
            _addInactiveBinding(e, i, o) {
                const a = this._bindingsByRootAndName
                  , c = this._bindings;
                let d = a[i];
                d === void 0 && (d = {},
                a[i] = d),
                d[o] = e,
                e._cacheIndex = c.length,
                c.push(e)
            }
            _removeInactiveBinding(e) {
                const i = this._bindings
                  , o = e.binding
                  , a = o.rootNode.uuid
                  , c = o.path
                  , d = this._bindingsByRootAndName
                  , f = d[a]
                  , v = i[i.length - 1]
                  , x = e._cacheIndex;
                v._cacheIndex = x,
                i[x] = v,
                i.pop(),
                delete f[c],
                Object.keys(f).length === 0 && delete d[a]
            }
            _lendBinding(e) {
                const i = this._bindings
                  , o = e._cacheIndex
                  , a = this._nActiveBindings++
                  , c = i[a];
                e._cacheIndex = a,
                i[a] = e,
                c._cacheIndex = o,
                i[o] = c
            }
            _takeBackBinding(e) {
                const i = this._bindings
                  , o = e._cacheIndex
                  , a = --this._nActiveBindings
                  , c = i[a];
                e._cacheIndex = a,
                i[a] = e,
                c._cacheIndex = o,
                i[o] = c
            }
            _lendControlInterpolant() {
                const e = this._controlInterpolants
                  , i = this._nActiveControlInterpolants++;
                let o = e[i];
                return o === void 0 && (o = new I0(new Float32Array(2),new Float32Array(2),1,yD),
                o.__cacheIndex = i,
                e[i] = o),
                o
            }
            _takeBackControlInterpolant(e) {
                const i = this._controlInterpolants
                  , o = e.__cacheIndex
                  , a = --this._nActiveControlInterpolants
                  , c = i[a];
                e.__cacheIndex = a,
                i[a] = e,
                c.__cacheIndex = o,
                i[o] = c
            }
            clipAction(e, i, o) {
                const a = i || this._root
                  , c = a.uuid;
                let d = typeof e == "string" ? Ad.findByName(a, e) : e;
                const f = d !== null ? d.uuid : e
                  , v = this._actionsByClip[f];
                let x = null;
                if (o === void 0 && (d !== null ? o = d.blendMode : o = se),
                v !== void 0) {
                    const P = v.actionByRoot[c];
                    if (P !== void 0 && P.blendMode === o)
                        return P;
                    x = v.knownActions[0],
                    d === null && (d = x._clip)
                }
                if (d === null)
                    return null;
                const w = new _D(this,d,i,o);
                return this._bindAction(w, x),
                this._addInactiveAction(w, f, c),
                w
            }
            existingAction(e, i) {
                const o = i || this._root
                  , a = o.uuid
                  , c = typeof e == "string" ? Ad.findByName(o, e) : e
                  , d = c ? c.uuid : e
                  , f = this._actionsByClip[d];
                return f !== void 0 && f.actionByRoot[a] || null
            }
            stopAllAction() {
                const e = this._actions
                  , i = this._nActiveActions;
                for (let o = i - 1; o >= 0; --o)
                    e[o].stop();
                return this
            }
            update(e) {
                e *= this.timeScale;
                const i = this._actions
                  , o = this._nActiveActions
                  , a = this.time += e
                  , c = Math.sign(e)
                  , d = this._accuIndex ^= 1;
                for (let x = 0; x !== o; ++x)
                    i[x]._update(a, e, c, d);
                const f = this._bindings
                  , v = this._nActiveBindings;
                for (let x = 0; x !== v; ++x)
                    f[x].apply(d);
                return this
            }
            setTime(e) {
                this.time = 0;
                for (let i = 0; i < this._actions.length; i++)
                    this._actions[i].time = 0;
                return this.update(e)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(e) {
                const i = this._actions
                  , o = e.uuid
                  , a = this._actionsByClip
                  , c = a[o];
                if (c !== void 0) {
                    const d = c.knownActions;
                    for (let f = 0, v = d.length; f !== v; ++f) {
                        const x = d[f];
                        this._deactivateAction(x);
                        const w = x._cacheIndex
                          , P = i[i.length - 1];
                        x._cacheIndex = null,
                        x._byClipCacheIndex = null,
                        P._cacheIndex = w,
                        i[w] = P,
                        i.pop(),
                        this._removeInactiveBindingsForAction(x)
                    }
                    delete a[o]
                }
            }
            uncacheRoot(e) {
                const i = e.uuid
                  , o = this._actionsByClip;
                for (const d in o) {
                    const f = o[d].actionByRoot
                      , v = f[i];
                    v !== void 0 && (this._deactivateAction(v),
                    this._removeInactiveAction(v))
                }
                const a = this._bindingsByRootAndName
                  , c = a[i];
                if (c !== void 0)
                    for (const d in c) {
                        const f = c[d];
                        f.restoreOriginalState(),
                        this._removeInactiveBinding(f)
                    }
            }
            uncacheAction(e, i) {
                const o = this.existingAction(e, i);
                o !== null && (this._deactivateAction(o),
                this._removeInactiveAction(o))
            }
        }
        class W0 {
            constructor(e) {
                this.value = e
            }
            clone() {
                return new W0(this.value.clone === void 0 ? this.value : this.value.clone())
            }
        }
        let bD = 0;
        class wD extends Kr {
            constructor() {
                super(),
                this.isUniformsGroup = !0,
                Object.defineProperty(this, "id", {
                    value: bD++
                }),
                this.name = "",
                this.usage = ln,
                this.uniforms = []
            }
            add(e) {
                return this.uniforms.push(e),
                this
            }
            remove(e) {
                const i = this.uniforms.indexOf(e);
                return i !== -1 && this.uniforms.splice(i, 1),
                this
            }
            setName(e) {
                return this.name = e,
                this
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            dispose() {
                return this.dispatchEvent({
                    type: "dispose"
                }),
                this
            }
            copy(e) {
                this.name = e.name,
                this.usage = e.usage;
                const i = e.uniforms;
                this.uniforms.length = 0;
                for (let o = 0, a = i.length; o < a; o++)
                    this.uniforms.push(i[o].clone());
                return this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class AD extends fp {
            constructor(e, i, o=1) {
                super(e, i),
                this.isInstancedInterleavedBuffer = !0,
                this.meshPerAttribute = o
            }
            copy(e) {
                return super.copy(e),
                this.meshPerAttribute = e.meshPerAttribute,
                this
            }
            clone(e) {
                const i = super.clone(e);
                return i.meshPerAttribute = this.meshPerAttribute,
                i
            }
            toJSON(e) {
                const i = super.toJSON(e);
                return i.isInstancedInterleavedBuffer = !0,
                i.meshPerAttribute = this.meshPerAttribute,
                i
            }
        }
        class SD {
            constructor(e, i, o, a, c) {
                this.isGLBufferAttribute = !0,
                this.name = "",
                this.buffer = e,
                this.type = i,
                this.itemSize = o,
                this.elementSize = a,
                this.count = c,
                this.version = 0
            }
            set needsUpdate(e) {
                e === !0 && this.version++
            }
            setBuffer(e) {
                return this.buffer = e,
                this
            }
            setType(e, i) {
                return this.type = e,
                this.elementSize = i,
                this
            }
            setItemSize(e) {
                return this.itemSize = e,
                this
            }
            setCount(e) {
                return this.count = e,
                this
            }
        }
        class TD {
            constructor(e, i, o=0, a=1 / 0) {
                this.ray = new Vh(e,i),
                this.near = o,
                this.far = a,
                this.camera = null,
                this.layers = new Xf,
                this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(e, i) {
                this.ray.set(e, i)
            }
            setFromCamera(e, i) {
                i.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(i.matrixWorld),
                this.ray.direction.set(e.x, e.y, .5).unproject(i).sub(this.ray.origin).normalize(),
                this.camera = i) : i.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (i.near + i.far) / (i.near - i.far)).unproject(i),
                this.ray.direction.set(0, 0, -1).transformDirection(i.matrixWorld),
                this.camera = i) : console.error("THREE.Raycaster: Unsupported camera type: " + i.type)
            }
            intersectObject(e, i=!0, o=[]) {
                return j0(e, this, o, i),
                o.sort(Nb),
                o
            }
            intersectObjects(e, i=!0, o=[]) {
                for (let a = 0, c = e.length; a < c; a++)
                    j0(e[a], this, o, i);
                return o.sort(Nb),
                o
            }
        }
        function Nb(u, e) {
            return u.distance - e.distance
        }
        function j0(u, e, i, o) {
            if (u.layers.test(e.layers) && u.raycast(e, i),
            o === !0) {
                const a = u.children;
                for (let c = 0, d = a.length; c < d; c++)
                    j0(a[c], e, i, !0)
            }
        }
        class ED {
            constructor(e=1, i=0, o=0) {
                return this.radius = e,
                this.phi = i,
                this.theta = o,
                this
            }
            set(e, i, o) {
                return this.radius = e,
                this.phi = i,
                this.theta = o,
                this
            }
            copy(e) {
                return this.radius = e.radius,
                this.phi = e.phi,
                this.theta = e.theta,
                this
            }
            makeSafe() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
                this
            }
            setFromVector3(e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            }
            setFromCartesianCoords(e, i, o) {
                return this.radius = Math.sqrt(e * e + i * i + o * o),
                this.radius === 0 ? (this.theta = 0,
                this.phi = 0) : (this.theta = Math.atan2(e, o),
                this.phi = Math.acos(Wi(i / this.radius, -1, 1))),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class MD {
            constructor(e=1, i=0, o=0) {
                return this.radius = e,
                this.theta = i,
                this.y = o,
                this
            }
            set(e, i, o) {
                return this.radius = e,
                this.theta = i,
                this.y = o,
                this
            }
            copy(e) {
                return this.radius = e.radius,
                this.theta = e.theta,
                this.y = e.y,
                this
            }
            setFromVector3(e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            }
            setFromCartesianCoords(e, i, o) {
                return this.radius = Math.sqrt(e * e + o * o),
                this.theta = Math.atan2(e, o),
                this.y = i,
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const zb = new _t;
        class CD {
            constructor(e=new _t(1 / 0,1 / 0), i=new _t(-1 / 0,-1 / 0)) {
                this.isBox2 = !0,
                this.min = e,
                this.max = i
            }
            set(e, i) {
                return this.min.copy(e),
                this.max.copy(i),
                this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let i = 0, o = e.length; i < o; i++)
                    this.expandByPoint(e[i]);
                return this
            }
            setFromCenterAndSize(e, i) {
                const o = zb.copy(i).multiplyScalar(.5);
                return this.min.copy(e).sub(o),
                this.max.copy(e).add(o),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(e) {
                return this.min.copy(e.min),
                this.max.copy(e.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0,
                this.max.x = this.max.y = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e),
                this.max.max(e),
                this
            }
            expandByVector(e) {
                return this.min.sub(e),
                this.max.add(e),
                this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e),
                this.max.addScalar(e),
                this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
            }
            getParameter(e, i) {
                return i.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
            }
            clampPoint(e, i) {
                return i.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, zb).distanceTo(e)
            }
            intersect(e) {
                return this.min.max(e.min),
                this.max.min(e.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(e) {
                return this.min.min(e.min),
                this.max.max(e.max),
                this
            }
            translate(e) {
                return this.min.add(e),
                this.max.add(e),
                this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const Gb = new me
          , Bp = new me;
        class PD {
            constructor(e=new me, i=new me) {
                this.start = e,
                this.end = i
            }
            set(e, i) {
                return this.start.copy(e),
                this.end.copy(i),
                this
            }
            copy(e) {
                return this.start.copy(e.start),
                this.end.copy(e.end),
                this
            }
            getCenter(e) {
                return e.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(e) {
                return e.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(e, i) {
                return this.delta(i).multiplyScalar(e).add(this.start)
            }
            closestPointToPointParameter(e, i) {
                Gb.subVectors(e, this.start),
                Bp.subVectors(this.end, this.start);
                const o = Bp.dot(Bp);
                let c = Bp.dot(Gb) / o;
                return i && (c = Wi(c, 0, 1)),
                c
            }
            closestPointToPoint(e, i, o) {
                const a = this.closestPointToPointParameter(e, i);
                return this.delta(o).multiplyScalar(a).add(this.start)
            }
            applyMatrix4(e) {
                return this.start.applyMatrix4(e),
                this.end.applyMatrix4(e),
                this
            }
            equals(e) {
                return e.start.equals(this.start) && e.end.equals(this.end)
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const Hb = new me;
        class RD extends Qi {
            constructor(e, i) {
                super(),
                this.light = e,
                this.matrix = e.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = i,
                this.type = "SpotLightHelper";
                const o = new Ai
                  , a = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                for (let d = 0, f = 1, v = 32; d < v; d++,
                f++) {
                    const x = d / v * Math.PI * 2
                      , w = f / v * Math.PI * 2;
                    a.push(Math.cos(x), Math.sin(x), 1, Math.cos(w), Math.sin(w), 1)
                }
                o.setAttribute("position", new Rn(a,3));
                const c = new ro({
                    fog: !1,
                    toneMapped: !1
                });
                this.cone = new Xa(o,c),
                this.add(this.cone),
                this.update()
            }
            dispose() {
                this.cone.geometry.dispose(),
                this.cone.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1);
                const e = this.light.distance ? this.light.distance : 1e3
                  , i = e * Math.tan(this.light.angle);
                this.cone.scale.set(i, i, e),
                Hb.setFromMatrixPosition(this.light.target.matrixWorld),
                this.cone.lookAt(Hb),
                this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }
        const ic = new me
          , Fp = new pi
          , X0 = new pi;
        class DD extends Xa {
            constructor(e) {
                const i = Vb(e)
                  , o = new Ai
                  , a = []
                  , c = []
                  , d = new gn(0,0,1)
                  , f = new gn(0,1,0);
                for (let x = 0; x < i.length; x++) {
                    const w = i[x];
                    w.parent && w.parent.isBone && (a.push(0, 0, 0),
                    a.push(0, 0, 0),
                    c.push(d.r, d.g, d.b),
                    c.push(f.r, f.g, f.b))
                }
                o.setAttribute("position", new Rn(a,3)),
                o.setAttribute("color", new Rn(c,3));
                const v = new ro({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                });
                super(o, v),
                this.isSkeletonHelper = !0,
                this.type = "SkeletonHelper",
                this.root = e,
                this.bones = i,
                this.matrix = e.matrixWorld,
                this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(e) {
                const i = this.bones
                  , o = this.geometry
                  , a = o.getAttribute("position");
                X0.copy(this.root.matrixWorld).invert();
                for (let c = 0, d = 0; c < i.length; c++) {
                    const f = i[c];
                    f.parent && f.parent.isBone && (Fp.multiplyMatrices(X0, f.matrixWorld),
                    ic.setFromMatrixPosition(Fp),
                    a.setXYZ(d, ic.x, ic.y, ic.z),
                    Fp.multiplyMatrices(X0, f.parent.matrixWorld),
                    ic.setFromMatrixPosition(Fp),
                    a.setXYZ(d + 1, ic.x, ic.y, ic.z),
                    d += 2)
                }
                o.getAttribute("position").needsUpdate = !0,
                super.updateMatrixWorld(e)
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        function Vb(u) {
            const e = [];
            u.isBone === !0 && e.push(u);
            for (let i = 0; i < u.children.length; i++)
                e.push.apply(e, Vb(u.children[i]));
            return e
        }
        class LD extends Es {
            constructor(e, i, o) {
                const a = new Ku(i,4,2)
                  , c = new ql({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                });
                super(a, c),
                this.light = e,
                this.color = o,
                this.type = "PointLightHelper",
                this.matrix = this.light.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.update()
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }
        }
        const ID = new me
          , Wb = new gn
          , jb = new gn;
        class OD extends Qi {
            constructor(e, i, o) {
                super(),
                this.light = e,
                this.matrix = e.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = o,
                this.type = "HemisphereLightHelper";
                const a = new Qu(i);
                a.rotateY(Math.PI * .5),
                this.material = new ql({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                }),
                this.color === void 0 && (this.material.vertexColors = !0);
                const c = a.getAttribute("position")
                  , d = new Float32Array(c.count * 3);
                a.setAttribute("color", new dr(d,3)),
                this.add(new Es(a,this.material)),
                this.update()
            }
            dispose() {
                this.children[0].geometry.dispose(),
                this.children[0].material.dispose()
            }
            update() {
                const e = this.children[0];
                if (this.color !== void 0)
                    this.material.color.set(this.color);
                else {
                    const i = e.geometry.getAttribute("color");
                    Wb.copy(this.light.color),
                    jb.copy(this.light.groundColor);
                    for (let o = 0, a = i.count; o < a; o++) {
                        const c = o < a / 2 ? Wb : jb;
                        i.setXYZ(o, c.r, c.g, c.b)
                    }
                    i.needsUpdate = !0
                }
                this.light.updateWorldMatrix(!0, !1),
                e.lookAt(ID.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }
        class BD extends Xa {
            constructor(e=10, i=10, o=4473924, a=8947848) {
                o = new gn(o),
                a = new gn(a);
                const c = i / 2
                  , d = e / i
                  , f = e / 2
                  , v = []
                  , x = [];
                for (let M = 0, I = 0, z = -f; M <= i; M++,
                z += d) {
                    v.push(-f, 0, z, f, 0, z),
                    v.push(z, 0, -f, z, 0, f);
                    const O = M === c ? o : a;
                    O.toArray(x, I),
                    I += 3,
                    O.toArray(x, I),
                    I += 3,
                    O.toArray(x, I),
                    I += 3,
                    O.toArray(x, I),
                    I += 3
                }
                const w = new Ai;
                w.setAttribute("position", new Rn(v,3)),
                w.setAttribute("color", new Rn(x,3));
                const P = new ro({
                    vertexColors: !0,
                    toneMapped: !1
                });
                super(w, P),
                this.type = "GridHelper"
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class FD extends Xa {
            constructor(e=10, i=16, o=8, a=64, c=4473924, d=8947848) {
                c = new gn(c),
                d = new gn(d);
                const f = []
                  , v = [];
                if (i > 1)
                    for (let P = 0; P < i; P++) {
                        const M = P / i * (Math.PI * 2)
                          , I = Math.sin(M) * e
                          , z = Math.cos(M) * e;
                        f.push(0, 0, 0),
                        f.push(I, 0, z);
                        const O = P & 1 ? c : d;
                        v.push(O.r, O.g, O.b),
                        v.push(O.r, O.g, O.b)
                    }
                for (let P = 0; P < o; P++) {
                    const M = P & 1 ? c : d
                      , I = e - e / o * P;
                    for (let z = 0; z < a; z++) {
                        let O = z / a * (Math.PI * 2)
                          , k = Math.sin(O) * I
                          , Q = Math.cos(O) * I;
                        f.push(k, 0, Q),
                        v.push(M.r, M.g, M.b),
                        O = (z + 1) / a * (Math.PI * 2),
                        k = Math.sin(O) * I,
                        Q = Math.cos(O) * I,
                        f.push(k, 0, Q),
                        v.push(M.r, M.g, M.b)
                    }
                }
                const x = new Ai;
                x.setAttribute("position", new Rn(f,3)),
                x.setAttribute("color", new Rn(v,3));
                const w = new ro({
                    vertexColors: !0,
                    toneMapped: !1
                });
                super(x, w),
                this.type = "PolarGridHelper"
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        const Xb = new me
          , kp = new me
          , Yb = new me;
        class kD extends Qi {
            constructor(e, i, o) {
                super(),
                this.light = e,
                this.matrix = e.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = o,
                this.type = "DirectionalLightHelper",
                i === void 0 && (i = 1);
                let a = new Ai;
                a.setAttribute("position", new Rn([-i, i, 0, i, i, 0, i, -i, 0, -i, -i, 0, -i, i, 0],3));
                const c = new ro({
                    fog: !1,
                    toneMapped: !1
                });
                this.lightPlane = new ec(a,c),
                this.add(this.lightPlane),
                a = new Ai,
                a.setAttribute("position", new Rn([0, 0, 0, 0, 0, 1],3)),
                this.targetLine = new ec(a,c),
                this.add(this.targetLine),
                this.update()
            }
            dispose() {
                this.lightPlane.geometry.dispose(),
                this.lightPlane.material.dispose(),
                this.targetLine.geometry.dispose(),
                this.targetLine.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1),
                Xb.setFromMatrixPosition(this.light.matrixWorld),
                kp.setFromMatrixPosition(this.light.target.matrixWorld),
                Yb.subVectors(kp, Xb),
                this.lightPlane.lookAt(kp),
                this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
                this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
                this.targetLine.material.color.copy(this.light.color)),
                this.targetLine.lookAt(kp),
                this.targetLine.scale.z = Yb.length()
            }
        }
        const Up = new me
          , Ur = new ip;
        class UD extends Xa {
            constructor(e) {
                const i = new Ai
                  , o = new ro({
                    color: 16777215,
                    vertexColors: !0,
                    toneMapped: !1
                })
                  , a = []
                  , c = []
                  , d = {};
                f("n1", "n2"),
                f("n2", "n4"),
                f("n4", "n3"),
                f("n3", "n1"),
                f("f1", "f2"),
                f("f2", "f4"),
                f("f4", "f3"),
                f("f3", "f1"),
                f("n1", "f1"),
                f("n2", "f2"),
                f("n3", "f3"),
                f("n4", "f4"),
                f("p", "n1"),
                f("p", "n2"),
                f("p", "n3"),
                f("p", "n4"),
                f("u1", "u2"),
                f("u2", "u3"),
                f("u3", "u1"),
                f("c", "t"),
                f("p", "c"),
                f("cn1", "cn2"),
                f("cn3", "cn4"),
                f("cf1", "cf2"),
                f("cf3", "cf4");
                function f(z, O) {
                    v(z),
                    v(O)
                }
                function v(z) {
                    a.push(0, 0, 0),
                    c.push(0, 0, 0),
                    d[z] === void 0 && (d[z] = []),
                    d[z].push(a.length / 3 - 1)
                }
                i.setAttribute("position", new Rn(a,3)),
                i.setAttribute("color", new Rn(c,3)),
                super(i, o),
                this.type = "CameraHelper",
                this.camera = e,
                this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                this.matrix = e.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.pointMap = d,
                this.update();
                const x = new gn(16755200)
                  , w = new gn(16711680)
                  , P = new gn(43775)
                  , M = new gn(16777215)
                  , I = new gn(3355443);
                this.setColors(x, w, P, M, I)
            }
            setColors(e, i, o, a, c) {
                const f = this.geometry.getAttribute("color");
                f.setXYZ(0, e.r, e.g, e.b),
                f.setXYZ(1, e.r, e.g, e.b),
                f.setXYZ(2, e.r, e.g, e.b),
                f.setXYZ(3, e.r, e.g, e.b),
                f.setXYZ(4, e.r, e.g, e.b),
                f.setXYZ(5, e.r, e.g, e.b),
                f.setXYZ(6, e.r, e.g, e.b),
                f.setXYZ(7, e.r, e.g, e.b),
                f.setXYZ(8, e.r, e.g, e.b),
                f.setXYZ(9, e.r, e.g, e.b),
                f.setXYZ(10, e.r, e.g, e.b),
                f.setXYZ(11, e.r, e.g, e.b),
                f.setXYZ(12, e.r, e.g, e.b),
                f.setXYZ(13, e.r, e.g, e.b),
                f.setXYZ(14, e.r, e.g, e.b),
                f.setXYZ(15, e.r, e.g, e.b),
                f.setXYZ(16, e.r, e.g, e.b),
                f.setXYZ(17, e.r, e.g, e.b),
                f.setXYZ(18, e.r, e.g, e.b),
                f.setXYZ(19, e.r, e.g, e.b),
                f.setXYZ(20, e.r, e.g, e.b),
                f.setXYZ(21, e.r, e.g, e.b),
                f.setXYZ(22, e.r, e.g, e.b),
                f.setXYZ(23, e.r, e.g, e.b),
                f.setXYZ(24, i.r, i.g, i.b),
                f.setXYZ(25, i.r, i.g, i.b),
                f.setXYZ(26, i.r, i.g, i.b),
                f.setXYZ(27, i.r, i.g, i.b),
                f.setXYZ(28, i.r, i.g, i.b),
                f.setXYZ(29, i.r, i.g, i.b),
                f.setXYZ(30, i.r, i.g, i.b),
                f.setXYZ(31, i.r, i.g, i.b),
                f.setXYZ(32, o.r, o.g, o.b),
                f.setXYZ(33, o.r, o.g, o.b),
                f.setXYZ(34, o.r, o.g, o.b),
                f.setXYZ(35, o.r, o.g, o.b),
                f.setXYZ(36, o.r, o.g, o.b),
                f.setXYZ(37, o.r, o.g, o.b),
                f.setXYZ(38, a.r, a.g, a.b),
                f.setXYZ(39, a.r, a.g, a.b),
                f.setXYZ(40, c.r, c.g, c.b),
                f.setXYZ(41, c.r, c.g, c.b),
                f.setXYZ(42, c.r, c.g, c.b),
                f.setXYZ(43, c.r, c.g, c.b),
                f.setXYZ(44, c.r, c.g, c.b),
                f.setXYZ(45, c.r, c.g, c.b),
                f.setXYZ(46, c.r, c.g, c.b),
                f.setXYZ(47, c.r, c.g, c.b),
                f.setXYZ(48, c.r, c.g, c.b),
                f.setXYZ(49, c.r, c.g, c.b),
                f.needsUpdate = !0
            }
            update() {
                const e = this.geometry
                  , i = this.pointMap
                  , o = 1
                  , a = 1;
                Ur.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                Vr("c", i, e, Ur, 0, 0, -1),
                Vr("t", i, e, Ur, 0, 0, 1),
                Vr("n1", i, e, Ur, -o, -a, -1),
                Vr("n2", i, e, Ur, o, -a, -1),
                Vr("n3", i, e, Ur, -o, a, -1),
                Vr("n4", i, e, Ur, o, a, -1),
                Vr("f1", i, e, Ur, -o, -a, 1),
                Vr("f2", i, e, Ur, o, -a, 1),
                Vr("f3", i, e, Ur, -o, a, 1),
                Vr("f4", i, e, Ur, o, a, 1),
                Vr("u1", i, e, Ur, o * .7, a * 1.1, -1),
                Vr("u2", i, e, Ur, -o * .7, a * 1.1, -1),
                Vr("u3", i, e, Ur, 0, a * 2, -1),
                Vr("cf1", i, e, Ur, -o, 0, 1),
                Vr("cf2", i, e, Ur, o, 0, 1),
                Vr("cf3", i, e, Ur, 0, -a, 1),
                Vr("cf4", i, e, Ur, 0, a, 1),
                Vr("cn1", i, e, Ur, -o, 0, -1),
                Vr("cn2", i, e, Ur, o, 0, -1),
                Vr("cn3", i, e, Ur, 0, -a, -1),
                Vr("cn4", i, e, Ur, 0, a, -1),
                e.getAttribute("position").needsUpdate = !0
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        function Vr(u, e, i, o, a, c, d) {
            Up.set(a, c, d).unproject(o);
            const f = e[u];
            if (f !== void 0) {
                const v = i.getAttribute("position");
                for (let x = 0, w = f.length; x < w; x++)
                    v.setXYZ(f[x], Up.x, Up.y, Up.z)
            }
        }
        const Np = new Zr;
        class ND extends Xa {
            constructor(e, i=16776960) {
                const o = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                  , a = new Float32Array(8 * 3)
                  , c = new Ai;
                c.setIndex(new dr(o,1)),
                c.setAttribute("position", new dr(a,3)),
                super(c, new ro({
                    color: i,
                    toneMapped: !1
                })),
                this.object = e,
                this.type = "BoxHelper",
                this.matrixAutoUpdate = !1,
                this.update()
            }
            update(e) {
                if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
                this.object !== void 0 && Np.setFromObject(this.object),
                Np.isEmpty())
                    return;
                const i = Np.min
                  , o = Np.max
                  , a = this.geometry.attributes.position
                  , c = a.array;
                c[0] = o.x,
                c[1] = o.y,
                c[2] = o.z,
                c[3] = i.x,
                c[4] = o.y,
                c[5] = o.z,
                c[6] = i.x,
                c[7] = i.y,
                c[8] = o.z,
                c[9] = o.x,
                c[10] = i.y,
                c[11] = o.z,
                c[12] = o.x,
                c[13] = o.y,
                c[14] = i.z,
                c[15] = i.x,
                c[16] = o.y,
                c[17] = i.z,
                c[18] = i.x,
                c[19] = i.y,
                c[20] = i.z,
                c[21] = o.x,
                c[22] = i.y,
                c[23] = i.z,
                a.needsUpdate = !0,
                this.geometry.computeBoundingSphere()
            }
            setFromObject(e) {
                return this.object = e,
                this.update(),
                this
            }
            copy(e, i) {
                return super.copy(e, i),
                this.object = e.object,
                this
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class zD extends Xa {
            constructor(e, i=16776960) {
                const o = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                  , a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
                  , c = new Ai;
                c.setIndex(new dr(o,1)),
                c.setAttribute("position", new Rn(a,3)),
                super(c, new ro({
                    color: i,
                    toneMapped: !1
                })),
                this.box = e,
                this.type = "Box3Helper",
                this.geometry.computeBoundingSphere()
            }
            updateMatrixWorld(e) {
                const i = this.box;
                i.isEmpty() || (i.getCenter(this.position),
                i.getSize(this.scale),
                this.scale.multiplyScalar(.5),
                super.updateMatrixWorld(e))
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class GD extends ec {
            constructor(e, i=1, o=16776960) {
                const a = o
                  , c = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
                  , d = new Ai;
                d.setAttribute("position", new Rn(c,3)),
                d.computeBoundingSphere(),
                super(d, new ro({
                    color: a,
                    toneMapped: !1
                })),
                this.type = "PlaneHelper",
                this.plane = e,
                this.size = i;
                const f = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
                  , v = new Ai;
                v.setAttribute("position", new Rn(f,3)),
                v.computeBoundingSphere(),
                this.add(new Es(v,new ql({
                    color: a,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1
                })))
            }
            updateMatrixWorld(e) {
                this.position.set(0, 0, 0),
                this.scale.set(.5 * this.size, .5 * this.size, 1),
                this.lookAt(this.plane.normal),
                this.translateZ(-this.plane.constant),
                super.updateMatrixWorld(e)
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose(),
                this.children[0].geometry.dispose(),
                this.children[0].material.dispose()
            }
        }
        const Qb = new me;
        let zp, Y0;
        class HD extends Qi {
            constructor(e=new me(0,0,1), i=new me(0,0,0), o=1, a=16776960, c=o * .2, d=c * .2) {
                super(),
                this.type = "ArrowHelper",
                zp === void 0 && (zp = new Ai,
                zp.setAttribute("position", new Rn([0, 0, 0, 0, 1, 0],3)),
                Y0 = new Vc(0,.5,1,5,1),
                Y0.translate(0, -.5, 0)),
                this.position.copy(i),
                this.line = new ec(zp,new ro({
                    color: a,
                    toneMapped: !1
                })),
                this.line.matrixAutoUpdate = !1,
                this.add(this.line),
                this.cone = new Es(Y0,new ql({
                    color: a,
                    toneMapped: !1
                })),
                this.cone.matrixAutoUpdate = !1,
                this.add(this.cone),
                this.setDirection(e),
                this.setLength(o, c, d)
            }
            setDirection(e) {
                if (e.y > .99999)
                    this.quaternion.set(0, 0, 0, 1);
                else if (e.y < -.99999)
                    this.quaternion.set(1, 0, 0, 0);
                else {
                    Qb.set(e.z, 0, -e.x).normalize();
                    const i = Math.acos(e.y);
                    this.quaternion.setFromAxisAngle(Qb, i)
                }
            }
            setLength(e, i=e * .2, o=i * .2) {
                this.line.scale.set(1, Math.max(1e-4, e - i), 1),
                this.line.updateMatrix(),
                this.cone.scale.set(o, i, o),
                this.cone.position.y = e,
                this.cone.updateMatrix()
            }
            setColor(e) {
                this.line.material.color.set(e),
                this.cone.material.color.set(e)
            }
            copy(e) {
                return super.copy(e, !1),
                this.line.copy(e.line),
                this.cone.copy(e.cone),
                this
            }
            dispose() {
                this.line.geometry.dispose(),
                this.line.material.dispose(),
                this.cone.geometry.dispose(),
                this.cone.material.dispose()
            }
        }
        class VD extends Xa {
            constructor(e=1) {
                const i = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
                  , o = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
                  , a = new Ai;
                a.setAttribute("position", new Rn(i,3)),
                a.setAttribute("color", new Rn(o,3));
                const c = new ro({
                    vertexColors: !0,
                    toneMapped: !1
                });
                super(a, c),
                this.type = "AxesHelper"
            }
            setColors(e, i, o) {
                const a = new gn
                  , c = this.geometry.attributes.color.array;
                return a.set(e),
                a.toArray(c, 0),
                a.toArray(c, 3),
                a.set(i),
                a.toArray(c, 6),
                a.toArray(c, 9),
                a.set(o),
                a.toArray(c, 12),
                a.toArray(c, 15),
                this.geometry.attributes.color.needsUpdate = !0,
                this
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        window.AxesHelper = VD;
        class WD {
            constructor() {
                this.type = "ShapePath",
                this.color = new gn,
                this.subPaths = [],
                this.currentPath = null
            }
            moveTo(e, i) {
                return this.currentPath = new rd,
                this.subPaths.push(this.currentPath),
                this.currentPath.moveTo(e, i),
                this
            }
            lineTo(e, i) {
                return this.currentPath.lineTo(e, i),
                this
            }
            quadraticCurveTo(e, i, o, a) {
                return this.currentPath.quadraticCurveTo(e, i, o, a),
                this
            }
            bezierCurveTo(e, i, o, a, c, d) {
                return this.currentPath.bezierCurveTo(e, i, o, a, c, d),
                this
            }
            splineThru(e) {
                return this.currentPath.splineThru(e),
                this
            }
            toShapes(e) {
                function i(Q) {
                    const Z = [];
                    for (let X = 0, K = Q.length; X < K; X++) {
                        const de = Q[X]
                          , be = new Wc;
                        be.curves = de.curves,
                        Z.push(be)
                    }
                    return Z
                }
                function o(Q, Z) {
                    const X = Z.length;
                    let K = !1;
                    for (let de = X - 1, be = 0; be < X; de = be++) {
                        let Me = Z[de]
                          , J = Z[be]
                          , ge = J.x - Me.x
                          , Le = J.y - Me.y;
                        if (Math.abs(Le) > Number.EPSILON) {
                            if (Le < 0 && (Me = Z[be],
                            ge = -ge,
                            J = Z[de],
                            Le = -Le),
                            Q.y < Me.y || Q.y > J.y)
                                continue;
                            if (Q.y === Me.y) {
                                if (Q.x === Me.x)
                                    return !0
                            } else {
                                const tt = Le * (Q.x - Me.x) - ge * (Q.y - Me.y);
                                if (tt === 0)
                                    return !0;
                                if (tt < 0)
                                    continue;
                                K = !K
                            }
                        } else {
                            if (Q.y !== Me.y)
                                continue;
                            if (J.x <= Q.x && Q.x <= Me.x || Me.x <= Q.x && Q.x <= J.x)
                                return !0
                        }
                    }
                    return K
                }
                const a = Ya.isClockWise
                  , c = this.subPaths;
                if (c.length === 0)
                    return [];
                let d, f, v;
                const x = [];
                if (c.length === 1)
                    return f = c[0],
                    v = new Wc,
                    v.curves = f.curves,
                    x.push(v),
                    x;
                let w = !a(c[0].getPoints());
                w = e ? !w : w;
                const P = []
                  , M = [];
                let I = [], z = 0, O;
                M[z] = void 0,
                I[z] = [];
                for (let Q = 0, Z = c.length; Q < Z; Q++)
                    f = c[Q],
                    O = f.getPoints(),
                    d = a(O),
                    d = e ? !d : d,
                    d ? (!w && M[z] && z++,
                    M[z] = {
                        s: new Wc,
                        p: O
                    },
                    M[z].s.curves = f.curves,
                    w && z++,
                    I[z] = []) : I[z].push({
                        h: f,
                        p: O[0]
                    });
                if (!M[0])
                    return i(c);
                if (M.length > 1) {
                    let Q = !1
                      , Z = 0;
                    for (let X = 0, K = M.length; X < K; X++)
                        P[X] = [];
                    for (let X = 0, K = M.length; X < K; X++) {
                        const de = I[X];
                        for (let be = 0; be < de.length; be++) {
                            const Me = de[be];
                            let J = !0;
                            for (let ge = 0; ge < M.length; ge++)
                                o(Me.p, M[ge].p) && (X !== ge && Z++,
                                J ? (J = !1,
                                P[ge].push(Me)) : Q = !0);
                            J && P[X].push(Me)
                        }
                    }
                    Z > 0 && Q === !1 && (I = P)
                }
                let k;
                for (let Q = 0, Z = M.length; Q < Z; Q++) {
                    v = M[Q].s,
                    x.push(v),
                    k = I[Q];
                    for (let X = 0, K = k.length; X < K; X++)
                        v.holes.push(k[X].h)
                }
                return x
            }
        }
        const Sl = jD();
        function jD() {
            const u = new ArrayBuffer(4)
              , e = new Float32Array(u)
              , i = new Uint32Array(u)
              , o = new Uint32Array(512)
              , a = new Uint32Array(512);
            for (let v = 0; v < 256; ++v) {
                const x = v - 127;
                x < -27 ? (o[v] = 0,
                o[v | 256] = 32768,
                a[v] = 24,
                a[v | 256] = 24) : x < -14 ? (o[v] = 1024 >> -x - 14,
                o[v | 256] = 1024 >> -x - 14 | 32768,
                a[v] = -x - 1,
                a[v | 256] = -x - 1) : x <= 15 ? (o[v] = x + 15 << 10,
                o[v | 256] = x + 15 << 10 | 32768,
                a[v] = 13,
                a[v | 256] = 13) : x < 128 ? (o[v] = 31744,
                o[v | 256] = 64512,
                a[v] = 24,
                a[v | 256] = 24) : (o[v] = 31744,
                o[v | 256] = 64512,
                a[v] = 13,
                a[v | 256] = 13)
            }
            const c = new Uint32Array(2048)
              , d = new Uint32Array(64)
              , f = new Uint32Array(64);
            for (let v = 1; v < 1024; ++v) {
                let x = v << 13
                  , w = 0;
                for (; !(x & 8388608); )
                    x <<= 1,
                    w -= 8388608;
                x &= -8388609,
                w += 947912704,
                c[v] = x | w
            }
            for (let v = 1024; v < 2048; ++v)
                c[v] = 939524096 + (v - 1024 << 13);
            for (let v = 1; v < 31; ++v)
                d[v] = v << 23;
            d[31] = 1199570944,
            d[32] = 2147483648;
            for (let v = 33; v < 63; ++v)
                d[v] = 2147483648 + (v - 32 << 23);
            d[63] = 3347054592;
            for (let v = 1; v < 64; ++v)
                v !== 32 && (f[v] = 1024);
            return {
                floatView: e,
                uint32View: i,
                baseTable: o,
                shiftTable: a,
                mantissaTable: c,
                exponentTable: d,
                offsetTable: f
            }
        }
        function XD(u) {
            Math.abs(u) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
            u = Wi(u, -65504, 65504),
            Sl.floatView[0] = u;
            const e = Sl.uint32View[0]
              , i = e >> 23 & 511;
            return Sl.baseTable[i] + ((e & 8388607) >> Sl.shiftTable[i])
        }
        function YD(u) {
            const e = u >> 10;
            return Sl.uint32View[0] = Sl.mantissaTable[Sl.offsetTable[e] + (u & 1023)] + Sl.exponentTable[e],
            Sl.floatView[0]
        }
        const QD = {
            toHalfFloat: XD,
            fromHalfFloat: YD
        };
        class KD extends Jl {
            constructor(e, i, o, a, c, d) {
                console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),
                super(e, i, o, a, c, d)
            }
        }
        class ZD extends sd {
            constructor(e, i, o, a) {
                console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),
                super(e, i, o, a)
            }
        }
        class qD extends od {
            constructor(e, i, o, a) {
                console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),
                super(e, i, o, a)
            }
        }
        class JD extends ad {
            constructor(e, i, o, a, c, d, f) {
                console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),
                super(e, i, o, a, c, d, f)
            }
        }
        class $D extends Vc {
            constructor(e, i, o, a, c, d, f, v) {
                console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),
                super(e, i, o, a, c, d, f, v)
            }
        }
        class eL extends ld {
            constructor(e, i) {
                console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),
                super(e, i)
            }
        }
        class tL extends dd {
            constructor(e, i) {
                console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),
                super(e, i)
            }
        }
        class nL extends fd {
            constructor(e, i) {
                console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),
                super(e, i)
            }
        }
        class iL extends Xu {
            constructor(e, i, o, a) {
                console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),
                super(e, i, o, a)
            }
        }
        class rL extends Qu {
            constructor(e, i) {
                console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),
                super(e, i)
            }
        }
        class sL extends Bu {
            constructor(e, i, o, a) {
                console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),
                super(e, i, o, a)
            }
        }
        class oL extends bl {
            constructor(e, i, o, a) {
                console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),
                super(e, i, o, a)
            }
        }
        class aL extends pd {
            constructor(e, i, o, a, c, d) {
                console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),
                super(e, i, o, a, c, d)
            }
        }
        class lL extends md {
            constructor(e, i) {
                console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),
                super(e, i)
            }
        }
        class cL extends Ku {
            constructor(e, i, o, a, c, d, f) {
                console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),
                super(e, i, o, a, c, d, f)
            }
        }
        class uL extends gd {
            constructor(e, i) {
                console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),
                super(e, i)
            }
        }
        class hL extends vd {
            constructor(e, i, o, a, c) {
                console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),
                super(e, i, o, a, c)
            }
        }
        class dL extends _d {
            constructor(e, i, o, a, c, d) {
                console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),
                super(e, i, o, a, c, d)
            }
        }
        class fL extends yd {
            constructor(e, i, o, a, c) {
                console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),
                super(e, i, o, a, c)
            }
        }
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: l
            }
        })),
        typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = l)
    }
    ,
    980: (t,n,r)=>{
        r.d(n, {
            LX: ()=>s,
            Vu: ()=>h,
            hR: ()=>l
        });
        async function s(g) {
            return new Promise((_,A)=>{
                const m = new FileReader;
                m.onload = ()=>_(m.result),
                m.onerror = A,
                m.readAsArrayBuffer(g)
            }
            )
        }
        async function h(g) {
            return new Promise((_,A)=>{
                const m = new FileReader;
                m.onload = ()=>_(m.result),
                m.onerror = A,
                m.readAsText(g)
            }
            )
        }
        async function l(g) {
            return new Promise((_,A)=>{
                const m = new FileReader;
                m.onload = ()=>_(m.result),
                m.onerror = A,
                m.readAsDataURL(g)
            }
            )
        }
    }
    ,
    631: (t,n,r)=>{
        r.r(n),
        r.d(n, {
            TweenChain: ()=>h
        });
        const s = r(622);
        class h {
            constructor(g) {
                this._object = g,
                this._tween = new s.Tween(g)
            }
            start() {
                return this._tween.start(),
                this
            }
            stop() {
                return this._tween.stop(),
                this
            }
            repeat(g) {
                return this._chainedTween.repeat(g),
                this
            }
            union() {
                return this._chainedTween = this._tween = new s.Tween(this._object).union(this._tween, this._chainedTween),
                this
            }
            call(g) {
                return this._chainTween().call(g),
                this
            }
            delay(g) {
                return this._chainTween().delay(g),
                this
            }
            to(g, _, A) {
                let m = this._chainTween().to(g, _);
                return A && (A.from && m.from(A.from),
                A.easing && m.easing(A.easing),
                A.onStart && m.onStart(A.onStart),
                A.onStop && m.onStop(A.onStop),
                A.onComplete && m.onComplete(A.onComplete),
                A.onUpdate && m.onUpdate(A.onUpdate),
                A.onRepeat && m.onRepeat(A.onRepeat)),
                this
            }
            _chainTween() {
                let g = this._tween;
                return this._chainedTween && (g = new s.Tween(this._object),
                this._chainedTween.chain(g)),
                this._chainedTween = g,
                g
            }
        }
    }
    ,
    622: (t,n)=>{
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = {
            Linear: {
                None: function(N) {
                    return N
                }
            },
            Quadratic: {
                In: function(N) {
                    return N * N
                },
                Out: function(N) {
                    return N * (2 - N)
                },
                InOut: function(N) {
                    return (N *= 2) < 1 ? .5 * N * N : -.5 * (--N * (N - 2) - 1)
                }
            },
            Cubic: {
                In: function(N) {
                    return N * N * N
                },
                Out: function(N) {
                    return --N * N * N + 1
                },
                InOut: function(N) {
                    return (N *= 2) < 1 ? .5 * N * N * N : .5 * ((N -= 2) * N * N + 2)
                }
            },
            Quartic: {
                In: function(N) {
                    return N * N * N * N
                },
                Out: function(N) {
                    return 1 - --N * N * N * N
                },
                InOut: function(N) {
                    return (N *= 2) < 1 ? .5 * N * N * N * N : -.5 * ((N -= 2) * N * N * N - 2)
                }
            },
            Quintic: {
                In: function(N) {
                    return N * N * N * N * N
                },
                Out: function(N) {
                    return --N * N * N * N * N + 1
                },
                InOut: function(N) {
                    return (N *= 2) < 1 ? .5 * N * N * N * N * N : .5 * ((N -= 2) * N * N * N * N + 2)
                }
            },
            Sinusoidal: {
                In: function(N) {
                    return 1 - Math.cos(N * Math.PI / 2)
                },
                Out: function(N) {
                    return Math.sin(N * Math.PI / 2)
                },
                InOut: function(N) {
                    return .5 * (1 - Math.cos(Math.PI * N))
                }
            },
            Exponential: {
                In: function(N) {
                    return N === 0 ? 0 : Math.pow(1024, N - 1)
                },
                Out: function(N) {
                    return N === 1 ? 1 : 1 - Math.pow(2, -10 * N)
                },
                InOut: function(N) {
                    return N === 0 ? 0 : N === 1 ? 1 : (N *= 2) < 1 ? .5 * Math.pow(1024, N - 1) : .5 * (-Math.pow(2, -10 * (N - 1)) + 2)
                }
            },
            Circular: {
                In: function(N) {
                    return 1 - Math.sqrt(1 - N * N)
                },
                Out: function(N) {
                    return Math.sqrt(1 - --N * N)
                },
                InOut: function(N) {
                    return (N *= 2) < 1 ? -.5 * (Math.sqrt(1 - N * N) - 1) : .5 * (Math.sqrt(1 - (N -= 2) * N) + 1)
                }
            },
            Elastic: {
                In: function(N) {
                    return N === 0 ? 0 : N === 1 ? 1 : -Math.pow(2, 10 * (N - 1)) * Math.sin((N - 1.1) * 5 * Math.PI)
                },
                Out: function(N) {
                    return N === 0 ? 0 : N === 1 ? 1 : Math.pow(2, -10 * N) * Math.sin((N - .1) * 5 * Math.PI) + 1
                },
                InOut: function(N) {
                    return N === 0 ? 0 : N === 1 ? 1 : (N *= 2,
                    N < 1 ? -.5 * Math.pow(2, 10 * (N - 1)) * Math.sin((N - 1.1) * 5 * Math.PI) : .5 * Math.pow(2, -10 * (N - 1)) * Math.sin((N - 1.1) * 5 * Math.PI) + 1)
                }
            },
            Back: {
                In: function(N) {
                    var ie = 1.70158;
                    return N * N * ((ie + 1) * N - ie)
                },
                Out: function(N) {
                    var ie = 1.70158;
                    return --N * N * ((ie + 1) * N + ie) + 1
                },
                InOut: function(N) {
                    var ie = 2.5949095;
                    return (N *= 2) < 1 ? .5 * (N * N * ((ie + 1) * N - ie)) : .5 * ((N -= 2) * N * ((ie + 1) * N + ie) + 2)
                }
            },
            Bounce: {
                In: function(N) {
                    return 1 - r.Bounce.Out(1 - N)
                },
                Out: function(N) {
                    return N < 1 / 2.75 ? 7.5625 * N * N : N < 2 / 2.75 ? 7.5625 * (N -= 1.5 / 2.75) * N + .75 : N < 2.5 / 2.75 ? 7.5625 * (N -= 2.25 / 2.75) * N + .9375 : 7.5625 * (N -= 2.625 / 2.75) * N + .984375
                },
                InOut: function(N) {
                    return N < .5 ? r.Bounce.In(N * 2) * .5 : r.Bounce.Out(N * 2 - 1) * .5 + .5
                }
            }
        }, s;
        typeof self > "u" && typeof process < "u" && process.hrtime ? s = function() {
            var N = process.hrtime();
            return N[0] * 1e3 + N[1] / 1e6
        }
        : typeof self < "u" && self.performance !== void 0 && self.performance.now !== void 0 ? s = self.performance.now.bind(self.performance) : Date.now !== void 0 ? s = Date.now : s = function() {
            return new Date().getTime()
        }
        ;
        function h() {
            return s() * .001
        }
        var l = function() {
            function N() {
                this._tweens = {},
                this._tweensAddedDuringUpdate = {}
            }
            return N.prototype.getAll = function() {
                var ie = this;
                return Object.keys(this._tweens).map(function(_e) {
                    return ie._tweens[_e]
                })
            }
            ,
            N.prototype.removeAll = function() {
                this._tweens = {}
            }
            ,
            N.prototype.add = function(ie) {
                this._tweens[ie.getId()] = ie,
                this._tweensAddedDuringUpdate[ie.getId()] = ie
            }
            ,
            N.prototype.remove = function(ie) {
                delete this._tweens[ie.getId()],
                delete this._tweensAddedDuringUpdate[ie.getId()]
            }
            ,
            N.prototype.update = function(ie, _e) {
                ie === void 0 && (ie = h()),
                _e === void 0 && (_e = !1);
                var Pe = Object.keys(this._tweens);
                if (Pe.length === 0)
                    return !1;
                for (; Pe.length > 0; ) {
                    this._tweensAddedDuringUpdate = {};
                    for (var Be = 0; Be < Pe.length; Be++) {
                        var Re = this._tweens[Pe[Be]]
                          , ct = !_e;
                        Re && Re.update(ie, ct) === !1 && !_e && delete this._tweens[Pe[Be]]
                    }
                    Pe = Object.keys(this._tweensAddedDuringUpdate)
                }
                return !0
            }
            ,
            N
        }()
          , g = {
            Linear: function(N, ie) {
                var _e = N.length - 1
                  , Pe = _e * ie
                  , Be = Math.floor(Pe)
                  , Re = g.Utils.Linear;
                return ie < 0 ? Re(N[0], N[1], Pe) : ie > 1 ? Re(N[_e], N[_e - 1], _e - Pe) : Re(N[Be], N[Be + 1 > _e ? _e : Be + 1], Pe - Be)
            },
            Bezier: function(N, ie) {
                for (var _e = 0, Pe = N.length - 1, Be = Math.pow, Re = g.Utils.Bernstein, ct = 0; ct <= Pe; ct++)
                    _e += Be(1 - ie, Pe - ct) * Be(ie, ct) * N[ct] * Re(Pe, ct);
                return _e
            },
            CatmullRom: function(N, ie) {
                var _e = N.length - 1
                  , Pe = _e * ie
                  , Be = Math.floor(Pe)
                  , Re = g.Utils.CatmullRom;
                return N[0] === N[_e] ? (ie < 0 && (Be = Math.floor(Pe = _e * (1 + ie))),
                Re(N[(Be - 1 + _e) % _e], N[Be], N[(Be + 1) % _e], N[(Be + 2) % _e], Pe - Be)) : ie < 0 ? N[0] - (Re(N[0], N[0], N[1], N[1], -Pe) - N[0]) : ie > 1 ? N[_e] - (Re(N[_e], N[_e], N[_e - 1], N[_e - 1], Pe - _e) - N[_e]) : Re(N[Be ? Be - 1 : 0], N[Be], N[_e < Be + 1 ? _e : Be + 1], N[_e < Be + 2 ? _e : Be + 2], Pe - Be)
            },
            Utils: {
                Linear: function(N, ie, _e) {
                    return (ie - N) * _e + N
                },
                Bernstein: function(N, ie) {
                    var _e = g.Utils.Factorial;
                    return _e(N) / _e(ie) / _e(N - ie)
                },
                Factorial: function() {
                    var N = [1];
                    return function(ie) {
                        var _e = 1;
                        if (N[ie])
                            return N[ie];
                        for (var Pe = ie; Pe > 1; Pe--)
                            _e *= Pe;
                        return N[ie] = _e,
                        _e
                    }
                }(),
                CatmullRom: function(N, ie, _e, Pe, Be) {
                    var Re = (_e - N) * .5
                      , ct = (Pe - ie) * .5
                      , et = Be * Be
                      , Ze = Be * et;
                    return (2 * ie - 2 * _e + Re + ct) * Ze + (-3 * ie + 3 * _e - 2 * Re - ct) * et + Re * Be + ie
                }
            }
        }
          , _ = function() {
            function N() {}
            return N.nextId = function() {
                return N._nextId++
            }
            ,
            N._nextId = 0,
            N
        }()
          , A = new l
          , m = function() {
            function N(ie, _e) {
                _e === void 0 && (_e = A),
                this._object = ie,
                this._group = _e,
                this._isPaused = !1,
                this._pauseStart = 0,
                this._valuesStart = {},
                this._valuesEnd = {},
                this._valuesStartRepeat = {},
                this._duration = 0,
                this._initialRepeat = 0,
                this._repeat = 0,
                this._yoyo = !1,
                this._isPlaying = !1,
                this._reversed = !1,
                this._delayTime = 0,
                this._startTime = 0,
                this._easingFunction = r.Linear.None,
                this._interpolationFunction = g.Linear,
                this._chainedTweens = [],
                this._onStartCallbackFired = !1,
                this._id = _.nextId(),
                this._isChainStopped = !1,
                this._goToEnd = !1,
                this._headTween = null,
                this._tailTween = null,
                this._headStart = !1
            }
            return N.prototype.getId = function() {
                return this._id
            }
            ,
            N.prototype.isPlaying = function() {
                return this._isPlaying
            }
            ,
            N.prototype.isPaused = function() {
                return this._isPaused
            }
            ,
            N.prototype.duration = function(ie) {
                return this._duration = ie,
                this
            }
            ,
            N.prototype.start = function(ie) {
                if (this._isPlaying)
                    return this;
                if (this._group && this._group.add(this),
                this._repeat = this._initialRepeat,
                this._reversed) {
                    this._reversed = !1;
                    for (var _e in this._valuesStartRepeat)
                        this._swapEndStartRepeatValues(_e),
                        this._valuesStart[_e] = this._valuesStartRepeat[_e]
                }
                return this._isPlaying = !0,
                this._isPaused = !1,
                this._onStartCallbackFired = !1,
                this._isChainStopped = !1,
                this._startTime = ie !== void 0 ? typeof ie == "string" ? h() + parseFloat(ie) : ie : h(),
                this._startTime += this._delayTime,
                this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat),
                this
            }
            ,
            N.prototype._setupProperties = function(ie, _e, Pe, Be) {
                for (var Re in Pe) {
                    var ct = ie[Re]
                      , et = Array.isArray(ct)
                      , Ze = et ? "array" : typeof ct
                      , Nt = !et && Array.isArray(Pe[Re]);
                    if (!(Ze === "undefined" || Ze === "function")) {
                        if (Nt) {
                            var Bt = Pe[Re];
                            if (Bt.length === 0)
                                continue;
                            Bt = Bt.map(this._handleRelativeValue.bind(this, ct)),
                            Pe[Re] = [ct].concat(Bt)
                        }
                        if ((Ze === "object" || et) && ct && !Nt) {
                            _e[Re] = et ? [] : {};
                            for (var en in ct)
                                _e[Re][en] = ct[en];
                            Be[Re] = et ? [] : {},
                            this._setupProperties(ct, _e[Re], Pe[Re], Be[Re])
                        } else
                            typeof _e[Re] > "u" && (_e[Re] = ct),
                            et || (_e[Re] *= 1),
                            Nt ? Be[Re] = Pe[Re].slice().reverse() : Be[Re] = _e[Re] || 0
                    }
                }
            }
            ,
            N.prototype.stop = function() {
                return this._isChainStopped || (this._isChainStopped = !0,
                this.stopChainedTweens()),
                this._isPlaying ? (this._group && this._group.remove(this),
                this._isPlaying = !1,
                this._isPaused = !1,
                this._onStopCallback && this._onStopCallback(this._object),
                this) : this
            }
            ,
            N.prototype.end = function() {
                return this._goToEnd = !0,
                this.update(1 / 0),
                this
            }
            ,
            N.prototype.pause = function(ie) {
                return ie === void 0 && (ie = h()),
                this._isPaused || !this._isPlaying ? this : (this._isPaused = !0,
                this._pauseStart = ie,
                this._group && this._group.remove(this),
                this)
            }
            ,
            N.prototype.resume = function(ie) {
                return ie === void 0 && (ie = h()),
                !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1,
                this._startTime += ie - this._pauseStart,
                this._pauseStart = 0,
                this._group && this._group.add(this),
                this)
            }
            ,
            N.prototype.stopChainedTweens = function() {
                for (var ie = 0, _e = this._chainedTweens.length; ie < _e; ie++)
                    this._chainedTweens[ie].stop();
                return this._chainedTweens = [],
                this
            }
            ,
            N.prototype.group = function(ie) {
                return this._group = ie,
                this
            }
            ,
            N.prototype.call = function(ie) {
                return this._onFinishCallback = ie,
                this
            }
            ,
            N.prototype.from = function(ie) {
                return this._valuesStart = Object.create(ie),
                this
            }
            ,
            N.prototype.to = function(ie, _e) {
                return this._valuesEnd = Object.create(ie),
                _e !== void 0 && (this._duration = _e),
                this._chainedTween = this,
                this
            }
            ,
            N.prototype.delay = function(ie) {
                return this._delayTime = ie,
                this
            }
            ,
            N.prototype.union = function(ie, _e) {
                return this._headTween = ie,
                this._tailTween = _e.chain(this),
                this._headStart = !0,
                this
            }
            ,
            N.prototype.repeat = function(ie) {
                return this._initialRepeat = ie,
                this._repeat = ie,
                this
            }
            ,
            N.prototype.repeatDelay = function(ie) {
                return this._repeatDelayTime = ie,
                this
            }
            ,
            N.prototype.yoyo = function(ie) {
                return this._yoyo = ie,
                this
            }
            ,
            N.prototype.easing = function(ie) {
                return this._easingFunction = ie,
                this
            }
            ,
            N.prototype.interpolation = function(ie) {
                return this._interpolationFunction = ie,
                this
            }
            ,
            N.prototype.chain = function() {
                for (var ie = [], _e = 0; _e < arguments.length; _e++)
                    ie[_e] = arguments[_e];
                return this._chainedTweens = ie,
                this
            }
            ,
            N.prototype.unchain = function() {
                for (var ie = 0; ie < arguments.length; ie++) {
                    let _e = this._chainedTweens.findIndex(Pe=>Pe == arguments[ie]);
                    _e > -1 && this._chainedTweens.splice(_e, 1)
                }
                return this
            }
            ,
            N.prototype.onStart = function(ie) {
                return this._onStartCallback = ie,
                this
            }
            ,
            N.prototype.onUpdate = function(ie) {
                return this._onUpdateCallback = ie,
                this
            }
            ,
            N.prototype.onRepeat = function(ie) {
                return this._onRepeatCallback = ie,
                this
            }
            ,
            N.prototype.onComplete = function(ie) {
                return this._onCompleteCallback = ie,
                this
            }
            ,
            N.prototype.onStop = function(ie) {
                return this._onStopCallback = ie,
                this
            }
            ,
            N.prototype.update = function(ie, _e) {
                if (ie === void 0 && (ie = h()),
                _e === void 0 && (_e = !0),
                this._isPaused)
                    return !0;
                var Pe, Be, Re = this._startTime + this._duration;
                if (!this._goToEnd && !this._isPlaying) {
                    if (ie > Re)
                        return !1;
                    _e && this.start(ie)
                }
                if (this._goToEnd = !1,
                ie < this._startTime)
                    return !0;
                this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object),
                this._onStartCallbackFired = !0),
                Be = (ie - this._startTime) / this._duration,
                Be = this._duration === 0 || Be > 1 ? 1 : Be;
                var ct = this._easingFunction(Be);
                if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, ct),
                this._onUpdateCallback && this._onUpdateCallback(this._object, Be),
                Be === 1) {
                    if (this._onFinishCallback && this._onFinishCallback(this._object),
                    this._headTween && this._headStart)
                        return this._headTween.start(this._startTime + this._duration),
                        this._headStart = !1,
                        this._isPlaying = !1,
                        !1;
                    if (this._repeat > 0) {
                        isFinite(this._repeat) && this._repeat--;
                        for (Pe in this._valuesStartRepeat)
                            !this._yoyo && typeof this._valuesEnd[Pe] == "string" && (this._valuesStartRepeat[Pe] = this._valuesStartRepeat[Pe] + parseFloat(this._valuesEnd[Pe])),
                            this._yoyo && this._swapEndStartRepeatValues(Pe),
                            this._valuesStart[Pe] = this._valuesStartRepeat[Pe];
                        return this._yoyo && (this._reversed = !this._reversed),
                        this._repeatDelayTime !== void 0 ? this._startTime = ie + this._repeatDelayTime : this._startTime = ie + this._delayTime,
                        this._onRepeatCallback && this._onRepeatCallback(this._object),
                        this._headTween && (this._headStart = !0,
                        this._initialRepeat = this._repeat),
                        !0
                    } else {
                        this._tailTween && this._tailTween.unchain(this),
                        this._onCompleteCallback && this._onCompleteCallback(this._object);
                        for (var et = 0, Ze = this._chainedTweens.length; et < Ze; et++)
                            this._chainedTweens[et].start(this._startTime + this._duration);
                        return this._isPlaying = !1,
                        !1
                    }
                }
                return !0
            }
            ,
            N.prototype._updateProperties = function(ie, _e, Pe, Be) {
                for (var Re in Pe)
                    if (_e[Re] !== void 0) {
                        var ct = _e[Re] || 0
                          , et = Pe[Re]
                          , Ze = Array.isArray(ie[Re])
                          , Nt = Array.isArray(et)
                          , Bt = !Ze && Nt;
                        if (Bt)
                            ie[Re] = this._interpolationFunction(et, Be);
                        else if (typeof et == "object" && et) {
                            this._updateProperties(ie[Re], ct, et, Be);
                            let en = Object.getOwnPropertyDescriptor(ie, Re);
                            en && en.set && (ie[Re] = ie[Re])
                        } else
                            et = this._handleRelativeValue(ct, et),
                            typeof et == "number" && (ie[Re] = ct + (et - ct) * Be)
                    }
            }
            ,
            N.prototype._handleRelativeValue = function(ie, _e) {
                return typeof _e != "string" ? _e : _e.charAt(0) === "+" || _e.charAt(0) === "-" ? ie + parseFloat(_e) : parseFloat(_e)
            }
            ,
            N.prototype._swapEndStartRepeatValues = function(ie) {
                var _e = this._valuesStartRepeat[ie]
                  , Pe = this._valuesEnd[ie];
                typeof Pe == "string" ? this._valuesStartRepeat[ie] = this._valuesStartRepeat[ie] + parseFloat(Pe) : this._valuesStartRepeat[ie] = this._valuesEnd[ie],
                this._valuesEnd[ie] = _e
            }
            ,
            N
        }()
          , D = "18.6.4"
          , U = _.nextId
          , R = A
          , ne = R.getAll.bind(R)
          , ce = R.removeAll.bind(R)
          , xe = R.add.bind(R)
          , Se = R.remove.bind(R)
          , $ = R.update.bind(R)
          , q = {
            Easing: r,
            Group: l,
            Interpolation: g,
            now: h,
            Sequence: _,
            nextId: U,
            Tween: m,
            VERSION: D,
            getAll: ne,
            removeAll: ce,
            add: xe,
            remove: Se,
            update: $
        };
        n.Easing = r,
        n.Group = l,
        n.Interpolation = g,
        n.Sequence = _,
        n.Tween = m,
        n.VERSION = D,
        n.add = xe,
        n.default = q,
        n.getAll = ne,
        n.nextId = U,
        n.now = h,
        n.remove = Se,
        n.removeAll = ce,
        n.update = $
    }
}
  , cA = {};
function Da(t) {
    var n = cA[t];
    if (n !== void 0)
        return n.exports;
    var r = cA[t] = {
        exports: {}
    };
    return X3[t](r, r.exports, Da),
    r.exports
}
Da.d = (t,n)=>{
    for (var r in n)
        Da.o(n, r) && !Da.o(t, r) && Object.defineProperty(t, r, {
            enumerable: !0,
            get: n[r]
        })
}
;
Da.o = (t,n)=>Object.prototype.hasOwnProperty.call(t, n);
Da.r = t=>{
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
    }),
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}
;
var H = {};
(()=>{
    Da.d(H, {
        J12: ()=>t.J12,
        $c: ()=>t.$c,
        I_b: ()=>t.I_b,
        oGK: ()=>t.oGK,
        $p: ()=>t.$p,
        $q: ()=>t.$q,
        $r: ()=>t.$r,
        L0d: ()=>t.L0d,
        i5S: ()=>t.i5S,
        nXV: ()=>t.nXV,
        bd1: ()=>t.bd1,
        LY2: ()=>t.LY2,
        iAO: ()=>t.iAO,
        bGH: ()=>t.bGH,
        NDo: ()=>t.NDo,
        gSk: ()=>t.gSk,
        WMw: ()=>t.WMw,
        OTo: ()=>t.OTo,
        Se2: ()=>t.Se2,
        cum: ()=>t.cum,
        Mig: ()=>t.Mig,
        i_9: ()=>t.i_9,
        fwF: ()=>t.fwF,
        m7l: ()=>t.m7l,
        vXP: ()=>t.vXP,
        sYA: ()=>t.sYA,
        Xcj: ()=>t.Xcj,
        mzJ: ()=>t.mzJ,
        ZZA: ()=>t.ZZA,
        T__: ()=>t.T__,
        HkE: ()=>t.HkE,
        tGC: ()=>t.tGC,
        gOo: ()=>t.gOo,
        f03: ()=>t.f03,
        BbS: ()=>t.BbS,
        kqm: ()=>t.kqm,
        GPr: ()=>t.GPr,
        Hmr: ()=>t.Hmr,
        SJI: ()=>t.SJI,
        mTL: ()=>t.mTL,
        y8_: ()=>t.y8_,
        Xim: ()=>t.Xim,
        _Li: ()=>t._Li,
        z81: ()=>t.z81,
        _MY: ()=>t._MY,
        NBQ: ()=>t.NBQ,
        dFZ: ()=>mo,
        IIx: ()=>t.IIx,
        N$j: ()=>t.N$j,
        _YM: ()=>t._YM,
        TUj: ()=>t.TUj,
        ZzF: ()=>t.ZzF,
        GQ: ()=>t.GQ,
        nvb: ()=>t.nvb,
        DvJ: ()=>t.DvJ,
        fQA: ()=>t.fQA,
        ePP: ()=>t.ePP,
        TlE: ()=>t.TlE,
        u9r: ()=>t.u9r,
        s4_: ()=>t.s4_,
        T95: ()=>t.T95,
        CtF: ()=>t.CtF,
        V1s: ()=>t.V1s,
        Rki: ()=>t.Rki,
        ROQ: ()=>t.ROQ,
        YN5: ()=>t.YN5,
        BVQ: ()=>t.BVQ,
        YT8: ()=>t.YT8,
        YGz: ()=>t.YGz,
        WXy: ()=>t.WXy,
        trn: ()=>t.trn,
        zf8: ()=>t.zf8,
        uWy: ()=>t.uWy,
        SUY: ()=>t.SUY,
        Ilk: ()=>t.Ilk,
        R2R: ()=>t.R2R,
        epp: ()=>t.epp,
        Wrv: ()=>t.Wrv,
        EKy: ()=>t.EKy,
        $S: ()=>t.$S,
        wA2: ()=>t.wA2,
        Z_g: ()=>t.Z_g,
        EB7: ()=>t.EB7,
        DqL: ()=>t.DqL,
        _3: ()=>t._3,
        b_z: ()=>t.b_z,
        unp: ()=>t.unp,
        _am: ()=>t._am,
        fY$: ()=>t.fY$,
        vxC: ()=>t.vxC,
        BtG: ()=>t.BtG,
        cBK: ()=>t.cBK,
        g8_: ()=>t.g8_,
        AXT: ()=>t.AXT,
        yj7: ()=>t.yj7,
        dYG: ()=>t.dYG,
        tm_: ()=>t.tm_,
        S2y: ()=>t.S2y,
        B02: ()=>t.B02,
        PeU: ()=>t.PeU,
        Hyl: ()=>t.Hyl,
        Wqd: ()=>t.Wqd,
        SVw: ()=>t.SVw,
        Xaj: ()=>t.Xaj,
        dZ3: ()=>t.dZ3,
        m_w: ()=>t.m_w,
        fHI: ()=>t.fHI,
        LBq: ()=>t.LBq,
        JUT: ()=>t.JUT,
        p3g: ()=>t.p3g,
        IEO: ()=>t.IEO,
        yxD: ()=>t.yxD,
        A5E: ()=>t.A5E,
        jfJ: ()=>t.jfJ,
        T_J: ()=>t.T_J,
        tEQ: ()=>t.tEQ,
        qkB: ()=>t.qkB,
        brP: ()=>t.brP,
        $YQ: ()=>t.$YQ,
        iRp: ()=>t.iRp,
        Ox3: ()=>t.Ox3,
        cBI: ()=>t.cBI,
        cU9: ()=>t.cU9,
        ntt: ()=>t.ntt,
        DT1: ()=>t.DT1,
        Kgo: ()=>t.Kgo,
        ehD: ()=>t.ehD,
        fSK: ()=>t.fSK,
        Vdb: ()=>t.Vdb,
        l8J: ()=>t.l8J,
        dj0: ()=>t.dj0,
        QM0: ()=>t.QM0,
        q7E: ()=>t.q7E,
        TOt: ()=>t.TOt,
        Ny0: ()=>t.Ny0,
        qAh: ()=>t.qAh,
        eD: ()=>t.eD,
        jwo: ()=>t.jwo,
        dSO: ()=>t.dSO,
        Bf4: ()=>t.Bf4,
        USm: ()=>t.USm,
        pBf: ()=>t.pBf,
        vpe: ()=>t.vpe,
        $Vf: ()=>t.$Vf,
        O7d: ()=>t.O7d,
        Aek: ()=>t.Aek,
        hH6: ()=>t.hH6,
        e62: ()=>t.e62,
        a$l: ()=>t.a$l,
        OM3: ()=>t.OM3,
        VzW: ()=>t.VzW,
        ybr: ()=>t.ybr,
        yo9: ()=>t.yo9,
        Wzm: ()=>t.Wzm,
        zUS: ()=>t.zUS,
        Wl3: ()=>t.Wl3,
        iWj: ()=>t.iWj,
        ylh: ()=>t.ylh,
        v9Y: ()=>t.v9Y,
        LSk: ()=>t.LSk,
        uoT: ()=>t.uoT,
        w$m: ()=>t.w$m,
        ksN: ()=>t.ksN,
        j4z: ()=>t.j4z,
        OAl: ()=>t.OAl,
        VLJ: ()=>t.VLJ,
        ZAu: ()=>t.ZAu,
        k7s: ()=>t.k7s,
        cLu: ()=>t.cLu,
        vmT: ()=>t.vmT,
        Qpg: ()=>t.Qpg,
        So8: ()=>t.So8,
        BqW: ()=>s,
        MR2: ()=>r,
        o0j: ()=>n,
        GfI: ()=>Se,
        Wjw: ()=>t.Wjw,
        cJO: ()=>t.cJO,
        KCx: ()=>t.KCx,
        QRU: ()=>t.QRU,
        S3k: ()=>t.S3k,
        PpQ: ()=>t.PpQ,
        ZRs: ()=>t.ZRs,
        oqc: ()=>t.oqc,
        lb7: ()=>t.lb7,
        L5s: ()=>t.L5s,
        $TI: ()=>t.$TI,
        SPe: ()=>t.SPe,
        aVm: ()=>t.aVm,
        j87: ()=>t.j87,
        RNb: ()=>t.RNb,
        Kz5: ()=>t.Kz5,
        vpT: ()=>t.vpT,
        kB5: ()=>t.kB5,
        _C8: ()=>t._C8,
        Syv: ()=>t.Syv,
        NMF: ()=>t.NMF,
        pIN: ()=>t.pIN,
        eMJ: ()=>t.eMJ,
        ZtY: ()=>t.ZtY,
        x5V: ()=>t.x5V,
        tUh: ()=>t.tUh,
        z8B: ()=>t.z8B,
        __J: ()=>t.__J,
        GZb: ()=>t.GZb,
        p7y: ()=>t.p7y,
        udN: ()=>t.udN,
        S9g: ()=>t.S9g,
        Zr5: ()=>t.Zr5,
        vCF: ()=>t.vCF,
        yt0: ()=>t.yt0,
        uXU: ()=>t.uXU,
        _kC: ()=>t._kC,
        lk7: ()=>t.lk7,
        DvN: ()=>t.DvN,
        x12: ()=>t.x12,
        Zzh: ()=>t.Zzh,
        nls: ()=>t.nls,
        g_z: ()=>t.g_z,
        U7: ()=>t.U7,
        FT0: ()=>t.FT0,
        blk: ()=>t.blk,
        ejS: ()=>t.ejS,
        rnI: ()=>t.rnI,
        wem: ()=>t.wem,
        lfu: ()=>t.lfu,
        FDw: ()=>t.FDw,
        lRj: ()=>t.lRj,
        D1R: ()=>t.D1R,
        qyh: ()=>t.qyh,
        GUF: ()=>t.GUF,
        EoG: ()=>t.EoG,
        aNw: ()=>t.aNw,
        Zp0: ()=>t.Zp0,
        lLk: ()=>t.lLk,
        jAl: ()=>t.jAl,
        uEv: ()=>t.uEv,
        YKA: ()=>t.YKA,
        cRx: ()=>t.cRx,
        Y8D: ()=>t.Y8D,
        RsA: ()=>t.RsA,
        B51: ()=>t.B51,
        F5T: ()=>t.F5T,
        u7G: ()=>t.u7G,
        M8C: ()=>t.M8C,
        Vkp: ()=>t.Vkp,
        yGw: ()=>t.yGw,
        Sm8: ()=>t.Sm8,
        Kj0: ()=>t.Kj0,
        vBJ: ()=>t.vBJ,
        lRF: ()=>t.lRF,
        Lun: ()=>t.Lun,
        YBo: ()=>t.YBo,
        kaV: ()=>t.kaV,
        RSm: ()=>t.RSm,
        xoR: ()=>t.xoR,
        EJi: ()=>t.EJi,
        Qme: ()=>t.Qme,
        Wid: ()=>t.Wid,
        jrH: ()=>t.jrH,
        IKL: ()=>t.IKL,
        r_: ()=>t.r_,
        OPb: ()=>t.OPb,
        OoA: ()=>t.OoA,
        qhX: ()=>t.qhX,
        M5h: ()=>t.M5h,
        Ns1: ()=>t.Ns1,
        TyD: ()=>t.TyD,
        vZf: ()=>t.vZf,
        HTd: ()=>t.HTd,
        aH4: ()=>t.aH4,
        YLQ: ()=>t.YLQ,
        BVF: ()=>t.BVF,
        MyG: ()=>t.MyG,
        jFi: ()=>t.jFi,
        aCh: ()=>t.aCh,
        uL9: ()=>t.uL9,
        fwl: ()=>t.fwl,
        IFH: ()=>t.IFH,
        bdR: ()=>t.bdR,
        M6v: ()=>t.M6v,
        RvT: ()=>t.RvT,
        dUE: ()=>t.dUE,
        Tme: ()=>t.Tme,
        Gql: ()=>t.Gql,
        PA7: ()=>t.PA7,
        REq: ()=>t.REq,
        pQR: ()=>t.pQR,
        ghN: ()=>t.ghN,
        Hy8: ()=>t.Hy8,
        Wpd: ()=>t.Wpd,
        LgZ: ()=>t.LgZ,
        iWC: ()=>t.iWC,
        i5E: ()=>t.i5E,
        iKG: ()=>t.iKG,
        _iA: ()=>t._iA,
        ntZ: ()=>t.ntZ,
        anP: ()=>t.anP,
        y$t: ()=>t.y$t,
        Ady: ()=>t.Ady,
        H8x: ()=>t.H8x,
        cPb: ()=>t.cPb,
        JOQ: ()=>t.JOQ,
        BKK: ()=>t.BKK,
        _12: ()=>t._12,
        tJx: ()=>t.tJx,
        OdJ: ()=>t.OdJ,
        SyM: ()=>t.SyM,
        cek: ()=>t.cek,
        xG9: ()=>t.xG9,
        woe: ()=>t.woe,
        UY4: ()=>t.UY4,
        aq0: ()=>t.aq0,
        ujx: ()=>t.ujx,
        Uol: ()=>t.Uol,
        VYz: ()=>t.VYz,
        XgS: ()=>t.XgS,
        iUV: ()=>t.iUV,
        tf: ()=>t.tf,
        ZQ6: ()=>t.ZQ6,
        mXe: ()=>t.mXe,
        _fP: ()=>t._fP,
        iLg: ()=>t.iLg,
        zbs: ()=>t.zbs,
        ZTh: ()=>t.ZTh,
        HdW: ()=>t.HdW,
        UZH: ()=>t.UZH,
        mSO: ()=>t.mSO,
        wk1: ()=>t.wk1,
        E2K: ()=>t.E2K,
        FUD: ()=>t.FUD,
        pKu: ()=>t.pKu,
        GG6: ()=>t.GG6,
        Gih: ()=>t.Gih,
        iiP: ()=>t.iiP,
        SvJ: ()=>t.SvJ,
        ptH: ()=>t.ptH,
        jZA: ()=>t.jZA,
        y2t: ()=>t.y2t,
        gi4: ()=>t.gi4,
        Djp: ()=>t.Djp,
        BG$: ()=>t.BG$,
        NYV: ()=>t.NYV,
        xJs: ()=>t.xJs,
        bsb: ()=>t.bsb,
        ekQ: ()=>t.ekQ,
        CaW: ()=>t.CaW,
        eaV: ()=>t.eaV,
        BFQ: ()=>t.BFQ,
        v3W: ()=>t.v3W,
        ILR: ()=>t.ILR,
        fto: ()=>t.fto,
        l0P: ()=>t.l0P,
        vCx: ()=>t.vCx,
        _AM: ()=>t._AM,
        wuA: ()=>t.wuA,
        av9: ()=>t.av9,
        CtA: ()=>t.CtA,
        mIn: ()=>t.mIn,
        FIo: ()=>t.FIo,
        zHn: ()=>t.zHn,
        iMs: ()=>t.iMs,
        T_f: ()=>t.T_f,
        hEm: ()=>t.hEm,
        D9w: ()=>t.D9w,
        CdI: ()=>t.CdI,
        TIb: ()=>t.TIb,
        rpg: ()=>t.rpg,
        ce8: ()=>t.ce8,
        rOj: ()=>t.rOj,
        V4E: ()=>t.V4E,
        o8S: ()=>t.o8S,
        lGU: ()=>t.lGU,
        vuL: ()=>t.vuL,
        Rov: ()=>Gs,
        KI_: ()=>t.KI_,
        xsS: ()=>t.xsS,
        b26: ()=>t.b26,
        WdD: ()=>t.WdD,
        Vj0: ()=>t.Vj0,
        jyz: ()=>t.jyz,
        Tn7: ()=>t.Tn7,
        bnF: ()=>t.bnF,
        HW6: ()=>t.HW6,
        oa8: ()=>t.oa8,
        T_1: ()=>t.T_1,
        iDF: ()=>t.iDF,
        iAb: ()=>t.iAb,
        OdW: ()=>t.OdW,
        _YX: ()=>t._YX,
        TUv: ()=>t.TUv,
        $uU: ()=>h,
        Hw6: ()=>t.Hw6,
        aLr: ()=>t.aLr,
        Aip: ()=>t.Aip,
        xo$: ()=>t.xo$,
        $V: ()=>t.$V,
        lDi: ()=>t.lDi,
        gti: ()=>t.gti,
        PMe: ()=>t.PMe,
        FvO: ()=>t.FvO,
        jyi: ()=>t.jyi,
        xeV: ()=>t.xeV,
        k74: ()=>t.k74,
        RlZ: ()=>t.RlZ,
        KhW: ()=>t.KhW,
        HgB: ()=>t.HgB,
        W2J: ()=>t.W2J,
        JWc: ()=>t.JWc,
        kP0: ()=>t.kP0,
        u37: ()=>t.u37,
        Z6B: ()=>t.Z6B,
        QZ1: ()=>t.QZ1,
        Ir4: ()=>t.Ir4,
        NwF: ()=>t.NwF,
        Wbm: ()=>t.Wbm,
        N4l: ()=>t.N4l,
        QmN: ()=>t.QmN,
        wes: ()=>t.wes,
        IOt: ()=>t.IOt,
        L5g: ()=>t.L5g,
        H$k: ()=>t.H$k,
        xEZ: ()=>t.xEZ,
        YQ_: ()=>t.YQ_,
        Yin: ()=>t.Yin,
        dpR: ()=>t.dpR,
        Cne: ()=>t.Cne,
        XvJ: ()=>t.XvJ,
        XZw: ()=>t.XZw,
        FE5: ()=>t.FE5,
        Ys8: ()=>t.Ys8,
        CJI: ()=>t.CJI,
        z$h: ()=>t.z$h,
        UlW: ()=>t.UlW,
        WwZ: ()=>t.WwZ,
        Lcc: ()=>t.Lcc,
        WXh: ()=>t.WXh,
        ub3: ()=>t.ub3,
        xfE: ()=>t.xfE,
        qlB: ()=>t.qlB,
        lCJ: ()=>t.lCJ,
        WTc: ()=>t.WTc,
        rAo: ()=>t.rAo,
        xWb: ()=>t.xWb,
        gH0: ()=>t.gH0,
        rBU: ()=>t.rBU,
        rDY: ()=>t.rDY,
        ywz: ()=>t.ywz,
        wJv: ()=>t.wJv,
        JQ4: ()=>t.JQ4,
        k0A: ()=>t.k0A,
        irR: ()=>t.irR,
        LsT: ()=>t.LsT,
        MiG: ()=>t.MiG,
        dwk: ()=>t.dwk,
        FM8: ()=>t.FM8,
        Pa4: ()=>t.Pa4,
        Ltg: ()=>t.Ltg,
        yC1: ()=>t.yC1,
        fO1: ()=>t.fO1,
        AEx: ()=>t.AEx,
        _9o: ()=>t._9o,
        k5T: ()=>t.k5T,
        b5g: ()=>t.b5g,
        Ywn: ()=>t.Ywn,
        GVz: ()=>t.GVz,
        oAp: ()=>t.oAp,
        kFz: ()=>t.kFz,
        dd2: ()=>t.dd2,
        CP7: ()=>t.CP7,
        fQK: ()=>t.fQK,
        Uk6: ()=>t.Uk6,
        _sL: ()=>t._sL,
        Pnf: ()=>t.Pnf,
        c8b: ()=>t.c8b,
        _lf: ()=>t._lf,
        ad5: ()=>t.ad5,
        L_r: ()=>t.L_r,
        eC3: ()=>t.eC3,
        BRj: ()=>t.BRj,
        rif: ()=>t.rif,
        HOT: ()=>t.HOT,
        jfB: ()=>t.jfB,
        wuM: ()=>t.wuM,
        bkz: ()=>t.bkz,
        lDs: ()=>t.lDs,
        tQ: ()=>t.tQ,
        Oe_: ()=>t.Oe_,
        YRX: ()=>t.YRX,
        S6$: ()=>t.S6$,
        CbL: ()=>t.CbL,
        knz: ()=>t.knz,
        lKs: ()=>t.lKs,
        c1W: ()=>t.c1W,
        GaT: ()=>t.GaT,
        OEW: ()=>t.OEW,
        nB6: ()=>t.nB6
    });
    var t = Da(400);
    /*!
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
    var n = function() {
        this.init()
    };
    n.prototype = {
        init: function() {
            var S = this || r;
            return S._counter = 1e3,
            S._html5AudioPool = [],
            S.html5PoolSize = 10,
            S._codecs = {},
            S._howls = [],
            S._muted = !1,
            S._volume = 1,
            S._canPlayEvent = "canplaythrough",
            S._navigator = typeof window < "u" && window.navigator ? window.navigator : null,
            S.masterGain = null,
            S.noAudio = !1,
            S.usingWebAudio = !0,
            S.autoSuspend = !0,
            S.ctx = null,
            S.autoUnlock = !0,
            S._setup(),
            S
        },
        volume: function(S) {
            var p = this || r;
            if (S = parseFloat(S),
            p.ctx || D(),
            typeof S < "u" && S >= 0 && S <= 1) {
                if (p._volume = S,
                p._muted)
                    return p;
                p.usingWebAudio && p.masterGain.gain.setValueAtTime(S, r.ctx.currentTime);
                for (var C = 0; C < p._howls.length; C++)
                    if (!p._howls[C]._webAudio)
                        for (var V = p._howls[C]._getSoundIds(), se = 0; se < V.length; se++) {
                            var ye = p._howls[C]._soundById(V[se]);
                            ye && ye._node && (ye._node.volume = ye._volume * S)
                        }
                return p
            }
            return p._volume
        },
        mute: function(S) {
            var p = this || r;
            p.ctx || D(),
            p._muted = S,
            p.usingWebAudio && p.masterGain.gain.setValueAtTime(S ? 0 : p._volume, r.ctx.currentTime);
            for (var C = 0; C < p._howls.length; C++)
                if (!p._howls[C]._webAudio)
                    for (var V = p._howls[C]._getSoundIds(), se = 0; se < V.length; se++) {
                        var ye = p._howls[C]._soundById(V[se]);
                        ye && ye._node && (ye._node.muted = S ? !0 : ye._muted)
                    }
            return p
        },
        stop: function() {
            for (var S = this || r, p = 0; p < S._howls.length; p++)
                S._howls[p].stop();
            return S
        },
        unload: function() {
            for (var S = this || r, p = S._howls.length - 1; p >= 0; p--)
                S._howls[p].unload();
            return S.usingWebAudio && S.ctx && typeof S.ctx.close < "u" && (S.ctx.close(),
            S.ctx = null,
            D()),
            S
        },
        codecs: function(S) {
            return (this || r)._codecs[S.replace(/^x-/, "")]
        },
        _setup: function() {
            var S = this || r;
            if (S.state = S.ctx && S.ctx.state || "suspended",
            S._autoSuspend(),
            !S.usingWebAudio)
                if (typeof Audio < "u")
                    try {
                        var p = new Audio;
                        typeof p.oncanplaythrough > "u" && (S._canPlayEvent = "canplay")
                    } catch {
                        S.noAudio = !0
                    }
                else
                    S.noAudio = !0;
            try {
                var p = new Audio;
                p.muted && (S.noAudio = !0)
            } catch {}
            return S.noAudio || S._setupCodecs(),
            S
        },
        _setupCodecs: function() {
            var S = this || r
              , p = null;
            try {
                p = typeof Audio < "u" ? new Audio : null
            } catch {
                return S
            }
            if (!p || typeof p.canPlayType != "function")
                return S;
            var C = p.canPlayType("audio/mpeg;").replace(/^no$/, "")
              , V = S._navigator ? S._navigator.userAgent : ""
              , se = V.match(/OPR\/([0-6].)/g)
              , ye = se && parseInt(se[0].split("/")[1], 10) < 33
              , ue = V.indexOf("Safari") !== -1 && V.indexOf("Chrome") === -1
              , Ce = V.match(/Version\/(.*?) /)
              , mt = ue && Ce && parseInt(Ce[1], 10) < 15;
            return S._codecs = {
                mp3: !!(!ye && (C || p.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                mpeg: !!C,
                opus: !!p.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                ogg: !!p.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                oga: !!p.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                wav: !!(p.canPlayType('audio/wav; codecs="1"') || p.canPlayType("audio/wav")).replace(/^no$/, ""),
                aac: !!p.canPlayType("audio/aac;").replace(/^no$/, ""),
                caf: !!p.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                m4a: !!(p.canPlayType("audio/x-m4a;") || p.canPlayType("audio/m4a;") || p.canPlayType("audio/aac;")).replace(/^no$/, ""),
                m4b: !!(p.canPlayType("audio/x-m4b;") || p.canPlayType("audio/m4b;") || p.canPlayType("audio/aac;")).replace(/^no$/, ""),
                mp4: !!(p.canPlayType("audio/x-mp4;") || p.canPlayType("audio/mp4;") || p.canPlayType("audio/aac;")).replace(/^no$/, ""),
                weba: !!(!mt && p.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                webm: !!(!mt && p.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                dolby: !!p.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                flac: !!(p.canPlayType("audio/x-flac;") || p.canPlayType("audio/flac;")).replace(/^no$/, "")
            },
            S
        },
        _unlockAudio: function() {
            var S = this || r;
            if (!(S._audioUnlocked || !S.ctx)) {
                S._audioUnlocked = !1,
                S.autoUnlock = !1,
                !S._mobileUnloaded && S.ctx.sampleRate !== 44100 && (S._mobileUnloaded = !0,
                S.unload()),
                S._scratchBuffer = S.ctx.createBuffer(1, 1, 22050);
                var p = function(C) {
                    for (; S._html5AudioPool.length < S.html5PoolSize; )
                        try {
                            var V = new Audio;
                            V._unlocked = !0,
                            S._releaseHtml5Audio(V)
                        } catch {
                            S.noAudio = !0;
                            break
                        }
                    for (var se = 0; se < S._howls.length; se++)
                        if (!S._howls[se]._webAudio)
                            for (var ye = S._howls[se]._getSoundIds(), ue = 0; ue < ye.length; ue++) {
                                var Ce = S._howls[se]._soundById(ye[ue]);
                                Ce && Ce._node && !Ce._node._unlocked && (Ce._node._unlocked = !0,
                                Ce._node.load())
                            }
                    S._autoResume();
                    var mt = S.ctx.createBufferSource();
                    mt.buffer = S._scratchBuffer,
                    mt.connect(S.ctx.destination),
                    typeof mt.start > "u" ? mt.noteOn(0) : mt.start(0),
                    typeof S.ctx.resume == "function" && S.ctx.resume(),
                    mt.onended = function() {
                        mt.disconnect(0),
                        S._audioUnlocked = !0,
                        document.removeEventListener("touchstart", p, !0),
                        document.removeEventListener("touchend", p, !0),
                        document.removeEventListener("click", p, !0),
                        document.removeEventListener("keydown", p, !0);
                        for (var nn = 0; nn < S._howls.length; nn++)
                            S._howls[nn]._emit("unlock")
                    }
                };
                return document.addEventListener("touchstart", p, !0),
                document.addEventListener("touchend", p, !0),
                document.addEventListener("click", p, !0),
                document.addEventListener("keydown", p, !0),
                S
            }
        },
        _obtainHtml5Audio: function() {
            var S = this || r;
            if (S._html5AudioPool.length)
                return S._html5AudioPool.pop();
            var p = new Audio().play();
            return p && typeof Promise < "u" && (p instanceof Promise || typeof p.then == "function") && p.catch(function() {
                console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
            }),
            new Audio
        },
        _releaseHtml5Audio: function(S) {
            var p = this || r;
            return S._unlocked && p._html5AudioPool.push(S),
            p
        },
        _autoSuspend: function() {
            var S = this;
            if (!(!S.autoSuspend || !S.ctx || typeof S.ctx.suspend > "u" || !r.usingWebAudio)) {
                for (var p = 0; p < S._howls.length; p++)
                    if (S._howls[p]._webAudio) {
                        for (var C = 0; C < S._howls[p]._sounds.length; C++)
                            if (!S._howls[p]._sounds[C]._paused)
                                return S
                    }
                return S._suspendTimer && clearTimeout(S._suspendTimer),
                S._suspendTimer = setTimeout(function() {
                    if (S.autoSuspend) {
                        S._suspendTimer = null,
                        S.state = "suspending";
                        var V = function() {
                            S.state = "suspended",
                            S._resumeAfterSuspend && (delete S._resumeAfterSuspend,
                            S._autoResume())
                        };
                        S.ctx.suspend().then(V, V)
                    }
                }, 3e4),
                S
            }
        },
        _autoResume: function() {
            var S = this;
            if (!(!S.ctx || typeof S.ctx.resume > "u" || !r.usingWebAudio))
                return S.state === "running" && S.ctx.state !== "interrupted" && S._suspendTimer ? (clearTimeout(S._suspendTimer),
                S._suspendTimer = null) : S.state === "suspended" || S.state === "running" && S.ctx.state === "interrupted" ? (S.ctx.resume().then(function() {
                    S.state = "running";
                    for (var p = 0; p < S._howls.length; p++)
                        S._howls[p]._emit("resume")
                }),
                S._suspendTimer && (clearTimeout(S._suspendTimer),
                S._suspendTimer = null)) : S.state === "suspending" && (S._resumeAfterSuspend = !0),
                S
        }
    };
    var r = new n
      , s = function(S) {
        var p = this;
        if (!S.src || S.src.length === 0) {
            console.error("An array of source files must be passed with any new Howl.");
            return
        }
        p.init(S)
    };
    s.prototype = {
        init: function(S) {
            var p = this;
            return r.ctx || D(),
            p._autoplay = S.autoplay || !1,
            p._format = typeof S.format != "string" ? S.format : [S.format],
            p._html5 = S.html5 || !1,
            p._muted = S.mute || !1,
            p._loop = S.loop || !1,
            p._pool = S.pool || 5,
            p._preload = typeof S.preload == "boolean" || S.preload === "metadata" ? S.preload : !0,
            p._rate = S.rate || 1,
            p._sprite = S.sprite || {},
            p._src = typeof S.src != "string" ? S.src : [S.src],
            p._volume = S.volume !== void 0 ? S.volume : 1,
            p._xhr = {
                method: S.xhr && S.xhr.method ? S.xhr.method : "GET",
                headers: S.xhr && S.xhr.headers ? S.xhr.headers : null,
                withCredentials: S.xhr && S.xhr.withCredentials ? S.xhr.withCredentials : !1
            },
            p._duration = 0,
            p._state = "unloaded",
            p._sounds = [],
            p._endTimers = {},
            p._queue = [],
            p._playLock = !1,
            p._onend = S.onend ? [{
                fn: S.onend
            }] : [],
            p._onfade = S.onfade ? [{
                fn: S.onfade
            }] : [],
            p._onload = S.onload ? [{
                fn: S.onload
            }] : [],
            p._onloaderror = S.onloaderror ? [{
                fn: S.onloaderror
            }] : [],
            p._onplayerror = S.onplayerror ? [{
                fn: S.onplayerror
            }] : [],
            p._onpause = S.onpause ? [{
                fn: S.onpause
            }] : [],
            p._onplay = S.onplay ? [{
                fn: S.onplay
            }] : [],
            p._onstop = S.onstop ? [{
                fn: S.onstop
            }] : [],
            p._onmute = S.onmute ? [{
                fn: S.onmute
            }] : [],
            p._onvolume = S.onvolume ? [{
                fn: S.onvolume
            }] : [],
            p._onrate = S.onrate ? [{
                fn: S.onrate
            }] : [],
            p._onseek = S.onseek ? [{
                fn: S.onseek
            }] : [],
            p._onunlock = S.onunlock ? [{
                fn: S.onunlock
            }] : [],
            p._onresume = [],
            p._webAudio = r.usingWebAudio && !p._html5,
            typeof r.ctx < "u" && r.ctx && r.autoUnlock && r._unlockAudio(),
            r._howls.push(p),
            p._autoplay && p._queue.push({
                event: "play",
                action: function() {
                    p.play()
                }
            }),
            p._preload && p._preload !== "none" && p.load(),
            p
        },
        load: function() {
            var S = this
              , p = null;
            if (r.noAudio) {
                S._emit("loaderror", null, "No audio support.");
                return
            }
            typeof S._src == "string" && (S._src = [S._src]);
            for (var C = 0; C < S._src.length; C++) {
                var V, se;
                if (S._format && S._format[C])
                    V = S._format[C];
                else {
                    if (se = S._src[C],
                    typeof se != "string") {
                        S._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                        continue
                    }
                    V = /^data:audio\/([^;,]+);/i.exec(se),
                    V || (V = /\.([^.]+)$/.exec(se.split("?", 1)[0])),
                    V && (V = V[1].toLowerCase())
                }
                if (V || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),
                V && r.codecs(V)) {
                    p = S._src[C];
                    break
                }
            }
            if (!p) {
                S._emit("loaderror", null, "No codec support for selected audio sources.");
                return
            }
            return S._src = p,
            S._state = "loading",
            window.location.protocol === "https:" && p.slice(0, 5) === "http:" && (S._html5 = !0,
            S._webAudio = !1),
            new h(S),
            S._webAudio && g(S),
            S
        },
        play: function(S, p) {
            var C = this
              , V = null;
            if (typeof S == "number")
                V = S,
                S = null;
            else {
                if (typeof S == "string" && C._state === "loaded" && !C._sprite[S])
                    return null;
                if (typeof S > "u" && (S = "__default",
                !C._playLock)) {
                    for (var se = 0, ye = 0; ye < C._sounds.length; ye++)
                        C._sounds[ye]._paused && !C._sounds[ye]._ended && (se++,
                        V = C._sounds[ye]._id);
                    se === 1 ? S = null : V = null
                }
            }
            var ue = V ? C._soundById(V) : C._inactiveSound();
            if (!ue)
                return null;
            if (V && !S && (S = ue._sprite || "__default"),
            C._state !== "loaded") {
                ue._sprite = S,
                ue._ended = !1;
                var Ce = ue._id;
                return C._queue.push({
                    event: "play",
                    action: function() {
                        C.play(Ce)
                    }
                }),
                Ce
            }
            if (V && !ue._paused)
                return p || C._loadQueue("play"),
                ue._id;
            C._webAudio && r._autoResume();
            var mt = Math.max(0, ue._seek > 0 ? ue._seek : C._sprite[S][0] / 1e3)
              , nn = Math.max(0, (C._sprite[S][0] + C._sprite[S][1]) / 1e3 - mt)
              , cn = nn * 1e3 / Math.abs(ue._rate)
              , ni = C._sprite[S][0] / 1e3
              , ae = (C._sprite[S][0] + C._sprite[S][1]) / 1e3;
            ue._sprite = S,
            ue._ended = !1;
            var y = function() {
                ue._paused = !1,
                ue._seek = mt,
                ue._start = ni,
                ue._stop = ae,
                ue._loop = !!(ue._loop || C._sprite[S][2])
            };
            if (mt >= ae) {
                C._ended(ue);
                return
            }
            var b = ue._node;
            if (C._webAudio) {
                var E = function() {
                    C._playLock = !1,
                    y(),
                    C._refreshBuffer(ue);
                    var j = ue._muted || C._muted ? 0 : ue._volume;
                    b.gain.setValueAtTime(j, r.ctx.currentTime),
                    ue._playStart = r.ctx.currentTime,
                    typeof b.bufferSource.start > "u" ? ue._loop ? b.bufferSource.noteGrainOn(0, mt, 86400) : b.bufferSource.noteGrainOn(0, mt, nn) : ue._loop ? b.bufferSource.start(0, mt, 86400) : b.bufferSource.start(0, mt, nn),
                    cn !== 1 / 0 && (C._endTimers[ue._id] = setTimeout(C._ended.bind(C, ue), cn)),
                    p || setTimeout(function() {
                        C._emit("play", ue._id),
                        C._loadQueue()
                    }, 0)
                };
                r.state === "running" && r.ctx.state !== "interrupted" ? E() : (C._playLock = !0,
                C.once("resume", E),
                C._clearTimer(ue._id))
            } else {
                var T = function() {
                    b.currentTime = mt,
                    b.muted = ue._muted || C._muted || r._muted || b.muted,
                    b.volume = ue._volume * r.volume(),
                    b.playbackRate = ue._rate;
                    try {
                        var j = b.play();
                        if (j && typeof Promise < "u" && (j instanceof Promise || typeof j.then == "function") ? (C._playLock = !0,
                        y(),
                        j.then(function() {
                            C._playLock = !1,
                            b._unlocked = !0,
                            p ? C._loadQueue() : C._emit("play", ue._id)
                        }).catch(function() {
                            C._playLock = !1,
                            C._emit("playerror", ue._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),
                            ue._ended = !0,
                            ue._paused = !0
                        })) : p || (C._playLock = !1,
                        y(),
                        C._emit("play", ue._id)),
                        b.playbackRate = ue._rate,
                        b.paused) {
                            C._emit("playerror", ue._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                            return
                        }
                        S !== "__default" || ue._loop ? C._endTimers[ue._id] = setTimeout(C._ended.bind(C, ue), cn) : (C._endTimers[ue._id] = function() {
                            C._ended(ue),
                            b.removeEventListener("ended", C._endTimers[ue._id], !1)
                        }
                        ,
                        b.addEventListener("ended", C._endTimers[ue._id], !1))
                    } catch (W) {
                        C._emit("playerror", ue._id, W)
                    }
                };
                b.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (b.src = C._src,
                b.load());
                var L = window && window.ejecta || !b.readyState && r._navigator.isCocoonJS;
                if (b.readyState >= 3 || L)
                    T();
                else {
                    C._playLock = !0,
                    C._state = "loading";
                    var F = function() {
                        C._state = "loaded",
                        T(),
                        b.removeEventListener(r._canPlayEvent, F, !1)
                    };
                    b.addEventListener(r._canPlayEvent, F, !1),
                    C._clearTimer(ue._id)
                }
            }
            return ue._id
        },
        filter: function(S, p=!0, C=.5) {
            var V = this
              , se = S ? V._soundById(S) : V._inactiveSound();
            if (!se)
                return null;
            V._webAudio && (se._filter === void 0 && (se._filter = r.ctx.createBiquadFilter(),
            se._filter.frequency.value = 22050,
            se._filter.type = "lowpass",
            se._node.disconnect(0),
            se._node.connect(se._filter),
            se._filter.connect(r.masterGain)),
            se._filter.frequency.linearRampToValueAtTime(p ? 300 : 22050, r.ctx.currentTime + C))
        },
        pause: function(S) {
            var p = this;
            if (p._state !== "loaded" || p._playLock)
                return p._queue.push({
                    event: "pause",
                    action: function() {
                        p.pause(S)
                    }
                }),
                p;
            for (var C = p._getSoundIds(S), V = 0; V < C.length; V++) {
                p._clearTimer(C[V]);
                var se = p._soundById(C[V]);
                if (se && !se._paused && (se._seek = p.seek(C[V]),
                se._rateSeek = 0,
                se._paused = !0,
                p._stopFade(C[V]),
                se._node))
                    if (p._webAudio) {
                        if (!se._node.bufferSource)
                            continue;
                        typeof se._node.bufferSource.stop > "u" ? se._node.bufferSource.noteOff(0) : se._node.bufferSource.stop(0),
                        p._cleanBuffer(se._node)
                    } else
                        (!isNaN(se._node.duration) || se._node.duration === 1 / 0) && se._node.pause();
                arguments[1] || p._emit("pause", se ? se._id : null)
            }
            return p
        },
        stop: function(S, p) {
            var C = this;
            if (C._state !== "loaded" || C._playLock)
                return C._queue.push({
                    event: "stop",
                    action: function() {
                        C.stop(S)
                    }
                }),
                C;
            for (var V = C._getSoundIds(S), se = 0; se < V.length; se++) {
                C._clearTimer(V[se]);
                var ye = C._soundById(V[se]);
                ye && (ye._seek = ye._start || 0,
                ye._rateSeek = 0,
                ye._paused = !0,
                ye._ended = !0,
                C._stopFade(V[se]),
                ye._node && (C._webAudio ? ye._node.bufferSource && (typeof ye._node.bufferSource.stop > "u" ? ye._node.bufferSource.noteOff(0) : ye._node.bufferSource.stop(0),
                C._cleanBuffer(ye._node)) : (!isNaN(ye._node.duration) || ye._node.duration === 1 / 0) && (ye._node.currentTime = ye._start || 0,
                ye._node.pause(),
                ye._node.duration === 1 / 0 && C._clearSound(ye._node))),
                p || C._emit("stop", ye._id))
            }
            return C
        },
        mute: function(S, p) {
            var C = this;
            if (C._state !== "loaded" || C._playLock)
                return C._queue.push({
                    event: "mute",
                    action: function() {
                        C.mute(S, p)
                    }
                }),
                C;
            if (typeof p > "u")
                if (typeof S == "boolean")
                    C._muted = S;
                else
                    return C._muted;
            for (var V = C._getSoundIds(p), se = 0; se < V.length; se++) {
                var ye = C._soundById(V[se]);
                ye && (ye._muted = S,
                ye._interval && C._stopFade(ye._id),
                C._webAudio && ye._node ? ye._node.gain.setValueAtTime(S ? 0 : ye._volume, r.ctx.currentTime) : ye._node && (ye._node.muted = r._muted ? !0 : S),
                C._emit("mute", ye._id))
            }
            return C
        },
        volume: function() {
            var S = this, p = arguments, C, V;
            if (p.length === 0)
                return S._volume;
            if (p.length === 1 || p.length === 2 && typeof p[1] > "u") {
                var se = S._getSoundIds()
                  , ye = se.indexOf(p[0]);
                ye >= 0 ? V = parseInt(p[0], 10) : C = parseFloat(p[0])
            } else
                p.length >= 2 && (C = parseFloat(p[0]),
                V = parseInt(p[1], 10));
            var ue;
            if (typeof C < "u" && C >= 0 && C <= 1) {
                if (S._state !== "loaded" || S._playLock)
                    return S._queue.push({
                        event: "volume",
                        action: function() {
                            S.volume.apply(S, p)
                        }
                    }),
                    S;
                typeof V > "u" && (S._volume = C),
                V = S._getSoundIds(V);
                for (var Ce = 0; Ce < V.length; Ce++)
                    ue = S._soundById(V[Ce]),
                    ue && (ue._volume = C,
                    p[2] || S._stopFade(V[Ce]),
                    S._webAudio && ue._node && !ue._muted ? ue._node.gain.setValueAtTime(C, r.ctx.currentTime) : ue._node && !ue._muted && (ue._node.volume = C * r.volume()),
                    S._emit("volume", ue._id))
            } else
                return ue = V ? S._soundById(V) : S._sounds[0],
                ue ? ue._volume : 0;
            return S
        },
        fade: function(S, p, C, V) {
            var se = this;
            if (se._state !== "loaded" || se._playLock)
                return se._queue.push({
                    event: "fade",
                    action: function() {
                        se.fade(S, p, C, V)
                    }
                }),
                se;
            S = Math.min(Math.max(0, parseFloat(S)), 1),
            p = Math.min(Math.max(0, parseFloat(p)), 1),
            C = parseFloat(C),
            se.volume(S, V);
            for (var ye = se._getSoundIds(V), ue = 0; ue < ye.length; ue++) {
                var Ce = se._soundById(ye[ue]);
                if (Ce) {
                    if (V || se._stopFade(ye[ue]),
                    se._webAudio && !Ce._muted) {
                        var mt = r.ctx.currentTime
                          , nn = mt + C / 1e3;
                        Ce._volume = S,
                        Ce._node.gain.setValueAtTime(S, mt),
                        Ce._node.gain.linearRampToValueAtTime(p, nn)
                    }
                    se._startFadeInterval(Ce, S, p, C, ye[ue], typeof V > "u")
                }
            }
            return se
        },
        _startFadeInterval: function(S, p, C, V, se, ye) {
            var ue = this
              , Ce = p
              , mt = C - p
              , nn = Math.abs(mt / .01)
              , cn = Math.max(4, nn > 0 ? V / nn : V)
              , ni = Date.now();
            S._fadeTo = C,
            S._interval && clearInterval(S._interval),
            S._interval = setInterval(function() {
                var ae = (Date.now() - ni) / V;
                ni = Date.now(),
                Ce += mt * ae,
                Ce = Math.round(Ce * 100) / 100,
                mt < 0 ? Ce = Math.max(C, Ce) : Ce = Math.min(C, Ce),
                ue._webAudio ? S._volume = Ce : ue.volume(Ce, S._id, !0),
                ye && (ue._volume = Ce),
                (C < p && Ce <= C || C > p && Ce >= C) && (clearInterval(S._interval),
                S._interval = null,
                S._fadeTo = null,
                ue.volume(C, S._id),
                ue._emit("fade", S._id))
            }, cn)
        },
        _stopFade: function(S) {
            var p = this
              , C = p._soundById(S);
            return C && C._interval && (p._webAudio && C._node.gain.cancelScheduledValues(r.ctx.currentTime),
            clearInterval(C._interval),
            C._interval = null,
            p.volume(C._fadeTo, S),
            C._fadeTo = null,
            p._emit("fade", S)),
            p
        },
        loop: function() {
            var S = this, p = arguments, C, V, se;
            if (p.length === 0)
                return S._loop;
            if (p.length === 1)
                if (typeof p[0] == "boolean")
                    C = p[0],
                    S._loop = C;
                else
                    return se = S._soundById(parseInt(p[0], 10)),
                    se ? se._loop : !1;
            else
                p.length === 2 && (C = p[0],
                V = parseInt(p[1], 10));
            for (var ye = S._getSoundIds(V), ue = 0; ue < ye.length; ue++)
                se = S._soundById(ye[ue]),
                se && (se._loop = C,
                S._webAudio && se._node && se._node.bufferSource && (se._node.bufferSource.loop = C,
                C && (se._node.bufferSource.loopStart = se._start || 0,
                se._node.bufferSource.loopEnd = se._stop,
                S.playing(ye[ue]) && (S.pause(ye[ue], !0),
                S.play(ye[ue], !0)))));
            return S
        },
        rate: function() {
            var S = this, p = arguments, C, V;
            if (p.length === 0)
                V = S._sounds[0]._id;
            else if (p.length === 1) {
                var se = S._getSoundIds()
                  , ye = se.indexOf(p[0]);
                ye >= 0 ? V = parseInt(p[0], 10) : C = parseFloat(p[0])
            } else
                p.length === 2 && (C = parseFloat(p[0]),
                V = parseInt(p[1], 10));
            var ue;
            if (typeof C == "number") {
                if (S._state !== "loaded" || S._playLock)
                    return S._queue.push({
                        event: "rate",
                        action: function() {
                            S.rate.apply(S, p)
                        }
                    }),
                    S;
                typeof V > "u" && (S._rate = C),
                V = S._getSoundIds(V);
                for (var Ce = 0; Ce < V.length; Ce++)
                    if (ue = S._soundById(V[Ce]),
                    ue) {
                        S.playing(V[Ce]) && (ue._rateSeek = S.seek(V[Ce]),
                        ue._playStart = S._webAudio ? r.ctx.currentTime : ue._playStart),
                        ue._rate = C,
                        S._webAudio && ue._node && ue._node.bufferSource ? ue._node.bufferSource.playbackRate.setValueAtTime(C, r.ctx.currentTime) : ue._node && (ue._node.playbackRate = C);
                        var mt = S.seek(V[Ce])
                          , nn = (S._sprite[ue._sprite][0] + S._sprite[ue._sprite][1]) / 1e3 - mt
                          , cn = nn * 1e3 / Math.abs(ue._rate);
                        (S._endTimers[V[Ce]] || !ue._paused) && (S._clearTimer(V[Ce]),
                        S._endTimers[V[Ce]] = setTimeout(S._ended.bind(S, ue), cn)),
                        S._emit("rate", ue._id)
                    }
            } else
                return ue = S._soundById(V),
                ue ? ue._rate : S._rate;
            return S
        },
        seek: function() {
            var S = this, p = arguments, C, V;
            if (p.length === 0)
                S._sounds.length && (V = S._sounds[0]._id);
            else if (p.length === 1) {
                var se = S._getSoundIds()
                  , ye = se.indexOf(p[0]);
                ye >= 0 ? V = parseInt(p[0], 10) : S._sounds.length && (V = S._sounds[0]._id,
                C = parseFloat(p[0]))
            } else
                p.length === 2 && (C = parseFloat(p[0]),
                V = parseInt(p[1], 10));
            if (typeof V > "u")
                return 0;
            if (typeof C == "number" && (S._state !== "loaded" || S._playLock))
                return S._queue.push({
                    event: "seek",
                    action: function() {
                        S.seek.apply(S, p)
                    }
                }),
                S;
            var ue = S._soundById(V);
            if (ue)
                if (typeof C == "number" && C >= 0) {
                    var Ce = S.playing(V);
                    Ce && S.pause(V, !0),
                    ue._seek = C,
                    ue._ended = !1,
                    S._clearTimer(V),
                    !S._webAudio && ue._node && !isNaN(ue._node.duration) && (ue._node.currentTime = C);
                    var mt = function() {
                        Ce && S.play(V, !0),
                        S._emit("seek", V)
                    };
                    if (Ce && !S._webAudio) {
                        var nn = function() {
                            S._playLock ? setTimeout(nn, 0) : mt()
                        };
                        setTimeout(nn, 0)
                    } else
                        mt()
                } else if (S._webAudio) {
                    var cn = S.playing(V) ? r.ctx.currentTime - ue._playStart : 0
                      , ni = ue._rateSeek ? ue._rateSeek - ue._seek : 0;
                    return ue._seek + (ni + cn * Math.abs(ue._rate))
                } else
                    return ue._node.currentTime;
            return S
        },
        playing: function(S) {
            var p = this;
            if (typeof S == "number") {
                var C = p._soundById(S);
                return C ? !C._paused : !1
            }
            for (var V = 0; V < p._sounds.length; V++)
                if (!p._sounds[V]._paused)
                    return !0;
            return !1
        },
        duration: function(S) {
            var p = this
              , C = p._duration
              , V = p._soundById(S);
            return V && (C = p._sprite[V._sprite][1] / 1e3),
            C
        },
        state: function() {
            return this._state
        },
        unload: function() {
            for (var S = this, p = S._sounds, C = 0; C < p.length; C++)
                p[C]._paused || S.stop(p[C]._id),
                S._webAudio || (S._clearSound(p[C]._node),
                p[C]._node.removeEventListener("error", p[C]._errorFn, !1),
                p[C]._node.removeEventListener(r._canPlayEvent, p[C]._loadFn, !1),
                p[C]._node.removeEventListener("ended", p[C]._endFn, !1),
                r._releaseHtml5Audio(p[C]._node)),
                delete p[C]._node,
                S._clearTimer(p[C]._id);
            var V = r._howls.indexOf(S);
            V >= 0 && r._howls.splice(V, 1);
            var se = !0;
            for (C = 0; C < r._howls.length; C++)
                if (r._howls[C]._src === S._src || S._src.indexOf(r._howls[C]._src) >= 0) {
                    se = !1;
                    break
                }
            return l && se && delete l[S._src],
            r.noAudio = !1,
            S._state = "unloaded",
            S._sounds = [],
            S = null,
            null
        },
        on: function(S, p, C, V) {
            var se = this
              , ye = se["_on" + S];
            return typeof p == "function" && ye.push(V ? {
                id: C,
                fn: p,
                once: V
            } : {
                id: C,
                fn: p
            }),
            se
        },
        off: function(S, p, C) {
            var V = this
              , se = V["_on" + S]
              , ye = 0;
            if (typeof p == "number" && (C = p,
            p = null),
            p || C)
                for (ye = 0; ye < se.length; ye++) {
                    var ue = C === se[ye].id;
                    if (p === se[ye].fn && ue || !p && ue) {
                        se.splice(ye, 1);
                        break
                    }
                }
            else if (S)
                V["_on" + S] = [];
            else {
                var Ce = Object.keys(V);
                for (ye = 0; ye < Ce.length; ye++)
                    Ce[ye].indexOf("_on") === 0 && Array.isArray(V[Ce[ye]]) && (V[Ce[ye]] = [])
            }
            return V
        },
        once: function(S, p, C) {
            var V = this;
            return V.on(S, p, C, 1),
            V
        },
        _emit: function(S, p, C) {
            for (var V = this, se = V["_on" + S], ye = se.length - 1; ye >= 0; ye--)
                (!se[ye].id || se[ye].id === p || S === "load") && (setTimeout((function(ue) {
                    ue.call(this, p, C)
                }
                ).bind(V, se[ye].fn), 0),
                se[ye].once && V.off(S, se[ye].fn, se[ye].id));
            return V._loadQueue(S),
            V
        },
        _loadQueue: function(S) {
            var p = this;
            if (p._queue.length > 0) {
                var C = p._queue[0];
                C.event === S && (p._queue.shift(),
                p._loadQueue()),
                S || C.action()
            }
            return p
        },
        _ended: function(S) {
            var p = this
              , C = S._sprite;
            if (!p._webAudio && S._node && !S._node.paused && !S._node.ended && S._node.currentTime < S._stop)
                return setTimeout(p._ended.bind(p, S), 100),
                p;
            var V = !!(S._loop || p._sprite[C][2]);
            if (p._emit("end", S._id),
            !p._webAudio && V && p.stop(S._id, !0).play(S._id),
            p._webAudio && V) {
                p._emit("play", S._id),
                S._seek = S._start || 0,
                S._rateSeek = 0,
                S._playStart = r.ctx.currentTime;
                var se = (S._stop - S._start) * 1e3 / Math.abs(S._rate);
                p._endTimers[S._id] = setTimeout(p._ended.bind(p, S), se)
            }
            return p._webAudio && !V && (S._paused = !0,
            S._ended = !0,
            S._seek = S._start || 0,
            S._rateSeek = 0,
            p._clearTimer(S._id),
            p._cleanBuffer(S._node),
            r._autoSuspend()),
            !p._webAudio && !V && p.stop(S._id, !0),
            p
        },
        _clearTimer: function(S) {
            var p = this;
            if (p._endTimers[S]) {
                if (typeof p._endTimers[S] != "function")
                    clearTimeout(p._endTimers[S]);
                else {
                    var C = p._soundById(S);
                    C && C._node && C._node.removeEventListener("ended", p._endTimers[S], !1)
                }
                delete p._endTimers[S]
            }
            return p
        },
        _soundById: function(S) {
            for (var p = this, C = 0; C < p._sounds.length; C++)
                if (S === p._sounds[C]._id)
                    return p._sounds[C];
            return null
        },
        _inactiveSound: function() {
            var S = this;
            S._drain();
            for (var p = 0; p < S._sounds.length; p++)
                if (S._sounds[p]._ended)
                    return S._sounds[p].reset();
            return new h(S)
        },
        _drain: function() {
            var S = this
              , p = S._pool
              , C = 0
              , V = 0;
            if (!(S._sounds.length < p)) {
                for (V = 0; V < S._sounds.length; V++)
                    S._sounds[V]._ended && C++;
                for (V = S._sounds.length - 1; V >= 0; V--) {
                    if (C <= p)
                        return;
                    S._sounds[V]._ended && (S._webAudio && S._sounds[V]._node && S._sounds[V]._node.disconnect(0),
                    S._sounds.splice(V, 1),
                    C--)
                }
            }
        },
        _getSoundIds: function(S) {
            var p = this;
            if (typeof S > "u") {
                for (var C = [], V = 0; V < p._sounds.length; V++)
                    C.push(p._sounds[V]._id);
                return C
            } else
                return [S]
        },
        _refreshBuffer: function(S) {
            var p = this;
            return S._node.bufferSource = r.ctx.createBufferSource(),
            S._node.bufferSource.buffer = l[p._src],
            S._panner ? S._node.bufferSource.connect(S._panner) : S._node.bufferSource.connect(S._node),
            S._node.bufferSource.loop = S._loop,
            S._loop && (S._node.bufferSource.loopStart = S._start || 0,
            S._node.bufferSource.loopEnd = S._stop || 0),
            S._node.bufferSource.playbackRate.setValueAtTime(S._rate, r.ctx.currentTime),
            p
        },
        _cleanBuffer: function(S) {
            var p = this
              , C = r._navigator && r._navigator.vendor.indexOf("Apple") >= 0;
            if (!S.bufferSource)
                return p;
            if (r._scratchBuffer && S.bufferSource && (S.bufferSource.onended = null,
            S.bufferSource.disconnect(0),
            C))
                try {
                    S.bufferSource.buffer = r._scratchBuffer
                } catch {}
            return S.bufferSource = null,
            p
        },
        _clearSound: function(S) {
            var p = /MSIE |Trident\//.test(r._navigator && r._navigator.userAgent);
            p || (S.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
        }
    };
    var h = function(S) {
        this._parent = S,
        this.init()
    };
    h.prototype = {
        init: function() {
            var S = this
              , p = S._parent;
            return S._muted = p._muted,
            S._loop = p._loop,
            S._volume = p._volume,
            S._rate = p._rate,
            S._seek = 0,
            S._paused = !0,
            S._ended = !0,
            S._sprite = "__default",
            S._id = ++r._counter,
            p._sounds.push(S),
            S.create(),
            S
        },
        create: function() {
            var S = this
              , p = S._parent
              , C = r._muted || S._muted || S._parent._muted ? 0 : S._volume;
            return p._webAudio ? (S._node = typeof r.ctx.createGain > "u" ? r.ctx.createGainNode() : r.ctx.createGain(),
            S._node.gain.setValueAtTime(C, r.ctx.currentTime),
            S._node.paused = !0,
            S._node.connect(r.masterGain)) : r.noAudio || (S._node = r._obtainHtml5Audio(),
            S._errorFn = S._errorListener.bind(S),
            S._node.addEventListener("error", S._errorFn, !1),
            S._loadFn = S._loadListener.bind(S),
            S._node.addEventListener(r._canPlayEvent, S._loadFn, !1),
            S._endFn = S._endListener.bind(S),
            S._node.addEventListener("ended", S._endFn, !1),
            S._node.src = p._src,
            S._node.preload = p._preload === !0 ? "auto" : p._preload,
            S._node.volume = C * r.volume(),
            S._node.load()),
            S
        },
        reset: function() {
            var S = this
              , p = S._parent;
            return S._muted = p._muted,
            S._loop = p._loop,
            S._volume = p._volume,
            S._rate = p._rate,
            S._seek = 0,
            S._rateSeek = 0,
            S._paused = !0,
            S._ended = !0,
            S._sprite = "__default",
            S._id = ++r._counter,
            S
        },
        _errorListener: function() {
            var S = this;
            S._parent._emit("loaderror", S._id, S._node.error ? S._node.error.code : 0),
            S._node.removeEventListener("error", S._errorFn, !1)
        },
        _loadListener: function() {
            var S = this
              , p = S._parent;
            p._duration = Math.ceil(S._node.duration * 10) / 10,
            Object.keys(p._sprite).length === 0 && (p._sprite = {
                __default: [0, p._duration * 1e3]
            }),
            p._state !== "loaded" && (p._state = "loaded",
            p._emit("load"),
            p._loadQueue()),
            S._node.removeEventListener(r._canPlayEvent, S._loadFn, !1)
        },
        _endListener: function() {
            var S = this
              , p = S._parent;
            p._duration === 1 / 0 && (p._duration = Math.ceil(S._node.duration * 10) / 10,
            p._sprite.__default[1] === 1 / 0 && (p._sprite.__default[1] = p._duration * 1e3),
            p._ended(S)),
            S._node.removeEventListener("ended", S._endFn, !1)
        }
    };
    var l = {}
      , g = function(S) {
        var p = S._src;
        if (l[p]) {
            S._duration = l[p].duration,
            m(S);
            return
        }
        if (/^data:[^;]+;base64,/.test(p)) {
            for (var C = atob(p.split(",")[1]), V = new Uint8Array(C.length), se = 0; se < C.length; ++se)
                V[se] = C.charCodeAt(se);
            A(V.buffer, S)
        } else {
            var ye = new XMLHttpRequest;
            ye.open(S._xhr.method, p, !0),
            ye.withCredentials = S._xhr.withCredentials,
            ye.responseType = "arraybuffer",
            S._xhr.headers && Object.keys(S._xhr.headers).forEach(function(ue) {
                ye.setRequestHeader(ue, S._xhr.headers[ue])
            }),
            ye.onload = function() {
                var ue = (ye.status + "")[0];
                if (ue !== "0" && ue !== "2" && ue !== "3") {
                    S._emit("loaderror", null, "Failed loading audio file with status: " + ye.status + ".");
                    return
                }
                A(ye.response, S)
            }
            ,
            ye.onerror = function() {
                S._webAudio && (S._html5 = !0,
                S._webAudio = !1,
                S._sounds = [],
                delete l[p],
                S.load())
            }
            ,
            _(ye)
        }
    }
      , _ = function(S) {
        try {
            S.send()
        } catch {
            S.onerror()
        }
    }
      , A = function(S, p) {
        var C = function() {
            p._emit("loaderror", null, "Decoding audio data failed.")
        }
          , V = function(se) {
            se && p._sounds.length > 0 ? (l[p._src] = se,
            m(p, se)) : C()
        };
        typeof Promise < "u" && r.ctx.decodeAudioData.length === 1 ? r.ctx.decodeAudioData(S).then(V).catch(C) : r.ctx.decodeAudioData(S, V, C)
    }
      , m = function(S, p) {
        p && !S._duration && (S._duration = p.duration),
        Object.keys(S._sprite).length === 0 && (S._sprite = {
            __default: [0, S._duration * 1e3]
        }),
        S._state !== "loaded" && (S._state = "loaded",
        S._emit("load"),
        S._loadQueue())
    }
      , D = function() {
        if (r.usingWebAudio) {
            try {
                typeof AudioContext < "u" ? r.ctx = new AudioContext : typeof webkitAudioContext < "u" ? r.ctx = new webkitAudioContext : r.usingWebAudio = !1
            } catch {
                r.usingWebAudio = !1
            }
            r.ctx || (r.usingWebAudio = !1);
            var S = /iP(hone|od|ad)/.test(r._navigator && r._navigator.platform)
              , p = r._navigator && r._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)
              , C = p ? parseInt(p[1], 10) : null;
            if (S && C && C < 9) {
                var V = /safari/.test(r._navigator && r._navigator.userAgent.toLowerCase());
                r._navigator && !V && (r.usingWebAudio = !1)
            }
            r.usingWebAudio && (r.masterGain = typeof r.ctx.createGain > "u" ? r.ctx.createGainNode() : r.ctx.createGain(),
            r.masterGain.gain.setValueAtTime(r._muted ? 0 : r._volume, r.ctx.currentTime),
            r.masterGain.connect(r.ctx.destination)),
            r._setup()
        }
    };
    /*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
    n.prototype._pos = [0, 0, 0],
    n.prototype._orientation = [0, 0, -1, 0, 1, 0],
    n.prototype.stereo = function(S) {
        var p = this;
        if (!p.ctx || !p.ctx.listener)
            return p;
        for (var C = p._howls.length - 1; C >= 0; C--)
            p._howls[C].stereo(S);
        return p
    }
    ,
    n.prototype.pos = function(S, p, C) {
        var V = this;
        if (!V.ctx || !V.ctx.listener)
            return V;
        if (p = typeof p != "number" ? V._pos[1] : p,
        C = typeof C != "number" ? V._pos[2] : C,
        typeof S == "number")
            V._pos = [S, p, C],
            typeof V.ctx.listener.positionX < "u" ? (V.ctx.listener.positionX.setTargetAtTime(V._pos[0], Howler.ctx.currentTime, .1),
            V.ctx.listener.positionY.setTargetAtTime(V._pos[1], Howler.ctx.currentTime, .1),
            V.ctx.listener.positionZ.setTargetAtTime(V._pos[2], Howler.ctx.currentTime, .1)) : V.ctx.listener.setPosition(V._pos[0], V._pos[1], V._pos[2]);
        else
            return V._pos;
        return V
    }
    ,
    n.prototype.orientation = function(S, p, C, V, se, ye) {
        var ue = this;
        if (!ue.ctx || !ue.ctx.listener)
            return ue;
        var Ce = ue._orientation;
        if (p = typeof p != "number" ? Ce[1] : p,
        C = typeof C != "number" ? Ce[2] : C,
        V = typeof V != "number" ? Ce[3] : V,
        se = typeof se != "number" ? Ce[4] : se,
        ye = typeof ye != "number" ? Ce[5] : ye,
        typeof S == "number")
            ue._orientation = [S, p, C, V, se, ye],
            typeof ue.ctx.listener.forwardX < "u" ? (ue.ctx.listener.forwardX.setTargetAtTime(S, Howler.ctx.currentTime, .1),
            ue.ctx.listener.forwardY.setTargetAtTime(p, Howler.ctx.currentTime, .1),
            ue.ctx.listener.forwardZ.setTargetAtTime(C, Howler.ctx.currentTime, .1),
            ue.ctx.listener.upX.setTargetAtTime(V, Howler.ctx.currentTime, .1),
            ue.ctx.listener.upY.setTargetAtTime(se, Howler.ctx.currentTime, .1),
            ue.ctx.listener.upZ.setTargetAtTime(ye, Howler.ctx.currentTime, .1)) : ue.ctx.listener.setOrientation(S, p, C, V, se, ye);
        else
            return Ce;
        return ue
    }
    ,
    s.prototype.init = function(S) {
        return function(p) {
            var C = this;
            return C._orientation = p.orientation || [1, 0, 0],
            C._stereo = p.stereo || null,
            C._pos = p.pos || null,
            C._pannerAttr = {
                coneInnerAngle: typeof p.coneInnerAngle < "u" ? p.coneInnerAngle : 360,
                coneOuterAngle: typeof p.coneOuterAngle < "u" ? p.coneOuterAngle : 360,
                coneOuterGain: typeof p.coneOuterGain < "u" ? p.coneOuterGain : 0,
                distanceModel: typeof p.distanceModel < "u" ? p.distanceModel : "inverse",
                maxDistance: typeof p.maxDistance < "u" ? p.maxDistance : 1e4,
                panningModel: typeof p.panningModel < "u" ? p.panningModel : "HRTF",
                refDistance: typeof p.refDistance < "u" ? p.refDistance : 1,
                rolloffFactor: typeof p.rolloffFactor < "u" ? p.rolloffFactor : 1
            },
            C._onstereo = p.onstereo ? [{
                fn: p.onstereo
            }] : [],
            C._onpos = p.onpos ? [{
                fn: p.onpos
            }] : [],
            C._onorientation = p.onorientation ? [{
                fn: p.onorientation
            }] : [],
            S.call(this, p)
        }
    }(s.prototype.init),
    s.prototype.stereo = function(S, p) {
        var C = this;
        if (!C._webAudio)
            return C;
        if (C._state !== "loaded")
            return C._queue.push({
                event: "stereo",
                action: function() {
                    C.stereo(S, p)
                }
            }),
            C;
        var V = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
        if (typeof p > "u")
            if (typeof S == "number")
                C._stereo = S,
                C._pos = [S, 0, 0];
            else
                return C._stereo;
        for (var se = C._getSoundIds(p), ye = 0; ye < se.length; ye++) {
            var ue = C._soundById(se[ye]);
            if (ue)
                if (typeof S == "number")
                    ue._stereo = S,
                    ue._pos = [S, 0, 0],
                    ue._node && (ue._pannerAttr.panningModel = "equalpower",
                    (!ue._panner || !ue._panner.pan) && U(ue, V),
                    V === "spatial" ? typeof ue._panner.positionX < "u" ? (ue._panner.positionX.setValueAtTime(S, Howler.ctx.currentTime),
                    ue._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime),
                    ue._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : ue._panner.setPosition(S, 0, 0) : ue._panner.pan.setValueAtTime(S, Howler.ctx.currentTime)),
                    C._emit("stereo", ue._id);
                else
                    return ue._stereo
        }
        return C
    }
    ,
    s.prototype.pos = function(S, p, C, V) {
        var se = this;
        if (!se._webAudio)
            return se;
        if (se._state !== "loaded")
            return se._queue.push({
                event: "pos",
                action: function() {
                    se.pos(S, p, C, V)
                }
            }),
            se;
        if (p = typeof p != "number" ? 0 : p,
        C = typeof C != "number" ? -.5 : C,
        typeof V > "u")
            if (typeof S == "number")
                se._pos = [S, p, C];
            else
                return se._pos;
        for (var ye = se._getSoundIds(V), ue = 0; ue < ye.length; ue++) {
            var Ce = se._soundById(ye[ue]);
            if (Ce)
                if (typeof S == "number")
                    Ce._pos = [S, p, C],
                    Ce._node && ((!Ce._panner || Ce._panner.pan) && U(Ce, "spatial"),
                    typeof Ce._panner.positionX < "u" ? (Ce._panner.positionX.setValueAtTime(S, Howler.ctx.currentTime),
                    Ce._panner.positionY.setValueAtTime(p, Howler.ctx.currentTime),
                    Ce._panner.positionZ.setValueAtTime(C, Howler.ctx.currentTime)) : Ce._panner.setPosition(S, p, C)),
                    se._emit("pos", Ce._id);
                else
                    return Ce._pos
        }
        return se
    }
    ,
    s.prototype.orientation = function(S, p, C, V) {
        var se = this;
        if (!se._webAudio)
            return se;
        if (se._state !== "loaded")
            return se._queue.push({
                event: "orientation",
                action: function() {
                    se.orientation(S, p, C, V)
                }
            }),
            se;
        if (p = typeof p != "number" ? se._orientation[1] : p,
        C = typeof C != "number" ? se._orientation[2] : C,
        typeof V > "u")
            if (typeof S == "number")
                se._orientation = [S, p, C];
            else
                return se._orientation;
        for (var ye = se._getSoundIds(V), ue = 0; ue < ye.length; ue++) {
            var Ce = se._soundById(ye[ue]);
            if (Ce)
                if (typeof S == "number")
                    Ce._orientation = [S, p, C],
                    Ce._node && (Ce._panner || (Ce._pos || (Ce._pos = se._pos || [0, 0, -.5]),
                    U(Ce, "spatial")),
                    typeof Ce._panner.orientationX < "u" ? (Ce._panner.orientationX.setValueAtTime(S, Howler.ctx.currentTime),
                    Ce._panner.orientationY.setValueAtTime(p, Howler.ctx.currentTime),
                    Ce._panner.orientationZ.setValueAtTime(C, Howler.ctx.currentTime)) : Ce._panner.setOrientation(S, p, C)),
                    se._emit("orientation", Ce._id);
                else
                    return Ce._orientation
        }
        return se
    }
    ,
    s.prototype.pannerAttr = function() {
        var S = this, p = arguments, C, V, se;
        if (!S._webAudio)
            return S;
        if (p.length === 0)
            return S._pannerAttr;
        if (p.length === 1)
            if (typeof p[0] == "object")
                C = p[0],
                typeof V > "u" && (C.pannerAttr || (C.pannerAttr = {
                    coneInnerAngle: C.coneInnerAngle,
                    coneOuterAngle: C.coneOuterAngle,
                    coneOuterGain: C.coneOuterGain,
                    distanceModel: C.distanceModel,
                    maxDistance: C.maxDistance,
                    refDistance: C.refDistance,
                    rolloffFactor: C.rolloffFactor,
                    panningModel: C.panningModel
                }),
                S._pannerAttr = {
                    coneInnerAngle: typeof C.pannerAttr.coneInnerAngle < "u" ? C.pannerAttr.coneInnerAngle : S._coneInnerAngle,
                    coneOuterAngle: typeof C.pannerAttr.coneOuterAngle < "u" ? C.pannerAttr.coneOuterAngle : S._coneOuterAngle,
                    coneOuterGain: typeof C.pannerAttr.coneOuterGain < "u" ? C.pannerAttr.coneOuterGain : S._coneOuterGain,
                    distanceModel: typeof C.pannerAttr.distanceModel < "u" ? C.pannerAttr.distanceModel : S._distanceModel,
                    maxDistance: typeof C.pannerAttr.maxDistance < "u" ? C.pannerAttr.maxDistance : S._maxDistance,
                    refDistance: typeof C.pannerAttr.refDistance < "u" ? C.pannerAttr.refDistance : S._refDistance,
                    rolloffFactor: typeof C.pannerAttr.rolloffFactor < "u" ? C.pannerAttr.rolloffFactor : S._rolloffFactor,
                    panningModel: typeof C.pannerAttr.panningModel < "u" ? C.pannerAttr.panningModel : S._panningModel
                });
            else
                return se = S._soundById(parseInt(p[0], 10)),
                se ? se._pannerAttr : S._pannerAttr;
        else
            p.length === 2 && (C = p[0],
            V = parseInt(p[1], 10));
        for (var ye = S._getSoundIds(V), ue = 0; ue < ye.length; ue++)
            if (se = S._soundById(ye[ue]),
            se) {
                var Ce = se._pannerAttr;
                Ce = {
                    coneInnerAngle: typeof C.coneInnerAngle < "u" ? C.coneInnerAngle : Ce.coneInnerAngle,
                    coneOuterAngle: typeof C.coneOuterAngle < "u" ? C.coneOuterAngle : Ce.coneOuterAngle,
                    coneOuterGain: typeof C.coneOuterGain < "u" ? C.coneOuterGain : Ce.coneOuterGain,
                    distanceModel: typeof C.distanceModel < "u" ? C.distanceModel : Ce.distanceModel,
                    maxDistance: typeof C.maxDistance < "u" ? C.maxDistance : Ce.maxDistance,
                    refDistance: typeof C.refDistance < "u" ? C.refDistance : Ce.refDistance,
                    rolloffFactor: typeof C.rolloffFactor < "u" ? C.rolloffFactor : Ce.rolloffFactor,
                    panningModel: typeof C.panningModel < "u" ? C.panningModel : Ce.panningModel
                };
                var mt = se._panner;
                mt || (se._pos || (se._pos = S._pos || [0, 0, -.5]),
                U(se, "spatial"),
                mt = se._panner),
                mt.coneInnerAngle = Ce.coneInnerAngle,
                mt.coneOuterAngle = Ce.coneOuterAngle,
                mt.coneOuterGain = Ce.coneOuterGain,
                mt.distanceModel = Ce.distanceModel,
                mt.maxDistance = Ce.maxDistance,
                mt.refDistance = Ce.refDistance,
                mt.rolloffFactor = Ce.rolloffFactor,
                mt.panningModel = Ce.panningModel
            }
        return S
    }
    ,
    h.prototype.init = function(S) {
        return function() {
            var p = this
              , C = p._parent;
            p._orientation = C._orientation,
            p._stereo = C._stereo,
            p._pos = C._pos,
            p._pannerAttr = C._pannerAttr,
            S.call(this),
            p._stereo ? C.stereo(p._stereo) : p._pos && C.pos(p._pos[0], p._pos[1], p._pos[2], p._id)
        }
    }(h.prototype.init),
    h.prototype.reset = function(S) {
        return function() {
            var p = this
              , C = p._parent;
            return p._orientation = C._orientation,
            p._stereo = C._stereo,
            p._pos = C._pos,
            p._pannerAttr = C._pannerAttr,
            p._stereo ? C.stereo(p._stereo) : p._pos ? C.pos(p._pos[0], p._pos[1], p._pos[2], p._id) : p._panner && (p._panner.disconnect(0),
            p._panner = void 0,
            C._refreshBuffer(p)),
            S.call(this)
        }
    }(h.prototype.reset);
    var U = function(S, p) {
        p = p || "spatial",
        p === "spatial" ? (S._panner = Howler.ctx.createPanner(),
        S._panner.coneInnerAngle = S._pannerAttr.coneInnerAngle,
        S._panner.coneOuterAngle = S._pannerAttr.coneOuterAngle,
        S._panner.coneOuterGain = S._pannerAttr.coneOuterGain,
        S._panner.distanceModel = S._pannerAttr.distanceModel,
        S._panner.maxDistance = S._pannerAttr.maxDistance,
        S._panner.refDistance = S._pannerAttr.refDistance,
        S._panner.rolloffFactor = S._pannerAttr.rolloffFactor,
        S._panner.panningModel = S._pannerAttr.panningModel,
        typeof S._panner.positionX < "u" ? (S._panner.positionX.setValueAtTime(S._pos[0], Howler.ctx.currentTime),
        S._panner.positionY.setValueAtTime(S._pos[1], Howler.ctx.currentTime),
        S._panner.positionZ.setValueAtTime(S._pos[2], Howler.ctx.currentTime)) : S._panner.setPosition(S._pos[0], S._pos[1], S._pos[2]),
        typeof S._panner.orientationX < "u" ? (S._panner.orientationX.setValueAtTime(S._orientation[0], Howler.ctx.currentTime),
        S._panner.orientationY.setValueAtTime(S._orientation[1], Howler.ctx.currentTime),
        S._panner.orientationZ.setValueAtTime(S._orientation[2], Howler.ctx.currentTime)) : S._panner.setOrientation(S._orientation[0], S._orientation[1], S._orientation[2])) : (S._panner = Howler.ctx.createStereoPanner(),
        S._panner.pan.setValueAtTime(S._stereo, Howler.ctx.currentTime)),
        S._panner.connect(S._node),
        S._paused || S._parent.pause(S._id, !0).play(S._id, !0)
    }
      , R = Da(25)
      , ne = Da(992);
    const ce = new R.Pa4
      , xe = new R.Pa4;
    class Se extends ne.S {
        constructor() {
            super(...arguments);
            B(this, "_sources", []);
            B(this, "listener", null)
        }
        addSource(C) {
            this._sources.push(C)
        }
        removeSource(C) {
            this._sources.remove(C)
        }
        removeByTarget(C) {
            for (let V = this._sources.length; V--; )
                this._sources[V].target === C && this._sources.splice(V, 1)
        }
        update(C) {
            for (const {sound: V, target: se} of this._sources)
                se.getWorldPosition(ce),
                se.getWorldDirection(xe),
                V.pos(ce.x, ce.y, ce.z),
                V.orientation(xe.x, xe.y, xe.z);
            if (this._sources.length) {
                let V = this.listener || this.viewer.camera;
                V.getWorldPosition(ce),
                V.getWorldDirection(xe),
                r.pos(ce.x, ce.y, ce.z),
                r.orientation(xe.x, xe.y, xe.z, 0, 1, 0)
            }
        }
    }
    var $ = Da(41);
    const q = ""
      , N = "srgb"
      , ie = "srgb-linear"
      , Pe = Number(R.UZH.replace(/\D+/g, "")) >= 152
      , Be = new Map([[R.rnI, ie], [R.knz, N]])
      , Re = new Map([[ie, R.rnI], [N, R.knz]]);
    function ct(S) {
        return S === null ? null : Pe ? S.outputColorSpace : Be.get(S.outputEncoding)
    }
    function et(S, p) {
        S !== null && (Pe ? S.colorSpace = p : S.encoding = Re.get(p))
    }
    const Ze = {
        SKIP: 9,
        SET: 30,
        ADD: 0,
        ALPHA: 1,
        AVERAGE: 2,
        COLOR: 3,
        COLOR_BURN: 4,
        COLOR_DODGE: 5,
        DARKEN: 6,
        DIFFERENCE: 7,
        DIVIDE: 8,
        DST: 9,
        EXCLUSION: 10,
        HARD_LIGHT: 11,
        HARD_MIX: 12,
        HUE: 13,
        INVERT: 14,
        INVERT_RGB: 15,
        LIGHTEN: 16,
        LINEAR_BURN: 17,
        LINEAR_DODGE: 18,
        LINEAR_LIGHT: 19,
        LUMINOSITY: 20,
        MULTIPLY: 21,
        NEGATION: 22,
        NORMAL: 23,
        OVERLAY: 24,
        PIN_LIGHT: 25,
        REFLECT: 26,
        SATURATION: 27,
        SCREEN: 28,
        SOFT_LIGHT: 29,
        SRC: 30,
        SUBTRACT: 31,
        VIVID_LIGHT: 32
    }
      , Nt = {
        DEPTH: 0,
        LUMA: 1,
        COLOR: 2
    }
      , Bt = {
        NONE: 0,
        DEPTH: 1,
        CONVOLUTION: 2
    }
      , en = {
        FRAGMENT_HEAD: "FRAGMENT_HEAD",
        FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
        FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
        VERTEX_HEAD: "VERTEX_HEAD",
        VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
    }
      , li = {
        VERY_SMALL: 0,
        SMALL: 1,
        MEDIUM: 2,
        LARGE: 3,
        VERY_LARGE: 4,
        HUGE: 5
    }
      , di = {
        DISABLED: 0,
        DEPTH: 1,
        CUSTOM: 2
    }
      , xi = {
        LOW: 0,
        MEDIUM: 1,
        HIGH: 2,
        ULTRA: 3
    }
      , zt = `#ifdef FRAMEBUFFER_PRECISION_HIGH

    uniform mediump sampler2D inputBuffer;

#else

    uniform lowp sampler2D inputBuffer;

#endif

varying vec2 vUv0;
varying vec2 vUv1;
varying vec2 vUv2;
varying vec2 vUv3;

void main() {

    vec4 sum = texture2D(inputBuffer, vUv0); // Top left
    sum += texture2D(inputBuffer, vUv1); // Top right
    sum += texture2D(inputBuffer, vUv2); // Bottom right
    sum += texture2D(inputBuffer, vUv3); // Bottom left
    gl_FragColor = sum * 0.25; // Compute the average

    #include <encodings_fragment>

}
`
      , Sn = `uniform vec4 texelSize; // XY = texel size, ZW = half texel size
uniform float kernel;
uniform float scale;

varying vec2 vUv0;
varying vec2 vUv1;
varying vec2 vUv2;
varying vec2 vUv3;

void main() {

    vec2 uv = position.xy * 0.5 + 0.5;
    vec2 dUv = (texelSize.xy * vec2(kernel) + texelSize.zw) * scale;

    vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
    vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
    vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
    vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

    gl_Position = vec4(position.xy, 1.0, 1.0);

}
`
      , rn = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])];
    class Ft extends R.jyz {
        constructor(p=new R.Ltg) {
            super({
                name: "KawaseBlurMaterial",
                uniforms: {
                    inputBuffer: new R.xWb(null),
                    texelSize: new R.xWb(new R.Ltg),
                    scale: new R.xWb(1),
                    kernel: new R.xWb(0)
                },
                blending: R.jFi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: zt,
                vertexShader: Sn
            }),
            this.setTexelSize(p.x, p.y),
            this.kernelSize = li.MEDIUM
        }
        set inputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        setInputBuffer(p) {
            this.inputBuffer = p
        }
        get kernelSequence() {
            return rn[this.kernelSize]
        }
        get scale() {
            return this.uniforms.scale.value
        }
        set scale(p) {
            this.uniforms.scale.value = p
        }
        getScale() {
            return this.uniforms.scale.value
        }
        setScale(p) {
            this.uniforms.scale.value = p
        }
        getKernel() {
            return null
        }
        get kernel() {
            return this.uniforms.kernel.value
        }
        set kernel(p) {
            this.uniforms.kernel.value = p
        }
        setKernel(p) {
            this.kernel = p
        }
        setTexelSize(p, C) {
            this.uniforms.texelSize.value.set(p, C, p * .5, C * .5)
        }
        setSize(p, C) {
            const V = 1 / p
              , se = 1 / C;
            this.uniforms.texelSize.value.set(V, se, V * .5, se * .5)
        }
    }
    const jt = `#include <common>
#include <dithering_pars_fragment>

#ifdef FRAMEBUFFER_PRECISION_HIGH

    uniform mediump sampler2D inputBuffer;

#else

    uniform lowp sampler2D inputBuffer;

#endif

uniform float opacity;

varying vec2 vUv;

void main() {

    vec4 texel = texture2D(inputBuffer, vUv);
    gl_FragColor = opacity * texel;

    #include <encodings_fragment>
    #include <dithering_fragment>

}
`
      , Xt = `varying vec2 vUv;

void main() {

    vUv = position.xy * 0.5 + 0.5;
    gl_Position = vec4(position.xy, 1.0, 1.0);

}
`;
    class Rt extends R.jyz {
        constructor() {
            super({
                name: "CopyMaterial",
                uniforms: {
                    inputBuffer: new R.xWb(null),
                    opacity: new R.xWb(1)
                },
                blending: R.jFi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: jt,
                vertexShader: Xt
            })
        }
        set inputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        setInputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        getOpacity(p) {
            return this.uniforms.opacity.value
        }
        setOpacity(p) {
            this.uniforms.opacity.value = p
        }
    }
    const Wn = `#ifdef FRAMEBUFFER_PRECISION_HIGH

    uniform mediump sampler2D inputBuffer;

#else

    uniform lowp sampler2D inputBuffer;

#endif

// (1 / 4) * 0.5 = 0.125
#define WEIGHT_INNER 0.125
// (1 / 9) * 0.5 = 0.0555555
#define WEIGHT_OUTER 0.0555555

varying vec2 vUv;
varying vec2 vUv00;
varying vec2 vUv01;
varying vec2 vUv02;
varying vec2 vUv03;
varying vec2 vUv04;
varying vec2 vUv05;
varying vec2 vUv06;
varying vec2 vUv07;
varying vec2 vUv08;
varying vec2 vUv09;
varying vec2 vUv10;
varying vec2 vUv11;

float clampToBorder(const in vec2 uv) {

    return float(uv.s >= 0.0 && uv.s <= 1.0 && uv.t >= 0.0 && uv.t <= 1.0);

}

void main() {

    vec4 c = vec4(0.0);

    vec4 w = WEIGHT_INNER * vec4(
        clampToBorder(vUv00),
        clampToBorder(vUv01),
        clampToBorder(vUv02),
        clampToBorder(vUv03)
    );

    c += w.x * texture2D(inputBuffer, vUv00);
    c += w.y * texture2D(inputBuffer, vUv01);
    c += w.z * texture2D(inputBuffer, vUv02);
    c += w.w * texture2D(inputBuffer, vUv03);

    w = WEIGHT_OUTER * vec4(
        clampToBorder(vUv04),
        clampToBorder(vUv05),
        clampToBorder(vUv06),
        clampToBorder(vUv07)
    );

    c += w.x * texture2D(inputBuffer, vUv04);
    c += w.y * texture2D(inputBuffer, vUv05);
    c += w.z * texture2D(inputBuffer, vUv06);
    c += w.w * texture2D(inputBuffer, vUv07);

    w = WEIGHT_OUTER * vec4(
        clampToBorder(vUv08),
        clampToBorder(vUv09),
        clampToBorder(vUv10),
        clampToBorder(vUv11)
    );

    c += w.x * texture2D(inputBuffer, vUv08);
    c += w.y * texture2D(inputBuffer, vUv09);
    c += w.z * texture2D(inputBuffer, vUv10);
    c += w.w * texture2D(inputBuffer, vUv11);

    c += WEIGHT_OUTER * texture2D(inputBuffer, vUv);
    gl_FragColor = c;

    #include <encodings_fragment>

}
`
      , He = `uniform vec2 texelSize;

varying vec2 vUv;
varying vec2 vUv00;
varying vec2 vUv01;
varying vec2 vUv02;
varying vec2 vUv03;
varying vec2 vUv04;
varying vec2 vUv05;
varying vec2 vUv06;
varying vec2 vUv07;
varying vec2 vUv08;
varying vec2 vUv09;
varying vec2 vUv10;
varying vec2 vUv11;

void main() {

    vUv = position.xy * 0.5 + 0.5;

    vUv00 = vUv + texelSize * vec2(-1.0, 1.0);
    vUv01 = vUv + texelSize * vec2(1.0, 1.0);
    vUv02 = vUv + texelSize * vec2(-1.0, -1.0);
    vUv03 = vUv + texelSize * vec2(1.0, -1.0);

    vUv04 = vUv + texelSize * vec2(-2.0, 2.0);
    vUv05 = vUv + texelSize * vec2(0.0, 2.0);
    vUv06 = vUv + texelSize * vec2(2.0, 2.0);
    vUv07 = vUv + texelSize * vec2(-2.0, 0.0);
    vUv08 = vUv + texelSize * vec2(2.0, 0.0);
    vUv09 = vUv + texelSize * vec2(-2.0, -2.0);
    vUv10 = vUv + texelSize * vec2(0.0, -2.0);
    vUv11 = vUv + texelSize * vec2(2.0, -2.0);

    gl_Position = vec4(position.xy, 1.0, 1.0);

}
`;
    class pt extends R.jyz {
        constructor() {
            super({
                name: "DownsamplingMaterial",
                uniforms: {
                    inputBuffer: new R.xWb(null),
                    texelSize: new R.xWb(new R.FM8)
                },
                blending: R.jFi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: Wn,
                vertexShader: He
            })
        }
        set inputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        setSize(p, C) {
            this.uniforms.texelSize.value.set(1 / p, 1 / C)
        }
    }
    const Fe = `varying vec2 vUv;
varying vec2 vUv0;
varying vec2 vUv1;

#if THREE_REVISION < 143

    #define luminance(v) linearToRelativeLuminance(v)

#endif

#if EDGE_DETECTION_MODE != 0

    varying vec2 vUv2;
    varying vec2 vUv3;
    varying vec2 vUv4;
    varying vec2 vUv5;

#endif

#if EDGE_DETECTION_MODE == 1

    #include <common>

#endif

#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1

    #ifdef GL_FRAGMENT_PRECISION_HIGH

        uniform highp sampler2D depthBuffer;

    #else

        uniform mediump sampler2D depthBuffer;

    #endif

    float readDepth(const in vec2 uv) {

        #if DEPTH_PACKING == 3201

            return unpackRGBAToDepth(texture2D(depthBuffer, uv));

        #else

            return texture2D(depthBuffer, uv).r;

        #endif

    }

    vec3 gatherNeighbors() {

        float p = readDepth(vUv);
        float pLeft = readDepth(vUv0);
        float pTop = readDepth(vUv1);

        return vec3(p, pLeft, pTop);

    }

#elif PREDICATION_MODE == 2

    uniform sampler2D predicationBuffer;

    vec3 gatherNeighbors() {

        float p = texture2D(predicationBuffer, vUv).r;
        float pLeft = texture2D(predicationBuffer, vUv0).r;
        float pTop = texture2D(predicationBuffer, vUv1).r;

        return vec3(p, pLeft, pTop);

    }

#endif

#if PREDICATION_MODE != 0

    vec2 calculatePredicatedThreshold() {

        vec3 neighbours = gatherNeighbors();
        vec2 delta = abs(neighbours.xx - neighbours.yz);
        vec2 edges = step(PREDICATION_THRESHOLD, delta);

        return PREDICATION_SCALE * EDGE_THRESHOLD * (1.0 - PREDICATION_STRENGTH * edges);

    }

#endif

#if EDGE_DETECTION_MODE != 0

    uniform sampler2D inputBuffer;

#endif

void main() {

    #if EDGE_DETECTION_MODE == 0

        const vec2 threshold = vec2(DEPTH_THRESHOLD);

    #elif PREDICATION_MODE != 0

        vec2 threshold = calculatePredicatedThreshold();

    #else

        const vec2 threshold = vec2(EDGE_THRESHOLD);

    #endif

    #if EDGE_DETECTION_MODE == 0

        // Depth-based edge detection.

        vec3 neighbors = gatherNeighbors();
        vec2 delta = abs(neighbors.xx - vec2(neighbors.y, neighbors.z));
        vec2 edges = step(threshold, delta);

        if(dot(edges, vec2(1.0)) == 0.0) {

            discard;

        }

        gl_FragColor = vec4(edges, 0.0, 1.0);

    #elif EDGE_DETECTION_MODE == 1

        // Luma-based edge detection.

        float l = luminance(texture2D(inputBuffer, vUv).rgb);
        float lLeft = luminance(texture2D(inputBuffer, vUv0).rgb);
        float lTop  = luminance(texture2D(inputBuffer, vUv1).rgb);

        vec4 delta;
        delta.xy = abs(l - vec2(lLeft, lTop));

        vec2 edges = step(threshold, delta.xy);

        if(dot(edges, vec2(1.0)) == 0.0) {

            discard;

        }

        // Calculate right and bottom deltas.
        float lRight = luminance(texture2D(inputBuffer, vUv2).rgb);
        float lBottom  = luminance(texture2D(inputBuffer, vUv3).rgb);
        delta.zw = abs(l - vec2(lRight, lBottom));

        // Calculate the maximum delta in the direct neighborhood.
        vec2 maxDelta = max(delta.xy, delta.zw);

        // Calculate left-left and top-top deltas.
        float lLeftLeft = luminance(texture2D(inputBuffer, vUv4).rgb);
        float lTopTop = luminance(texture2D(inputBuffer, vUv5).rgb);
        delta.zw = abs(vec2(lLeft, lTop) - vec2(lLeftLeft, lTopTop));

        // Calculate the final maximum delta.
        maxDelta = max(maxDelta.xy, delta.zw);
        float finalDelta = max(maxDelta.x, maxDelta.y);

        // Local contrast adaptation.
        edges.xy *= step(finalDelta, LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);

        gl_FragColor = vec4(edges, 0.0, 1.0);

    #elif EDGE_DETECTION_MODE == 2

        // Chroma-based edge detection.

        vec4 delta;
        vec3 c = texture2D(inputBuffer, vUv).rgb;

        vec3 cLeft = texture2D(inputBuffer, vUv0).rgb;
        vec3 t = abs(c - cLeft);
        delta.x = max(max(t.r, t.g), t.b);

        vec3 cTop = texture2D(inputBuffer, vUv1).rgb;
        t = abs(c - cTop);
        delta.y = max(max(t.r, t.g), t.b);

        vec2 edges = step(threshold, delta.xy);

        if(dot(edges, vec2(1.0)) == 0.0) {

            discard;

        }

        // Calculate right and bottom deltas.
        vec3 cRight = texture2D(inputBuffer, vUv2).rgb;
        t = abs(c - cRight);
        delta.z = max(max(t.r, t.g), t.b);

        vec3 cBottom = texture2D(inputBuffer, vUv3).rgb;
        t = abs(c - cBottom);
        delta.w = max(max(t.r, t.g), t.b);

        // Calculate the maximum delta in the direct neighborhood.
        vec2 maxDelta = max(delta.xy, delta.zw);

        // Calculate left-left and top-top deltas.
        vec3 cLeftLeft = texture2D(inputBuffer, vUv4).rgb;
        t = abs(c - cLeftLeft);
        delta.z = max(max(t.r, t.g), t.b);

        vec3 cTopTop = texture2D(inputBuffer, vUv5).rgb;
        t = abs(c - cTopTop);
        delta.w = max(max(t.r, t.g), t.b);

        // Calculate the final maximum delta.
        maxDelta = max(maxDelta.xy, delta.zw);
        float finalDelta = max(maxDelta.x, maxDelta.y);

        // Local contrast adaptation.
        edges *= step(finalDelta, LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);

        gl_FragColor = vec4(edges, 0.0, 1.0);

    #endif

}
`
      , qe = `uniform vec2 texelSize;

varying vec2 vUv;
varying vec2 vUv0;
varying vec2 vUv1;

#if EDGE_DETECTION_MODE != 0

    varying vec2 vUv2;
    varying vec2 vUv3;
    varying vec2 vUv4;
    varying vec2 vUv5;

#endif

void main() {

    vUv = position.xy * 0.5 + 0.5;

    // Left and top texel coordinates.
    vUv0 = vUv + texelSize * vec2(-1.0, 0.0);
    vUv1 = vUv + texelSize * vec2(0.0, -1.0);

    #if EDGE_DETECTION_MODE != 0

        // Right and bottom texel coordinates.
        vUv2 = vUv + texelSize * vec2(1.0, 0.0);
        vUv3 = vUv + texelSize * vec2(0.0, 1.0);

        // Left-left and top-top texel coordinates.
        vUv4 = vUv + texelSize * vec2(-2.0, 0.0);
        vUv5 = vUv + texelSize * vec2(0.0, -2.0);

    #endif

    gl_Position = vec4(position.xy, 1.0, 1.0);

}
`;
    class wt extends R.jyz {
        constructor(p=new R.FM8, C=Nt.COLOR) {
            super({
                name: "EdgeDetectionMaterial",
                defines: {
                    THREE_REVISION: R.UZH.replace(/\D+/g, ""),
                    LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                    EDGE_THRESHOLD: "0.1",
                    DEPTH_THRESHOLD: "0.01",
                    PREDICATION_MODE: "0",
                    PREDICATION_THRESHOLD: "0.01",
                    PREDICATION_SCALE: "2.0",
                    PREDICATION_STRENGTH: "1.0",
                    DEPTH_PACKING: "0"
                },
                uniforms: {
                    inputBuffer: new R.xWb(null),
                    depthBuffer: new R.xWb(null),
                    predicationBuffer: new R.xWb(null),
                    texelSize: new R.xWb(p)
                },
                blending: R.jFi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: Fe,
                vertexShader: qe
            }),
            this.edgeDetectionMode = C
        }
        set depthBuffer(p) {
            this.uniforms.depthBuffer.value = p
        }
        set depthPacking(p) {
            this.defines.DEPTH_PACKING = p.toFixed(0),
            this.needsUpdate = !0
        }
        setDepthBuffer(p, C=R.z81) {
            this.depthBuffer = p,
            this.depthPacking = C
        }
        get edgeDetectionMode() {
            return Number(this.defines.EDGE_DETECTION_MODE)
        }
        set edgeDetectionMode(p) {
            this.defines.EDGE_DETECTION_MODE = p.toFixed(0),
            this.needsUpdate = !0
        }
        getEdgeDetectionMode() {
            return this.edgeDetectionMode
        }
        setEdgeDetectionMode(p) {
            this.edgeDetectionMode = p
        }
        get localContrastAdaptationFactor() {
            return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)
        }
        set localContrastAdaptationFactor(p) {
            this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = p.toFixed("6"),
            this.needsUpdate = !0
        }
        getLocalContrastAdaptationFactor() {
            return this.localContrastAdaptationFactor
        }
        setLocalContrastAdaptationFactor(p) {
            this.localContrastAdaptationFactor = p
        }
        get edgeDetectionThreshold() {
            return Number(this.defines.EDGE_THRESHOLD)
        }
        set edgeDetectionThreshold(p) {
            this.defines.EDGE_THRESHOLD = p.toFixed("6"),
            this.defines.DEPTH_THRESHOLD = (p * .1).toFixed("6"),
            this.needsUpdate = !0
        }
        getEdgeDetectionThreshold() {
            return this.edgeDetectionThreshold
        }
        setEdgeDetectionThreshold(p) {
            this.edgeDetectionThreshold = p
        }
        get predicationMode() {
            return Number(this.defines.PREDICATION_MODE)
        }
        set predicationMode(p) {
            this.defines.PREDICATION_MODE = p.toFixed(0),
            this.needsUpdate = !0
        }
        getPredicationMode() {
            return this.predicationMode
        }
        setPredicationMode(p) {
            this.predicationMode = p
        }
        set predicationBuffer(p) {
            this.uniforms.predicationBuffer.value = p
        }
        setPredicationBuffer(p) {
            this.uniforms.predicationBuffer.value = p
        }
        get predicationThreshold() {
            return Number(this.defines.PREDICATION_THRESHOLD)
        }
        set predicationThreshold(p) {
            this.defines.PREDICATION_THRESHOLD = p.toFixed("6"),
            this.needsUpdate = !0
        }
        getPredicationThreshold() {
            return this.predicationThreshold
        }
        setPredicationThreshold(p) {
            this.predicationThreshold = p
        }
        get predicationScale() {
            return Number(this.defines.PREDICATION_SCALE)
        }
        set predicationScale(p) {
            this.defines.PREDICATION_SCALE = p.toFixed("6"),
            this.needsUpdate = !0
        }
        getPredicationScale() {
            return this.predicationScale
        }
        setPredicationScale(p) {
            this.predicationScale = p
        }
        get predicationStrength() {
            return Number(this.defines.PREDICATION_STRENGTH)
        }
        set predicationStrength(p) {
            this.defines.PREDICATION_STRENGTH = p.toFixed("6"),
            this.needsUpdate = !0
        }
        getPredicationStrength() {
            return this.predicationStrength
        }
        setPredicationStrength(p) {
            this.predicationStrength = p
        }
        setSize(p, C) {
            this.uniforms.texelSize.value.set(1 / p, 1 / C)
        }
    }
    const An = `#include <common>
#include <packing>
#include <dithering_pars_fragment>

#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)

#ifdef FRAMEBUFFER_PRECISION_HIGH

    uniform mediump sampler2D inputBuffer;

#else

    uniform lowp sampler2D inputBuffer;

#endif

#if DEPTH_PACKING == 3201

    uniform lowp sampler2D depthBuffer;

#elif defined(GL_FRAGMENT_PRECISION_HIGH)

    uniform highp sampler2D depthBuffer;

#else

    uniform mediump sampler2D depthBuffer;

#endif

uniform vec2 resolution;
uniform vec2 texelSize;

uniform float cameraNear;
uniform float cameraFar;
uniform float aspect;
uniform float time;

varying vec2 vUv;

#if THREE_REVISION < 143

    #define luminance(v) linearToRelativeLuminance(v)

#endif

#if THREE_REVISION >= 137

    vec4 sRGBToLinear(const in vec4 value) {

        return vec4(mix(
            pow(value.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)),
            value.rgb * 0.0773993808,
            vec3(lessThanEqual(value.rgb, vec3(0.04045)))
        ), value.a);

    }

#endif

float readDepth(const in vec2 uv) {

    #if DEPTH_PACKING == 3201

        return unpackRGBAToDepth(texture2D(depthBuffer, uv));

    #else

        return texture2D(depthBuffer, uv).r;

    #endif

}

float getViewZ(const in float depth) {

    #ifdef PERSPECTIVE_CAMERA

        return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);

    #else

        return orthographicDepthToViewZ(depth, cameraNear, cameraFar);

    #endif

}

/**
 * Based on work by Sam Hocevar, Emil Persson and Ian Taylor.
 * https://www.chilliant.com/rgb2hsv.html
 */

vec3 RGBToHCV(const in vec3 RGB) {

    vec4 P = mix(vec4(RGB.bg, -1.0, 2.0 / 3.0), vec4(RGB.gb, 0.0, -1.0 / 3.0), step(RGB.b, RGB.g));
    vec4 Q = mix(vec4(P.xyw, RGB.r), vec4(RGB.r, P.yzx), step(P.x, RGB.r));
    float C = Q.x - min(Q.w, Q.y);
    float H = abs((Q.w - Q.y) / (6.0 * C + EPSILON) + Q.z);
    return vec3(H, C, Q.x);

}

vec3 RGBToHSL(const in vec3 RGB) {

    vec3 HCV = RGBToHCV(RGB);
    float L = HCV.z - HCV.y * 0.5;
    float S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + EPSILON);
    return vec3(HCV.x, S, L);

}

vec3 HueToRGB(const in float H) {

    float R = abs(H * 6.0 - 3.0) - 1.0;
    float G = 2.0 - abs(H * 6.0 - 2.0);
    float B = 2.0 - abs(H * 6.0 - 4.0);
    return clamp(vec3(R, G, B), 0.0, 1.0);

}

vec3 HSLToRGB(const in vec3 HSL) {

    vec3 RGB = HueToRGB(HSL.x);
    float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;
    return (RGB - 0.5) * C + HSL.z;

}

FRAGMENT_HEAD

void main() {

    FRAGMENT_MAIN_UV

    vec4 color0 = texture2D(inputBuffer, UV);
    vec4 color1 = vec4(0.0);

    FRAGMENT_MAIN_IMAGE

    gl_FragColor = color0;

    #ifdef ENCODE_OUTPUT

        #include <encodings_fragment>

    #endif

    #include <dithering_fragment>

}
`
      , Qt = `uniform vec2 resolution;
uniform vec2 texelSize;

uniform float cameraNear;
uniform float cameraFar;
uniform float aspect;
uniform float time;

varying vec2 vUv;

VERTEX_HEAD

void main() {

    vUv = position.xy * 0.5 + 0.5;

    VERTEX_MAIN_SUPPORT

    gl_Position = vec4(position.xy, 1.0, 1.0);

}
`;
    class Pi extends R.jyz {
        constructor(p, C, V, se, ye=!1) {
            super({
                name: "EffectMaterial",
                defines: {
                    THREE_REVISION: R.UZH.replace(/\D+/g, ""),
                    DEPTH_PACKING: "0",
                    ENCODE_OUTPUT: "1"
                },
                uniforms: {
                    inputBuffer: new R.xWb(null),
                    depthBuffer: new R.xWb(null),
                    resolution: new R.xWb(new R.FM8),
                    texelSize: new R.xWb(new R.FM8),
                    cameraNear: new R.xWb(.3),
                    cameraFar: new R.xWb(1e3),
                    aspect: new R.xWb(1),
                    time: new R.xWb(0)
                },
                blending: R.jFi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                dithering: ye
            }),
            p && this.setShaderParts(p),
            C && this.setDefines(C),
            V && this.setUniforms(V),
            this.copyCameraSettings(se)
        }
        set inputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        setInputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        get depthBuffer() {
            return this.uniforms.depthBuffer.value
        }
        set depthBuffer(p) {
            this.uniforms.depthBuffer.value = p
        }
        get depthPacking() {
            return Number(this.defines.DEPTH_PACKING)
        }
        set depthPacking(p) {
            this.defines.DEPTH_PACKING = p.toFixed(0),
            this.needsUpdate = !0
        }
        setDepthBuffer(p, C=R.z81) {
            this.depthBuffer = p,
            this.depthPacking = C
        }
        setShaderData(p) {
            this.setShaderParts(p.shaderParts),
            this.setDefines(p.defines),
            this.setUniforms(p.uniforms),
            this.setExtensions(p.extensions)
        }
        setShaderParts(p) {
            return this.fragmentShader = An.replace(en.FRAGMENT_HEAD, p.get(en.FRAGMENT_HEAD) || "").replace(en.FRAGMENT_MAIN_UV, p.get(en.FRAGMENT_MAIN_UV) || "").replace(en.FRAGMENT_MAIN_IMAGE, p.get(en.FRAGMENT_MAIN_IMAGE) || ""),
            this.vertexShader = Qt.replace(en.VERTEX_HEAD, p.get(en.VERTEX_HEAD) || "").replace(en.VERTEX_MAIN_SUPPORT, p.get(en.VERTEX_MAIN_SUPPORT) || ""),
            this.needsUpdate = !0,
            this
        }
        setDefines(p) {
            for (const C of p.entries())
                this.defines[C[0]] = C[1];
            return this.needsUpdate = !0,
            this
        }
        setUniforms(p) {
            for (const C of p.entries())
                this.uniforms[C[0]] = C[1];
            return this
        }
        setExtensions(p) {
            this.extensions = {};
            for (const C of p)
                this.extensions[C] = !0;
            return this
        }
        get encodeOutput() {
            return this.defines.ENCODE_OUTPUT !== void 0
        }
        set encodeOutput(p) {
            this.encodeOutput !== p && (p ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT,
            this.needsUpdate = !0)
        }
        isOutputEncodingEnabled(p) {
            return this.encodeOutput
        }
        setOutputEncodingEnabled(p) {
            this.encodeOutput = p
        }
        get time() {
            return this.uniforms.time.value
        }
        set time(p) {
            this.uniforms.time.value = p
        }
        setDeltaTime(p) {
            this.uniforms.time.value += p
        }
        adoptCameraSettings(p) {
            this.copyCameraSettings(p)
        }
        copyCameraSettings(p) {
            p && (this.uniforms.cameraNear.value = p.near,
            this.uniforms.cameraFar.value = p.far,
            p instanceof R.cPb ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
            this.needsUpdate = !0)
        }
        setSize(p, C) {
            const V = this.uniforms;
            V.resolution.value.set(p, C),
            V.texelSize.value.set(1 / p, 1 / C),
            V.aspect.value = p / C
        }
        static get Section() {
            return en
        }
    }
    const ui = `#include <common>

#if THREE_REVISION < 143

    #define luminance(v) linearToRelativeLuminance(v)

#endif

#ifdef FRAMEBUFFER_PRECISION_HIGH

    uniform mediump sampler2D inputBuffer;

#else

    uniform lowp sampler2D inputBuffer;

#endif

#ifdef RANGE

    uniform vec2 range;

#elif defined(THRESHOLD)

    uniform float threshold;
    uniform float smoothing;

#endif

varying vec2 vUv;

void main() {

    vec4 texel = texture2D(inputBuffer, vUv);
    float l = luminance(texel.rgb);

    #ifdef RANGE

        // Apply a luminance range mask.
        float low = step(range.x, l);
        float high = step(l, range.y);

        l *= low * high;

    #elif defined(THRESHOLD)

        l = smoothstep(threshold, threshold + smoothing, l);

    #endif

    #ifdef COLOR

        gl_FragColor = vec4(texel.rgb * l, l);

    #else

        gl_FragColor = vec4(l);

    #endif

}
`;
    class mi extends R.jyz {
        constructor(p=!1, C=null) {
            super({
                name: "LuminanceMaterial",
                defines: {
                    THREE_REVISION: R.UZH.replace(/\D+/g, "")
                },
                uniforms: {
                    inputBuffer: new R.xWb(null),
                    threshold: new R.xWb(0),
                    smoothing: new R.xWb(1),
                    range: new R.xWb(null)
                },
                blending: R.jFi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: ui,
                vertexShader: Xt
            }),
            this.colorOutput = p,
            this.luminanceRange = C
        }
        set inputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        setInputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        get threshold() {
            return this.uniforms.threshold.value
        }
        set threshold(p) {
            this.smoothing > 0 || p > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD,
            this.uniforms.threshold.value = p
        }
        getThreshold() {
            return this.threshold
        }
        setThreshold(p) {
            this.threshold = p
        }
        get smoothing() {
            return this.uniforms.smoothing.value
        }
        set smoothing(p) {
            this.threshold > 0 || p > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD,
            this.uniforms.smoothing.value = p
        }
        getSmoothingFactor() {
            return this.smoothing
        }
        setSmoothingFactor(p) {
            this.smoothing = p
        }
        get useThreshold() {
            return this.threshold > 0 || this.smoothing > 0
        }
        set useThreshold(p) {}
        get colorOutput() {
            return this.defines.COLOR !== void 0
        }
        set colorOutput(p) {
            p ? this.defines.COLOR = "1" : delete this.defines.COLOR,
            this.needsUpdate = !0
        }
        isColorOutputEnabled(p) {
            return this.colorOutput
        }
        setColorOutputEnabled(p) {
            this.colorOutput = p
        }
        get useRange() {
            return this.luminanceRange !== null
        }
        set useRange(p) {
            this.luminanceRange = null
        }
        get luminanceRange() {
            return this.uniforms.range.value
        }
        set luminanceRange(p) {
            p !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE,
            this.uniforms.range.value = p,
            this.needsUpdate = !0
        }
        getLuminanceRange() {
            return this.luminanceRange
        }
        setLuminanceRange(p) {
            this.luminanceRange = p
        }
    }
    const Si = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)

#if __VERSION__ < 300

    #define round(v) floor(v + 0.5)

#endif

#ifdef FRAMEBUFFER_PRECISION_HIGH

    uniform mediump sampler2D inputBuffer;

#else

    uniform lowp sampler2D inputBuffer;

#endif

uniform lowp sampler2D areaTexture;
uniform lowp sampler2D searchTexture;

uniform vec2 texelSize;
uniform vec2 resolution;

varying vec2 vUv;
varying vec4 vOffset[3];
varying vec2 vPixCoord;


/**
 * Moves values to a target vector based on a given conditional vector.
 */

void movec(const in bvec2 c, inout vec2 variable, const in vec2 value) {

    if(c.x) { variable.x = value.x; }
    if(c.y) { variable.y = value.y; }

}

void movec(const in bvec4 c, inout vec4 variable, const in vec4 value) {

    movec(c.xy, variable.xy, value.xy);
    movec(c.zw, variable.zw, value.zw);

}

/**
 * Allows to decode two binary values from a bilinear-filtered access.
 *
 * Bilinear access for fetching 'e' have a 0.25 offset, and we are interested
 * in the R and G edges:
 *
 * +---G---+-------+
 * |   x o R   x   |
 * +-------+-------+
 *
 * Then, if one of these edge is enabled:
 *  Red: (0.75 * X + 0.25 * 1) => 0.25 or 1.0
 *  Green: (0.75 * 1 + 0.25 * X) => 0.75 or 1.0
 *
 * This function will unpack the values (mad + mul + round):
 * wolframalpha.com: round(x * abs(5 * x - 5 * 0.75)) plot 0 to 1
 */

vec2 decodeDiagBilinearAccess(in vec2 e) {

    e.r = e.r * abs(5.0 * e.r - 5.0 * 0.75);

    return round(e);

}

vec4 decodeDiagBilinearAccess(in vec4 e) {

    e.rb = e.rb * abs(5.0 * e.rb - 5.0 * 0.75);

    return round(e);

}

/**
 * Diagonal pattern searches.
 */

vec2 searchDiag1(const in vec2 texCoord, const in vec2 dir, out vec2 e) {

    vec4 coord = vec4(texCoord, -1.0, 1.0);
    vec3 t = vec3(texelSize, 1.0);

    for(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {

        if(!(coord.z < float(MAX_SEARCH_STEPS_DIAG_INT - 1) && coord.w > 0.9)) {

            break;

        }

        coord.xyz = t * vec3(dir, 1.0) + coord.xyz;
        e = texture2D(inputBuffer, coord.xy).rg;
        coord.w = dot(e, vec2(0.5));

    }

    return coord.zw;

}

vec2 searchDiag2(const in vec2 texCoord, const in vec2 dir, out vec2 e) {

    vec4 coord = vec4(texCoord, -1.0, 1.0);
    coord.x += 0.25 * texelSize.x; // See @SearchDiag2Optimization
    vec3 t = vec3(texelSize, 1.0);

    for(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {

        if(!(coord.z < float(MAX_SEARCH_STEPS_DIAG_INT - 1) && coord.w > 0.9)) {

            break;

        }

        coord.xyz = t * vec3(dir, 1.0) + coord.xyz;

        // @SearchDiag2Optimization
        // Fetch both edges at once using bilinear filtering.
        e = texture2D(inputBuffer, coord.xy).rg;
        e = decodeDiagBilinearAccess(e);

        // Non-optimized version:
        // e.g = texture2D(inputBuffer, coord.xy).g;
        // e.r = SMAASampleLevelZeroOffset(inputBuffer, coord.xy, vec2(1, 0)).r;

        coord.w = dot(e, vec2(0.5));

    }

    return coord.zw;

}

/**
 * Calculates the area corresponding to a certain diagonal distance and crossing
 * edges 'e'.
 */

vec2 areaDiag(const in vec2 dist, const in vec2 e, const in float offset) {

    vec2 texCoord = vec2(AREATEX_MAX_DISTANCE_DIAG, AREATEX_MAX_DISTANCE_DIAG) * e + dist;

    // Apply a scale and bias for mapping to texel space.
    texCoord = AREATEX_PIXEL_SIZE * texCoord + 0.5 * AREATEX_PIXEL_SIZE;

    // Diagonal areas are on the second half of the texture.
    texCoord.x += 0.5;

    // Move to the proper place, according to the subpixel offset.
    texCoord.y += AREATEX_SUBTEX_SIZE * offset;

    return texture2D(areaTexture, texCoord).rg;

}

/**
 * Searches for diagonal patterns and returns the corresponding weights.
 */

vec2 calculateDiagWeights(const in vec2 texCoord, const in vec2 e, const in vec4 subsampleIndices) {

    vec2 weights = vec2(0.0);

    // Search for the line ends.
    vec4 d;
    vec2 end;

    if(e.r > 0.0) {

        d.xz = searchDiag1(texCoord, vec2(-1.0,  1.0), end);
        d.x += float(end.y > 0.9);

    } else {

        d.xz = vec2(0.0);

    }

    d.yw = searchDiag1(texCoord, vec2(1.0, -1.0), end);

    if(d.x + d.y > 2.0) { // d.x + d.y + 1 > 3

        // Fetch the crossing edges.
        vec4 coords = vec4(-d.x + 0.25, d.x, d.y, -d.y - 0.25) * texelSize.xyxy + texCoord.xyxy;
        vec4 c;
        c.xy = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(-1, 0)).rg;
        c.zw = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, 0)).rg;
        c.yxwz = decodeDiagBilinearAccess(c.xyzw);

        // Non-optimized version:
        // vec4 coords = vec4(-d.x, d.x, d.y, -d.y) * texelSize.xyxy + texCoord.xyxy;
        // vec4 c;
        // c.x = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(-1, 0)).g;
        // c.y = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(0, 0)).r;
        // c.z = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, 0)).g;
        // c.w = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, -1)).r;

        // Merge crossing edges at each side into a single value.
        vec2 cc = vec2(2.0) * c.xz + c.yw;

        // Remove the crossing edge if no end of the line could be found.
        movec(bvec2(step(0.9, d.zw)), cc, vec2(0.0));

        // Fetch the areas for this line.
        weights += areaDiag(d.xy, cc, subsampleIndices.z);

    }

    // Search for the line ends.
    d.xz = searchDiag2(texCoord, vec2(-1.0, -1.0), end);

    if(sampleLevelZeroOffset(inputBuffer, texCoord, vec2(1, 0)).r > 0.0) {

        d.yw = searchDiag2(texCoord, vec2(1.0), end);
        d.y += float(end.y > 0.9);

    } else {

        d.yw = vec2(0.0);

    }

    if(d.x + d.y > 2.0) { // d.x + d.y + 1 > 3

        // Fetch the crossing edges.
        vec4 coords = vec4(-d.x, -d.x, d.y, d.y) * texelSize.xyxy + texCoord.xyxy;
        vec4 c;
        c.x = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(-1, 0)).g;
        c.y = sampleLevelZeroOffset(inputBuffer, coords.xy, vec2(0, -1)).r;
        c.zw = sampleLevelZeroOffset(inputBuffer, coords.zw, vec2(1, 0)).gr;
        vec2 cc = vec2(2.0) * c.xz + c.yw;

        // Remove the crossing edge if no end of the line could be found.
        movec(bvec2(step(0.9, d.zw)), cc, vec2(0.0));

        // Fetch the areas for this line.
        weights += areaDiag(d.xy, cc, subsampleIndices.w).gr;

    }

    return weights;

}

/**
 * Determines how much length should be added in the last step of the searches.
 *
 * Takes the bilinearly interpolated edge (see @PSEUDO_GATHER4), and adds 0, 1
 * or 2 depending on which edges and crossing edges are active.
 */

float searchLength(const in vec2 e, const in float offset) {

    /* The texture is flipped vertically, with left and right cases taking half
    of the space horizontally. */
    vec2 scale = SEARCHTEX_SIZE * vec2(0.5, -1.0);
    vec2 bias = SEARCHTEX_SIZE * vec2(offset, 1.0);

    // Scale and bias to access texel centers.
    scale += vec2(-1.0, 1.0);
    bias += vec2(0.5, -0.5);

    // Convert from pixel coordinates to texcoords.
    scale *= 1.0 / SEARCHTEX_PACKED_SIZE;
    bias *= 1.0 / SEARCHTEX_PACKED_SIZE;

    return texture2D(searchTexture, scale * e + bias).r;

}

/**
 * Horizontal search for the second pass.
 */

float searchXLeft(in vec2 texCoord, const in float end) {

    /* @PSEUDO_GATHER4
    This texCoord has been offset by (-0.25, -0.125) in the vertex shader to
    sample between edges, thus fetching four edges in a row.
    Sampling with different offsets in each direction allows to disambiguate
    which edges are active from the four fetched ones. */

    vec2 e = vec2(0.0, 1.0);

    for(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {

        if(!(texCoord.x > end && e.g > 0.8281 && e.r == 0.0)) {

            break;

        }

        e = texture2D(inputBuffer, texCoord).rg;
        texCoord = vec2(-2.0, 0.0) * texelSize + texCoord;

    }

    float offset = -(255.0 / 127.0) * searchLength(e, 0.0) + 3.25;

    return texelSize.x * offset + texCoord.x;

    // Non-optimized version:
    // Correct the previous (-0.25, -0.125) offset.
    // texCoord.x += 0.25 * texelSize.x;
    // The searches are biased by 1, so adjust the coords accordingly.
    // texCoord.x += texelSize.x;
    // Disambiguate the length added by the last step.
    // texCoord.x += 2.0 * texelSize.x; // Undo last step.
    // texCoord.x -= texelSize.x * (255.0 / 127.0) * searchLength(e, 0.0);
    // return texelSize.x * offset + texCoord.x);

}

float searchXRight(vec2 texCoord, const in float end) {

    vec2 e = vec2(0.0, 1.0);

    for(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {

        if(!(texCoord.x < end && e.g > 0.8281 && e.r == 0.0)) {

            break;

        }

        e = texture2D(inputBuffer, texCoord).rg;
        texCoord = vec2(2.0, 0.0) * texelSize.xy + texCoord;

    }

    float offset = -(255.0 / 127.0) * searchLength(e, 0.5) + 3.25;

    return -texelSize.x * offset + texCoord.x;

}

/**
 * Vertical search for the second pass.
 */

float searchYUp(vec2 texCoord, const in float end) {

    vec2 e = vec2(1.0, 0.0);

    for(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {

        if(!(texCoord.y > end && e.r > 0.8281 && e.g == 0.0)) {

            break;

        }

        e = texture2D(inputBuffer, texCoord).rg;
        texCoord = -vec2(0.0, 2.0) * texelSize.xy + texCoord;

    }

    float offset = -(255.0 / 127.0) * searchLength(e.gr, 0.0) + 3.25;

    return texelSize.y * offset + texCoord.y;

}

float searchYDown(vec2 texCoord, const in float end) {

    vec2 e = vec2(1.0, 0.0);

    for(int i = 0; i < MAX_SEARCH_STEPS_INT; i++) {

        if(!(texCoord.y < end && e.r > 0.8281 && e.g == 0.0)) {

            break;

        }

        e = texture2D(inputBuffer, texCoord).rg;
        texCoord = vec2(0.0, 2.0) * texelSize.xy + texCoord;

    }

    float offset = -(255.0 / 127.0) * searchLength(e.gr, 0.5) + 3.25;

    return -texelSize.y * offset + texCoord.y;

}

/**
 * Determines the areas at each side of the current edge.
 */

vec2 area(const in vec2 dist, const in float e1, const in float e2, const in float offset) {

    // Rounding prevents precision errors of bilinear filtering.
    vec2 texCoord = vec2(AREATEX_MAX_DISTANCE) * round(4.0 * vec2(e1, e2)) + dist;

    // Apply a scale and bias for mapping to texel space.
    texCoord = AREATEX_PIXEL_SIZE * texCoord + 0.5 * AREATEX_PIXEL_SIZE;

    // Move to the proper place, according to the subpixel offset.
    texCoord.y = AREATEX_SUBTEX_SIZE * offset + texCoord.y;

    return texture2D(areaTexture, texCoord).rg;

}

/**
 * Corner detection.
 */

void detectHorizontalCornerPattern(inout vec2 weights, const in vec4 texCoord, const in vec2 d) {

    #if !defined(DISABLE_CORNER_DETECTION)

        vec2 leftRight = step(d.xy, d.yx);
        vec2 rounding = (1.0 - CORNER_ROUNDING_NORM) * leftRight;

        // Reduce blending for pixels in the center of a line.
        rounding /= leftRight.x + leftRight.y;

        vec2 factor = vec2(1.0);
        factor.x -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(0, 1)).r;
        factor.x -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(1, 1)).r;
        factor.y -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(0, -2)).r;
        factor.y -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(1, -2)).r;

        weights *= clamp(factor, 0.0, 1.0);

    #endif

}

void detectVerticalCornerPattern(inout vec2 weights, const in vec4 texCoord, const in vec2 d) {

    #if !defined(DISABLE_CORNER_DETECTION)

        vec2 leftRight = step(d.xy, d.yx);
        vec2 rounding = (1.0 - CORNER_ROUNDING_NORM) * leftRight;

        rounding /= leftRight.x + leftRight.y;

        vec2 factor = vec2(1.0);
        factor.x -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(1, 0)).g;
        factor.x -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(1, 1)).g;
        factor.y -= rounding.x * sampleLevelZeroOffset(inputBuffer, texCoord.xy, vec2(-2, 0)).g;
        factor.y -= rounding.y * sampleLevelZeroOffset(inputBuffer, texCoord.zw, vec2(-2, 1)).g;

        weights *= clamp(factor, 0.0, 1.0);

    #endif

}

void main() {

    vec4 weights = vec4(0.0);
    vec4 subsampleIndices = vec4(0.0);
    vec2 e = texture2D(inputBuffer, vUv).rg;

    if(e.g > 0.0) {

        // Edge at north.

        #if !defined(DISABLE_DIAG_DETECTION)

            /* Diagonals have both north and west edges, so searching for them in one of
            the boundaries is enough. */
            weights.rg = calculateDiagWeights(vUv, e, subsampleIndices);

            // Skip horizontal/vertical processing if there is a diagonal.
            if(weights.r == -weights.g) { // weights.r + weights.g == 0.0

        #endif

        vec2 d;

        // Find the distance to the left.
        vec3 coords;
        coords.x = searchXLeft(vOffset[0].xy, vOffset[2].x);
        coords.y = vOffset[1].y; // vOffset[1].y = vUv.y - 0.25 * texelSize.y (@CROSSING_OFFSET)
        d.x = coords.x;

        /* Now fetch the left crossing edges, two at a time using bilinear
        filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to discern what
        value each edge has. */
        float e1 = texture2D(inputBuffer, coords.xy).r;

        // Find the distance to the right.
        coords.z = searchXRight(vOffset[0].zw, vOffset[2].y);
        d.y = coords.z;

        /* Translate distances to pixel units for better interleave arithmetic and
        memory accesses. */
        d = round(resolution.xx * d + -vPixCoord.xx);

        // The area texture is compressed quadratically.
        vec2 sqrtD = sqrt(abs(d));

        // Fetch the right crossing edges.
        float e2 = sampleLevelZeroOffset(inputBuffer, coords.zy, vec2(1, 0)).r;

        // Pattern recognized, now get the actual area.
        weights.rg = area(sqrtD, e1, e2, subsampleIndices.y);

        // Fix corners.
        coords.y = vUv.y;
        detectHorizontalCornerPattern(weights.rg, coords.xyzy, d);

        #if !defined(DISABLE_DIAG_DETECTION)

            } else {

                // Skip vertical processing.
                e.r = 0.0;

            }

        #endif

    }

    if(e.r > 0.0) {

        // Edge at west.

        vec2 d;

        // Find the distance to the top.
        vec3 coords;
        coords.y = searchYUp(vOffset[1].xy, vOffset[2].z);
        coords.x = vOffset[0].x; // vOffset[1].x = vUv.x - 0.25 * texelSize.x;
        d.x = coords.y;

        // Fetch the top crossing edges.
        float e1 = texture2D(inputBuffer, coords.xy).g;

        // Find the distance to the bottom.
        coords.z = searchYDown(vOffset[1].zw, vOffset[2].w);
        d.y = coords.z;

        // Translate distances into pixel units.
        d = round(resolution.yy * d - vPixCoord.yy);

        // The area texture is compressed quadratically.
        vec2 sqrtD = sqrt(abs(d));

        // Fetch the bottom crossing edges.
        float e2 = sampleLevelZeroOffset(inputBuffer, coords.xz, vec2(0, 1)).g;

        // Get the area for this direction.
        weights.ba = area(sqrtD, e1, e2, subsampleIndices.x);

        // Fix corners.
        coords.x = vUv.x;
        detectVerticalCornerPattern(weights.ba, coords.xyxz, d);

    }

    gl_FragColor = weights;

}
`
      , Gt = `uniform vec2 texelSize;
uniform vec2 resolution;

varying vec2 vUv;
varying vec4 vOffset[3];
varying vec2 vPixCoord;

void main() {

    vUv = position.xy * 0.5 + 0.5;
    vPixCoord = vUv * resolution;

    // Offsets for the searches (see @PSEUDO_GATHER4).
    vOffset[0] = vUv.xyxy + texelSize.xyxy * vec4(-0.25, -0.125, 1.25, -0.125);
    vOffset[1] = vUv.xyxy + texelSize.xyxy * vec4(-0.125, -0.25, -0.125, 1.25);

    // This indicates the ends of the loops.
    vOffset[2] = vec4(vOffset[0].xz, vOffset[1].yw) +
        vec4(-2.0, 2.0, -2.0, 2.0) * texelSize.xxyy * MAX_SEARCH_STEPS_FLOAT;

    gl_Position = vec4(position.xy, 1.0, 1.0);

}
`;
    class On extends R.jyz {
        constructor(p=new R.FM8, C=new R.FM8) {
            super({
                name: "SMAAWeightsMaterial",
                defines: {
                    MAX_SEARCH_STEPS_INT: "16",
                    MAX_SEARCH_STEPS_FLOAT: "16.0",
                    MAX_SEARCH_STEPS_DIAG_INT: "8",
                    MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                    CORNER_ROUNDING: "25",
                    CORNER_ROUNDING_NORM: "0.25",
                    AREATEX_MAX_DISTANCE: "16.0",
                    AREATEX_MAX_DISTANCE_DIAG: "20.0",
                    AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                    AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                    SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                    SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                },
                uniforms: {
                    inputBuffer: new R.xWb(null),
                    searchTexture: new R.xWb(null),
                    areaTexture: new R.xWb(null),
                    resolution: new R.xWb(C),
                    texelSize: new R.xWb(p)
                },
                blending: R.jFi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: Si,
                vertexShader: Gt
            })
        }
        set inputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        setInputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        get searchTexture() {
            return this.uniforms.searchTexture.value
        }
        set searchTexture(p) {
            this.uniforms.searchTexture.value = p
        }
        get areaTexture() {
            return this.uniforms.areaTexture.value
        }
        set areaTexture(p) {
            this.uniforms.areaTexture.value = p
        }
        setLookupTextures(p, C) {
            this.searchTexture = p,
            this.areaTexture = C
        }
        get orthogonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_INT)
        }
        set orthogonalSearchSteps(p) {
            const C = Math.min(Math.max(p, 0), 112);
            this.defines.MAX_SEARCH_STEPS_INT = C.toFixed("0"),
            this.defines.MAX_SEARCH_STEPS_FLOAT = C.toFixed("1"),
            this.needsUpdate = !0
        }
        setOrthogonalSearchSteps(p) {
            this.orthogonalSearchSteps = p
        }
        get diagonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)
        }
        set diagonalSearchSteps(p) {
            const C = Math.min(Math.max(p, 0), 20);
            this.defines.MAX_SEARCH_STEPS_DIAG_INT = C.toFixed("0"),
            this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = C.toFixed("1"),
            this.needsUpdate = !0
        }
        setDiagonalSearchSteps(p) {
            this.diagonalSearchSteps = p
        }
        get diagonalDetection() {
            return this.defines.DISABLE_DIAG_DETECTION === void 0
        }
        set diagonalDetection(p) {
            p ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1",
            this.needsUpdate = !0
        }
        isDiagonalDetectionEnabled() {
            return this.diagonalDetection
        }
        setDiagonalDetectionEnabled(p) {
            this.diagonalDetection = p
        }
        get cornerRounding() {
            return Number(this.defines.CORNER_ROUNDING)
        }
        set cornerRounding(p) {
            const C = Math.min(Math.max(p, 0), 100);
            this.defines.CORNER_ROUNDING = C.toFixed("4"),
            this.defines.CORNER_ROUNDING_NORM = (C / 100).toFixed("4"),
            this.needsUpdate = !0
        }
        setCornerRounding(p) {
            this.cornerRounding = p
        }
        get cornerDetection() {
            return this.defines.DISABLE_CORNER_DETECTION === void 0
        }
        set cornerDetection(p) {
            p ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1",
            this.needsUpdate = !0
        }
        isCornerRoundingEnabled() {
            return this.cornerDetection
        }
        setCornerRoundingEnabled(p) {
            this.cornerDetection = p
        }
        setSize(p, C) {
            const V = this.uniforms;
            V.texelSize.value.set(1 / p, 1 / C),
            V.resolution.value.set(p, C)
        }
    }
    const kn = `#ifdef FRAMEBUFFER_PRECISION_HIGH

    uniform mediump sampler2D inputBuffer;
    uniform mediump sampler2D supportBuffer;

#else

    uniform lowp sampler2D inputBuffer;
    uniform lowp sampler2D supportBuffer;

#endif

uniform float radius;

varying vec2 vUv;
varying vec2 vUv0;
varying vec2 vUv1;
varying vec2 vUv2;
varying vec2 vUv3;
varying vec2 vUv4;
varying vec2 vUv5;
varying vec2 vUv6;
varying vec2 vUv7;

void main() {

    vec4 c = vec4(0.0);

    c += texture2D(inputBuffer, vUv0) * 0.0625;
    c += texture2D(inputBuffer, vUv1) * 0.125;
    c += texture2D(inputBuffer, vUv2) * 0.0625;
    c += texture2D(inputBuffer, vUv3) * 0.125;
    c += texture2D(inputBuffer, vUv) * 0.25;
    c += texture2D(inputBuffer, vUv4) * 0.125;
    c += texture2D(inputBuffer, vUv5) * 0.0625;
    c += texture2D(inputBuffer, vUv6) * 0.125;
    c += texture2D(inputBuffer, vUv7) * 0.0625;

    vec4 baseColor = texture2D(supportBuffer, vUv);
    gl_FragColor = mix(baseColor, c, radius);

    #include <encodings_fragment>

}
`
      , bi = `uniform vec2 texelSize;

varying vec2 vUv;
varying vec2 vUv0;
varying vec2 vUv1;
varying vec2 vUv2;
varying vec2 vUv3;
varying vec2 vUv4;
varying vec2 vUv5;
varying vec2 vUv6;
varying vec2 vUv7;

void main() {

    vUv = position.xy * 0.5 + 0.5;

    vUv0 = vUv + texelSize * vec2(-1.0, 1.0);
    vUv1 = vUv + texelSize * vec2(0.0, 1.0);
    vUv2 = vUv + texelSize * vec2(1.0, 1.0);
    vUv3 = vUv + texelSize * vec2(-1.0, 0.0);

    vUv4 = vUv + texelSize * vec2(1.0, 0.0);
    vUv5 = vUv + texelSize * vec2(-1.0, -1.0);
    vUv6 = vUv + texelSize * vec2(0.0, -1.0);
    vUv7 = vUv + texelSize * vec2(1.0, -1.0);

    gl_Position = vec4(position.xy, 1.0, 1.0);

}
`;
    class $i extends R.jyz {
        constructor() {
            super({
                name: "UpsamplingMaterial",
                uniforms: {
                    inputBuffer: new R.xWb(null),
                    supportBuffer: new R.xWb(null),
                    texelSize: new R.xWb(new R.FM8),
                    radius: new R.xWb(.85)
                },
                blending: R.jFi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: kn,
                vertexShader: bi
            })
        }
        set inputBuffer(p) {
            this.uniforms.inputBuffer.value = p
        }
        set supportBuffer(p) {
            this.uniforms.supportBuffer.value = p
        }
        get radius() {
            return this.uniforms.radius.value
        }
        set radius(p) {
            this.uniforms.radius.value = p
        }
        setSize(p, C) {
            this.uniforms.texelSize.value.set(1 / p, 1 / C)
        }
    }
    const zr = new R.V1s;
    let Fi = null;
    function vr() {
        if (Fi === null) {
            const S = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0])
              , p = new Float32Array([0, 0, 2, 0, 0, 2]);
            Fi = new R.u9r,
            Fi.setAttribute !== void 0 ? (Fi.setAttribute("position", new R.TlE(S,3)),
            Fi.setAttribute("uv", new R.TlE(p,2))) : (Fi.addAttribute("position", new R.TlE(S,3)),
            Fi.addAttribute("uv", new R.TlE(p,2)))
        }
        return Fi
    }
    class Oi {
        constructor(p="Pass", C=new R.xsS, V=zr) {
            this.name = p,
            this.renderer = null,
            this.scene = C,
            this.camera = V,
            this.screen = null,
            this.rtt = !0,
            this.needsSwap = !0,
            this.needsDepthTexture = !1,
            this.enabled = !0
        }
        get renderToScreen() {
            return !this.rtt
        }
        set renderToScreen(p) {
            if (this.rtt === p) {
                const C = this.fullscreenMaterial;
                C !== null && (C.needsUpdate = !0),
                this.rtt = !p
            }
        }
        set mainScene(p) {}
        set mainCamera(p) {}
        setRenderer(p) {
            this.renderer = p
        }
        isEnabled() {
            return this.enabled
        }
        setEnabled(p) {
            this.enabled = p
        }
        get fullscreenMaterial() {
            return this.screen !== null ? this.screen.material : null
        }
        set fullscreenMaterial(p) {
            let C = this.screen;
            C !== null ? C.material = p : (C = new R.Kj0(vr(),p),
            C.frustumCulled = !1,
            this.scene === null && (this.scene = new R.xsS),
            this.scene.add(C),
            this.screen = C)
        }
        getFullscreenMaterial() {
            return this.fullscreenMaterial
        }
        setFullscreenMaterial(p) {
            this.fullscreenMaterial = p
        }
        getDepthTexture() {
            return null
        }
        setDepthTexture(p, C=R.z81) {}
        render(p, C, V, se, ye) {
            throw new Error("Render method not implemented!")
        }
        setSize(p, C) {}
        initialize(p, C, V) {}
        dispose() {
            for (const p of Object.keys(this)) {
                const C = this[p];
                (C instanceof R.dd2 || C instanceof R.F5T || C instanceof R.xEZ || C instanceof Oi) && this[p].dispose()
            }
        }
    }
    class ts extends Oi {
        constructor(p, C=!0) {
            super("CopyPass"),
            this.fullscreenMaterial = new Rt,
            this.needsSwap = !1,
            this.renderTarget = p,
            p === void 0 && (this.renderTarget = new R.dd2(1,1,{
                minFilter: R.wem,
                magFilter: R.wem,
                stencilBuffer: !1,
                depthBuffer: !1
            }),
            this.renderTarget.texture.name = "CopyPass.Target"),
            this.autoResize = C
        }
        get resize() {
            return this.autoResize
        }
        set resize(p) {
            this.autoResize = p
        }
        get texture() {
            return this.renderTarget.texture
        }
        getTexture() {
            return this.renderTarget.texture
        }
        setAutoResizeEnabled(p) {
            this.autoResize = p
        }
        render(p, C, V, se, ye) {
            this.fullscreenMaterial.inputBuffer = C.texture,
            p.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
            p.render(this.scene, this.camera)
        }
        setSize(p, C) {
            this.autoResize && this.renderTarget.setSize(p, C)
        }
        initialize(p, C, V) {
            V !== void 0 && (this.renderTarget.texture.type = V,
            V !== R.ywz ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : ct(p) === N && et(this.renderTarget.texture, N))
        }
    }
    class Gr extends Oi {
        constructor() {
            super("ClearMaskPass", null, null),
            this.needsSwap = !1
        }
        render(p, C, V, se, ye) {
            const ue = p.state.buffers.stencil;
            ue.setLocked(!1),
            ue.setTest(!1)
        }
    }
    const ys = new R.Ilk;
    class xs extends Oi {
        constructor(p=!0, C=!0, V=!1) {
            super("ClearPass", null, null),
            this.needsSwap = !1,
            this.color = p,
            this.depth = C,
            this.stencil = V,
            this.overrideClearColor = null,
            this.overrideClearAlpha = -1
        }
        setClearFlags(p, C, V) {
            this.color = p,
            this.depth = C,
            this.stencil = V
        }
        getOverrideClearColor() {
            return this.overrideClearColor
        }
        setOverrideClearColor(p) {
            this.overrideClearColor = p
        }
        getOverrideClearAlpha() {
            return this.overrideClearAlpha
        }
        setOverrideClearAlpha(p) {
            this.overrideClearAlpha = p
        }
        render(p, C, V, se, ye) {
            const ue = this.overrideClearColor
              , Ce = this.overrideClearAlpha
              , mt = p.getClearAlpha()
              , nn = ue !== null
              , cn = Ce >= 0;
            nn ? (p.getClearColor(ys),
            p.setClearColor(ue, cn ? Ce : mt)) : cn && p.setClearAlpha(Ce),
            p.setRenderTarget(this.renderToScreen ? null : C),
            p.clear(this.color, this.depth, this.stencil),
            nn ? p.setClearColor(ys, mt) : cn && p.setClearAlpha(mt)
        }
    }
    const hi = -1;
    class Ti extends R.pBf {
        constructor(p, C=hi, V=hi, se=1) {
            super(),
            this.resizable = p,
            this.baseSize = new R.FM8(1,1),
            this.preferredSize = new R.FM8(C,V),
            this.target = this.preferredSize,
            this.s = se,
            this.effectiveSize = new R.FM8,
            this.addEventListener("change", ()=>this.updateEffectiveSize()),
            this.updateEffectiveSize()
        }
        updateEffectiveSize() {
            const p = this.baseSize
              , C = this.preferredSize
              , V = this.effectiveSize
              , se = this.scale;
            C.width !== hi ? V.width = C.width : C.height !== hi ? V.width = Math.round(C.height * (p.width / Math.max(p.height, 1))) : V.width = Math.round(p.width * se),
            C.height !== hi ? V.height = C.height : C.width !== hi ? V.height = Math.round(C.width / Math.max(p.width / Math.max(p.height, 1), 1)) : V.height = Math.round(p.height * se)
        }
        get width() {
            return this.effectiveSize.width
        }
        set width(p) {
            this.preferredWidth = p
        }
        get height() {
            return this.effectiveSize.height
        }
        set height(p) {
            this.preferredHeight = p
        }
        getWidth() {
            return this.width
        }
        getHeight() {
            return this.height
        }
        get scale() {
            return this.s
        }
        set scale(p) {
            this.s !== p && (this.s = p,
            this.preferredSize.setScalar(hi),
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getScale() {
            return this.scale
        }
        setScale(p) {
            this.scale = p
        }
        get baseWidth() {
            return this.baseSize.width
        }
        set baseWidth(p) {
            this.baseSize.width !== p && (this.baseSize.width = p,
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getBaseWidth() {
            return this.baseWidth
        }
        setBaseWidth(p) {
            this.baseWidth = p
        }
        get baseHeight() {
            return this.baseSize.height
        }
        set baseHeight(p) {
            this.baseSize.height !== p && (this.baseSize.height = p,
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getBaseHeight() {
            return this.baseHeight
        }
        setBaseHeight(p) {
            this.baseHeight = p
        }
        setBaseSize(p, C) {
            (this.baseSize.width !== p || this.baseSize.height !== C) && (this.baseSize.set(p, C),
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        get preferredWidth() {
            return this.preferredSize.width
        }
        set preferredWidth(p) {
            this.preferredSize.width !== p && (this.preferredSize.width = p,
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getPreferredWidth() {
            return this.preferredWidth
        }
        setPreferredWidth(p) {
            this.preferredWidth = p
        }
        get preferredHeight() {
            return this.preferredSize.height
        }
        set preferredHeight(p) {
            this.preferredSize.height !== p && (this.preferredSize.height = p,
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getPreferredHeight() {
            return this.preferredHeight
        }
        setPreferredHeight(p) {
            this.preferredHeight = p
        }
        setPreferredSize(p, C) {
            (this.preferredSize.width !== p || this.preferredSize.height !== C) && (this.preferredSize.set(p, C),
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        copy(p) {
            this.s = p.scale,
            this.baseSize.set(p.baseWidth, p.baseHeight),
            this.preferredSize.set(p.preferredWidth, p.preferredHeight),
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.baseSize.width, this.baseSize.height)
        }
        static get AUTO_SIZE() {
            return hi
        }
    }
    let gi = !1;
    class qi {
        constructor(p=null) {
            this.originalMaterials = new Map,
            this.material = null,
            this.materials = null,
            this.materialsBackSide = null,
            this.materialsDoubleSide = null,
            this.materialsFlatShaded = null,
            this.materialsFlatShadedBackSide = null,
            this.materialsFlatShadedDoubleSide = null,
            this.setMaterial(p),
            this.meshCount = 0,
            this.replaceMaterial = C=>{
                if (C.isMesh) {
                    let V;
                    if (C.material.flatShading)
                        switch (C.material.side) {
                        case R.ehD:
                            V = this.materialsFlatShadedDoubleSide;
                            break;
                        case R._Li:
                            V = this.materialsFlatShadedBackSide;
                            break;
                        default:
                            V = this.materialsFlatShaded;
                            break
                        }
                    else
                        switch (C.material.side) {
                        case R.ehD:
                            V = this.materialsDoubleSide;
                            break;
                        case R._Li:
                            V = this.materialsBackSide;
                            break;
                        default:
                            V = this.materials;
                            break
                        }
                    this.originalMaterials.set(C, C.material),
                    C.isSkinnedMesh ? C.material = V[2] : C.isInstancedMesh ? C.material = V[1] : C.material = V[0],
                    ++this.meshCount
                }
            }
        }
        cloneMaterial(p) {
            if (!(p instanceof R.jyz))
                return p.clone();
            const C = p.uniforms
              , V = new Map;
            for (const ye in C) {
                const ue = C[ye].value;
                ue.isRenderTargetTexture && (C[ye].value = null,
                V.set(ye, ue))
            }
            const se = p.clone();
            for (const ye of V)
                C[ye[0]].value = ye[1],
                se.uniforms[ye[0]].value = ye[1];
            return se
        }
        setMaterial(p) {
            if (this.disposeMaterials(),
            this.material = p,
            p !== null) {
                const C = this.materials = [this.cloneMaterial(p), this.cloneMaterial(p), this.cloneMaterial(p)];
                for (const V of C)
                    V.uniforms = Object.assign({}, p.uniforms),
                    V.side = R.Wl3;
                C[2].skinning = !0,
                this.materialsBackSide = C.map(V=>{
                    const se = this.cloneMaterial(V);
                    return se.uniforms = Object.assign({}, p.uniforms),
                    se.side = R._Li,
                    se
                }
                ),
                this.materialsDoubleSide = C.map(V=>{
                    const se = this.cloneMaterial(V);
                    return se.uniforms = Object.assign({}, p.uniforms),
                    se.side = R.ehD,
                    se
                }
                ),
                this.materialsFlatShaded = C.map(V=>{
                    const se = this.cloneMaterial(V);
                    return se.uniforms = Object.assign({}, p.uniforms),
                    se.flatShading = !0,
                    se
                }
                ),
                this.materialsFlatShadedBackSide = C.map(V=>{
                    const se = this.cloneMaterial(V);
                    return se.uniforms = Object.assign({}, p.uniforms),
                    se.flatShading = !0,
                    se.side = R._Li,
                    se
                }
                ),
                this.materialsFlatShadedDoubleSide = C.map(V=>{
                    const se = this.cloneMaterial(V);
                    return se.uniforms = Object.assign({}, p.uniforms),
                    se.flatShading = !0,
                    se.side = R.ehD,
                    se
                }
                )
            }
        }
        render(p, C, V) {
            const se = p.shadowMap.enabled;
            if (p.shadowMap.enabled = !1,
            gi) {
                const ye = this.originalMaterials;
                this.meshCount = 0,
                C.traverse(this.replaceMaterial),
                p.render(C, V);
                for (const ue of ye)
                    ue[0].material = ue[1];
                this.meshCount !== ye.size && ye.clear()
            } else {
                const ye = C.overrideMaterial;
                C.overrideMaterial = this.material,
                p.render(C, V),
                C.overrideMaterial = ye
            }
            p.shadowMap.enabled = se
        }
        disposeMaterials() {
            if (this.material !== null) {
                const p = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                for (const C of p)
                    C.dispose()
            }
        }
        dispose() {
            this.originalMaterials.clear(),
            this.disposeMaterials()
        }
        static get workaroundEnabled() {
            return gi
        }
        static set workaroundEnabled(p) {
            gi = p
        }
    }
    class ks extends Oi {
        constructor(p, C, V=null) {
            super("RenderPass", p, C),
            this.needsSwap = !1,
            this.clearPass = new xs,
            this.overrideMaterialManager = V === null ? null : new qi(V),
            this.ignoreBackground = !1,
            this.skipShadowMapUpdate = !1,
            this.selection = null
        }
        set mainScene(p) {
            this.scene = p
        }
        set mainCamera(p) {
            this.camera = p
        }
        get renderToScreen() {
            return super.renderToScreen
        }
        set renderToScreen(p) {
            super.renderToScreen = p,
            this.clearPass.renderToScreen = p
        }
        get overrideMaterial() {
            const p = this.overrideMaterialManager;
            return p !== null ? p.material : null
        }
        set overrideMaterial(p) {
            const C = this.overrideMaterialManager;
            p !== null ? C !== null ? C.setMaterial(p) : this.overrideMaterialManager = new qi(p) : C !== null && (C.dispose(),
            this.overrideMaterialManager = null)
        }
        getOverrideMaterial() {
            return this.overrideMaterial
        }
        setOverrideMaterial(p) {
            this.overrideMaterial = p
        }
        get clear() {
            return this.clearPass.enabled
        }
        set clear(p) {
            this.clearPass.enabled = p
        }
        getSelection() {
            return this.selection
        }
        setSelection(p) {
            this.selection = p
        }
        isBackgroundDisabled() {
            return this.ignoreBackground
        }
        setBackgroundDisabled(p) {
            this.ignoreBackground = p
        }
        isShadowMapDisabled() {
            return this.skipShadowMapUpdate
        }
        setShadowMapDisabled(p) {
            this.skipShadowMapUpdate = p
        }
        getClearPass() {
            return this.clearPass
        }
        render(p, C, V, se, ye) {
            // console.error('p:', p);
            const ue = this.scene
              , Ce = this.camera
              // , Ce = window.camera
              , mt = this.selection
              , nn = Ce.layers.mask
              , cn = ue.background
              , ni = p.shadowMap.autoUpdate
              , ae = this.renderToScreen ? null : C;
            mt !== null && Ce.layers.set(mt.getLayer()),
            this.skipShadowMapUpdate && (p.shadowMap.autoUpdate = !1),
            (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (ue.background = null),
            this.clearPass.enabled && (this.clearPass.setClearFlags(p.autoClearColor, p.autoClearDepth, p.autoClearStencil),
            this.clearPass.render(p, C)),
            p.setRenderTarget(ae),
            this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(p, ue, Ce) : p.render(ue, Ce),
            Ce.layers.mask = nn,
            ue.background = cn,
            p.shadowMap.autoUpdate = ni
        }
    }
    function Gi(S, p, C) {
        for (const V of p) {
            const se = "$1" + S + V.charAt(0).toUpperCase() + V.slice(1)
              , ye = new RegExp("([^\\.])(\\b" + V + "\\b)","g");
            for (const ue of C.entries())
                ue[1] !== null && C.set(ue[0], ue[1].replace(ye, se))
        }
    }
    function Ao(S, p, C) {
        let V = p.getFragmentShader()
          , se = p.getVertexShader();
        const ye = V !== void 0 && /mainImage/.test(V)
          , ue = V !== void 0 && /mainUv/.test(V);
        if (C.attributes |= p.getAttributes(),
        V === void 0)
            throw new Error(`Missing fragment shader (${p.name})`);
        if (ue && C.attributes & Bt.CONVOLUTION)
            throw new Error(`Effects that transform UVs are incompatible with convolution effects (${p.name})`);
        if (!ye && !ue)
            throw new Error(`Could not find mainImage or mainUv function (${p.name})`);
        {
            const Ce = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g
              , mt = C.shaderParts;
            let nn = mt.get(en.FRAGMENT_HEAD) || ""
              , cn = mt.get(en.FRAGMENT_MAIN_UV) || ""
              , ni = mt.get(en.FRAGMENT_MAIN_IMAGE) || ""
              , ae = mt.get(en.VERTEX_HEAD) || ""
              , y = mt.get(en.VERTEX_MAIN_SUPPORT) || "";
            const b = new Set
              , E = new Set;
            if (ue && (cn += `  ${S}MainUv(UV);
`,
            C.uvTransformation = !0),
            se !== null && /mainSupport/.test(se)) {
                const F = /mainSupport *\([\w\s]*?uv\s*?\)/.test(se);
                y += `  ${S}MainSupport(`,
                y += F ? `vUv);
` : `);
`;
                for (const j of se.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
                    for (const W of j[1].split(/\s*,\s*/))
                        C.varyings.add(W),
                        b.add(W),
                        E.add(W);
                for (const j of se.matchAll(Ce))
                    E.add(j[1])
            }
            for (const F of V.matchAll(Ce))
                E.add(F[1]);
            for (const F of p.defines.keys())
                E.add(F.replace(/\([\w\s,]*\)/g, ""));
            for (const F of p.uniforms.keys())
                E.add(F);
            E.delete("while"),
            E.delete("for"),
            E.delete("if"),
            p.uniforms.forEach((F,j)=>C.uniforms.set(S + j.charAt(0).toUpperCase() + j.slice(1), F)),
            p.defines.forEach((F,j)=>C.defines.set(S + j.charAt(0).toUpperCase() + j.slice(1), F));
            const T = new Map([["fragment", V], ["vertex", se]]);
            Gi(S, E, C.defines),
            Gi(S, E, T),
            V = T.get("fragment"),
            se = T.get("vertex");
            const L = p.blendMode;
            if (C.blendModes.set(L.blendFunction, L),
            ye) {
                p.inputColorSpace !== null && p.inputColorSpace !== C.colorSpace && (ni += p.inputColorSpace === N ? `color0 = LinearTosRGB(color0);
    ` : `color0 = sRGBToLinear(color0);
    `),
                p.outputColorSpace !== q ? C.colorSpace = p.outputColorSpace : p.inputColorSpace !== null && (C.colorSpace = p.inputColorSpace);
                const F = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
                ni += `${S}MainImage(color0, UV, `,
                C.attributes & Bt.DEPTH && F.test(V) && (ni += "depth, ",
                C.readDepth = !0),
                ni += `color1);
    `;
                const j = S + "BlendOpacity";
                C.uniforms.set(j, L.opacity),
                ni += `color0 = blend${L.blendFunction}(color0, color1, ${j});

    `,
                nn += `uniform float ${j};

`
            }
            if (nn += V + `
`,
            se !== null && (ae += se + `
`),
            mt.set(en.FRAGMENT_HEAD, nn),
            mt.set(en.FRAGMENT_MAIN_UV, cn),
            mt.set(en.FRAGMENT_MAIN_IMAGE, ni),
            mt.set(en.VERTEX_HEAD, ae),
            mt.set(en.VERTEX_MAIN_SUPPORT, y),
            p.extensions !== null)
                for (const F of p.extensions)
                    C.extensions.add(F)
        }
    }
    class Hi extends Oi {
        constructor(p, ...C) {
            super("EffectPass"),
            this.fullscreenMaterial = new Pi(null,null,null,p),
            this.listener = V=>this.handleEvent(V),
            this.effects = [],
            this.setEffects(C),
            this.skipRendering = !1,
            this.minTime = 1,
            this.maxTime = Number.POSITIVE_INFINITY,
            this.timeScale = 1
        }
        set mainScene(p) {
            for (const C of this.effects)
                C.mainScene = p
        }
        set mainCamera(p) {
            this.fullscreenMaterial.copyCameraSettings(p);
            for (const C of this.effects)
                C.mainCamera = p
        }
        get encodeOutput() {
            return this.fullscreenMaterial.encodeOutput
        }
        set encodeOutput(p) {
            this.fullscreenMaterial.encodeOutput = p
        }
        get dithering() {
            return this.fullscreenMaterial.dithering
        }
        set dithering(p) {
            const C = this.fullscreenMaterial;
            C.dithering = p,
            C.needsUpdate = !0
        }
        setEffects(p) {
            for (const C of this.effects)
                C.removeEventListener("change", this.listener);
            this.effects = p.sort((C,V)=>V.attributes - C.attributes);
            for (const C of this.effects)
                C.addEventListener("change", this.listener)
        }
        updateMaterial() {
            const p = new uo;
            let C = 0;
            for (const Ce of this.effects)
                if (Ce.blendMode.blendFunction === Ze.DST)
                    p.attributes |= Ce.getAttributes() & Bt.DEPTH;
                else {
                    if (p.attributes & Ce.getAttributes() & Bt.CONVOLUTION)
                        throw new Error(`Convolution effects cannot be merged (${Ce.name})`);
                    Ao("e" + C++, Ce, p)
                }
            let V = p.shaderParts.get(en.FRAGMENT_HEAD)
              , se = p.shaderParts.get(en.FRAGMENT_MAIN_IMAGE)
              , ye = p.shaderParts.get(en.FRAGMENT_MAIN_UV);
            const ue = /\bblend\b/g;
            for (const Ce of p.blendModes.values())
                V += Ce.getShaderCode().replace(ue, `blend${Ce.blendFunction}`) + `
`;
            p.attributes & Bt.DEPTH ? (p.readDepth && (se = `float depth = readDepth(UV);

    ` + se),
            this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1,
            p.colorSpace === N && (se += `color0 = sRGBToLinear(color0);
    `),
            p.uvTransformation ? (ye = `vec2 transformedUv = vUv;
` + ye,
            p.defines.set("UV", "transformedUv")) : p.defines.set("UV", "vUv"),
            p.shaderParts.set(en.FRAGMENT_HEAD, V),
            p.shaderParts.set(en.FRAGMENT_MAIN_IMAGE, se),
            p.shaderParts.set(en.FRAGMENT_MAIN_UV, ye);
            for (const [Ce,mt] of p.shaderParts)
                mt !== null && p.shaderParts.set(Ce, mt.trim().replace(/^#/, `
#`));
            this.skipRendering = C === 0,
            this.needsSwap = !this.skipRendering,
            this.fullscreenMaterial.setShaderData(p)
        }
        recompile() {
            this.updateMaterial()
        }
        getDepthTexture() {
            return this.fullscreenMaterial.depthBuffer
        }
        setDepthTexture(p, C=R.z81) {
            this.fullscreenMaterial.depthBuffer = p,
            this.fullscreenMaterial.depthPacking = C;
            for (const V of this.effects)
                V.setDepthTexture(p, C)
        }
        render(p, C, V, se, ye) {
            for (const ue of this.effects)
                ue.update(p, C, se);
            if (!this.skipRendering || this.renderToScreen) {
                const ue = this.fullscreenMaterial;
                ue.inputBuffer = C.texture,
                ue.time += se * this.timeScale,
                p.setRenderTarget(this.renderToScreen ? null : V),
                p.render(this.scene, this.camera)
            }
        }
        setSize(p, C) {
            this.fullscreenMaterial.setSize(p, C);
            for (const V of this.effects)
                V.setSize(p, C)
        }
        initialize(p, C, V) {
            this.renderer = p;
            for (const se of this.effects)
                se.initialize(p, C, V);
            this.updateMaterial(),
            V !== void 0 && V !== R.ywz && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
        }
        dispose() {
            super.dispose();
            for (const p of this.effects)
                p.removeEventListener("change", this.listener),
                p.dispose()
        }
        handleEvent(p) {
            switch (p.type) {
            case "change":
                this.recompile();
                break
            }
        }
    }
    class Us extends Oi {
        constructor({kernelSize: p=li.MEDIUM, resolutionScale: C=.5, width: V=Ti.AUTO_SIZE, height: se=Ti.AUTO_SIZE, resolutionX: ye=V, resolutionY: ue=se}={}) {
            super("KawaseBlurPass"),
            this.renderTargetA = new R.dd2(1,1,{
                depthBuffer: !1
            }),
            this.renderTargetA.texture.name = "Blur.Target.A",
            this.renderTargetB = this.renderTargetA.clone(),
            this.renderTargetB.texture.name = "Blur.Target.B";
            const Ce = this.resolution = new Ti(this,ye,ue,C);
            Ce.addEventListener("change", mt=>this.setSize(Ce.baseWidth, Ce.baseHeight)),
            this._blurMaterial = new Ft,
            this._blurMaterial.kernelSize = p,
            this.copyMaterial = new Rt
        }
        getResolution() {
            return this.resolution
        }
        get blurMaterial() {
            return this._blurMaterial
        }
        set blurMaterial(p) {
            this._blurMaterial = p
        }
        get dithering() {
            return this.copyMaterial.dithering
        }
        set dithering(p) {
            this.copyMaterial.dithering = p
        }
        get kernelSize() {
            return this.blurMaterial.kernelSize
        }
        set kernelSize(p) {
            this.blurMaterial.kernelSize = p
        }
        get width() {
            return this.resolution.width
        }
        set width(p) {
            this.resolution.preferredWidth = p
        }
        get height() {
            return this.resolution.height
        }
        set height(p) {
            this.resolution.preferredHeight = p
        }
        get scale() {
            return this.blurMaterial.scale
        }
        set scale(p) {
            this.blurMaterial.scale = p
        }
        getScale() {
            return this.blurMaterial.scale
        }
        setScale(p) {
            this.blurMaterial.scale = p
        }
        getKernelSize() {
            return this.kernelSize
        }
        setKernelSize(p) {
            this.kernelSize = p
        }
        getResolutionScale() {
            return this.resolution.scale
        }
        setResolutionScale(p) {
            this.resolution.scale = p
        }
        render(p, C, V, se, ye) {
            const ue = this.scene
              , Ce = this.camera
              , mt = this.renderTargetA
              , nn = this.renderTargetB
              , cn = this.blurMaterial
              , ni = cn.kernelSequence;
            let ae = C;
            this.fullscreenMaterial = cn;
            for (let y = 0, b = ni.length; y < b; ++y) {
                const E = y & 1 ? nn : mt;
                cn.kernel = ni[y],
                cn.inputBuffer = ae.texture,
                p.setRenderTarget(E),
                p.render(ue, Ce),
                ae = E
            }
            this.fullscreenMaterial = this.copyMaterial,
            this.copyMaterial.inputBuffer = ae.texture,
            p.setRenderTarget(this.renderToScreen ? null : V),
            p.render(ue, Ce)
        }
        setSize(p, C) {
            const V = this.resolution;
            V.setBaseSize(p, C);
            const se = V.width
              , ye = V.height;
            this.renderTargetA.setSize(se, ye),
            this.renderTargetB.setSize(se, ye),
            this.blurMaterial.setSize(p, C)
        }
        initialize(p, C, V) {
            V !== void 0 && (this.renderTargetA.texture.type = V,
            this.renderTargetB.texture.type = V,
            V !== R.ywz ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
            this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : ct(p) === N && (et(this.renderTargetA.texture, N),
            et(this.renderTargetB.texture, N)))
        }
        static get AUTO_SIZE() {
            return Ti.AUTO_SIZE
        }
    }
    class Ba extends Oi {
        constructor({renderTarget: p, luminanceRange: C, colorOutput: V, resolutionScale: se=1, width: ye=Ti.AUTO_SIZE, height: ue=Ti.AUTO_SIZE, resolutionX: Ce=ye, resolutionY: mt=ue}={}) {
            super("LuminancePass"),
            this.fullscreenMaterial = new mi(V,C),
            this.needsSwap = !1,
            this.renderTarget = p,
            this.renderTarget === void 0 && (this.renderTarget = new R.dd2(1,1,{
                depthBuffer: !1
            }),
            this.renderTarget.texture.name = "LuminancePass.Target");
            const nn = this.resolution = new Ti(this,Ce,mt,se);
            nn.addEventListener("change", cn=>this.setSize(nn.baseWidth, nn.baseHeight))
        }
        get texture() {
            return this.renderTarget.texture
        }
        getTexture() {
            return this.renderTarget.texture
        }
        getResolution() {
            return this.resolution
        }
        render(p, C, V, se, ye) {
            const ue = this.fullscreenMaterial;
            ue.inputBuffer = C.texture,
            p.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
            p.render(this.scene, this.camera)
        }
        setSize(p, C) {
            const V = this.resolution;
            V.setBaseSize(p, C),
            this.renderTarget.setSize(V.width, V.height)
        }
        initialize(p, C, V) {
            V !== void 0 && V !== R.ywz && (this.renderTarget.texture.type = V,
            this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
        }
    }
    class Fr extends Oi {
        constructor(p, C) {
            super("MaskPass", p, C),
            this.needsSwap = !1,
            this.clearPass = new xs(!1,!1,!0),
            this.inverse = !1
        }
        set mainScene(p) {
            this.scene = p
        }
        set mainCamera(p) {
            this.camera = p
        }
        get inverted() {
            return this.inverse
        }
        set inverted(p) {
            this.inverse = p
        }
        get clear() {
            return this.clearPass.enabled
        }
        set clear(p) {
            this.clearPass.enabled = p
        }
        getClearPass() {
            return this.clearPass
        }
        isInverted() {
            return this.inverted
        }
        setInverted(p) {
            this.inverted = p
        }
        render(p, C, V, se, ye) {
            const ue = p.getContext()
              , Ce = p.state.buffers
              , mt = this.scene
              , nn = this.camera
              , cn = this.clearPass
              , ni = this.inverted ? 0 : 1
              , ae = 1 - ni;
            Ce.color.setMask(!1),
            Ce.depth.setMask(!1),
            Ce.color.setLocked(!0),
            Ce.depth.setLocked(!0),
            Ce.stencil.setTest(!0),
            Ce.stencil.setOp(ue.REPLACE, ue.REPLACE, ue.REPLACE),
            Ce.stencil.setFunc(ue.ALWAYS, ni, 4294967295),
            Ce.stencil.setClear(ae),
            Ce.stencil.setLocked(!0),
            this.clearPass.enabled && (this.renderToScreen ? cn.render(p, null) : (cn.render(p, C),
            cn.render(p, V))),
            this.renderToScreen ? (p.setRenderTarget(null),
            p.render(mt, nn)) : (p.setRenderTarget(C),
            p.render(mt, nn),
            p.setRenderTarget(V),
            p.render(mt, nn)),
            Ce.color.setLocked(!1),
            Ce.depth.setLocked(!1),
            Ce.stencil.setLocked(!1),
            Ce.stencil.setFunc(ue.EQUAL, 1, 4294967295),
            Ce.stencil.setOp(ue.KEEP, ue.KEEP, ue.KEEP),
            Ce.stencil.setLocked(!0)
        }
    }
    class Ns extends Oi {
        constructor() {
            super("MipmapBlurPass"),
            this.needsSwap = !1,
            this.renderTarget = new R.dd2(1,1,{
                depthBuffer: !1
            }),
            this.renderTarget.texture.name = "Upsampling.Mipmap0",
            this.downsamplingMipmaps = [],
            this.upsamplingMipmaps = [],
            this.downsamplingMaterial = new pt,
            this.upsamplingMaterial = new $i,
            this.resolution = new R.FM8
        }
        get texture() {
            return this.renderTarget.texture
        }
        get levels() {
            return this.downsamplingMipmaps.length
        }
        set levels(p) {
            if (this.levels !== p) {
                const C = this.renderTarget;
                this.dispose(),
                this.downsamplingMipmaps = [],
                this.upsamplingMipmaps = [];
                for (let V = 0; V < p; ++V) {
                    const se = C.clone();
                    se.texture.name = "Downsampling.Mipmap" + V,
                    this.downsamplingMipmaps.push(se)
                }
                this.upsamplingMipmaps.push(C);
                for (let V = 1, se = p - 1; V < se; ++V) {
                    const ye = C.clone();
                    ye.texture.name = "Upsampling.Mipmap" + V,
                    this.upsamplingMipmaps.push(ye)
                }
                this.setSize(this.resolution.x, this.resolution.y)
            }
        }
        get radius() {
            return this.upsamplingMaterial.radius
        }
        set radius(p) {
            this.upsamplingMaterial.radius = p
        }
        render(p, C, V, se, ye) {
            const {scene: ue, camera: Ce} = this
              , {downsamplingMaterial: mt, upsamplingMaterial: nn} = this
              , {downsamplingMipmaps: cn, upsamplingMipmaps: ni} = this;
            let ae = C;
            this.fullscreenMaterial = mt;
            for (let y = 0, b = cn.length; y < b; ++y) {
                const E = cn[y];
                mt.setSize(ae.width, ae.height),
                mt.inputBuffer = ae.texture,
                p.setRenderTarget(E),
                p.render(ue, Ce),
                ae = E
            }
            this.fullscreenMaterial = nn;
            for (let y = ni.length - 1; y >= 0; --y) {
                const b = ni[y];
                nn.setSize(ae.width, ae.height),
                nn.inputBuffer = ae.texture,
                nn.supportBuffer = cn[y].texture,
                p.setRenderTarget(b),
                p.render(ue, Ce),
                ae = b
            }
        }
        setSize(p, C) {
            const V = this.resolution;
            V.set(p, C);
            let se = V.width
              , ye = V.height;
            for (let ue = 0, Ce = this.downsamplingMipmaps.length; ue < Ce; ++ue)
                se = Math.round(se * .5),
                ye = Math.round(ye * .5),
                this.downsamplingMipmaps[ue].setSize(se, ye),
                ue < this.upsamplingMipmaps.length && this.upsamplingMipmaps[ue].setSize(se, ye)
        }
        initialize(p, C, V) {
            if (V !== void 0) {
                const se = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
                for (const ye of se)
                    ye.texture.type = V;
                if (V !== R.ywz)
                    this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
                    this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
                else if (ct(p) === N)
                    for (const ye of se)
                        et(ye.texture, N)
            }
        }
        dispose() {
            super.dispose();
            for (const p of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))
                p.dispose()
        }
    }
    class bs extends Oi {
        constructor(p, C="inputBuffer") {
            super("ShaderPass"),
            this.fullscreenMaterial = p,
            this.input = C
        }
        setInput(p) {
            this.input = p
        }
        render(p, C, V, se, ye) {
            const ue = this.fullscreenMaterial.uniforms;
            C !== null && ue !== void 0 && ue[this.input] !== void 0 && (ue[this.input].value = C.texture),
            p.setRenderTarget(this.renderToScreen ? null : V),
            p.render(this.scene, this.camera)
        }
        initialize(p, C, V) {
            V !== void 0 && V !== R.ywz && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
        }
    }
    const jo = 1 / 1e3
      , us = 1e3;
    class ha {
        constructor() {
            this.startTime = performance.now(),
            this.previousTime = 0,
            this.currentTime = 0,
            this._delta = 0,
            this._elapsed = 0,
            this._fixedDelta = 1e3 / 60,
            this.timescale = 1,
            this.useFixedDelta = !1,
            this._autoReset = !1
        }
        get autoReset() {
            return this._autoReset
        }
        set autoReset(p) {
            typeof document < "u" && document.hidden !== void 0 && (p ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this),
            this._autoReset = p)
        }
        get delta() {
            return this._delta * jo
        }
        get fixedDelta() {
            return this._fixedDelta * jo
        }
        set fixedDelta(p) {
            this._fixedDelta = p * us
        }
        get elapsed() {
            return this._elapsed * jo
        }
        update(p) {
            this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime,
            this.currentTime = (p !== void 0 ? p : performance.now()) - this.startTime,
            this._delta = this.currentTime - this.previousTime),
            this._delta *= this.timescale,
            this._elapsed += this._delta
        }
        reset() {
            this._delta = 0,
            this._elapsed = 0,
            this.currentTime = performance.now() - this.startTime
        }
        handleEvent(p) {
            document.hidden || (this.currentTime = performance.now() - this.startTime)
        }
        dispose() {
            this.autoReset = !1
        }
    }
    class da {
        constructor(p=null, {depthBuffer: C=!0, stencilBuffer: V=!1, multisampling: se=0, frameBufferType: ye}={}) {
            this.renderer = null,
            this.inputBuffer = this.createBuffer(C, V, ye, se),
            this.outputBuffer = this.inputBuffer.clone(),
            this.copyPass = new ts,
            this.depthTexture = null,
            this.passes = [],
            this.timer = new ha,
            this.autoRenderToScreen = !0,
            this.setRenderer(p);

            window.effectComposer = this;
        }
        get multisampling() {
            return this.inputBuffer.samples || 0
        }
        set multisampling(p) {
            const C = this.inputBuffer
              , V = this.multisampling;
            V > 0 && p > 0 ? (this.inputBuffer.samples = p,
            this.outputBuffer.samples = p,
            this.inputBuffer.dispose(),
            this.outputBuffer.dispose()) : V !== p && (this.inputBuffer.dispose(),
            this.outputBuffer.dispose(),
            this.inputBuffer = this.createBuffer(C.depthBuffer, C.stencilBuffer, C.texture.type, p),
            this.inputBuffer.depthTexture = this.depthTexture,
            this.outputBuffer = this.inputBuffer.clone())
        }
        getTimer() {
            return this.timer
        }
        getRenderer() {
            return this.renderer
        }
        setRenderer(p) {
            if (this.renderer = p,
            p !== null) {
                const C = p.getSize(new R.FM8)
                  , V = p.getContext().getContextAttributes().alpha
                  , se = this.inputBuffer.texture.type;
                se === R.ywz && ct(p) === N && (et(this.inputBuffer.texture, N),
                et(this.outputBuffer.texture, N),
                this.inputBuffer.dispose(),
                this.outputBuffer.dispose()),
                p.autoClear = !1,
                this.setSize(C.width, C.height);
                for (const ye of this.passes)
                    ye.initialize(p, V, se)
            }
        }
        replaceRenderer(p, C=!0) {
            const V = this.renderer
              , se = V.domElement.parentNode;
            return this.setRenderer(p),
            C && se !== null && (se.removeChild(V.domElement),
            se.appendChild(p.domElement)),
            V
        }
        createDepthTexture() {
            const p = this.depthTexture = new R.$YQ;
            return this.inputBuffer.depthTexture = p,
            this.inputBuffer.dispose(),
            this.inputBuffer.stencilBuffer ? (p.format = R.brP,
            p.type = R.wJv) : p.type = R.JQ4,
            p
        }
        deleteDepthTexture() {
            if (this.depthTexture !== null) {
                this.depthTexture.dispose(),
                this.depthTexture = null,
                this.inputBuffer.depthTexture = null,
                this.inputBuffer.dispose();
                for (const p of this.passes)
                    p.setDepthTexture(null)
            }
        }
        createBuffer(p, C, V, se) {
            const ye = this.renderer
              , ue = ye === null ? new R.FM8 : ye.getDrawingBufferSize(new R.FM8)
              , Ce = {
                minFilter: R.wem,
                magFilter: R.wem,
                stencilBuffer: C,
                depthBuffer: p,
                type: V
            }
              , mt = new R.dd2(ue.width,ue.height,Ce);
            return se > 0 && (mt.ignoreDepthForMultisampleCopy = !1,
            mt.samples = se),
            V === R.ywz && ct(ye) === N && et(mt.texture, N),
            mt.texture.name = "EffectComposer.Buffer",
            mt.texture.generateMipmaps = !1,
            mt
        }
        setMainScene(p) {
            for (const C of this.passes)
                C.mainScene = p
        }
        setMainCamera(p) {
            for (const C of this.passes)
                C.mainCamera = p
        }
        addPass(p, C) {
            const V = this.passes
              , se = this.renderer
              , ye = se.getDrawingBufferSize(new R.FM8)
              , ue = se.getContext().getContextAttributes().alpha
              , Ce = this.inputBuffer.texture.type;
            if (p.setRenderer(se),
            p.setSize(ye.width, ye.height),
            p.initialize(se, ue, Ce),
            this.autoRenderToScreen && (V.length > 0 && (V[V.length - 1].renderToScreen = !1),
            p.renderToScreen && (this.autoRenderToScreen = !1)),
            C !== void 0 ? V.splice(C, 0, p) : V.push(p),
            this.autoRenderToScreen && (V[V.length - 1].renderToScreen = !0),
            p.needsDepthTexture || this.depthTexture !== null)
                if (this.depthTexture === null) {
                    const mt = this.createDepthTexture();
                    for (p of V)
                        p.setDepthTexture(mt)
                } else
                    p.setDepthTexture(this.depthTexture)
        }
        removePass(p) {
            const C = this.passes
              , V = C.indexOf(p);
            if (V !== -1 && C.splice(V, 1).length > 0) {
                if (this.depthTexture !== null) {
                    const ue = (mt,nn)=>mt || nn.needsDepthTexture;
                    C.reduce(ue, !1) || (p.getDepthTexture() === this.depthTexture && p.setDepthTexture(null),
                    this.deleteDepthTexture())
                }
                this.autoRenderToScreen && V === C.length && (p.renderToScreen = !1,
                C.length > 0 && (C[C.length - 1].renderToScreen = !0))
            }
        }
        removeAllPasses() {
            const p = this.passes;
            this.deleteDepthTexture(),
            p.length > 0 && (this.autoRenderToScreen && (p[p.length - 1].renderToScreen = !1),
            this.passes = [])
        }
        render(p) {
            const C = this.renderer
              , V = this.copyPass;
            let se = this.inputBuffer, ye = this.outputBuffer, ue = !1, Ce, mt, nn;
            p === void 0 && (this.timer.update(),
            p = this.timer.delta);
            let cn = null;
            for (let ni = this.passes.length; ni--; )
                if (this.passes[ni].enabled) {
                    cn = this.passes[ni];
                    break
                }
            for (const ni of this.passes)
                ni.enabled && (this.autoRenderToScreen && (ni.renderToScreen = ni === cn),
                ni.render(C, se, ye, p, ue),
                ni.needsSwap && (ue && (V.renderToScreen = ni.renderToScreen,
                Ce = C.getContext(),
                mt = C.state.buffers.stencil,
                mt.setFunc(Ce.NOTEQUAL, 1, 4294967295),
                V.render(C, se, ye, p, ue),
                mt.setFunc(Ce.EQUAL, 1, 4294967295)),
                nn = se,
                se = ye,
                ye = nn),
                ni instanceof Fr ? ue = !0 : ni instanceof Gr && (ue = !1))
        }
        setSize(p, C, V) {
            const se = this.renderer
              , ye = se.getSize(new R.FM8);
            (p === void 0 || C === void 0) && (p = ye.width,
            C = ye.height),
            (ye.width !== p || ye.height !== C) && se.setSize(p, C, V);
            const ue = se.getDrawingBufferSize(new R.FM8);
            this.inputBuffer.setSize(ue.width, ue.height),
            this.outputBuffer.setSize(ue.width, ue.height);
            for (const Ce of this.passes)
                Ce.setSize(ue.width, ue.height)
        }
        reset() {
            const p = this.timer.autoReset;
            this.dispose(),
            this.autoRenderToScreen = !0,
            this.timer.autoReset = p
        }
        dispose() {
            for (const p of this.passes)
                p.dispose();
            this.passes = [],
            this.inputBuffer !== null && this.inputBuffer.dispose(),
            this.outputBuffer !== null && this.outputBuffer.dispose(),
            this.deleteDepthTexture(),
            this.copyPass.dispose(),
            this.timer.dispose()
        }
    }
    class uo {
        constructor() {
            this.shaderParts = new Map([[en.FRAGMENT_HEAD, null], [en.FRAGMENT_MAIN_UV, null], [en.FRAGMENT_MAIN_IMAGE, null], [en.VERTEX_HEAD, null], [en.VERTEX_MAIN_SUPPORT, null]]),
            this.defines = new Map,
            this.uniforms = new Map,
            this.blendModes = new Map,
            this.extensions = new Set,
            this.attributes = Bt.NONE,
            this.varyings = new Set,
            this.uvTransformation = !1,
            this.readDepth = !1,
            this.colorSpace = ie
        }
    }
    const Js = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, x + y, opacity);

}
`
      , So = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, y, min(y.a, opacity));

}
`
      , Fa = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, (x + y) * 0.5, opacity);

}
`
      , Wl = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec3 xHSL = RGBToHSL(x.rgb);
    vec3 yHSL = RGBToHSL(y.rgb);
    vec3 z = HSLToRGB(vec3(yHSL.rg, xHSL.b));
    return vec4(mix(x.rgb, z, opacity), y.a);

}
`
      , ti = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec4 z = mix(step(0.0, y) * (1.0 - min(vec4(1.0), (1.0 - x) / y)), vec4(1.0), step(1.0, x));
    return mix(x, z, opacity);

}
`
      , jl = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec4 z = step(0.0, x) * mix(min(vec4(1.0), x / max(1.0 - y, 1e-9)), vec4(1.0), step(1.0, y));
    return mix(x, z, opacity);

}
`
      , Xr = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, min(x, y), opacity);

}
`
      , ol = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, abs(x - y), opacity);

}
`
      , al = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, x / max(y, 1e-12), opacity);

}
`
      , $s = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, (x + y - 2.0 * x * y), opacity);

}
`
      , ho = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec4 a = min(x, 1.0), b = min(y, 1.0);
    vec4 z = mix(2.0 * a * b, 1.0 - 2.0 * (1.0 - a) * (1.0 - b), step(0.5, y));
    return mix(x, z, opacity);

}
`
      , Xl = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, step(1.0, x + y), opacity);

}
`
      , ll = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec3 xHSL = RGBToHSL(x.rgb);
    vec3 yHSL = RGBToHSL(y.rgb);
    vec3 z = HSLToRGB(vec3(yHSL.r, xHSL.gb));
    return vec4(mix(x.rgb, z, opacity), y.a);

}
`
      , cl = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, 1.0 - y, opacity);

}
`
      , fa = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, y * (1.0 - x), opacity);

}
`
      , ul = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, max(x, y), opacity);

}
`
      , ka = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, clamp(y + x - 1.0, 0.0, 1.0), opacity);

}
`
      , Ua = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, min(x + y, 1.0), opacity);

}
`
      , Na = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, clamp(2.0 * y + x - 1.0, 0.0, 1.0), opacity);

}
`
      , pa = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec3 xHSL = RGBToHSL(x.rgb);
    vec3 yHSL = RGBToHSL(y.rgb);
    vec3 z = HSLToRGB(vec3(xHSL.rg, yHSL.b));
    return vec4(mix(x.rgb, z, opacity), y.a);

}
`
      , hl = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, x * y, opacity);

}
`
      , za = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, 1.0 - abs(1.0 - x - y), opacity);

}
`
      , ma = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, y, opacity);

}
`
      , nr = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec4 z = mix(2.0 * y * x, 1.0 - 2.0 * (1.0 - y) * (1.0 - x), step(0.5, x));
    return mix(x, z, opacity);

}
`
      , fo = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec4 y2 = 2.0 * y;

    vec4 z = mix(
        mix(y2, x, step(0.5 * x, y)),
        max(vec4(0.0), y2 - 1.0),
        step(x, (y2 - 1.0))
    );

    return mix(x, z, opacity);

}
`
      , Ga = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec4 z = mix(min(x * x / max(1.0 - y, 1e-12), 1.0), y, step(1.0, y));
    return mix(x, z, opacity);

}
`
      , dl = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec3 xHSL = RGBToHSL(x.rgb);
    vec3 yHSL = RGBToHSL(y.rgb);
    vec3 z = HSLToRGB(vec3(xHSL.r, yHSL.g, xHSL.b));
    return vec4(mix(x.rgb, z, opacity), y.a);

}
`
      , fl = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, x + y - min(x * y, 1.0), opacity);

}
`
      , pl = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec4 y2 = 2.0 * y;
    vec4 w = step(0.5, y);

    vec4 z = mix(
        x - (1.0 - y2) * x * (1.0 - x),
        mix(
            x + (y2 - 1.0) * (sqrt(x) - x),
            x + (y2 - 1.0) * x * ((16.0 * x - 12.0) * x + 3.0),
            w * (1.0 - step(0.25, x))
        ),
        w
    );

    return mix(x, z, opacity);

}
`
      , ga = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return y;

}
`
      , Ha = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    return mix(x, max(x + y - 1.0, 0.0), opacity);

}
`
      , To = `vec4 blend(const in vec4 x, const in vec4 y, const in float opacity) {

    vec4 z = mix(
        max(1.0 - min((1.0 - x) / (2.0 * y), 1.0), 0.0),
        min(x / (2.0 * (1.0 - y)), 1.0),
        step(0.5, y)
    );

    return mix(x, z, opacity);

}
`
      , Eo = new Map([[Ze.ADD, Js], [Ze.ALPHA, So], [Ze.AVERAGE, Fa], [Ze.COLOR, Wl], [Ze.COLOR_BURN, ti], [Ze.COLOR_DODGE, jl], [Ze.DARKEN, Xr], [Ze.DIFFERENCE, ol], [Ze.DIVIDE, al], [Ze.DST, null], [Ze.EXCLUSION, $s], [Ze.HARD_LIGHT, ho], [Ze.HARD_MIX, Xl], [Ze.HUE, ll], [Ze.INVERT, cl], [Ze.INVERT_RGB, fa], [Ze.LIGHTEN, ul], [Ze.LINEAR_BURN, ka], [Ze.LINEAR_DODGE, Ua], [Ze.LINEAR_LIGHT, Na], [Ze.LUMINOSITY, pa], [Ze.MULTIPLY, hl], [Ze.NEGATION, za], [Ze.NORMAL, ma], [Ze.OVERLAY, nr], [Ze.PIN_LIGHT, fo], [Ze.REFLECT, Ga], [Ze.SATURATION, dl], [Ze.SCREEN, fl], [Ze.SOFT_LIGHT, pl], [Ze.SRC, ga], [Ze.SUBTRACT, Ha], [Ze.VIVID_LIGHT, To]]);
    class Yr extends R.pBf {
        constructor(p, C=1) {
            super(),
            this._blendFunction = p,
            this.opacity = new R.xWb(C)
        }
        getOpacity() {
            return this.opacity.value
        }
        setOpacity(p) {
            this.opacity.value = p
        }
        get blendFunction() {
            return this._blendFunction
        }
        set blendFunction(p) {
            this._blendFunction = p,
            this.dispatchEvent({
                type: "change"
            })
        }
        getBlendFunction() {
            return this.blendFunction
        }
        setBlendFunction(p) {
            this.blendFunction = p
        }
        getShaderCode() {
            return Eo.get(this.blendFunction)
        }
    }
    class Qr extends R.pBf {
        constructor(p, C, {attributes: V=Bt.NONE, blendFunction: se=Ze.NORMAL, defines: ye=new Map, uniforms: ue=new Map, extensions: Ce=null, vertexShader: mt=null}={}) {
            super(),
            this.name = p,
            this.renderer = null,
            this.attributes = V,
            this.fragmentShader = C,
            this.vertexShader = mt,
            this.defines = ye,
            this.uniforms = ue,
            this.extensions = Ce,
            this.blendMode = new Yr(se),
            this.blendMode.addEventListener("change", nn=>this.setChanged()),
            this._inputColorSpace = ie,
            this._outputColorSpace = q
        }
        get inputColorSpace() {
            return this._inputColorSpace
        }
        set inputColorSpace(p) {
            this._inputColorSpace = p,
            this.setChanged()
        }
        get outputColorSpace() {
            return this._outputColorSpace
        }
        set outputColorSpace(p) {
            this._outputColorSpace = p,
            this.setChanged()
        }
        set mainScene(p) {}
        set mainCamera(p) {}
        getName() {
            return this.name
        }
        setRenderer(p) {
            this.renderer = p
        }
        getDefines() {
            return this.defines
        }
        getUniforms() {
            return this.uniforms
        }
        getExtensions() {
            return this.extensions
        }
        getBlendMode() {
            return this.blendMode
        }
        getAttributes() {
            return this.attributes
        }
        setAttributes(p) {
            this.attributes = p,
            this.setChanged()
        }
        getFragmentShader() {
            return this.fragmentShader
        }
        setFragmentShader(p) {
            this.fragmentShader = p,
            this.setChanged()
        }
        getVertexShader() {
            return this.vertexShader
        }
        setVertexShader(p) {
            this.vertexShader = p,
            this.setChanged()
        }
        setChanged() {
            this.dispatchEvent({
                type: "change"
            })
        }
        setDepthTexture(p, C=R.z81) {}
        update(p, C, V) {}
        setSize(p, C) {}
        initialize(p, C, V) {}
        dispose() {
            for (const p of Object.keys(this)) {
                const C = this[p];
                (C instanceof R.dd2 || C instanceof R.F5T || C instanceof R.xEZ || C instanceof Oi) && this[p].dispose()
            }
        }
    }
    const va = `#ifdef FRAMEBUFFER_PRECISION_HIGH

    uniform mediump sampler2D map;

#else

    uniform lowp sampler2D map;

#endif

uniform float intensity;

void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {

    outputColor = texture2D(map, uv) * intensity;

}
`;
    class po extends Qr {
        constructor({blendFunction: p=Ze.SCREEN, luminanceThreshold: C=.9, luminanceSmoothing: V=.025, mipmapBlur: se=!1, intensity: ye=1, radius: ue=.85, levels: Ce=8, kernelSize: mt=li.LARGE, resolutionScale: nn=.5, width: cn=Ti.AUTO_SIZE, height: ni=Ti.AUTO_SIZE, resolutionX: ae=cn, resolutionY: y=ni}={}) {
            super("BloomEffect", va, {
                blendFunction: p,
                uniforms: new Map([["map", new R.xWb(null)], ["intensity", new R.xWb(ye)]])
            }),
            this.renderTarget = new R.dd2(1,1,{
                depthBuffer: !1
            }),
            this.renderTarget.texture.name = "Bloom.Target",
            this.blurPass = new Us({
                kernelSize: mt
            }),
            this.luminancePass = new Ba({
                colorOutput: !0
            }),
            this.luminanceMaterial.threshold = C,
            this.luminanceMaterial.smoothing = V,
            this.mipmapBlurPass = new Ns,
            this.mipmapBlurPass.enabled = se,
            this.mipmapBlurPass.radius = ue,
            this.mipmapBlurPass.levels = Ce,
            this.uniforms.get("map").value = se ? this.mipmapBlurPass.texture : this.renderTarget.texture;
            const b = this.resolution = new Ti(this,ae,y,nn);
            b.addEventListener("change", E=>this.setSize(b.baseWidth, b.baseHeight))
        }
        get texture() {
            return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture
        }
        getTexture() {
            return this.texture
        }
        getResolution() {
            return this.resolution
        }
        getBlurPass() {
            return this.blurPass
        }
        getLuminancePass() {
            return this.luminancePass
        }
        get luminanceMaterial() {
            return this.luminancePass.fullscreenMaterial
        }
        getLuminanceMaterial() {
            return this.luminancePass.fullscreenMaterial
        }
        get width() {
            return this.resolution.width
        }
        set width(p) {
            this.resolution.preferredWidth = p
        }
        get height() {
            return this.resolution.height
        }
        set height(p) {
            this.resolution.preferredHeight = p
        }
        get dithering() {
            return this.blurPass.dithering
        }
        set dithering(p) {
            this.blurPass.dithering = p
        }
        get kernelSize() {
            return this.blurPass.kernelSize
        }
        set kernelSize(p) {
            this.blurPass.kernelSize = p
        }
        get distinction() {
            return console.warn(this.name, "distinction was removed"),
            1
        }
        set distinction(p) {
            console.warn(this.name, "distinction was removed")
        }
        get intensity() {
            return this.uniforms.get("intensity").value
        }
        set intensity(p) {
            this.uniforms.get("intensity").value = p
        }
        getIntensity() {
            return this.intensity
        }
        setIntensity(p) {
            this.intensity = p
        }
        getResolutionScale() {
            return this.resolution.scale
        }
        setResolutionScale(p) {
            this.resolution.scale = p
        }
        update(p, C, V) {
            const se = this.renderTarget
              , ye = this.luminancePass;
            ye.enabled ? (ye.render(p, C),
            this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(p, ye.renderTarget) : this.blurPass.render(p, ye.renderTarget, se)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(p, C) : this.blurPass.render(p, C, se)
        }
        setSize(p, C) {
            const V = this.resolution;
            V.setBaseSize(p, C),
            this.renderTarget.setSize(V.width, V.height),
            this.blurPass.resolution.copy(V),
            this.luminancePass.setSize(p, C),
            this.mipmapBlurPass.setSize(p, C)
        }
        initialize(p, C, V) {
            this.blurPass.initialize(p, C, V),
            this.luminancePass.initialize(p, C, V),
            this.mipmapBlurPass.initialize(p, C, V),
            V !== void 0 && (this.renderTarget.texture.type = V,
            ct(p) === N && et(this.renderTarget.texture, N))
        }
    }
    new R.Pa4,
    new R.yGw,
    new R.Ilk,
    new R.Pa4,
    new R.Pa4;
    const Mo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC"
      , Xo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC"
      , zs = `uniform sampler2D weightMap;

varying vec2 vOffset0;
varying vec2 vOffset1;

/**
 * Moves values to a target vector based on a given conditional vector.
 */

void movec(const in bvec2 c, inout vec2 variable, const in vec2 value) {

    if(c.x) { variable.x = value.x; }
    if(c.y) { variable.y = value.y; }

}

void movec(const in bvec4 c, inout vec4 variable, const in vec4 value) {

    movec(c.xy, variable.xy, value.xy);
    movec(c.zw, variable.zw, value.zw);

}

void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {

    // Fetch the blending weights for the current pixel.
    vec4 a;
    a.x = texture2D(weightMap, vOffset0).a;
    a.y = texture2D(weightMap, vOffset1).g;
    a.wz = texture2D(weightMap, uv).rb;

    vec4 color = inputColor;

    // Ignore tiny blending weights.
    if(dot(a, vec4(1.0)) >= 1e-5) {

        // max(horizontal) > max(vertical)
        bool h = max(a.x, a.z) > max(a.y, a.w);

        // Calculate the blending offsets.
        vec4 blendingOffset = vec4(0.0, a.y, 0.0, a.w);
        vec2 blendingWeight = a.yw;
        movec(bvec4(h), blendingOffset, vec4(a.x, 0.0, a.z, 0.0));
        movec(bvec2(h), blendingWeight, a.xz);
        blendingWeight /= dot(blendingWeight, vec2(1.0));

        // Calculate the texture coordinates.
        vec4 blendingCoord = blendingOffset * vec4(texelSize, -texelSize) + uv.xyxy;

        // Rely on bilinear filtering to mix the current pixel with the neighbor.
        color = blendingWeight.x * texture2D(inputBuffer, blendingCoord.xy);
        color += blendingWeight.y * texture2D(inputBuffer, blendingCoord.zw);

    }

    outputColor = color;

}
`
      , _a = `varying vec2 vOffset0;
varying vec2 vOffset1;

void mainSupport(const in vec2 uv) {

    vOffset0 = uv + texelSize * vec2(1.0, 0.0);
    vOffset1 = uv + texelSize * vec2(0.0, 1.0);

}
`;
    class Co extends Qr {
        constructor({blendFunction: p=Ze.SRC, preset: C=xi.MEDIUM, edgeDetectionMode: V=Nt.COLOR, predicationMode: se=di.DISABLED}={}) {
            super("SMAAEffect", zs, {
                vertexShader: _a,
                blendFunction: p,
                attributes: Bt.CONVOLUTION | Bt.DEPTH,
                uniforms: new Map([["weightMap", new R.xWb(null)]])
            });
            let ye, ue;
            arguments.length > 1 && (ye = arguments[0],
            ue = arguments[1],
            arguments.length > 2 && (C = arguments[2]),
            arguments.length > 3 && (V = arguments[3])),
            this.renderTargetEdges = new R.dd2(1,1,{
                depthBuffer: !1
            }),
            this.renderTargetEdges.texture.name = "SMAA.Edges",
            this.renderTargetWeights = this.renderTargetEdges.clone(),
            this.renderTargetWeights.texture.name = "SMAA.Weights",
            this.uniforms.get("weightMap").value = this.renderTargetWeights.texture,
            this.clearPass = new xs(!0,!1,!1),
            this.clearPass.overrideClearColor = new R.Ilk(0),
            this.clearPass.overrideClearAlpha = 1,
            this.edgeDetectionPass = new bs(new wt),
            this.edgeDetectionMaterial.edgeDetectionMode = V,
            this.edgeDetectionMaterial.predicationMode = se,
            this.weightsPass = new bs(new On);
            const Ce = new R.lLk;
            Ce.onLoad = ()=>{
                const mt = new R.xEZ(ye);
                mt.name = "SMAA.Search",
                mt.magFilter = R.TyD,
                mt.minFilter = R.TyD,
                mt.generateMipmaps = !1,
                mt.needsUpdate = !0,
                mt.flipY = !0,
                this.weightsMaterial.searchTexture = mt;
                const nn = new R.xEZ(ue);
                nn.name = "SMAA.Area",
                nn.magFilter = R.wem,
                nn.minFilter = R.wem,
                nn.generateMipmaps = !1,
                nn.needsUpdate = !0,
                nn.flipY = !1,
                this.weightsMaterial.areaTexture = nn,
                this.dispatchEvent({
                    type: "load"
                })
            }
            ,
            Ce.itemStart("search"),
            Ce.itemStart("area"),
            ye !== void 0 && ue !== void 0 ? (Ce.itemEnd("search"),
            Ce.itemEnd("area")) : typeof Image < "u" && (ye = new Image,
            ue = new Image,
            ye.addEventListener("load", ()=>Ce.itemEnd("search")),
            ue.addEventListener("load", ()=>Ce.itemEnd("area")),
            ye.src = Mo,
            ue.src = Xo),
            this.applyPreset(C)
        }
        get edgesTexture() {
            return this.renderTargetEdges.texture
        }
        getEdgesTexture() {
            return this.edgesTexture
        }
        get weightsTexture() {
            return this.renderTargetWeights.texture
        }
        getWeightsTexture() {
            return this.weightsTexture
        }
        get edgeDetectionMaterial() {
            return this.edgeDetectionPass.fullscreenMaterial
        }
        get colorEdgesMaterial() {
            return this.edgeDetectionMaterial
        }
        getEdgeDetectionMaterial() {
            return this.edgeDetectionMaterial
        }
        get weightsMaterial() {
            return this.weightsPass.fullscreenMaterial
        }
        getWeightsMaterial() {
            return this.weightsMaterial
        }
        setEdgeDetectionThreshold(p) {
            this.edgeDetectionMaterial.edgeDetectionThreshold = p
        }
        setOrthogonalSearchSteps(p) {
            this.weightsMaterial.orthogonalSearchSteps = p
        }
        applyPreset(p) {
            const C = this.edgeDetectionMaterial
              , V = this.weightsMaterial;
            switch (p) {
            case xi.LOW:
                C.edgeDetectionThreshold = .15,
                V.orthogonalSearchSteps = 4,
                V.diagonalDetection = !1,
                V.cornerDetection = !1;
                break;
            case xi.MEDIUM:
                C.edgeDetectionThreshold = .1,
                V.orthogonalSearchSteps = 8,
                V.diagonalDetection = !1,
                V.cornerDetection = !1;
                break;
            case xi.HIGH:
                C.edgeDetectionThreshold = .1,
                V.orthogonalSearchSteps = 16,
                V.diagonalSearchSteps = 8,
                V.cornerRounding = 25,
                V.diagonalDetection = !0,
                V.cornerDetection = !0;
                break;
            case xi.ULTRA:
                C.edgeDetectionThreshold = .05,
                V.orthogonalSearchSteps = 32,
                V.diagonalSearchSteps = 16,
                V.cornerRounding = 25,
                V.diagonalDetection = !0,
                V.cornerDetection = !0;
                break
            }
        }
        setDepthTexture(p, C=R.z81) {
            this.edgeDetectionMaterial.depthBuffer = p,
            this.edgeDetectionMaterial.depthPacking = C
        }
        update(p, C, V) {
            this.clearPass.render(p, this.renderTargetEdges),
            this.edgeDetectionPass.render(p, C, this.renderTargetEdges),
            this.weightsPass.render(p, this.renderTargetEdges, this.renderTargetWeights)
        }
        setSize(p, C) {
            this.edgeDetectionMaterial.setSize(p, C),
            this.weightsMaterial.setSize(p, C),
            this.renderTargetEdges.setSize(p, C),
            this.renderTargetWeights.setSize(p, C)
        }
        dispose() {
            const {searchTexture: p, areaTexture: C} = this.weightsMaterial;
            p !== null && C !== null && (p.dispose(),
            C.dispose()),
            super.dispose()
        }
        static get searchImageDataURL() {
            return Mo
        }
        static get areaImageDataURL() {
            return Xo
        }
    }
    class Va extends ne.S {
        constructor(C) {
            super();
            B(this, "_composer", null);
            this.onLoad = ()=>{
                this._composer = new da(this.viewer.renderer,Object.assign({
                    frameBufferType: R.cLu
                }, C)),
                this._composer.addPass(new ks(this.viewer.scene,this.viewer.camera)),
                this.viewer.resizeCallback = (V,se)=>this._composer.setSize(V, se),
                this.viewer.renderCallback = V=>this._composer.render(V)
            }
        }
        onDestroy() {
            this._composer && this._composer.dispose()
        }
        addPass(C) {
            this._composer && this._composer.addPass(C)
        }
        removePass(C) {
            this._composer && this._composer.removePass(C)
        }
    }
    var eo = function(S, p, C, V) {
        var se = arguments.length, ye = se < 3 ? p : V === null ? V = Object.getOwnPropertyDescriptor(p, C) : V, ue;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            ye = Reflect.decorate(S, p, C, V);
        else
            for (var Ce = S.length - 1; Ce >= 0; Ce--)
                (ue = S[Ce]) && (ye = (se < 3 ? ue(ye) : se > 3 ? ue(p, C, ye) : ue(p, C)) || ye);
        return se > 3 && ye && Object.defineProperty(p, C, ye),
        ye
    };
    let ns = class extends ne.S {
        constructor() {
            super(...arguments);
            B(this, "_effectPass", null);
            B(this, "_effects", []);
            B(this, "_needsUpdate", !1);
            B(this, "_postprocessing")
        }
        onInit() {
            this._postprocessing = this.viewer.getPlugin(Va)
        }
        addEffect(C) {
            this._effects.push(C),
            this._needsUpdate = !0
        }
        removeEffect(C) {
            this._effects.remove(C),
            this._needsUpdate = !0
        }
        update(C) {
            this._needsUpdate && (this._needsUpdate = !1,
            this._effectPass && (this._postprocessing.removePass(this._effectPass),
            this._effectPass = null),
            this._effectPass === null && (this._effectPass = new Hi(this.viewer.camera,...this._effects),
            this._postprocessing.addPass(this._effectPass)))
        }
    }
    ;
    ns = eo([(0,
    $.HO)(Va)], ns);
    var Po = function(S, p, C, V) {
        var se = arguments.length, ye = se < 3 ? p : V === null ? V = Object.getOwnPropertyDescriptor(p, C) : V, ue;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            ye = Reflect.decorate(S, p, C, V);
        else
            for (var Ce = S.length - 1; Ce >= 0; Ce--)
                (ue = S[Ce]) && (ye = (se < 3 ? ue(ye) : se > 3 ? ue(p, C, ye) : ue(p, C)) || ye);
        return se > 3 && ye && Object.defineProperty(p, C, ye),
        ye
    };
    let ya = class extends ne.S {
        constructor() {
            super(...arguments);
            B(this, "effect");
            B(this, "isEffectPlugin", !0);
            B(this, "_manager")
        }
        onEnable() {
            var C;
            (C = this._manager) == null || C.addEffect(this.effect)
        }
        onDisable() {
            var C;
            (C = this._manager) == null || C.removeEffect(this.effect)
        }
        onInit() {
            this._manager = this.viewer.getPlugin(ns)
        }
    }
    ;
    ya = Po([(0,
    $.HO)(ns)], ya);
    var Yo = function(S, p, C, V) {
        var se = arguments.length, ye = se < 3 ? p : V === null ? V = Object.getOwnPropertyDescriptor(p, C) : V, ue;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            ye = Reflect.decorate(S, p, C, V);
        else
            for (var Ce = S.length - 1; Ce >= 0; Ce--)
                (ue = S[Ce]) && (ye = (se < 3 ? ue(ye) : se > 3 ? ue(p, C, ye) : ue(p, C)) || ye);
        return se > 3 && ye && Object.defineProperty(p, C, ye),
        ye
    };
    let mo = class extends ya {
        constructor(p) {
            super(),
            this.effect = new po({
                blendFunction: Ze.ADD,
                ...p
            })
        }
        get intensity() {
            return this.effect.intensity
        }
        set intensity(p) {
            this.effect.intensity = p
        }
        get luminanceThreshold() {
            return this.effect.luminanceMaterial.threshold
        }
        set luminanceThreshold(p) {
            this.effect.luminanceMaterial.threshold = p
        }
        get luminanceSmoothing() {
            return this.effect.luminanceMaterial.smoothing
        }
        set luminanceSmoothing(p) {
            this.effect.luminanceMaterial.smoothing = p
        }
    }
    ;
    Yo([(0,
    $.Cb)({
        min: 0,
        max: 1,
        step: .01
    })], mo.prototype, "intensity", null),
    Yo([(0,
    $.Cb)({
        min: 0,
        max: 10,
        step: .01
    })], mo.prototype, "luminanceThreshold", null),
    Yo([(0,
    $.Cb)({
        min: 0,
        max: 10,
        step: .01
    })], mo.prototype, "luminanceSmoothing", null),
    mo = Yo([(0,
    $.jf)("BloomPlugin")], mo);
    var ws = function(S, p, C, V) {
        var se = arguments.length, ye = se < 3 ? p : V === null ? V = Object.getOwnPropertyDescriptor(p, C) : V, ue;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            ye = Reflect.decorate(S, p, C, V);
        else
            for (var Ce = S.length - 1; Ce >= 0; Ce--)
                (ue = S[Ce]) && (ye = (se < 3 ? ue(ye) : se > 3 ? ue(p, C, ye) : ue(p, C)) || ye);
        return se > 3 && ye && Object.defineProperty(p, C, ye),
        ye
    };
    let Gs = class extends ya {
        constructor(C={}) {
            super();
            B(this, "_preset", xi.MEDIUM);
            this.effect = new Co(C)
        }
        get preset() {
            return this._preset
        }
        set preset(C) {
            this._preset = C,
            this.effect.applyPreset(C)
        }
        get edgeDetectionMode() {
            return this.effect.edgeDetectionMaterial.edgeDetectionMode
        }
        set edgeDetectionMode(C) {
            this.effect.edgeDetectionMaterial.edgeDetectionMode = C
        }
        get predicationMode() {
            return this.effect.edgeDetectionMaterial.predicationMode
        }
        set predicationMode(C) {
            this.effect.edgeDetectionMaterial.predicationMode = C
        }
    }
    ;
    ws([(0,
    $.Cb)({
        value: xi
    })], Gs.prototype, "preset", null),
    ws([(0,
    $.Cb)({
        value: Nt
    })], Gs.prototype, "edgeDetectionMode", null),
    ws([(0,
    $.Cb)({
        value: di
    })], Gs.prototype, "predicationMode", null),
    Gs = ws([(0,
    $.jf)("SMAAPlugin")], Gs)
}
)();
H.J12;
H.$c;
H.I_b;
H.oGK;
H.$p;
H.$q;
H.$r;
H.L0d;
H.i5S;
var rM = H.nXV;
H.bd1;
var Y3 = H.LY2;
H.iAO;
H.bGH;
H.NDo;
H.gSk;
var xg = H.WMw;
H.OTo;
H.Se2;
H.cum;
H.Mig;
H.i_9;
H.fwF;
H.m7l;
H.vXP;
H.sYA;
H.Xcj;
H.mzJ;
H.ZZA;
H.T__;
H.HkE;
H.tGC;
H.gOo;
H.f03;
H.BbS;
H.kqm;
H.GPr;
H.Hmr;
H.SJI;
H.mTL;
H.y8_;
H.Xim;
H._Li;
H.z81;
H._MY;
var Q3 = H.NBQ
  , K3 = H.dFZ;
H.IIx;
H.N$j;
H._YM;
H.TUj;
H.ZzF;
H.GQ;
H.nvb;
H.DvJ;
H.fQA;
H.ePP;
H.TlE;
H.u9r;
H.s4_;
H.T95;
H.CtF;
H.V1s;
H.Rki;
var Z3 = H.ROQ;
H.YN5;
H.BVQ;
H.YT8;
H.YGz;
H.WXy;
H.trn;
H.zf8;
var uA = H.uWy;
H.SUY;
var Xi = H.Ilk;
H.R2R;
H.epp;
H.Wrv;
H.EKy;
H.$S;
var wo = H.wA2;
H.Z_g;
H.EB7;
H.DqL;
H._3;
H.b_z;
H.unp;
H._am;
H.fY$;
H.vxC;
H.BtG;
H.cBK;
var q3 = H.g8_;
H.AXT;
H.yj7;
H.dYG;
H.tm_;
H.S2y;
H.B02;
H.PeU;
H.Hyl;
H.Wqd;
H.SVw;
H.Xaj;
H.dZ3;
H.m_w;
H.fHI;
H.LBq;
H.JUT;
H.p3g;
var hA = H.IEO;
H.yxD;
H.A5E;
H.jfJ;
H.T_J;
H.tEQ;
H.qkB;
H.brP;
H.$YQ;
var Rs = H.iRp;
H.Ox3;
H.cBI;
H.cU9;
H.ntt;
H.DT1;
H.Kgo;
var bg = H.ehD;
H.fSK;
H.Vdb;
H.l8J;
H.dj0;
H.QM0;
H.q7E;
H.TOt;
H.Ny0;
var J3 = H.qAh;
H.eD;
H.jwo;
H.dSO;
H.Bf4;
var go = H.USm;
H.pBf;
var $3 = H.vpe;
H.$Vf;
H.O7d;
H.Aek;
H.hH6;
H.e62;
H.a$l;
H.OM3;
var dA = H.VzW;
H.ybr;
H.yo9;
H.Wzm;
H.zUS;
H.Wl3;
H.iWj;
H.ylh;
H.v9Y;
H.LSk;
H.uoT;
H.w$m;
H.ksN;
H.j4z;
H.OAl;
H.VLJ;
H.ZAu;
H.k7s;
var eO = H.cLu;
H.vmT;
H.Qpg;
H.So8;
var tO = H.BqW;
H.MR2;
H.o0j;
H.GfI;
H.Wjw;
H.cJO;
H.KCx;
H.QRU;
H.S3k;
H.PpQ;
H.ZRs;
H.oqc;
H.lb7;
H.L5s;
H.$TI;
var nO = H.SPe;
H.aVm;
H.j87;
H.RNb;
H.Kz5;
H.vpT;
H.kB5;
H._C8;
H.Syv;
H.NMF;
H.pIN;
H.eMJ;
H.ZtY;
H.x5V;
H.tUh;
H.z8B;
H.__J;
H.GZb;
H.p7y;
H.udN;
H.S9g;
H.Zr5;
H.vCF;
H.yt0;
H.uXU;
H._kC;
H.lk7;
H.DvN;
H.x12;
H.Zzh;
H.nls;
H.g_z;
H.U7;
H.FT0;
H.blk;
H.ejS;
var th = H.rnI
  , fA = H.wem;
H.lfu;
H.FDw;
H.lRj;
var pA = H.D1R;
H.qyh;
H.GUF;
H.EoG;
H.aNw;
H.Zp0;
H.lLk;
H.jAl;
H.uEv;
H.YKA;
H.cRx;
H.Y8D;
H.RsA;
H.B51;
var iO = H.F5T;
H.u7G;
var sM = H.M8C;
H.Vkp;
var F_ = H.yGw;
H.Sm8;
var rO = H.Kj0
  , sO = H.vBJ;
H.lRF;
H.Lun;
H.YBo;
var oO = H.kaV;
H.RSm;
H.xoR;
H.EJi;
H.Qme;
var mA = H.Wid;
H.jrH;
H.IKL;
H.r_;
H.OPb;
H.OoA;
H.qhX;
H.M5h;
H.Ns1;
var rm = H.TyD;
H.vZf;
H.HTd;
H.aH4;
H.YLQ;
H.BVF;
H.MyG;
H.jFi;
H.aCh;
H.uL9;
H.fwl;
H.IFH;
H.bdR;
H.M6v;
H.RvT;
H.dUE;
H.Tme;
H.Gql;
H.PA7;
H.REq;
H.pQR;
H.ghN;
H.Hy8;
H.Wpd;
H.LgZ;
H.iWC;
var aO = H.i5E
  , lO = H.iKG;
H._iA;
H.ntZ;
var cO = H.anP;
H.y$t;
H.Ady;
var Sv = H.H8x
  , oM = H.cPb
  , uO = H.JOQ;
H.BKK;
var hO = H._12;
H.tJx;
H.OdJ;
H.SyM;
H.cek;
H.xG9;
H.woe;
H.UY4;
H.aq0;
H.ujx;
H.Uol;
H.VYz;
var dO = H.XgS;
H.iUV;
H.tf;
H.ZQ6;
H.mXe;
var il = H._fP;
H.iLg;
H.zbs;
H.ZTh;
H.HdW;
H.UZH;
H.mSO;
var k_ = H.wk1;
H.E2K;
H.FUD;
H.pKu;
H.GG6;
H.Gih;
H.iiP;
H.SvJ;
H.ptH;
H.jZA;
H.y2t;
H.gi4;
H.Djp;
H.BG$;
H.NYV;
H.xJs;
H.bsb;
H.ekQ;
H.CaW;
H.eaV;
H.BFQ;
H.v3W;
H.ILR;
H.fto;
H.l0P;
H.vCx;
H._AM;
H.wuA;
H.av9;
H.CtA;
H.mIn;
H.FIo;
H.zHn;
H.iMs;
H.T_f;
H.hEm;
H.D9w;
H.CdI;
H.TIb;
var sc = H.rpg;
H.ce8;
H.rOj;
H.V4E;
H.o8S;
H.lGU;
H.vuL;
var fO = H.Rov;
H.KI_;
var pO = H.xsS;
H.b26;
H.WdD;
H.Vj0;
var Wo = H.jyz;
H.Tn7;
H.bnF;
H.HW6;
H.oa8;
H.T_1;
H.iDF;
H.iAb;
H.OdW;
H._YX;
H.TUv;
H.$uU;
H.Hw6;
H.aLr;
H.Aip;
var mO = H.xo$;
H.$V;
H.lDi;
H.gti;
H.PMe;
H.FvO;
H.jyi;
H.xeV;
H.k74;
H.RlZ;
H.KhW;
H.HgB;
H.W2J;
H.JWc;
H.kP0;
H.u37;
H.Z6B;
H.QZ1;
H.Ir4;
H.NwF;
H.Wbm;
H.N4l;
H.QmN;
var Jt = H.wes;
H.IOt;
H.L5g;
H.H$k;
var aM = H.xEZ;
H.YQ_;
H.Yin;
H.dpR;
H.Cne;
H.XvJ;
H.XZw;
H.FE5;
H.Ys8;
H.CJI;
H.z$h;
H.UlW;
H.WwZ;
H.Lcc;
H.WXh;
H.ub3;
H.xfE;
H.qlB;
H.lCJ;
H.WTc;
H.rAo;
H.xWb;
H.gH0;
var gA = H.rBU;
H.rDY;
H.ywz;
H.wJv;
H.JQ4;
H.k0A;
H.irR;
H.LsT;
H.MiG;
H.dwk;
var wf = H.FM8
  , Li = H.Pa4
  , Af = H.Ltg;
H.yC1;
H.fO1;
var Zm = H.AEx;
H._9o;
H.k5T;
H.b5g;
H.Ywn;
H.GVz;
H.oAp;
H.kFz;
var lM = H.dd2
  , gO = H.CP7;
H.fQK;
H.Uk6;
H._sL;
H.Pnf;
H.c8b;
H._lf;
H.ad5;
H.L_r;
H.eC3;
H.BRj;
H.rif;
H.HOT;
H.jfB;
H.wuM;
H.bkz;
H.lDs;
H.tQ;
H.Oe_;
H.YRX;
var Ju = H.S6$
  , ua = H.CbL
  , Qy = H.knz;
H.lKs;
H.c1W;
H.GaT;
H.OEW;
H.nB6;
class vO {
    constructor() {
        B(this, "RES_VERSION", "1.0.5");
        B(this, "CODE_VERSION", "1.1.4");
        B(this, "DEBUG", location.href.includes("localhost") || location.href.includes("192.168"));
        B(this, "COMPRESS", !0)
    }
    get VERSION() {
        return `res ${this.RES_VERSION} code ${this.CODE_VERSION}`
    }
    autoURL(n) {
        return this.COMPRESS ? (n.includes(".raw") || (n = n.replace(".jpg", ".webp").replace(".jpeg", ".webp").replace(".png", ".webp").replace(".glb", ".bin")),
        n.replace("res/", `/su7/${this.RES_VERSION}/`)) : n
    }
}
const ai = new vO;
class _O {
    constructor() {
        B(this, "maxSpeed", 20);
        B(this, "speedUpDuration", 2);
        B(this, "LAYER_CAPTURE", 31);
        B(this, "LAYER_PLANE_REFLECT", 29);
        B(this, "lightUpTime", 2);
        B(this, "sm_car");
        B(this, "sm_size");
        B(this, "sm_startroom");
        B(this, "sm_speedup");
        B(this, "sm_curvature");
        B(this, "sm_windspeed");
        B(this, "sm_linecar");
        B(this, "sm_carradar");
        B(this, "sm_simpleCar");
        B(this, "sm_car_lightbar");
        B(this, "ut_car_body_ao", {
            value: null
        });
        B(this, "ut_startroom_ao", {
            value: null
        });
        B(this, "ut_startroom_light", {
            value: null
        });
        B(this, "ut_floor_normal", {
            value: null
        });
        B(this, "ut_floor_roughness", {
            value: null
        });
        B(this, "ut_cubeCapture", {
            value: null
        });
        B(this, "ut_blurCapture", {
            value: null
        });
        B(this, "ut_saLine", {
            value: null
        });
        B(this, "ut_street", {
            value: null
        });
        B(this, "ut_scar_matcap", {
            value: null
        });
        B(this, "ut_white", {
            value: null
        });
        B(this, "ut_dark", {
            value: null
        });
        B(this, "ut_floorMap", {
            value: null
        });
        B(this, "ut_car_body_t_gm", {
            value: null
        });
        B(this, "ut_car_body_t_gm2", {
            value: null
        });
        B(this, "ut_gm02_car_window_bc", {
            value: null
        });
        B(this, "ut_gm02_car_window_roughness", {
            value: null
        });
        B(this, "ut_gm02_floor_bc", {
            value: null
        });
        B(this, "ut_police_Car_body_BC", {
            value: null
        });
        B(this, "ut_police_floor_bc", {
            value: null
        });
        B(this, "ut_env_night", {
            value: null
        });
        B(this, "ut_env_light", {
            value: null
        });
        B(this, "u_time", {
            value: 0
        });
        B(this, "u_car_envMapIntensity", {
            value: 1
        });
        B(this, "u_floor_typeSwitch", {
            value: 0
        });
        B(this, "u_speedUpBackgroundValue", {
            value: 0
        });
        B(this, "u_car_discard", {
            value: 1
        });
        B(this, "u_speedTime", {
            value: 0
        });
        B(this, "u_floorLightMapIntensity", {
            value: 0
        });
        B(this, "u_floorLightMapColor", {
            value: new Xi("#000000")
        });
        B(this, "u_floorReflectIntensity", {
            value: 0
        });
        B(this, "u_floorUVOffset", {
            value: new wf
        });
        B(this, "u_simpleCarCenter1", {
            value: new Li
        });
        B(this, "u_simpleCarCenter2", {
            value: new Li
        });
        B(this, "u_policeColorChange", {
            value: 0
        });
        B(this, "u_reflect", {
            u_reflectTexture: {
                value: null
            },
            u_reflectMatrix: {
                value: null
            }
        });
        B(this, "u_m_car_window_orignData", {
            opacity: 0,
            roughness: 0,
            color: new Xi
        });
        B(this, "colors", new Map([["custom", {
            col: new Xi("#ffc03f").convertSRGBToLinear(),
            hsl: {
                h: 40.31 / 360,
                s: 1,
                l: .6235
            },
            bgUrl: "custom.png",
            rough: .03,
            metal: .1
        }], ["00", {
            col: new Xi("#25d6e9").convertSRGBToLinear(),
            bgUrl: "b1.png",
            metal: .16
        }], ["01", {
            col: new Xi("#7c8670").convertSRGBToLinear(),
            bgUrl: "b2.png",
            metal: .17
        }], ["02", {
            col: new Xi("#9C9C9C").convertSRGBToLinear(),
            bgUrl: "b3.png",
            metal: .16
        }], ["03", {
            col: new Xi("#D9D9D9").convertSRGBToLinear(),
            bgUrl: "b4.png"
        }], ["04", {
            col: new Xi("#7C6D83").convertSRGBToLinear(),
            bgUrl: "b5.png",
            rough: .03,
            metal: .27
        }], ["05", {
            col: new Xi("#d15523").convertSRGBToLinear(),
            bgUrl: "b6.png",
            rough: .13
        }], ["06", {
            col: new Xi("#7495be").convertSRGBToLinear(),
            bgUrl: "b7.png"
        }], ["07", {
            col: new Xi("#54657f").convertSRGBToLinear(),
            bgUrl: "b8.png",
            rough: .12,
            metal: .16
        }], ["08", {
            col: new Xi("#2a2933").convertSRGBToLinear(),
            bgUrl: "b9.png",
            metal: .77
        }], ["09", {
            col: new Xi("#FFFFFF").convertSRGBToLinear(),
            bgUrl: "b10.png",
            tcar: this.ut_car_body_t_gm
        }], ["10", {
            col: new Xi("#FFFFFF").convertSRGBToLinear(),
            bgUrl: "b12.png",
            rough: .7,
            metal: 0,
            tcar: this.ut_car_body_t_gm2,
            tw: this.ut_gm02_car_window_bc,
            twr: this.ut_gm02_car_window_roughness,
            tf: this.ut_gm02_floor_bc
        }], ["11", {
            col: new Xi("#FFFFFF").convertSRGBToLinear(),
            bgUrl: "b13.png",
            tcar: this.ut_police_Car_body_BC,
            tf: this.ut_police_floor_bc
        }]]));
        B(this, "u_carColor", {
            value: this.colors.get("00").col.clone()
        });
        B(this, "u_carMetalness", {
            value: this.colors.get("00").metal
        });
        B(this, "u_carRoughness", {
            value: 0
        })
    }
    getCustomParams() {
        const r = new URLSearchParams(window.location.search).get("v");
        if (r && r.length == 10) {
            const s = r
              , h = parseInt(s.slice(6, 8), 16) / 255
              , l = parseInt(s.slice(8, 10), 16) / 255
              , g = s.slice(0, 6);
            if (h && (this.colors.get("custom").rough = h),
            l && (this.colors.get("custom").metal = l),
            g) {
                const _ = new Xi("#" + g);
                this.colors.get("custom").col.copy(_),
                _.convertLinearToSRGB(),
                _.getHSL(this.colors.get("custom").hsl)
            }
            return "custom"
        }
        return r && r.includes("h") && r.length == 3 ? r.slice(1, 3) : 0
    }
    generateCustomParams() {
        if (Ie.currentColorIndex == "custom") {
            let n = Math.round(this.colors.get("custom").rough * 255).toString(16);
            n.length < 2 && (n = "0" + n);
            let r = Math.round(this.colors.get("custom").metal * 255).toString(16);
            r.length < 2 && (r = "0" + r);
            const s = this.colors.get("custom").col.getHexString();
            return (ai.DEBUG ? "http://192.168.23.49:5173/su7?v=" : "https://gamemcu.com/su7?v=") + s + n + r
        } else
            return (ai.DEBUG ? "http://192.168.23.49:5173/su7?v=h" : "https://gamemcu.com/su7?v=h") + Ie.currentColorIndex
    }
}
const Ae = new _O;
var Bn = (t=>(t[t.Loading = 0] = "Loading",
t[t.BeginAnim = 1] = "BeginAnim",
t[t.State1 = 2] = "State1",
t[t.State2 = 3] = "State2",
t[t.State3 = 4] = "State3",
t[t.State4 = 5] = "State4",
t[t.State5 = 6] = "State5",
t))(Bn || {})
  , sa = (t=>(t[t.presetColorTable = 0] = "presetColorTable",
t[t.customColorTable = 1] = "customColorTable",
t))(sa || {});
class yO extends $3 {
    constructor() {
        super(...arguments);
        B(this, "loading", 0);
        B(this, "PRELOADED", "preloaded");
        B(this, "UPDATESHOWINGSTATE", "updateShowingState");
        B(this, "CLICKEFFECT", "clickEffect");
        B(this, "CHANGECOLOR", "changeColor");
        B(this, "PLAY_SFX", "playSFX");
        B(this, "PLAY_BGM", "playBGM");
        B(this, "FADE_BGM", "fadeBGM");
        B(this, "MUTE", "mute");
        B(this, "PRESSED_STATE_CHANGED", "pressedStateChanged");
        B(this, "UPDATECOLORTABLESTATE", "updateColorTableState");
        B(this, "SCREENSHOT", "screenshot");
        B(this, "_isInClickEffect", !1);
        B(this, "_currentShowingState", 0);
        B(this, "_currentColorIndex", "00");
        B(this, "_currentColorTableState", 0)
    }
    get currentShowingState() {
        return this._currentShowingState
    }
    get isInClickEffect() {
        return this._isInClickEffect
    }
    get currentColorIndex() {
        return this._currentColorIndex
    }
    get currentColorTableState() {
        return this._currentColorTableState
    }
    reset() {
        this.on(this.UPDATESHOWINGSTATE, r=>{
            this._currentShowingState = r
        }
        ),
        this.on(this.CLICKEFFECT, r=>{
            this._isInClickEffect = r
        }
        ),
        this.on(this.CHANGECOLOR, r=>{
            this._currentColorIndex = r,
            r == "11" ? Ae.u_policeColorChange.value = 1 : Ae.u_policeColorChange.value = 0
        }
        ),
        this.on(this.UPDATECOLORTABLESTATE, r=>{
            this._currentColorTableState = r
        }
        ),
        this.on(this.PRELOADED, ()=>{
            this.emit(this.UPDATESHOWINGSTATE, 1)
        }
        )
    }
}
const Ie = new yO;
var xO = Object.defineProperty
  , bO = Object.getOwnPropertyDescriptor
  , Ic = (t,n,r,s)=>{
    for (var h = s > 1 ? void 0 : s ? bO(n, r) : n, l = t.length - 1, g; l >= 0; l--)
        (g = t[l]) && (h = (s ? g(n, r, h) : g(h)) || h);
    return s && h && xO(n, r, h),
    h
}
;
const vA = new Li
  , Tv = new go
  , wO = new il
  , AO = rM();
class Hl extends wo {
    constructor({near: r=.01, far: s=100, fov: h=45, rotation: l=new go(0,-Math.PI / 2,0), lookAt: g=new Li, springLength: _=2}) {
        super();
        B(this, "enablePositionNoise", !0);
        B(this, "positionFrequency", 1.5);
        B(this, "positionAmplitude", .04);
        B(this, "positionScale", rM(1));
        B(this, "positionFractalLevel", 3);
        B(this, "_time", []);
        B(this, "_fbmNorm", 1 / .75);
        B(this, "_springLength", 2);
        B(this, "_lookAt", new Li(0,.23686,0));
        B(this, "rotation", new go(0,-Math.PI / 2,0));
        B(this, "targetCameraPosition", new Li);
        this.onLoad = ()=>{
            this.viewer.camera.near = r,
            this.viewer.camera.far = s,
            this.viewer.camera.fov = h,
            this.viewer.camera.updateProjectionMatrix(),
            this.rotation.copy(l),
            this._lookAt.copy(g),
            this._springLength = _,
            this.calculateCameraPosition(),
            this.viewer.camera.position.copy(this.targetCameraPosition),
            this.viewer.camera.lookAt(this._lookAt),
            this.rehash()
        }
    }
    rehash() {
        for (let r = 0; r < 6; r++)
            this._time[r] = sM.randFloat(-1e4, 0)
    }
    get springLength() {
        return this._springLength
    }
    set springLength(r) {
        this._springLength = r
    }
    get __rotation() {
        return this.rotation
    }
    set __rotation(r) {
        this.rotation.copy(r)
    }
    get lookAt() {
        return this._lookAt
    }
    set lookAt(r) {
        this._lookAt.copy(r)
    }
    gotoPOI(r, s, h, l=1.5, g=Jt.Easing.Cubic.InOut, _=0) {
        return new Promise(A=>{
            const m = new il().setFromEuler(this.rotation)
              , D = new il;
            Jt.TweenManager.KillTweensOf(this),
            Jt.TweenManager.Tween(this).to({
                lookAt: r,
                springLength: s
            }, l).delay(_).onUpdate((U,R)=>{
                const ne = wO.setFromEuler(h);
                D.copy(m).slerp(ne, g(R)),
                this.rotation.copy(Tv.setFromQuaternion(D, "YZX"))
            }
            ).easing(g).start().onComplete(()=>{
                A(!0)
            }
            )
        }
        )
    }
    calculateCameraPosition() {
        Tv.set(0, this.rotation.y, this.rotation.z),
        vA.set(1, 0, 0).applyEuler(Tv).multiplyScalar(this._springLength).add(this._lookAt),
        this.targetCameraPosition.copy(vA)
    }
    update(r) {
        if (this.calculateCameraPosition(),
        this.viewer.camera.position.copy(this.targetCameraPosition),
        this.viewer.camera.lookAt(this._lookAt),
        this.enablePositionNoise) {
            for (let h = 0; h < 3; h++)
                this._time[h] += this.positionFrequency * r;
            let s = AO.set(Sv.Fbm(this.positionFractalLevel, this._time[0]), Sv.Fbm(this.positionFractalLevel, this._time[1]), Sv.Fbm(this.positionFractalLevel, this._time[2]));
            s = s.multiply(this.positionScale),
            s.multiplyScalar(this.positionAmplitude * this._fbmNorm),
            this.viewer.camera.position.add(s)
        }
    }
}
Ic([ua({
    dir: "position"
})], Hl.prototype, "enablePositionNoise", 2);
Ic([ua({
    dir: "position"
})], Hl.prototype, "positionFrequency", 2);
Ic([ua({
    dir: "position"
})], Hl.prototype, "positionAmplitude", 2);
Ic([ua({
    dir: "position"
})], Hl.prototype, "positionScale", 2);
Ic([ua({
    dir: "position",
    min: 0,
    max: 8,
    step: 1
})], Hl.prototype, "positionFractalLevel", 2);
Ic([ua()], Hl.prototype, "springLength", 1);
Ic([ua()], Hl.prototype, "__rotation", 1);
Ic([ua()], Hl.prototype, "lookAt", 1);
new il;
new Li;
function Za() {
    const t = navigator.userAgent;
    return /iPad/.test(t) ? !1 : /Mobile|Android|iPhone|iPod|BlackBerry|Windows Phone|iPad/gi.test(t)
}
function SO() {
    const t = document.documentElement.clientWidth
      , n = document.documentElement.clientHeight;
    return !(t > n)
}
const cM = new oM;
cM.position.set(5, 0, 0);
cM.lookAt(new Li(0,0,0));
new rO(new mO(1),[new iO]);
function rl(t, n, r) {
    return t + (n - t) * r
}
function TO(t, n, r) {
    return n.x = rl(0, t.x, r),
    n.y = rl(0, t.y, r),
    n.z = rl(0, t.z, r),
    n
}
function EO(t, n) {
    t.x -= n.x,
    t.y -= n.y,
    t.z -= n.z
}
function MO(t, n) {
    t.x += n.x,
    t.y += n.y,
    t.z += n.z
}
function _A(t, n, r) {
    return t = Math.max(n, t),
    t = Math.min(r, t),
    t
}
function yA() {
    return "maxTouchPoints"in navigator && navigator.maxTouchPoints > 0
}
const $u = new wf
  , Ev = new go
  , Bd = new il
  , xA = new il
  , CO = new go;
class PO extends wo {
    constructor({springCamera: r}) {
        super();
        B(this, "enableClamp", !0);
        B(this, "targetFov", 45);
        B(this, "springlengthOffset", 0);
        B(this, "lerpStrength", 1);
        B(this, "moveSpeed", [1, 1]);
        B(this, "_currentLengthOffset", 0);
        B(this, "_springRotationZClampRange", [.02, .3]);
        B(this, "_springRotationYClampRange", [-100, 100]);
        B(this, "_deltaRotation", new go);
        B(this, "_targetRotation", new go);
        B(this, "_targetSpringLength", 0);
        B(this, "_targetLookAt", new Li);
        B(this, "_button", -1);
        B(this, "_preLoc0", new wf);
        B(this, "_preLoc1", new wf);
        B(this, "_touchID");
        B(this, "_springCamera");
        B(this, "_enableControlCamera", !1);
        B(this, "_lerpQuatStrength", 5);
        B(this, "_lerpLengthStrength", 3);
        B(this, "_mouseWheelSum", 0);
        this.onLoad = ()=>{
            this._springCamera = r,
            this.reset()
        }
    }
    get lerpLengthStrength() {
        return this._lerpLengthStrength
    }
    set lerpLengthStrength(r) {
        this._lerpLengthStrength = r
    }
    get springLength() {
        return this._targetSpringLength
    }
    set springLength(r) {
        this._targetSpringLength = r
    }
    get enableControlCamera() {
        return this._enableControlCamera
    }
    set enableControlCamera(r) {
        this._enableControlCamera !== r && (this._enableControlCamera = r,
        r ? (yA() ? (this.viewer.on(Rs.TOUCH_START, this._onTouchStart, this),
        this.viewer.on(Rs.TOUCH_MOVE, this._onTouchMove, this)) : (this.viewer.on(Rs.POINTER_DOWN, this._onMouseDown, this),
        this.viewer.on(Rs.POINTER_UP, this._onMouseUp, this),
        this.viewer.on(Rs.POINTER_MOVE, this._onMouseMove, this)),
        this.viewer.on(Rs.MOUSE_WHEEL, this._onMouseWheel, this),
        this.reset()) : (yA() ? (this.viewer.off(Rs.TOUCH_START, this._onTouchStart, this),
        this.viewer.off(Rs.TOUCH_MOVE, this._onTouchMove, this)) : (this.viewer.off(Rs.POINTER_DOWN, this._onMouseDown, this),
        this.viewer.off(Rs.POINTER_UP, this._onMouseUp, this),
        this.viewer.off(Rs.POINTER_MOVE, this._onMouseMove, this)),
        this.viewer.off(Rs.MOUSE_WHEEL, this._onMouseWheel, this)))
    }
    reset() {
        this._button = -1,
        this._touchID = -1,
        this.springLength = this._springCamera.springLength,
        this._targetLookAt.copy(this._springCamera.lookAt),
        this._targetRotation.copy(this._springCamera.rotation),
        this._deltaRotation.set(0, 0, 0),
        this.targetFov = this.viewer.camera.fov
    }
    _onMouseDown(r) {
        this._button = r.button,
        this._preLoc0.set(r.pageX, r.pageY)
    }
    _onMouseUp(r) {
        this._button = -1
    }
    _onMouseMove(r) {
        switch ($u.set(r.pageX, r.pageY),
        this._button) {
        case 0:
            this._preLoc0.sub($u).multiplyScalar(this._springCamera.springLength * .001),
            this.updateDeltaRotation();
            break
        }
        this._preLoc0.copy($u)
    }
    updateDeltaRotation() {
        this._deltaRotation.y += this._preLoc0.x * this.moveSpeed[0],
        this._deltaRotation.z -= this._preLoc0.y * this.moveSpeed[1]
    }
    _onMouseWheel(r) {
        this._mouseWheelSum += r.deltaY,
        this._mouseWheelSum > 200 ? (this._mouseWheelSum = 0,
        wA(!0)) : this._mouseWheelSum < -200 && (this._mouseWheelSum = 0,
        wA(!1))
    }
    _onTouchStart(r) {
        const s = r.touches;
        s.length == 1 && (this._preLoc0.set(s[0].pageX, s[0].pageY),
        this._touchID = r.touches[0].identifier),
        s.length > 1 && (this._preLoc1.set(s[1].pageX, s[1].pageY),
        console.log("preLoc1=" + Math.round(this._preLoc1.x) + "  " + Math.round(this._preLoc1.y)))
    }
    _onTouchMove(r) {
        const s = r.touches;
        s.length === 1 && this._touchID === s[0].identifier && ($u.set(s[0].pageX, s[0].pageY),
        this._preLoc0.sub($u).multiplyScalar(this._springCamera.springLength * .0016),
        this.updateDeltaRotation(),
        this._preLoc0.copy($u))
    }
    update(r) {
        Math.abs(this.viewer.camera.fov - this.targetFov) > .01 && (this.viewer.camera.fov = rl(this.viewer.camera.fov, this.targetFov, this.lerpStrength * r),
        this.viewer.camera.updateProjectionMatrix()),
        this._currentLengthOffset = rl(this._currentLengthOffset, this.springlengthOffset, this.lerpStrength * r);
        const s = this._targetSpringLength + this._currentLengthOffset;
        this._springCamera.lookAt.lerp(this._targetLookAt, r),
        this._springCamera.springLength = rl(this._springCamera.springLength, s, .016 * this._lerpLengthStrength),
        TO(this._deltaRotation, Ev, r * 10),
        EO(this._deltaRotation, Ev),
        MO(this._targetRotation, Ev),
        Bd.setFromEuler(this._targetRotation),
        this._targetRotation.setFromQuaternion(Bd, "YZX"),
        this.enableClamp && (this._targetRotation.z = _A(this._targetRotation.z, this._springRotationZClampRange[0], this._springRotationZClampRange[1]),
        this._targetRotation.y = _A(this._targetRotation.y, this._springRotationYClampRange[0], this._springRotationYClampRange[1])),
        Bd.setFromEuler(this._springCamera.rotation),
        xA.setFromEuler(this._targetRotation),
        Bd.slerp(xA, r * this._lerpQuatStrength),
        this._springCamera.rotation.copy(CO.setFromQuaternion(Bd, "YZX"))
    }
    gotoPOI(r, s, h, l=1.5, g=Jt.Easing.Cubic.InOut, _=0) {
        return new Promise(A=>{
            var m;
            Jt.TweenManager.KillTweensOf(this),
            Jt.TweenManager.Timeline(this).delay(l).call(()=>{
                this.reset()
            }
            ).start(),
            (m = this._springCamera) == null || m.gotoPOI(r, s, h, l, g, _).then(()=>{
                A(!0)
            }
            )
        }
        )
    }
    setNewTarget(r, s, h) {
        this.reset(),
        this._lerpQuatStrength = 0,
        Jt.TweenManager.KillTweensOf(this),
        Jt.TweenManager.Timeline(this).to({
            _lerpQuatStrength: 5
        }, 1).start(),
        this.springLength = s,
        this._targetLookAt.copy(r),
        this._targetRotation.copy(h)
    }
    setNewRange(r=[.02, .3], s=[-100, 100]) {
        this._springRotationZClampRange = r,
        this._springRotationYClampRange = s
    }
}
const bA = .3;
let Mv = !0;
function wA(t) {
    if (!Ie.isInClickEffect && Mv)
        switch (Mv = !1,
        Jt.TweenManager.Timeline(bA).delay(bA).call(()=>Mv = !0).start(),
        Ie.currentShowingState) {
        case Bn.State1:
            t ? Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State2) : Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State4);
            break;
        case Bn.State2:
            t ? Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State3) : Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State1);
            break;
        case Bn.State3:
            t ? Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State4) : Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State2);
            break;
        case Bn.State4:
            t ? Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State1) : Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State3);
            break
        }
}
class RO extends wo {
    constructor(r=new wf(1024,1024), s=29, h=0) {
        super();
        B(this, "_clipBias", 0);
        B(this, "_camera");
        B(this, "_reflectPlane");
        B(this, "_reflectMatrix");
        B(this, "_renderTexture");
        this._clipBias = h,
        this._camera = new oM,
        this._camera.layers.set(s),
        this._reflectPlane = new uO,
        this._reflectMatrix = new F_,
        this._renderTexture = new lM(r.x,r.y),
        this._renderTexture.texture.generateMipmaps = !0,
        this._renderTexture.texture.minFilter = pA,
        this._renderTexture.texture.magFilter = pA,
        this._renderTexture.texture.wrapS = uA,
        this._renderTexture.texture.wrapT = uA,
        this.onLoad = ()=>{
            this._reflectPlane.set(Li.UP, 0),
            this._reflectPlane.applyMatrix4(this.node.matrixWorld),
            this.viewer.on(Zm.RENDER_BEFORE, this.beforeRender, this)
        }
    }
    get reflectMatrix() {
        return this._reflectMatrix
    }
    get reflectTexture() {
        return this._renderTexture.texture
    }
    onDestroy() {
        this.viewer.off(Zm.RENDER_BEFORE, this.beforeRender, this)
    }
    beforeRender() {
        this._reflectPlane.set(Li.UP, 0),
        this._reflectPlane.applyMatrix4(this.node.matrixWorld);
        const r = this._camera.layers.mask;
        this._camera.copy(this.viewer.camera),
        this._camera.layers.mask = r;
        const s = Li.UNIT_Z.clone().negate()
          , h = this.viewer.camera.getWorldPosition(new Li);
        if (s.applyQuaternion(this.viewer.camera.getWorldQuaternion(new il)),
        s.dot(this._reflectPlane.normal) > .2) {
            console.log("no need capture reflect:", s.dot(this._reflectPlane.normal), s, this._reflectPlane.normal);
            return
        }
        s.reflect(this._reflectPlane.normal);
        const l = new Li;
        this._reflectPlane.projectPoint(h, l);
        const g = l.clone();
        g.sub(h),
        g.add(l),
        this._camera.position.copy(g);
        const _ = new Li(0,0,-1);
        _.applyQuaternion(this.viewer.camera.getWorldQuaternion(new il)),
        _.add(h);
        const A = new Li;
        this.node.getWorldPosition(A),
        A.sub(_),
        A.reflect(this._reflectPlane.normal).negate(),
        A.add(this.node.getWorldPosition(new Li)),
        this._camera.up.set(0, 1, 0),
        this._camera.applyQuaternion(this.viewer.camera.getWorldQuaternion(new il)),
        this._camera.up.reflect(this._reflectPlane.normal),
        this._camera.lookAt(A),
        this._camera.updateMatrixWorld();
        const m = new F_;
        m.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        m.multiply(this._camera.projectionMatrix),
        m.multiply(this._camera.matrixWorldInverse),
        this._reflectMatrix.copy(m),
        this._reflectPlane.applyMatrix4(this._camera.matrixWorldInverse);
        const D = new Af(this._reflectPlane.normal.x,this._reflectPlane.normal.y,this._reflectPlane.normal.z,this._reflectPlane.constant)
          , U = this._camera.projectionMatrix
          , R = new Af;
        R.x = (Math.sign(D.x) + U.elements[8]) / U.elements[0],
        R.y = (Math.sign(D.y) + U.elements[9]) / U.elements[5],
        R.z = -1,
        R.w = (1 + U.elements[10]) / U.elements[14],
        D.multiplyScalar(2 / D.dot(R)),
        U.elements[2] = D.x,
        U.elements[6] = D.y,
        U.elements[10] = D.z + 1 - this._clipBias,
        U.elements[14] = D.w;
        const ne = this.viewer.renderer.getRenderTarget();
        this.viewer.renderer.setRenderTarget(this._renderTexture),
        this.viewer.renderer.state.buffers.depth.setMask(!0),
        this.viewer.renderer.autoClear === !1 && this.viewer.renderer.clear(),
        this.viewer.renderer.render(this.viewer.scene, this._camera),
        this.viewer.renderer.setRenderTarget(ne);
        const ce = this.viewer.camera.viewport;
        ce !== void 0 && this.viewer.renderer.state.viewport(ce)
    }
}
const wg = `
    vec2 hash( vec2 p ) {
        p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));
        return -1.0 + 2.0*fract(sin(p)*43758.5453123);
    }
    float noise2d( in vec2 p ) {
        const float K1 = 0.366025404; // (sqrt(3)-1)/2;
        const float K2 = 0.211324865; // (3-sqrt(3))/6;
        vec2 i = floor(p + (p.x+p.y)*K1);
        vec2 a = p - i + (i.x+i.y)*K2;
        vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));
        vec2 b = a - o + K2;
        vec2 c = a - 1.0 + 2.0*K2;
        vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
        vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
        return dot(n, vec3(70.0));
}`
  , DO = `
float random (vec2 st) {
    return fract(sin(dot(st.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

vec3 pos2col ( vec2 ipos ) {

    ipos += vec2(9.,0.); // Just moved to pick some nice colors

    float r = random( ipos + vec2( 12., 2. ) );
    float g = random( ipos + vec2(7., 5. ) );
    float b = random( ipos );


    vec3 col = vec3(r,g,b);
    return col;
}

vec3 colorNoise ( vec2 st ) {
    vec2 ipos = floor( st );
    vec2 fpos = fract( st );


    // Four corners in 2D of a tile
    vec3 a = pos2col(ipos);
    vec3 b = pos2col(ipos + vec2(1.0, 0.0));
    vec3 c = pos2col(ipos + vec2(0.0, 1.0));
    vec3 d = pos2col(ipos + vec2(1.0, 1.0));

    // Cubic Hermine Curve.  Same as SmoothStep()
    vec2 u = fpos*fpos*(3.0-2.0*fpos);
    // u = smoothstep(0.,1.,fpos);

    // Mix 4 coorners percentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}
`
  , If = `
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUv;
varying vec3 vPositionW;
varying vec3 vPositionObj;
varying vec3 vNormalW;
attribute vec3 color;
varying vec3 vColor;
varying vec3 vViewPosition;
varying vec4 viewerUV;

#ifdef USE_INSTANCING
  varying vec3 vPositionIns;
  varying vec3 vPositionInsModel;
  varying vec3 vInstanceColor;
  attribute vec3 instanceColor; // 实例化颜色属性
#endif

void main() {
    vPosition = position;
    vNormal = normalMatrix * normal;
    vPositionW = vec3( modelMatrix*vec4( position, 1.0 ));
    vPositionObj = vec3( modelMatrix*vec4( vec3(0.), 1.0 ));
    vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );
    vUv = uv;
    vColor=color;

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    vViewPosition = -mvPosition.xyz;

    #ifdef USE_INSTANCING
      vPositionInsModel = position;
      vPositionIns = vec3(instanceMatrix * vec4(vec3(0.),1.));
      vPositionW = vec3(instanceMatrix * vec4(vPositionW,1.));
      vPosition = vec3(instanceMatrix * vec4(vPosition,1.));
      vInstanceColor = instanceColor;
    #endif

    gl_Position = projectionMatrix * mvPosition;
    viewerUV = vec4((gl_Position.xyz / gl_Position.w).xy* 0.5 + 0.5,0.,1.);
}`
  , LO = `
varying vec4 vWorldPosition;
    varying vec2 vUv;
    varying vec2 vUv2;
    varying vec4 vViewPosition;
    varying vec3 vNormal;
    varying vec4 vTangent;

    uniform vec3 color;
    uniform sampler2D map;
    uniform float opacity;
    uniform float roughness;
    uniform sampler2D roughnessMap;
    uniform float metalness;
    uniform sampler2D metalnessMap;
    uniform sampler2D aoMap;
    uniform sampler2D lightMap;
    uniform vec3 lightMapColor;
    uniform float lightMapIntensity;
    uniform vec3 emissive;
    uniform sampler2D emissiveMap;
    uniform sampler2D normalMap;
    uniform float distortionScale;
    uniform float u_floor_typeSwitch;
    uniform sampler2D ut_street;

    uniform float u_lightIntensity;
    uniform float u_reflectIntensity;
    uniform vec2 u_floorUVOffset;

    uniform mat4 u_reflectMatrix;
    uniform sampler2D u_reflectTexture;

    #include <common>
    #include <packing>
    #include <bsdfs>
    #include <fog_pars_fragment>
    #include <logdepthbuf_pars_fragment>
    #include <lights_pars_begin>
    #include <shadowmap_pars_fragment>
    #include <shadowmask_pars_fragment>

    vec4 getNoise( vec2 uv ) {
        vec2 uv0 = ( uv / 103.0 );
        vec2 uv1 = uv / 107.0;
        vec2 uv2 = uv / vec2( 8907.0, 9803.0 );
        vec2 uv3 = uv / vec2( 1091.0, 1027.0 );
        vec4 noise = texture2D( normalMap, uv0 ) +
            texture2D( normalMap, uv1 ) +
            texture2D( normalMap, uv2 ) +
            texture2D( normalMap, uv3 );
        return noise * 0.5 - 1.0;
    }

    void main(){
        #include <logdepthbuf_fragment>

        vec3 surfaceNormal = vec3(0.,1.,0.);
        #ifdef USE_NORMAL_MAP
            vec3 normalSample = texture2D( normalMap, vWorldPosition.xz+u_floorUVOffset).rgb*2.-vec3(1.);
            surfaceNormal = normalize( normalSample.xzy );
        #endif

        vec3 diffuseLight = vec3(0.0);
        vec3 eyeDirection = -vViewPosition.xyz;
        float d = length(eyeDirection);
        eyeDirection = normalize(eyeDirection);

        //法线对反射的影响强度
        vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / d ) * distortionScale;

        float metallic = metalness;
        #ifdef USE_METALNESS_MAP
            metallic = texture2D(metalnessMap, vUv).b * metallic;
        #endif

        float theta = max( dot( eyeDirection, vNormal ), 0.0 );
        float rf0 = 0.02;
        float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 2.0 );

        float roughness_factory = roughness;
        #ifdef USE_ROUGHNESS_MAP
            roughness_factory *= texture2D(roughnessMap, (vWorldPosition.xz+u_floorUVOffset)*0.2).g;
        #endif
        roughness_factory = roughness_factory*(1.7 - 0.7*roughness_factory);

        vec4 samplePoint = u_reflectMatrix * vWorldPosition;
        samplePoint = samplePoint / samplePoint.w;
        vec3 reflectionSample = texture2D(u_reflectTexture, samplePoint.xy + distortion, roughness_factory*6.).xyz * u_reflectIntensity;
        vec3 lightSample = vec3(lightMapIntensity * u_lightIntensity)*lightMapColor;

        #ifdef USE_LIGHT_MAP
            lightSample *= texture2D(lightMap,vUv2).rgb;
        #endif

        #ifdef USE_AO_MAP
            float aoSample = texture2D(aoMap,vUv2).r;
            lightSample*=aoSample;
        #endif

        vec3 streetCol = texture(ut_street,vec2((vWorldPosition.z+15.)/30.,(vWorldPosition.x+u_floorUVOffset.x)/60.)).rgb;
        lightSample = mix(lightSample,streetCol,vec3(u_floor_typeSwitch));

        vec3 colorFactory = color;
        #ifdef USE_MAP
            vec3 mapColor =  texture2D(map, vUv).rgb;
            mapColor = mix(mapColor,vec3(1.),vec3(u_floor_typeSwitch));
            colorFactory *= mapColor.rgb;
        #endif

        //漫反射强度的简单计算方式
        diffuseLight = lightSample * colorFactory; //* theta;
        vec3 outColor = mix(diffuseLight, reflectionSample, reflectance);

        gl_FragColor = vec4(outColor, opacity);
        // gl_FragColor = vec4(vec3(theta*(roughness_factory)), 1.);
        // gl_FragColor = vec4(vec3(vUv,0.), 1.);
        #include <tonemapping_fragment>
        #include <encodings_fragment>
        #include <fog_fragment>
    }
`
  , IO = `
varying vec4 vWorldPosition;
    varying vec2 vUv;
    varying vec2 vUv2;
    varying vec4 vViewPosition;
    varying vec3 vNormal;
    varying vec4 vTangent;

    attribute vec2 uv2;
    attribute vec2 uv3;

    #include <common>
    #include <fog_pars_vertex>
    #include <shadowmap_pars_vertex>
    #include <logdepthbuf_pars_vertex>

    void main() {
        vUv = uv;
        vUv2 = uv2;
        vWorldPosition = modelMatrix * vec4( position, 1.0 );
        vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
        vViewPosition = mvPosition / mvPosition.w;
        vNormal = normalMatrix * normal;
        #ifdef USE_TANGENT
        vTangent = tangent;
        #endif
        gl_Position = projectionMatrix * mvPosition;

        #include <beginnormal_vertex>
        #include <defaultnormal_vertex>
        #include <logdepthbuf_vertex>
        #include <fog_vertex>
        #include <shadowmap_vertex>
    }`
  , OO = `varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUv;
varying vec3 vPositionW;
varying vec3 vNormalW;
attribute vec3 color;
varying vec3 vColor;
varying vec4 viewerUV;

void main() {
    vPosition = position;
    vNormal = normalMatrix * normal;
    vPositionW = vec3( modelMatrix*vec4( position, 1.0 ));
    vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );
    vUv = uv;
    vColor=color;

    #ifdef USE_INSTANCING
      vPositionW = vec3(instanceMatrix * vec4(vPositionW,1.));
      vPosition = vec3(instanceMatrix * vec4(vPosition,1.));
    #endif

    // 添加面向摄像机的代码
    vec3 instancePosition = vec3(modelMatrix * vec4(vec3(0.),1.));
    #ifdef USE_INSTANCING
      instancePosition = vec3(instanceMatrix * vec4(vec3(0.),1.));
    #endif

    vec3 normalFace = vec3(0.,1.,0.);
    vec3 cameraDir = normalize(cameraPosition.xyz - instancePosition);
    vec3 vcV = normalize(cross( normalFace,cameraDir ));
    vec3 vcU = normalize(cross( cameraDir,vcV ));
    vec3 vcN = normalize(cross( vcV,vcU ));
    mat3 viewMatrix = mat3( vcV, vcU, vcN );


    float scale = 1.;
    #ifdef USE_DISTANCE_SCALING
      scale = pow(length(cameraPosition - instancePosition) / 50000., 0.8);
    #endif

    vec3 mvPosition = viewMatrix * vec3( position * scale);
    #ifdef USE_INSTANCING
      mvPosition.xyz += instancePosition;
    #endif
    gl_Position = projectionMatrix * modelViewMatrix * vec4(mvPosition, 1.0);
    viewerUV = vec4((gl_Position.xyz / gl_Position.w).xy* 0.5 + 0.5,0.,1.);
}`;
function BO() {
    Ag.matcap = Ae.ut_scar_matcap.value
}
function FO(t) {
    if (!t) {
        console.warn("ReflectMaterial: no mesh parameter");
        return
    }
    const n = {
        color: {
            value: new Xi
        },
        map: Ae.ut_floorMap,
        opacity: {
            value: 1
        },
        roughness: {
            value: 1
        },
        roughnessMap: {
            value: null
        },
        metalness: {
            value: 1
        },
        metalnessMap: {
            value: null
        },
        aoMap: {
            value: null
        },
        lightMap: {
            value: null
        },
        lightMapColor: Ae.u_floorLightMapColor,
        lightMapIntensity: {
            value: 1
        },
        emissive: {
            value: new Xi
        },
        emissiveMap: {
            value: null
        },
        normalMap: {
            value: null
        },
        distortionScale: {
            value: 0
        },
        u_lightIntensity: Ae.u_floorLightMapIntensity,
        u_reflectIntensity: Ae.u_floorReflectIntensity,
        u_floor_typeSwitch: Ae.u_floor_typeSwitch,
        ut_street: Ae.ut_street,
        u_floorUVOffset: Ae.u_floorUVOffset,
        ...gA.fog,
        ...gA.lights,
        ...Ae.u_reflect
    }
      , r = {}
      , s = t.material;
    if (s) {
        n.color = {
            value: s.color
        },
        r.USE_MAP = "",
        n.opacity = {
            value: s.opacity
        },
        s.roughnessMap && (n.roughnessMap = {
            value: s.roughnessMap
        },
        r.USE_ROUGHNESS_MAP = ""),
        n.metalness = {
            value: s.metalness
        },
        s.metalnessMap && (n.metalnessMap = {
            value: s.metalnessMap
        },
        r.USE_METALNESS_MAP = ""),
        n.emissive = {
            value: s.emissive
        },
        s.emissiveMap && (n.emissiveMap = {
            value: s.emissiveMap
        },
        r.USE_EMISSIVE_MAP = ""),
        s.aoMap && (n.aoMap = {
            value: s.aoMap
        },
        r.USE_AO_MAP = ""),
        n.lightMapIntensity = {
            value: s.lightMapIntensity
        },
        s.lightMap && (n.lightMap = {
            value: s.lightMap
        },
        r.USE_LIGHT_MAP = ""),
        s.normalMap && (s.normalMap.anisotropy = 4,
        n.normalMap = {
            value: s.normalMap
        },
        r.USE_NORMAL_MAP = "");
        const h = new Wo({
            defines: r,
            uniforms: n,
            vertexShader: IO,
            fragmentShader: LO
        });
        h.name = "M_Reflect",
        t.material = h
    } else
        console.log("ReflectMaterial: not a MeshStandardMaterial")
}
const kO = new Wo({
    uniforms: {
        time: Ae.u_speedTime,
        vSpeed: Ae.u_speedUpBackgroundValue,
        vPoliceColorChange: Ae.u_policeColorChange
    },
    vertexShader: If,
    fragmentShader: `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec3 vPositionW;
    varying vec3 vNormalW;

    uniform float vPoliceColorChange;
    uniform float vSpeed;
    uniform float time;

    ${wg}
    ${DO}
    void main() {
        vec2 uv_0 = vUv+vec2(-time*0.5,0.);
        float noiseMask = (noise2d(uv_0*vec2(3.,100.))+1.)/2.;
        noiseMask = pow(clamp(noiseMask-0.1,0.,1.),11.);
        noiseMask = smoothstep(0.0,0.04,noiseMask)*2.;

        vec3 colorNoiseMask = colorNoise(uv_0*vec2(10.,100.))*vec3(1.5,1.,400.);
        noiseMask*=smoothstep(0.02,0.5,vUv.x)*smoothstep(0.02,0.5,1.-vUv.x);
        noiseMask*=smoothstep(0.01,0.1,vUv.y)*smoothstep(0.01,0.1,1.-vUv.y);

        noiseMask*=smoothstep(1.,10.,vSpeed);

        colorNoiseMask = clamp(colorNoiseMask,vec3(0.),vec3(1.));

        vec3 policeColor = mix(vec3(3.,.3,.3),vec3(0.3,0.3,3.),vec3(smoothstep(0.10,0.30,colorNoiseMask.g)));
        colorNoiseMask = mix(colorNoiseMask,policeColor,vec3(vPoliceColorChange));

        gl_FragColor = vec4(vec3(colorNoiseMask),noiseMask);
        // #include <tonemapping_fragment>
        // #include <encodings_fragment>
    }
    `,
    depthWrite: !1,
    transparent: !0
});
function AA(t) {
    let n = t.fragmentShader
      , r = t.vertexShader;
    r = r.replace("#include <common>", `
            #include <common>
            varying vec3 reflectVec;
            varying vec3 vPosW;
            #if (!defined(USE_UV))
                #define USE_UV
            #endif
            `),
    r = r.replace("#include <fog_vertex>", `
            #include <fog_vertex>
            vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );
            vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
            reflectVec = reflect( cameraToVertex, worldNormal);
            vPosW = worldPosition.xyz;
            `),
    n = n.replace("#include <common>", `
            #include <common>
            varying vec3 reflectVec;
            varying vec3 vPosW;
            uniform samplerCube cubeCaptureReflectMap;
            uniform samplerCube blurCaptureReflectMap;
            uniform float vEnvMapIntensity;
            uniform float vDiscardOpacity;
            ${wg}
            #if (!defined(USE_UV))
                #define USE_UV
            #endif

            `),
    n = n.replace("#include <envmap_physical_pars_fragment>", `
            #if defined( USE_ENVMAP )

            #if defined( USE_BOX_PROJECTION )

                uniform vec4 probePos;
                uniform vec3 probeBoxMin;
                uniform vec3 probeBoxMax;

                vec3 boxProjection(vec3 nrdir, vec3 worldPos, vec3 probePos, vec3 boxMin, vec3 boxMax) {

                    vec3 tbot = boxMin - worldPos;
                    vec3 ttop = boxMax - worldPos;
                    vec3 tmax = mix(tbot, ttop, step(vec3(0), nrdir));
                    tmax /= nrdir;
                    float t = min(min(tmax.x, tmax.y), tmax.z);
                    return worldPos + nrdir * t - probePos;

                }
            #endif
                vec3 getIBLIrradiance( const in vec3 normal ) {

                    //添加光源
                    #if defined( ENVMAP_TYPE_CUBE_UV )

                        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

                        #if defined( USE_BOX_PROJECTION )
                            if (probePos.w > 0.001) {
                                worldNormal = boxProjection(worldNormal, vWorldPosition, probePos.xyz, probeBoxMin.xyz, probeBoxMax.xyz);
                            }
                        #endif

                        vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1. );
                        vec4 reflectColor = textureLod( blurCaptureReflectMap, worldNormal, 0.);

                        return PI * mix( reflectColor.rgb, envMapColor.rgb, vEnvMapIntensity);
                    #else

                        return vec3( 0.0 );

                    #endif

                }

                vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {

                    #if defined( ENVMAP_TYPE_CUBE_UV )

                        vec3 reflectVec = reflect( - viewDir, normal );

                        // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
                        reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

                        reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

                    #if defined( USE_BOX_PROJECTION )
                        if (probePos.w > 0.001) {
                            reflectVec = boxProjection(reflectVec, vWorldPosition, probePos.xyz, probeBoxMin.xyz, probeBoxMax.xyz);
                        }
                    #endif

                        vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
                        envMapColor.rgb *= vEnvMapIntensity;

                        float lod = roughness*(1.7 - 0.7*roughness);
                        //粗糙度高的时候反射稍稍强一点
                        envMapColor.rgb += textureLod( cubeCaptureReflectMap, reflectVec, lod*6. ).rgb * (3.+roughness);

                        return envMapColor.rgb;
                    #else

                        return vec3( 0.0 );

                    #endif

                }

            #endif
            `),
    n = n.replace("#include <clipping_planes_fragment>", `

            float discardMask = (noise2d(vUv*15.)+1.)/2.;
            float mm = 1.-(vPosW.x+2.7)/5.4;
            if(mm < (1. - vDiscardOpacity)) discard;
            #include <clipping_planes_fragment>
            `),
    n = n.replace("#include <dithering_fragment>", `
            #include <dithering_fragment>
            float discardLightMask = (1.-step(mm,(1. - vDiscardOpacity)))*step(mm,(1. - vDiscardOpacity)+0.002);
            gl_FragColor = vec4(vec3(mix(gl_FragColor.rgb,vec3(0.5,0.9,1.),vec3(discardLightMask))),gl_FragColor.a);
            `),
    t.uniforms.cubeCaptureReflectMap = Ae.ut_cubeCapture,
    t.uniforms.blurCaptureReflectMap = Ae.ut_blurCapture,
    t.uniforms.vEnvMapIntensity = Ae.u_car_envMapIntensity,
    t.uniforms.vDiscardOpacity = Ae.u_car_discard,
    t.vertexShader = r,
    t.fragmentShader = n
}
function UO(t) {
    let n = t.fragmentShader
      , r = t.vertexShader;
    r = r.replace("#include <common>", `
            #include <common>
            varying vec2 vUv2;
            attribute vec2 uv2;
            `),
    r = r.replace("#include <fog_vertex>", `
            #include <fog_vertex>
            vUv2 = uv2;
            `),
    n = n.replace("#include <common>", `
            #include <common>
            uniform float timer;
            varying vec2 vUv2;
            `),
    n = n.replace("#include <emissivemap_fragment>", `
            #ifdef USE_EMISSIVEMAP
                vec4 emissiveColor = texture2D( emissiveMap, vUv);
                // totalEmissiveRadiance *= ;
                // totalEmissiveRadiance *= emissiveColor.rgb * (step((cos(vUv2.x*10.+timer*20.)+1.),0.5)+0.);
                totalEmissiveRadiance =  emissiveColor.rgb*50.+totalEmissiveRadiance*emissiveColor.rgb * (step((cos(vUv2.x*10.+timer*20.)+1.),0.5)+0.);
            #endif
            `),
    t.uniforms.timer = Ae.u_time,
    t.vertexShader = r,
    t.fragmentShader = n
}
const NO = new Wo({
    name: "m_curvature",
    uniforms: {
        opacity: {
            value: 1
        },
        vColor: {
            value: new Xi("#fdffc7")
        },
        tSaLine: Ae.ut_saLine,
        time: Ae.u_time
    },
    vertexShader: If,
    fragmentShader: `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec3 vPositionW;
    varying vec3 vNormalW;

    uniform sampler2D tSaLine;
    uniform vec3 vColor;
    uniform float opacity;
    uniform float time;
    void main() {
        vec2 l_uv = vUv*50.+vec2(-time,0.);
        float mask = texture(tSaLine,l_uv).r;
        mask*=(1.-smoothstep(0.2,0.28,vUv.x));

        gl_FragColor = vec4(vec3(vColor),mask*opacity);
    }
    `,
    depthWrite: !1,
    side: bg,
    transparent: !0
})
  , zO = new Wo({
    name: "m_windLine",
    uniforms: {
        vNoiseParams_alpha: {
            value: new Af(6,2,2,.5)
        },
        vNoiseParams_wave: {
            value: new Af(2,1,1,.5)
        },
        vIntensity: {
            value: 3
        },
        vColor: {
            value: new Xi("#cdeffe")
        },
        tSaLine: Ae.ut_saLine,
        time: Ae.u_time,
        opacity: {
            value: 1
        }
    },
    vertexShader: If,
    fragmentShader: `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec3 vPositionW;
    varying vec3 vNormalW;

    uniform vec4 vNoiseParams_alpha;
    uniform vec4 vNoiseParams_wave;
    uniform float vIntensity;
    uniform vec3 vColor;
    uniform float time;
    uniform float opacity;
    uniform sampler2D tSaLine;
    ${wg}

    void main() {
        float noiseMask_alpha = noise2d((vUv+vec2(0.,time*vNoiseParams_alpha.w))*vNoiseParams_alpha.xy)*vNoiseParams_alpha.z;
        float noiseMask_wave = noise2d((vUv+vec2(0.,time*vNoiseParams_wave.w))*vNoiseParams_wave.xy)*vNoiseParams_wave.z;
        vec2 l_uv = vUv*10.;
        float mask = texture(tSaLine,l_uv+vec2(noiseMask_wave,0.)).r;
        // float mask = texture(tSaLine,l_uv).r;
        mask*=(smoothstep(0.,0.5,vUv.y))*(1.-smoothstep(0.5,1.,vUv.y));

        gl_FragColor = vec4(vec3(vColor),clamp(mask*(noiseMask_alpha+0.5)*vIntensity*opacity,0.,1.));
    }
    `,
    transparent: !0,
    depthWrite: !1,
    side: bg
})
  , GO = new Wo({
    name: "m_linecar",
    uniforms: {
        time: Ae.u_time,
        opacity: {
            value: 1
        },
        vNoiseParams_wave: {
            value: new Af(1,20,10,1.2)
        }
    },
    vertexShader: If,
    fragmentShader: `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec3 vPositionW;
    varying vec3 vNormalW;
    varying vec3 vColor;

    uniform float time;
    uniform float opacity;
    uniform vec4 vNoiseParams_wave;
    ${wg}

    void main() {
        float noiseMask_alpha = noise2d((vUv+vec2(time*vNoiseParams_wave.w,0.))*vNoiseParams_wave.xy)*vNoiseParams_wave.z;
        float mask = noiseMask_alpha*(smoothstep(0.05,0.4,vUv.x))*(1.-smoothstep(0.6,0.95,vUv.x));
        mask = mask*(smoothstep(0.05,0.4,vUv.y))*(1.-smoothstep(0.6,0.95,vUv.y));
        gl_FragColor = vec4(clamp(vec3(vColor*2.),0.,1.),clamp(mask*opacity,0.,1.));
    }

    `,
    transparent: !0,
    depthWrite: !1,
    blending: xg,
    side: bg
})
  , HO = new Wo({
    name: "m_carradar",
    uniforms: {
        time: Ae.u_time,
        opacity: {
            value: 1
        },
        uColor: {
            value: new Xi("#88eeff")
        },
        uCenter1: Ae.u_simpleCarCenter1,
        uCenter2: Ae.u_simpleCarCenter2
    },
    vertexShader: If,
    fragmentShader: `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec3 vPositionW;
    varying vec3 vNormalW;

    uniform vec3 uColor;
    uniform float time;
    uniform float opacity;
    uniform vec3 uCenter1;
    uniform vec3 uCenter2;

    const float X_By_Y = 2.3; //  x/z椭圆长宽比

    //椭圆化
    float normalizedEllipticalDistance(vec3 position, vec3 center, float radius) {
        vec2 d = center.xz - position.xz;
        d.y *= X_By_Y;
        return length(d) / radius;
    }

    void main() {

        float distanceP = clamp(1. - normalizedEllipticalDistance(vPositionW, uCenter1, 4.3), 0., 1.);
        distanceP += clamp(1. - normalizedEllipticalDistance(vPositionW, uCenter2, 4.3), 0., 1.);

        float uv_x = vUv.x*10. - time*3.;
        float maskCos = cos(uv_x);

        float maskX = mod(vUv.x*10.-time*3.,1.);
        maskX = step(maskX,0.2+distanceP*0.8);
        maskX *= maskCos;

        float maskY = mod(vUv.y*100.,1.);
        maskY = step(maskY,0.2);

        float mask = maskX*maskY;

        vec3 color = mix(uColor,vec3(0.1,1.,0.2),vec3(smoothstep(0.,0.5,distanceP)));

        gl_FragColor = vec4(vec3(color),clamp(mask*opacity,0.,1.));
        // gl_FragColor = vec4(vec3(distanceP),1.);
    }

    `,
    transparent: !0,
    depthWrite: !1,
    blending: xg,
    side: bg
})
  , Ag = new oO({
    transparent: !0,
    blending: xg
});
Ag.onBeforeCompile = t=>{
    let n = t.fragmentShader
      , r = t.vertexShader;
    r = r.replace("#include <common>", `
        #include <common>
        varying vec3 vWorldPosition;
        `),
    r = r.replace("#include <fog_vertex>", `
        #include <fog_vertex>
        vWorldPosition = vec3( modelMatrix*vec4( position, 1.0 ));
        `),
    n = n.replace("#include <common>", `
        #include <common>
        varying vec3 vWorldPosition;
        `),
    n = n.replace("vec4 diffuseColor = vec4( diffuse, opacity );", `
        float op = opacity*clamp(1.-abs(vWorldPosition.x)/14.,0.,1.);
        vec4 diffuseColor = vec4( diffuse, op );
        `),
    t.vertexShader = r,
    t.fragmentShader = n
}
;
const SA = new Wo({
    name: "m_radarPoints",
    uniforms: {
        time: Ae.u_time,
        opacity: {
            value: 0
        },
        vColor: {
            value: new Xi("#fff")
        }
    },
    vertexShader: OO,
    fragmentShader: `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec3 vPositionW;
    varying vec3 vNormalW;

    uniform float time;
    uniform float opacity;
    uniform vec3 vColor;

    void main() {
        float distanceUV = length(vUv-vec2(0.5,0.5));
        distanceUV = smoothstep(distanceUV,0.2,1.);
        gl_FragColor = vec4(vec3(vColor),opacity*distanceUV);
        // gl_FragColor = vec4(vec3(distanceP),1.);
    }

    `,
    blending: xg,
    depthWrite: !1,
    transparent: !0
});
var VO = Object.defineProperty
  , WO = Object.getOwnPropertyDescriptor
  , uM = (t,n,r,s)=>{
    for (var h = s > 1 ? void 0 : s ? WO(n, r) : n, l = t.length - 1, g; l >= 0; l--)
        (g = t[l]) && (h = (s ? g(n, r, h) : g(h)) || h);
    return s && h && VO(n, r, h),
    h
}
;
const jO = `
varying vec2   vUv;

void main() {
    vUv = uv;
    gl_Position = vec4(position, 1.);
}
`
  , XO = `
uniform sampler2D tEnv0;
uniform sampler2D tEnv1;
uniform float     weight;
uniform float     intensity;

varying vec2      vUv;

void main() {
    vec3 col0 = texture(tEnv0, vUv).rgb;
    vec3 col1 = texture(tEnv1, vUv).rgb;
    gl_FragColor = vec4(mix(col0, col1, weight) * intensity, 1.);
}
`;
class Ky extends wo {
    constructor(r) {
        super();
        B(this, "_envRT");
        B(this, "_mixMaterial");
        B(this, "_pmremGenerator");
        B(this, "_needsUpdate", !0);
        this._init = ()=>{
            const s = r.envMap0
              , h = r.envMap1;
            this._mixMaterial = new Wo({
                vertexShader: jO,
                fragmentShader: XO,
                uniforms: {
                    tEnv0: {
                        value: s
                    },
                    tEnv1: {
                        value: h
                    },
                    intensity: {
                        value: 1
                    },
                    weight: {
                        value: 0
                    }
                }
            });
            const l = s.source.data;
            this._envRT = new lM(l.width,l.height,{
                magFilter: fA,
                minFilter: fA,
                generateMipmaps: !1,
                type: eO,
                format: k_,
                encoding: th,
                depthBuffer: !1
            }),
            this._envRT.texture.mapping = q3
        }
    }
    get intensity() {
        return this._mixMaterial.uniforms.intensity.value
    }
    set intensity(r) {
        this._mixMaterial.uniforms.intensity.value !== r && (this._mixMaterial.uniforms.intensity.value = r,
        this._needsUpdate = !0)
    }
    get weight() {
        return this._mixMaterial.uniforms.weight.value
    }
    set weight(r) {
        this._mixMaterial.uniforms.weight.value !== r && (this._mixMaterial.uniforms.weight.value = r,
        this._needsUpdate = !0)
    }
    get envMap() {
        return this._envRT.texture
    }
    onLoad() {
        this._init && this._init()
    }
    update() {
        this._needsUpdate && (this._needsUpdate = !1,
        Q3(this.viewer.renderer, this._envRT, this._mixMaterial))
    }
    onDestroy() {
        var r;
        this._envRT.dispose(),
        this._mixMaterial.dispose(),
        (r = this._pmremGenerator) == null || r.dispose()
    }
}
uM([ua({
    min: 0,
    max: 1,
    step: .01
})], Ky.prototype, "intensity", 1);
uM([ua({
    min: 0,
    max: 1,
    step: .01
})], Ky.prototype, "weight", 1);
var U_ = (t=>(t[t.dark = 0] = "dark",
t[t.night = 1] = "night",
t[t.light = 2] = "light",
t))(U_ || {});
class YO extends wo {
    constructor(r, s) {
        super();
        B(this, "_dynamicEnv");
        this.onLoad = ()=>{
            this._dynamicEnv = this.viewer.addNode(new Ky({
                envMap0: r,
                envMap1: s
            })),
            this._dynamicEnv.intensity = 0,
            this._dynamicEnv.weight = 0,
            this.viewer.scene.environment = this._dynamicEnv.envMap
        }
    }
    setState(r, s=1, h=Jt.Easing.Cubic.InOut, l=1) {
        switch (r) {
        case 0:
            Jt.TweenManager.KillTweensOf(this._dynamicEnv),
            Jt.TweenManager.Tween(this._dynamicEnv).to({
                intensity: 0,
                weight: 0
            }, s).easing(h).start();
            break;
        case 1:
            Jt.TweenManager.KillTweensOf(this._dynamicEnv),
            Jt.TweenManager.Tween(this._dynamicEnv).to({
                intensity: l,
                weight: 0
            }, s).easing(h).start();
            break;
        case 2:
            Jt.TweenManager.KillTweensOf(this._dynamicEnv),
            Jt.TweenManager.Tween(this._dynamicEnv).to({
                intensity: l,
                weight: 1
            }, s).easing(h).start();
            break
        }
    }
}
const TA = new Xi("#000000")
  , QO = new Xi("#000000")
  , KO = new Xi("#ffffff");
class ZO extends wo {
    constructor(r) {
        super();
        B(this, "_lightMaterial");
        B(this, "_lightValue", 0);
        this.onLoad = ()=>{
            this._lightMaterial = r.meshData.materials.Car_ight,
            this._lightMaterial.toneMapped = !1,
            this._lightMaterial.aoMapIntensity = 0,
            this._lightMaterial.color = TA,
            this._lightMaterial.needsUpdate = !0
        }
    }
    set lightValue(r) {
        this._lightValue = r,
        TA.copy(QO).lerp(KO, r)
    }
    get lightValue() {
        return this._lightValue
    }
}
class qO extends wo {
    constructor(r) {
        super();
        B(this, "_lightMaterial");
        this.onLoad = ()=>{
            this._lightMaterial = r.meshData.materials.light,
            this._lightMaterial.emissive.setRGB(0, 0, 0),
            this._lightMaterial.transparent = !0,
            this._lightMaterial.depthWrite = !1,
            this._lightMaterial.needsUpdate = !0,
            this.opacity = 1
        }
    }
    get lightEmissiveIntensity() {
        return this._lightMaterial.emissiveIntensity
    }
    set lightEmissiveIntensity(r) {
        this._lightMaterial.emissiveIntensity = r
    }
    get lightEmissiveColor() {
        return this._lightMaterial.emissive
    }
    set lightEmissiveColor(r) {
        this._lightMaterial.emissive.copy(r)
    }
    get opacity() {
        return this._lightMaterial.opacity
    }
    set opacity(r) {
        this._lightMaterial.opacity = r
    }
}
class JO extends wo {
    onEnable() {
        this.viewer.on(Rs.POINTER_DOWN, this._onPointerDown, this),
        this.viewer.on(Rs.POINTER_UP, this._onPointerUp, this)
    }
    onDisable() {
        this.viewer.off(Rs.POINTER_DOWN, this._onPointerDown, this),
        this.viewer.off(Rs.POINTER_UP, this._onPointerUp, this)
    }
    _onPointerDown() {
        Ie.emit(Ie.CLICKEFFECT, !0)
    }
    _onPointerUp() {
        Ie.emit(Ie.CLICKEFFECT, !1)
    }
}
const EA = new Li;
class $O extends wo {
    constructor(r, s) {
        super();
        B(this, "_wheels");
        B(this, "_targetVelocity", 0);
        B(this, "_currentVelocity", 0);
        B(this, "_lerpStrength", 1);
        B(this, "_springCameraOB");
        this.onLoad = ()=>{
            const h = r.children[0].children.find(l=>l.name == "Wheel");
            this._wheels = h,
            this._springCameraOB = s
        }
    }
    set targetVelocity(r) {
        this._targetVelocity = r
    }
    set lerpStrength(r) {
        this._lerpStrength = r
    }
    update(r) {
        this._currentVelocity = rl(this._currentVelocity, this._targetVelocity, r * this._lerpStrength);
        for (const h of this._wheels.children)
            h.rotateZ(-this._currentVelocity * r / (Math.PI * .737774) * 2 * Math.PI);
        Ae.u_floorUVOffset.value.x += this._currentVelocity * r;
        let s = Ae.u_speedUpBackgroundValue.value;
        Ie.currentShowingState == Bn.State1 ? s = rl(s, this._currentVelocity, r * 2) : s = rl(s, 0, r * 5),
        Ae.u_speedUpBackgroundValue.value = s,
        EA.set(1, 1, 1).multiplyScalar(s / 5),
        this._springCameraOB._springCamera.positionScale.copy(EA),
        s < .1 ? Ae.sm_speedup.visible = !1 : Ae.sm_speedup.visible = !0
    }
}
class Vl extends wo {
    constructor() {
        super(...arguments);
        B(this, "controller", null)
    }
    show(r=1, s=0) {
        Jt.TweenManager.KillTweensOf(this.controller),
        Jt.TweenManager.Tween(this.controller).delay(s).to({
            visibility: 1
        }, r).easing(Jt.Easing.Cubic.InOut).start()
    }
    hide(r=1, s=0) {
        Jt.TweenManager.KillTweensOf(this.controller),
        Jt.TweenManager.Tween(this.controller).delay(s).to({
            visibility: 0
        }, r).easing(Jt.Easing.Cubic.InOut).start()
    }
}
class eB extends Vl {
    onLoad() {
        const {materials: n} = Ae.sm_size.meshData;
        this.viewer.addNode(Ae.sm_size),
        this.controller = new Proxy({
            visibility: 1
        },{
            set: (r,s,h)=>(r[s] = h,
            h >= .005 ? Ae.sm_size.visible = !0 : Ae.sm_size.visible = !1,
            Object.values(n).forEach(l=>{
                l.opacity = h,
                l instanceof Wo && (l.uniforms.opacity.value = h)
            }
            ),
            !0)
        }),
        this.controller.visibility = 0
    }
}
class tB extends Vl {
    onLoad() {
        const {materials: n} = Ae.sm_curvature.meshData;
        this.viewer.addNode(Ae.sm_curvature),
        this.controller = new Proxy({
            visibility: 1
        },{
            set: (r,s,h)=>(r[s] = h,
            h >= .005 ? Ae.sm_curvature.visible = !0 : Ae.sm_curvature.visible = !1,
            Object.values(n).forEach(l=>{
                l.opacity = h,
                l instanceof Wo && (l.uniforms.opacity.value = h)
            }
            ),
            !0)
        }),
        this.controller.visibility = 0
    }
}
class nB extends Vl {
    onLoad() {
        const {materials: n} = Ae.sm_windspeed.meshData;
        this.viewer.addNode(Ae.sm_windspeed),
        this.controller = new Proxy({
            visibility: 1
        },{
            set: (r,s,h)=>(r[s] = h,
            h >= .005 ? Ae.sm_windspeed.visible = !0 : Ae.sm_windspeed.visible = !1,
            Object.values(n).forEach(l=>{
                l.opacity = h,
                l instanceof Wo && (l.uniforms.opacity.value = h)
            }
            ),
            !0)
        }),
        this.controller.visibility = 0
    }
}
class iB extends Vl {
    onLoad() {
        const {materials: n} = Ae.sm_linecar.meshData;
        this.viewer.addNode(Ae.sm_linecar),
        this.controller = new Proxy({
            visibility: 1
        },{
            set: (r,s,h)=>(r[s] = h,
            h >= .005 ? Ae.sm_linecar.visible = !0 : Ae.sm_linecar.visible = !1,
            Object.values(n).forEach(l=>{
                Ae.u_car_discard.value = 1 - h,
                l.opacity = h,
                l instanceof Wo && (l.uniforms.opacity.value = h)
            }
            ),
            !0)
        }),
        this.controller.visibility = 0
    }
}
class rB extends Vl {
    onLoad() {
        const {materials: n} = Ae.sm_carradar.meshData;
        this.viewer.addNode(Ae.sm_carradar),
        this.controller = new Proxy({
            visibility: 1
        },{
            set: (r,s,h)=>(r[s] = h,
            Ae.u_floor_typeSwitch.value = h,
            h >= .005 ? Ae.sm_carradar.visible = !0 : Ae.sm_carradar.visible = !1,
            Object.values(n).forEach(l=>{
                l.opacity = h,
                l instanceof Wo && (l.uniforms.opacity.value = h)
            }
            ),
            !0)
        }),
        this.controller.visibility = 0
    }
}
class sB extends Vl {
    constructor() {
        super(...arguments);
        B(this, "_length", 17);
        B(this, "_car1");
        B(this, "_car2");
        B(this, "_moveParams1", new Li);
        B(this, "_moveParams2", new Li)
    }
    onLoad() {
        this._car1 = Ae.sm_simpleCar.children[0],
        this._car2 = this._car1.clone(),
        Ae.sm_simpleCar.add(this._car2),
        this.viewer.addNode(Ae.sm_simpleCar),
        this.controller = new Proxy({
            visibility: 1
        },{
            set: (r,s,h)=>(r[s] = h,
            h >= .005 ? Ae.sm_simpleCar.visible = !0 : Ae.sm_simpleCar.visible = !1,
            Ag.opacity = h,
            !0)
        }),
        this.controller.visibility = 0,
        this.randomUpdate(this._moveParams1, this._car1),
        this.randomUpdate(this._moveParams2, this._car2)
    }
    randomUpdate(r, s) {
        r.x = Math.random() > .5 ? -1 : 1,
        r.y = Math.random() * 3 + 2.5,
        r.z = Math.random() * 2 + 1,
        s.position.x = this._length * -r.x
    }
    update(r) {
        if (this._car1 && this._car2) {
            const s = this._car1.position;
            s.set(s.x + r * this._moveParams1.z * this._moveParams1.x, s.y, this._moveParams1.y),
            Ae.u_simpleCarCenter1.value.copy(s),
            Math.abs(s.x) > this._length && this.randomUpdate(this._moveParams1, this._car1);
            const h = this._car2.position;
            h.set(h.x + r * this._moveParams2.z * this._moveParams2.x, s.y, -this._moveParams2.y),
            Ae.u_simpleCarCenter2.value.copy(h),
            Math.abs(h.x) > this._length && this.randomUpdate(this._moveParams2, this._car2)
        }
    }
}
const Fd = [[.65, 1.04, -1.16], [-.35, 1.43, -.69], [1.08, .72, -1.01], [1.95, .76, -1], [-1.66, 1.34, 0], [-1.95, .58, -1], [.35, 1.44, -.08], [.26, 1.46, -0], [2.53, .45, -.64], [2.73, .43, -.3], [2.78, .43, -0], [-2.3, .67, -.88], [-2.72, .68, 0], [-2.69, .62, -.4], [-2.24, .53, -.94], [.65, 1.04, 1.16], [-.35, 1.43, .69], [1.08, .72, 1.01], [1.95, .76, 1], [-1.95, .58, 1], [.35, 1.44, .08], [2.53, .45, .64], [2.73, .43, .3], [-2.3, .67, .88], [-2.69, .62, .4], [-2.24, .53, .94], [2.62, .43, .4], [-2.69, .62, -.4]]
  , MA = new F_
  , CA = new Li
  , oB = new il
  , aB = new Li(1,1,1);
class lB extends Vl {
    onLoad() {
        const n = new hO(.1,.1)
          , r = new nO(n,SA,Fd.length);
        for (let s = 0; s < Fd.length; s++)
            CA.set(Fd[s][0], Fd[s][1], Fd[s][2]),
            MA.compose(CA, oB, aB),
            r.setMatrixAt(s, MA);
        r.instanceMatrix.needsUpdate = !0,
        this.viewer.scene.add(r),
        this.controller = new Proxy({
            visibility: 1
        },{
            set: (s,h,l)=>(s[h] = l,
            l >= .005 ? r.visible = !0 : r.visible = !1,
            SA.uniforms.opacity.value = l,
            !0)
        }),
        this.controller.visibility = 0
    }
}
const PA = new Li;
class cB extends Vl {
    constructor() {
        super(...arguments);
        B(this, "_originPos", new Li);
        B(this, "_originRotZ", 0);
        B(this, "_targetPos", new Li(-2.3626,1.1511,0));
        B(this, "_targetRotZ", -12.9 / 360 * Math.PI * 2)
    }
    onLoad() {
        const r = Ae.sm_car.children[0].children.find(s=>s.name == "WeiYi");
        this._originPos.copy(r.position),
        this._originRotZ = r.rotation.z,
        this.controller = new Proxy({
            visibility: 1
        },{
            set: (s,h,l)=>(s[h] = l,
            PA.copy(this._originPos).lerp(this._targetPos, l),
            r.position.copy(PA),
            r.rotation.z = rl(this._originRotZ, this._targetRotZ, l),
            !0)
        }),
        this.controller.visibility = 0
    }
}
class uB extends wo {
    constructor() {
        super(...arguments);
        B(this, "_sound");
        B(this, "_beatID", -1);
        B(this, "_scan0ID", -1);
        B(this, "_scan0Changed", !1);
        B(this, "_bubuID", -1)
    }
    onLoad() {
        this._sound = new tO({
            src: [ai.autoURL("res/audios/bgm2.mp3")],
            sprite: {
                melody: [0, 14534, !0],
                beat: [14535, 10900, !0],
                click: [25500, 370],
                scan0: [26e3, 734],
                scan1: [26867, 734],
                ka: [27700, 367],
                bubu: [28200, 1300, !0]
            }
        }),
        Ie.on(Ie.PLAY_BGM, ()=>{
            this._sound.play("melody"),
            this._beatID = this._sound.play("beat"),
            this._bubuID = this._sound.play("bubu"),
            this._sound.volume(0, this._bubuID)
        }
        ),
        Ie.on(Ie.PLAY_SFX, r=>{
            this._sound.play(r)
        }
        ),
        Ie.on(Ie.MUTE, r=>{
            this._sound.mute(r)
        }
        ),
        Ie.on(Ie.PRESSED_STATE_CHANGED, (r,s)=>{
            s === Bn.State1 && (Jt.TweenManager.KillTweensOf(this._sound),
            r ? (Ie.currentColorIndex === "11" && Jt.TweenManager.Timeline(this._sound).delay(1).call(()=>{
                this._sound.fade(this._sound.volume(this._bubuID), .8, 1e3, this._bubuID)
            }
            ).start(),
            this._sound.fade(this._sound.volume(this._beatID), .3, 1e3, this._beatID)) : (this._sound.fade(this._sound.volume(this._beatID), 1, 1e3, this._beatID),
            this._sound.fade(this._sound.volume(this._bubuID), 0, 1e3, this._bubuID))),
            s === Bn.State2 && (Jt.TweenManager.KillTweensOf(this._sound),
            r && Jt.TweenManager.Timeline(this._sound).delay(.3).call(()=>{
                this._sound.play("boom")
            }
            ).start()),
            s === Bn.State3 && (Jt.TweenManager.KillTweensOf(this._sound),
            r ? Jt.TweenManager.Timeline(this._sound).delay(.3).call(()=>{
                this._scan0ID = this._sound.play("scan0"),
                this._scan0Changed = !0
            }
            ).start() : this._scan0Changed && (this._scan0Changed = !1,
            this._sound.stop(this._scan0ID),
            this._sound.play("scan1")))
        }
        )
    }
    onDestroy() {
        this._sound.stop()
    }
}
var kh;
function hM(t) {
    this.mode = Fo.MODE_8BIT_BYTE,
    this.data = t,
    this.parsedData = [];
    for (var n = 0, r = this.data.length; n < r; n++) {
        var s = []
          , h = this.data.charCodeAt(n);
        h > 65536 ? (s[0] = 240 | (h & 1835008) >>> 18,
        s[1] = 128 | (h & 258048) >>> 12,
        s[2] = 128 | (h & 4032) >>> 6,
        s[3] = 128 | h & 63) : h > 2048 ? (s[0] = 224 | (h & 61440) >>> 12,
        s[1] = 128 | (h & 4032) >>> 6,
        s[2] = 128 | h & 63) : h > 128 ? (s[0] = 192 | (h & 1984) >>> 6,
        s[1] = 128 | h & 63) : s[0] = h,
        this.parsedData.push(s)
    }
    this.parsedData = Array.prototype.concat.apply([], this.parsedData),
    this.parsedData.length != this.data.length && (this.parsedData.unshift(191),
    this.parsedData.unshift(187),
    this.parsedData.unshift(239))
}
hM.prototype = {
    getLength: function(t) {
        return this.parsedData.length
    },
    write: function(t) {
        for (var n = 0, r = this.parsedData.length; n < r; n++)
            t.put(this.parsedData[n], 8)
    }
};
function $a(t, n) {
    this.typeNumber = t,
    this.errorCorrectLevel = n,
    this.modules = null,
    this.moduleCount = 0,
    this.dataCache = null,
    this.dataList = []
}
$a.prototype = {
    addData: function(t) {
        var n = new hM(t);
        this.dataList.push(n),
        this.dataCache = null
    },
    isDark: function(t, n) {
        if (t < 0 || this.moduleCount <= t || n < 0 || this.moduleCount <= n)
            throw new Error(t + "," + n);
        return this.modules[t][n]
    },
    getModuleCount: function() {
        return this.moduleCount
    },
    make: function() {
        this.makeImpl(!1, this.getBestMaskPattern())
    },
    makeImpl: function(t, n) {
        this.moduleCount = this.typeNumber * 4 + 17,
        this.modules = new Array(this.moduleCount);
        for (var r = 0; r < this.moduleCount; r++) {
            this.modules[r] = new Array(this.moduleCount);
            for (var s = 0; s < this.moduleCount; s++)
                this.modules[r][s] = null
        }
        this.setupPositionProbePattern(0, 0),
        this.setupPositionProbePattern(this.moduleCount - 7, 0),
        this.setupPositionProbePattern(0, this.moduleCount - 7),
        this.setupPositionAdjustPattern(),
        this.setupTimingPattern(),
        this.setupTypeInfo(t, n),
        this.typeNumber >= 7 && this.setupTypeNumber(t),
        this.dataCache == null && (this.dataCache = $a.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)),
        this.mapData(this.dataCache, n)
    },
    setupPositionProbePattern: function(t, n) {
        for (var r = -1; r <= 7; r++)
            if (!(t + r <= -1 || this.moduleCount <= t + r))
                for (var s = -1; s <= 7; s++)
                    n + s <= -1 || this.moduleCount <= n + s || (0 <= r && r <= 6 && (s == 0 || s == 6) || 0 <= s && s <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= s && s <= 4 ? this.modules[t + r][n + s] = !0 : this.modules[t + r][n + s] = !1)
    },
    getBestMaskPattern: function() {
        for (var t = 0, n = 0, r = 0; r < 8; r++) {
            this.makeImpl(!0, r);
            var s = Dr.getLostPoint(this);
            (r == 0 || t > s) && (t = s,
            n = r)
        }
        return n
    },
    createMovieClip: function(t, n, r) {
        var s = t.createEmptyMovieClip(n, r)
          , h = 1;
        this.make();
        for (var l = 0; l < this.modules.length; l++)
            for (var g = l * h, _ = 0; _ < this.modules[l].length; _++) {
                var A = _ * h
                  , m = this.modules[l][_];
                m && (s.beginFill(0, 100),
                s.moveTo(A, g),
                s.lineTo(A + h, g),
                s.lineTo(A + h, g + h),
                s.lineTo(A, g + h),
                s.endFill())
            }
        return s
    },
    setupTimingPattern: function() {
        for (var t = 8; t < this.moduleCount - 8; t++)
            this.modules[t][6] == null && (this.modules[t][6] = t % 2 == 0);
        for (var n = 8; n < this.moduleCount - 8; n++)
            this.modules[6][n] == null && (this.modules[6][n] = n % 2 == 0)
    },
    setupPositionAdjustPattern: function() {
        for (var t = Dr.getPatternPosition(this.typeNumber), n = 0; n < t.length; n++)
            for (var r = 0; r < t.length; r++) {
                var s = t[n]
                  , h = t[r];
                if (this.modules[s][h] == null)
                    for (var l = -2; l <= 2; l++)
                        for (var g = -2; g <= 2; g++)
                            l == -2 || l == 2 || g == -2 || g == 2 || l == 0 && g == 0 ? this.modules[s + l][h + g] = !0 : this.modules[s + l][h + g] = !1
            }
    },
    setupTypeNumber: function(t) {
        for (var n = Dr.getBCHTypeNumber(this.typeNumber), r = 0; r < 18; r++) {
            var s = !t && (n >> r & 1) == 1;
            this.modules[Math.floor(r / 3)][r % 3 + this.moduleCount - 8 - 3] = s
        }
        for (var r = 0; r < 18; r++) {
            var s = !t && (n >> r & 1) == 1;
            this.modules[r % 3 + this.moduleCount - 8 - 3][Math.floor(r / 3)] = s
        }
    },
    setupTypeInfo: function(t, n) {
        for (var r = this.errorCorrectLevel << 3 | n, s = Dr.getBCHTypeInfo(r), h = 0; h < 15; h++) {
            var l = !t && (s >> h & 1) == 1;
            h < 6 ? this.modules[h][8] = l : h < 8 ? this.modules[h + 1][8] = l : this.modules[this.moduleCount - 15 + h][8] = l
        }
        for (var h = 0; h < 15; h++) {
            var l = !t && (s >> h & 1) == 1;
            h < 8 ? this.modules[8][this.moduleCount - h - 1] = l : h < 9 ? this.modules[8][15 - h - 1 + 1] = l : this.modules[8][15 - h - 1] = l
        }
        this.modules[this.moduleCount - 8][8] = !t
    },
    mapData: function(t, n) {
        for (var r = -1, s = this.moduleCount - 1, h = 7, l = 0, g = this.moduleCount - 1; g > 0; g -= 2)
            for (g == 6 && g--; ; ) {
                for (var _ = 0; _ < 2; _++)
                    if (this.modules[s][g - _] == null) {
                        var A = !1;
                        l < t.length && (A = (t[l] >>> h & 1) == 1);
                        var m = Dr.getMask(n, s, g - _);
                        m && (A = !A),
                        this.modules[s][g - _] = A,
                        h--,
                        h == -1 && (l++,
                        h = 7)
                    }
                if (s += r,
                s < 0 || this.moduleCount <= s) {
                    s -= r,
                    r = -r;
                    break
                }
            }
    }
};
$a.PAD0 = 236;
$a.PAD1 = 17;
$a.createData = function(t, n, r) {
    for (var s = Ja.getRSBlocks(t, n), h = new dM, l = 0; l < r.length; l++) {
        var g = r[l];
        h.put(g.mode, 4),
        h.put(g.getLength(), Dr.getLengthInBits(g.mode, t)),
        g.write(h)
    }
    for (var _ = 0, l = 0; l < s.length; l++)
        _ += s[l].dataCount;
    if (h.getLengthInBits() > _ * 8)
        throw new Error("code length overflow. (" + h.getLengthInBits() + ">" + _ * 8 + ")");
    for (h.getLengthInBits() + 4 <= _ * 8 && h.put(0, 4); h.getLengthInBits() % 8 != 0; )
        h.putBit(!1);
    for (; !(h.getLengthInBits() >= _ * 8 || (h.put($a.PAD0, 8),
    h.getLengthInBits() >= _ * 8)); )
        h.put($a.PAD1, 8);
    return $a.createBytes(h, s)
}
;
$a.createBytes = function(t, n) {
    for (var r = 0, s = 0, h = 0, l = new Array(n.length), g = new Array(n.length), _ = 0; _ < n.length; _++) {
        var A = n[_].dataCount
          , m = n[_].totalCount - A;
        s = Math.max(s, A),
        h = Math.max(h, m),
        l[_] = new Array(A);
        for (var D = 0; D < l[_].length; D++)
            l[_][D] = 255 & t.buffer[D + r];
        r += A;
        var U = Dr.getErrorCorrectPolynomial(m)
          , R = new Sh(l[_],U.getLength() - 1)
          , ne = R.mod(U);
        g[_] = new Array(U.getLength() - 1);
        for (var D = 0; D < g[_].length; D++) {
            var ce = D + ne.getLength() - g[_].length;
            g[_][D] = ce >= 0 ? ne.get(ce) : 0
        }
    }
    for (var xe = 0, D = 0; D < n.length; D++)
        xe += n[D].totalCount;
    for (var Se = new Array(xe), $ = 0, D = 0; D < s; D++)
        for (var _ = 0; _ < n.length; _++)
            D < l[_].length && (Se[$++] = l[_][D]);
    for (var D = 0; D < h; D++)
        for (var _ = 0; _ < n.length; _++)
            D < g[_].length && (Se[$++] = g[_][D]);
    return Se
}
;
var Fo = {
    MODE_NUMBER: 1,
    MODE_ALPHA_NUM: 2,
    MODE_8BIT_BYTE: 4,
    MODE_KANJI: 8
}
  , el = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
}
  , oc = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
}
  , Dr = {
    PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
    G15: 1335,
    G18: 7973,
    G15_MASK: 21522,
    getBCHTypeInfo: function(t) {
        for (var n = t << 10; Dr.getBCHDigit(n) - Dr.getBCHDigit(Dr.G15) >= 0; )
            n ^= Dr.G15 << Dr.getBCHDigit(n) - Dr.getBCHDigit(Dr.G15);
        return (t << 10 | n) ^ Dr.G15_MASK
    },
    getBCHTypeNumber: function(t) {
        for (var n = t << 12; Dr.getBCHDigit(n) - Dr.getBCHDigit(Dr.G18) >= 0; )
            n ^= Dr.G18 << Dr.getBCHDigit(n) - Dr.getBCHDigit(Dr.G18);
        return t << 12 | n
    },
    getBCHDigit: function(t) {
        for (var n = 0; t != 0; )
            n++,
            t >>>= 1;
        return n
    },
    getPatternPosition: function(t) {
        return Dr.PATTERN_POSITION_TABLE[t - 1]
    },
    getMask: function(t, n, r) {
        switch (t) {
        case oc.PATTERN000:
            return (n + r) % 2 == 0;
        case oc.PATTERN001:
            return n % 2 == 0;
        case oc.PATTERN010:
            return r % 3 == 0;
        case oc.PATTERN011:
            return (n + r) % 3 == 0;
        case oc.PATTERN100:
            return (Math.floor(n / 2) + Math.floor(r / 3)) % 2 == 0;
        case oc.PATTERN101:
            return n * r % 2 + n * r % 3 == 0;
        case oc.PATTERN110:
            return (n * r % 2 + n * r % 3) % 2 == 0;
        case oc.PATTERN111:
            return (n * r % 3 + (n + r) % 2) % 2 == 0;
        default:
            throw new Error("bad maskPattern:" + t)
        }
    },
    getErrorCorrectPolynomial: function(t) {
        for (var n = new Sh([1],0), r = 0; r < t; r++)
            n = n.multiply(new Sh([1, gs.gexp(r)],0));
        return n
    },
    getLengthInBits: function(t, n) {
        if (1 <= n && n < 10)
            switch (t) {
            case Fo.MODE_NUMBER:
                return 10;
            case Fo.MODE_ALPHA_NUM:
                return 9;
            case Fo.MODE_8BIT_BYTE:
                return 8;
            case Fo.MODE_KANJI:
                return 8;
            default:
                throw new Error("mode:" + t)
            }
        else if (n < 27)
            switch (t) {
            case Fo.MODE_NUMBER:
                return 12;
            case Fo.MODE_ALPHA_NUM:
                return 11;
            case Fo.MODE_8BIT_BYTE:
                return 16;
            case Fo.MODE_KANJI:
                return 10;
            default:
                throw new Error("mode:" + t)
            }
        else if (n < 41)
            switch (t) {
            case Fo.MODE_NUMBER:
                return 14;
            case Fo.MODE_ALPHA_NUM:
                return 13;
            case Fo.MODE_8BIT_BYTE:
                return 16;
            case Fo.MODE_KANJI:
                return 12;
            default:
                throw new Error("mode:" + t)
            }
        else
            throw new Error("type:" + n)
    },
    getLostPoint: function(t) {
        for (var n = t.getModuleCount(), r = 0, s = 0; s < n; s++)
            for (var h = 0; h < n; h++) {
                for (var l = 0, g = t.isDark(s, h), _ = -1; _ <= 1; _++)
                    if (!(s + _ < 0 || n <= s + _))
                        for (var A = -1; A <= 1; A++)
                            h + A < 0 || n <= h + A || _ == 0 && A == 0 || g == t.isDark(s + _, h + A) && l++;
                l > 5 && (r += 3 + l - 5)
            }
        for (var s = 0; s < n - 1; s++)
            for (var h = 0; h < n - 1; h++) {
                var m = 0;
                t.isDark(s, h) && m++,
                t.isDark(s + 1, h) && m++,
                t.isDark(s, h + 1) && m++,
                t.isDark(s + 1, h + 1) && m++,
                (m == 0 || m == 4) && (r += 3)
            }
        for (var s = 0; s < n; s++)
            for (var h = 0; h < n - 6; h++)
                t.isDark(s, h) && !t.isDark(s, h + 1) && t.isDark(s, h + 2) && t.isDark(s, h + 3) && t.isDark(s, h + 4) && !t.isDark(s, h + 5) && t.isDark(s, h + 6) && (r += 40);
        for (var h = 0; h < n; h++)
            for (var s = 0; s < n - 6; s++)
                t.isDark(s, h) && !t.isDark(s + 1, h) && t.isDark(s + 2, h) && t.isDark(s + 3, h) && t.isDark(s + 4, h) && !t.isDark(s + 5, h) && t.isDark(s + 6, h) && (r += 40);
        for (var D = 0, h = 0; h < n; h++)
            for (var s = 0; s < n; s++)
                t.isDark(s, h) && D++;
        var U = Math.abs(100 * D / n / n - 50) / 5;
        return r += U * 10,
        r
    }
}
  , gs = {
    glog: function(t) {
        if (t < 1)
            throw new Error("glog(" + t + ")");
        return gs.LOG_TABLE[t]
    },
    gexp: function(t) {
        for (; t < 0; )
            t += 255;
        for (; t >= 256; )
            t -= 255;
        return gs.EXP_TABLE[t]
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256)
};
for (var Is = 0; Is < 8; Is++)
    gs.EXP_TABLE[Is] = 1 << Is;
for (var Is = 8; Is < 256; Is++)
    gs.EXP_TABLE[Is] = gs.EXP_TABLE[Is - 4] ^ gs.EXP_TABLE[Is - 5] ^ gs.EXP_TABLE[Is - 6] ^ gs.EXP_TABLE[Is - 8];
for (var Is = 0; Is < 255; Is++)
    gs.LOG_TABLE[gs.EXP_TABLE[Is]] = Is;
function Sh(t, n) {
    if (t.length == null)
        throw new Error(t.length + "/" + n);
    for (var r = 0; r < t.length && t[r] == 0; )
        r++;
    this.num = new Array(t.length - r + n);
    for (var s = 0; s < t.length - r; s++)
        this.num[s] = t[s + r]
}
Sh.prototype = {
    get: function(t) {
        return this.num[t]
    },
    getLength: function() {
        return this.num.length
    },
    multiply: function(t) {
        for (var n = new Array(this.getLength() + t.getLength() - 1), r = 0; r < this.getLength(); r++)
            for (var s = 0; s < t.getLength(); s++)
                n[r + s] ^= gs.gexp(gs.glog(this.get(r)) + gs.glog(t.get(s)));
        return new Sh(n,0)
    },
    mod: function(t) {
        if (this.getLength() - t.getLength() < 0)
            return this;
        for (var n = gs.glog(this.get(0)) - gs.glog(t.get(0)), r = new Array(this.getLength()), s = 0; s < this.getLength(); s++)
            r[s] = this.get(s);
        for (var s = 0; s < t.getLength(); s++)
            r[s] ^= gs.gexp(gs.glog(t.get(s)) + n);
        return new Sh(r,0).mod(t)
    }
};
function Ja(t, n) {
    this.totalCount = t,
    this.dataCount = n
}
Ja.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
Ja.getRSBlocks = function(t, n) {
    var r = Ja.getRsBlockTable(t, n);
    if (r == null)
        throw new Error("bad rs block @ typeNumber:" + t + "/errorCorrectLevel:" + n);
    for (var s = r.length / 3, h = [], l = 0; l < s; l++)
        for (var g = r[l * 3 + 0], _ = r[l * 3 + 1], A = r[l * 3 + 2], m = 0; m < g; m++)
            h.push(new Ja(_,A));
    return h
}
;
Ja.getRsBlockTable = function(t, n) {
    switch (n) {
    case el.L:
        return Ja.RS_BLOCK_TABLE[(t - 1) * 4 + 0];
    case el.M:
        return Ja.RS_BLOCK_TABLE[(t - 1) * 4 + 1];
    case el.Q:
        return Ja.RS_BLOCK_TABLE[(t - 1) * 4 + 2];
    case el.H:
        return Ja.RS_BLOCK_TABLE[(t - 1) * 4 + 3];
    default:
        return
    }
}
;
function dM() {
    this.buffer = [],
    this.length = 0
}
dM.prototype = {
    get: function(t) {
        var n = Math.floor(t / 8);
        return (this.buffer[n] >>> 7 - t % 8 & 1) == 1
    },
    put: function(t, n) {
        for (var r = 0; r < n; r++)
            this.putBit((t >>> n - r - 1 & 1) == 1)
    },
    getLengthInBits: function() {
        return this.length
    },
    putBit: function(t) {
        var n = Math.floor(this.length / 8);
        this.buffer.length <= n && this.buffer.push(0),
        t && (this.buffer[n] |= 128 >>> this.length % 8),
        this.length++
    }
};
var eh = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
function hB() {
    return typeof CanvasRenderingContext2D < "u"
}
function N_() {
    var t = !1
      , n = navigator.userAgent;
    if (/android/i.test(n)) {
        t = !0;
        var r = n.toString().match(/android ([0-9]\.[0-9])/i);
        r && r[1] && (t = parseFloat(r[1]))
    }
    return t
}
var fM = function() {
    var t = function(n, r) {
        this._el = n,
        this._htOption = r
    };
    return t.prototype.draw = function(n) {
        var r = this._htOption
          , s = this._el
          , h = n.getModuleCount();
        Math.floor(r.width / h),
        Math.floor(r.height / h),
        this.clear();
        function l(D, U) {
            var R = document.createElementNS("http://www.w3.org/2000/svg", D);
            for (var ne in U)
                U.hasOwnProperty(ne) && R.setAttribute(ne, U[ne]);
            return R
        }
        var g = l("svg", {
            viewBox: "0 0 " + String(h) + " " + String(h),
            width: "100%",
            height: "100%",
            fill: r.colorLight
        });
        g.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"),
        s.appendChild(g),
        g.appendChild(l("rect", {
            fill: r.colorLight,
            width: "100%",
            height: "100%"
        })),
        g.appendChild(l("rect", {
            fill: r.colorDark,
            width: "1",
            height: "1",
            id: "template"
        }));
        for (var _ = 0; _ < h; _++)
            for (var A = 0; A < h; A++)
                if (n.isDark(_, A)) {
                    var m = l("use", {
                        x: String(A),
                        y: String(_)
                    });
                    m.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#template"),
                    g.appendChild(m)
                }
    }
    ,
    t.prototype.clear = function() {
        for (; this._el.hasChildNodes(); )
            this._el.removeChild(this._el.lastChild)
    }
    ,
    t
}()
  , dB = document.documentElement.tagName.toLowerCase() === "svg"
  , RA = dB ? fM : hB() ? function() {
    function t() {
        this._elImage.src = this._elCanvas.toDataURL("image/png"),
        this._elImage.style.display = "block",
        this._elCanvas.style.display = "none"
    }
    const n = N_();
    if (n && n <= 2.1) {
        var r = 1 / window.devicePixelRatio
          , s = CanvasRenderingContext2D.prototype.drawImage;
        CanvasRenderingContext2D.prototype.drawImage = function(g, _, A, m, D, U, R, ne, ce) {
            console.error('drawImage:', arguments);
            if ("nodeName"in g && /img/i.test(g.nodeName))
                for (var xe = arguments.length - 1; xe >= 1; xe--)
                    arguments[xe] = arguments[xe] * r;
            else
                typeof ne > "u" && (arguments[1] *= r,
                arguments[2] *= r,
                arguments[3] *= r,
                arguments[4] *= r);
            s.apply(this, arguments)
        }
    }
    function h(g, _) {
        var A = this;
        if (A._fFail = _,
        A._fSuccess = g,
        A._bSupportDataURI === null) {
            var m = document.createElement("img")
              , D = function() {
                A._bSupportDataURI = !1,
                A._fFail && A._fFail.call(A)
            }
              , U = function() {
                A._bSupportDataURI = !0,
                A._fSuccess && A._fSuccess.call(A)
            };
            m.onabort = D,
            m.onerror = D,
            m.onload = U,
            m.src = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==";
            return
        } else
            A._bSupportDataURI === !0 && A._fSuccess ? A._fSuccess.call(A) : A._bSupportDataURI === !1 && A._fFail && A._fFail.call(A)
    }
    var l = function(g, _) {
        this._bIsPainted = !1,
        this._android = N_(),
        this._htOption = _,
        this._elCanvas = document.createElement("canvas"),
        this._elCanvas.width = _.width,
        this._elCanvas.height = _.height,
        g.appendChild(this._elCanvas),
        this._el = g,
        this._oContext = this._elCanvas.getContext("2d"),
        this._bIsPainted = !1,
        this._elImage = document.createElement("img"),
        this._elImage.alt = "Scan me!",
        this._elImage.style.display = "none",
        this._el.appendChild(this._elImage),
        this._bSupportDataURI = null
    };
    return l.prototype.draw = function(g) {
        var _ = this._elImage
          , A = this._oContext
          , m = this._htOption
          , D = g.getModuleCount()
          , U = m.width / D
          , R = m.height / D
          , ne = Math.round(U)
          , ce = Math.round(R);
        _.style.display = "none",
        this.clear();
        for (var xe = 0; xe < D; xe++)
            for (var Se = 0; Se < D; Se++) {
                var $ = g.isDark(xe, Se)
                  , q = Se * U
                  , N = xe * R;
                A.strokeStyle = $ ? m.colorDark : m.colorLight,
                A.lineWidth = 1,
                A.fillStyle = $ ? m.colorDark : m.colorLight,
                A.fillRect(q, N, U, R),
                A.strokeRect(Math.floor(q) + .5, Math.floor(N) + .5, ne, ce),
                A.strokeRect(Math.ceil(q) - .5, Math.ceil(N) - .5, ne, ce)
            }
        this._bIsPainted = !0
    }
    ,
    l.prototype.makeImage = function() {
        this._bIsPainted && h.call(this, t)
    }
    ,
    l.prototype.isPainted = function() {
        return this._bIsPainted
    }
    ,
    l.prototype.clear = function() {
        this._oContext.clearRect(0, 0, this._elCanvas.width, this._elCanvas.height),
        this._bIsPainted = !1
    }
    ,
    l.prototype.round = function(g) {
        return g && Math.floor(g * 1e3) / 1e3
    }
    ,
    l
}() : function() {
    var t = function(n, r) {
        this._el = n,
        this._htOption = r
    };
    return t.prototype.draw = function(n) {
        for (var r = this._htOption, s = this._el, h = n.getModuleCount(), l = Math.floor(r.width / h), g = Math.floor(r.height / h), _ = ['<table style="border:0;border-collapse:collapse;">'], A = 0; A < h; A++) {
            _.push("<tr>");
            for (var m = 0; m < h; m++)
                _.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + l + "px;height:" + g + "px;background-color:" + (n.isDark(A, m) ? r.colorDark : r.colorLight) + ';"></td>');
            _.push("</tr>")
        }
        _.push("</table>"),
        s.innerHTML = _.join("");
        var D = s.childNodes[0]
          , U = (r.width - D.offsetWidth) / 2
          , R = (r.height - D.offsetHeight) / 2;
        U > 0 && R > 0 && (D.style.margin = R + "px " + U + "px")
    }
    ,
    t.prototype.clear = function() {
        this._el.innerHTML = ""
    }
    ,
    t
}();
function fB(t, n) {
    for (var r = 1, s = pB(t), h = 0, l = eh.length; h <= l; h++) {
        var g = 0;
        switch (n) {
        case el.L:
            g = eh[h][0];
            break;
        case el.M:
            g = eh[h][1];
            break;
        case el.Q:
            g = eh[h][2];
            break;
        case el.H:
            g = eh[h][3];
            break
        }
        if (s <= g)
            break;
        r++
    }
    if (r > eh.length)
        throw new Error("Too long data");
    return r
}
function pB(t) {
    var n = encodeURI(t).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
    return n.length + (n.length != t ? 3 : 0)
}
kh = function(t, n) {
    if (this._htOption = {
        width: 256,
        height: 256,
        typeNumber: 4,
        colorDark: "#000000",
        colorLight: "#ffffff",
        correctLevel: el.H
    },
    typeof n == "string" && (n = {
        text: n
    }),
    n)
        for (var r in n)
            this._htOption[r] = n[r];
    typeof t == "string" && (t = document.getElementById(t)),
    this._htOption.useSVG && (RA = fM),
    this._android = N_(),
    this._el = t,
    this._oQRCode = null,
    this._oDrawing = new RA(this._el,this._htOption),
    this._htOption.text && this.makeCode(this._htOption.text)
}
;
kh.prototype.makeCode = function(t) {
    this._oQRCode = new $a(fB(t, this._htOption.correctLevel),this._htOption.correctLevel),
    this._oQRCode.addData(t),
    this._oQRCode.make(),
    this._el.title = t,
    this._oDrawing.draw(this._oQRCode),
    this.makeImage()
}
;
kh.prototype.makeImage = function() {
    typeof this._oDrawing.makeImage == "function" && (!this._android || this._android >= 3) && this._oDrawing.makeImage()
}
;
kh.prototype.clear = function() {
    this._oDrawing.clear()
}
;
kh.CorrectLevel = el;
var mB = Object.defineProperty
  , gB = Object.getOwnPropertyDescriptor
  , vB = (t,n,r,s)=>{
    for (var h = s > 1 ? void 0 : s ? gB(n, r) : n, l = t.length - 1, g; l >= 0; l--)
        (g = t[l]) && (h = (s ? g(n, r, h) : g(h)) || h);
    return s && h && mB(n, r, h),
    h
}
;
const _B = `
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="708" height="223" viewBox="0 0 708 223" fill="none">
<path d="M155.839 93.2234C140.396 89.3748 113.977 87.8351 92.3308 86.6804C80.7716 85.7822 70.6909 85.2051 64.4207 84.307C51.3763 82.5107 51.0537 69.6805 51.9542 63.1376C53.4395 54.4771 57.9019 46.4582 83.9974 43.4431C109.515 40.4281 164.428 50.628 179.22 53.2582C181.874 53.8355 183.36 53.2582 183.938 50.8846C185.423 41.3262 188.655 15.9867 188.655 15.9867C188.978 12.9717 187.493 10.919 184.522 10.0208C163.46 3.47748 120.113 -1.59041 84.2595 0.462399C57.25 1.93784 40.973 6.10765 27.5992 14.5113C5.95933 28.2395 -0.31087 48.2544 0.0117124 67.6275C0.334295 87.6423 8.3451 107.593 22.2363 117.794C35.2875 126.774 55.4422 128.506 80.7044 130.046C102.344 131.265 128.185 133.318 138.588 136.589C149.892 140.182 151.639 149.099 151.054 156.283C149.892 173.283 131.74 178.993 97.3712 178.993C68.621 178.993 47.2365 174.245 18.1704 170.332C14.9379 169.755 12.8075 170.332 12.5454 173.348L7.51176 210.041C7.18246 212.993 8.99698 215.43 11.0602 215.687C41.9407 221.332 73.0834 222.551 98.601 222.872C115.201 222.872 145.759 221.653 163.588 213.891C189.106 202.536 200.994 183.484 203.064 165.842C204.227 157.182 205.712 139.284 200.416 127.673C193.823 111.763 182.257 100.409 155.839 93.2234ZM457.273 3.99071L411.278 3.99071C409.208 3.99071 407.723 5.4661 407.723 7.26229L407.723 110.801C407.723 133.767 408.885 152.306 397.649 165.136C386.983 177.646 373.616 179.763 354.295 179.763C334.725 179.763 321.674 177.646 310.692 165.136C299.382 152.306 299.711 133.831 300.289 110.801L300.612 97.3938L300.612 7.26229C300.612 5.4661 299.126 3.99071 297.057 3.99071L251.384 3.99071C249.576 3.99071 248.152 5.4661 248.152 7.26229L248.152 110.801C248.152 148.136 250.222 179.121 271.284 200.034C291.761 220.306 317.541 223 354.362 223C390.861 223 415.478 221.204 436.54 200.612C457.017 180.019 460.243 148.072 460.243 110.801L460.243 7.26229C460.243 5.53026 459.02 3.99071 457.273 3.99071ZM704.384 3.99071L503.852 3.99071C501.789 3.99071 500.297 5.78688 500.297 7.58306L500.297 44.2771C500.297 46.3941 501.789 48.1261 503.852 48.1261L645.009 48.1261L639.458 58.2619C639.458 58.2619 573.886 168.664 550.432 213.441C549.524 215.559 550.432 218.83 552.824 218.83L604.182 218.83C606.252 218.83 609.8 218.253 610.708 216.457C638.873 168.408 682.482 91.4278 705.93 46.3941C706.837 44.2771 708 40.7489 708 36.2583L708 7.58306C708 5.78688 706.515 3.99071 704.384 3.99071Z"   fill="#424242" >
</path>
</svg>
`
  , yB = `
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="720.9970703125" height="115.619140625" viewBox="0 0 720.9970703125 115.619140625" fill="none">
<path d="M718.183 4.7692L694.916 4.7692C693.911 4.7692 693.099 5.54187 693.099 6.50771L693.099 111.013C693.099 111.947 693.911 112.752 694.916 112.752L718.183 112.752C719.154 112.752 719.997 111.979 719.997 111.013L719.997 6.50771C719.997 5.54187 719.188 4.7692 718.183 4.7692ZM646.922 12.6892C637.459 4.02868 622.228 2.96628 609.914 2.96628C594.002 2.96628 583.858 6.31456 577.703 9.40532L573.425 9.40532C567.431 6.15361 556.802 2.96628 540.176 2.96628C527.861 2.96628 512.728 3.86773 503.427 11.5302C495.714 17.8726 493.934 26.3721 493.934 43.7573L493.934 110.916C493.934 111.85 494.743 112.655 495.748 112.655L519.015 112.655C520.02 112.655 520.829 111.882 520.829 110.916L520.829 110.691C520.829 110.691 520.829 68.2258 520.829 55.6375C520.829 45.6568 520.441 35.2579 522.612 31.3946C524.328 28.3682 526.988 25.0199 539.626 25.0199C554.695 25.0199 558.258 26.0502 560.625 32.6179C561.174 34.1633 561.467 36.3847 561.596 39.0892C561.596 42.341 561.596 48.007 561.596 61.4003L561.596 110.949C561.596 111.882 562.408 112.687 563.413 112.687L563.443 112.687L586.68 112.687L586.71 112.687C587.715 112.687 588.527 111.914 588.527 110.949L588.527 61.4003C588.527 48.0394 588.527 42.373 588.527 39.0892C588.655 36.3847 588.945 34.1954 589.498 32.6179C591.865 26.0502 595.428 25.0199 610.497 25.0199C623.135 25.0199 625.791 28.4004 627.511 31.3946C629.712 35.2579 629.294 45.6568 629.294 55.6375C629.294 68.2258 629.294 110.691 629.294 110.691L629.294 110.916C629.294 111.85 630.103 112.655 631.108 112.655L654.375 112.655C655.38 112.655 656.189 111.882 656.189 110.916L656.189 47.8462C656.158 29.817 655.541 20.577 646.922 12.6892ZM177.909 4.7692L154.642 4.7692C153.637 4.7692 152.827 5.54187 152.827 6.50771L152.827 111.013C152.827 111.947 153.637 112.752 154.642 112.752L177.909 112.752C178.881 112.752 179.724 111.979 179.724 111.013L179.724 6.50771C179.724 5.54187 178.914 4.7692 177.909 4.7692ZM80.0757 57.859L121.426 7.47359C122.333 6.37896 121.523 4.73697 120.097 4.73697L90.2834 4.73697C89.5704 4.73697 88.8901 5.05898 88.4687 5.63849L61.1503 41.2783L34.4806 5.67065C34.0592 5.09114 33.3786 4.7692 32.6656 4.7692L2.75503 4.7692C1.32915 4.7692 0.551443 6.37896 1.42641 7.47359L43.2949 58.7925L1.39397 110.047C0.519006 111.142 1.32915 112.752 2.75503 112.752L32.6332 112.752C33.3462 112.752 34.0592 112.398 34.4806 111.818L62.3818 76.3067L88.825 111.818C89.2464 112.398 89.927 112.719 90.64 112.719L120.162 112.719C121.587 112.719 122.365 111.11 121.49 110.015L80.0757 57.859ZM312.88 19.096C302.121 4.51163 282.678 0.100887 262.521 1.16332C242.073 2.25798 227.814 6.50771 224.185 7.85989C221.917 8.69698 222.208 10.6287 222.176 11.7555C222.078 15.619 221.787 24.6658 221.819 28.7224C221.819 30.4931 224.055 31.3302 225.935 30.6863C233.388 28.0785 247.161 23.9253 258.243 23.056C270.201 22.0902 286.858 23.3458 291.362 30.0102C293.631 33.3906 294.02 39.7008 294.344 45.0132C286.89 44.2404 275.386 42.9525 263.947 43.5641C255.392 44.0149 239.027 45.1096 229.402 50.1644C221.56 54.2853 216.958 57.9878 214.528 64.9417C212.551 70.5436 212.032 75.888 212.648 81.3612C214.074 93.853 218.481 100.067 224.444 104.413C233.842 111.27 245.702 114.877 270.234 114.329C302.866 113.621 311.454 103.254 315.796 95.8812C323.153 83.3254 321.889 63.5253 321.662 51.3555C321.5 46.3651 320.722 29.7526 312.88 19.096ZM291.978 85.6756C288.9 92.0499 277.363 92.9515 270.849 93.2734C258.827 93.821 249.526 93.0482 243.791 90.2793C239.999 88.4442 236.92 84.2909 236.693 79.4617C236.467 75.3732 237.05 72.9582 238.832 70.4472C242.883 64.6841 254.387 63.2998 265.729 62.8814C273.636 62.5914 285.918 63.493 294.603 64.5553C294.441 73.1194 293.76 81.9407 291.978 85.6756ZM405.79 2.7731C389.359 2.7731 372.864 4.8336 362.461 14.8785C352.058 24.9555 348.04 40.0872 348.04 58.6317C348.04 77.2083 351.637 92.0499 362.04 102.127C372.443 112.172 389.325 114.619 405.756 114.619C422.217 114.619 438.584 112.558 448.987 102.481C459.387 92.4043 463.503 77.1759 463.503 58.6317C463.503 40.0872 459.873 25.3097 449.439 15.2326C439.069 5.18773 422.217 2.7731 405.79 2.7731ZM431.488 86.2228C425.524 92.9194 414.7 94.1106 405.79 94.1106C396.877 94.1106 386.086 92.9194 380.122 86.2551C374.159 79.5585 373.737 70.4792 373.737 58.6637C373.737 46.8482 374.129 38.0266 380.092 31.3302C386.052 24.6336 395.646 23.4424 405.79 23.4424C415.93 23.4424 425.524 24.6014 431.488 31.3302C437.448 38.0266 437.839 46.8482 437.839 58.6637C437.839 70.4792 437.448 79.5261 431.488 86.2228Z" stroke="rgba(222, 222, 222, 1)" stroke-width="2"   >
</path>
</svg>
`;
function sm(t, n=!1) {
    const r = new Image
      , s = new aM(r);
    return s.encoding = Qy,
    r.src = n ? t : "data:image/svg+xml," + encodeURIComponent(t),
    r.onload = ()=>{
        s.needsUpdate = !0
    }
    ,
    s
}
function Cv(t) {
    const n = new Z3(t);
    return n.encoding = Qy,
    n
}
class pM extends wo {
    constructor() {
        super(...arguments);
        B(this, "_qrcode");
        B(this, "_camera");
        B(this, "_material");
        B(this, "_frontScene");
        B(this, "_frontRenderer");
        B(this, "_hiddenObjects", []);
        B(this, "_isSaving", !1);
        B(this, "_canvasTexture");
        B(this, "_qrcodeTexture");
        B(this, "_carMesh")
    }
    show() {
        this.enabled = !0,
        this._material.opacity = 0,
        Jt.TweenManager.KillTweensOf(this._material),
        Jt.TweenManager.Tween(this._material).to({
            opacity: 1
        }, 1).easing(Jt.Easing.Cubic.InOut).start()
    }
    hide() {
        this.enabled = !1
    }
    screenshot() {
        this._frontRenderer === void 0 && (this._frontRenderer = new gO,
        this._frontRenderer.setPixelRatio(window.devicePixelRatio),
        this._frontRenderer.outputEncoding = this.viewer.renderer.outputEncoding),
        this._isSaving = !0,
        this.viewer.render(0),
        this._canvasTexture.needsUpdate = !0,
        this._isSaving = !1;
        const r = this.viewer.size;
        this._hiddenObjects.forEach(h=>h.visible = !0),
        this._genQRCode(Ae.generateCustomParams()),
        this._frontRenderer.setSize(r.width, r.height),
        this._frontRenderer.render(this._frontScene, this._camera),
        this._hiddenObjects.forEach(h=>h.visible = !1);
        const s = document.getElementById("screenshot-img");
        if (s) {
            const h = 1228.8 * r.width / 1920
              , l = h * r.height / r.width;
            s.src = this._frontRenderer.domElement.toDataURL("image/png"),
            s.width = h,
            s.height = l
        }
    }
    onEnable() {
        Ie.on(Ie.SCREENSHOT, this.screenshot, this)
    }
    onDisable() {
        Ie.off(Ie.SCREENSHOT, this.screenshot, this)
    }
    onLoad() {
        const r = this.viewer.size;
        this._camera = new lO(-r.width / 2,r.width / 2,r.height / 2,-r.height / 2,0,1),
        this._material = new sO({
            transparent: !0,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            map: new aM
        }),
        this.viewer.renderer.sortObjects = !1,
        this._frontScene = new pO;
        const s = this._carMesh = new Ju.Plane(1,1);
        s.material = this._material,
        s.localUniforms.map = this._canvasTexture = Cv(this.viewer.renderer.domElement),
        this._frontScene.add(s),
        this._hiddenObjects.push(s);
        const h = new Ju.Plane(500,500 * 228 / 718);
        h.material = this._material,
        h.localUniforms.map = sm(_B),
        this._frontScene.add(h);
        const l = new Ju.Plane(130,130 * 53 / 187);
        l.material = this._material,
        l.localUniforms.map = sm(ai.autoURL("res/icon/gamemcu.png"), !0),
        this._frontScene.add(l),
        this._hiddenObjects.push(l);
        const g = new Ju.Plane(550,550 * 118 / 729);
        g.material = this._material,
        g.localUniforms.map = sm(yB),
        this._frontScene.add(g);
        const _ = new Ju.Plane(160,160 * 330 / 256);
        _.material = this._material,
        _.localUniforms.map = sm(ai.autoURL("res/icon/qrcode.png"), !0),
        this._frontScene.add(_),
        this._hiddenObjects.push(_);
        const A = new Ju.Plane(150,150);
        A.material = this._material,
        A.localUniforms.map = this._qrcodeTexture = this._createQRCodeTexture(),
        this._frontScene.add(A),
        this._hiddenObjects.push(A),
        this._hiddenObjects.forEach(m=>m.visible = !1),
        this._updateLayout(),
        this.viewer.on(Rs.RESIZE, this._onResize, this),
        this.viewer.on(Zm.RENDER_AFTER, this._onAfterRender, this)
    }
    onDestroy() {
        this.viewer.targetOff(this)
    }
    _onAfterRender() {
        this.enabled && !this._isSaving && this.viewer.renderer.render(this._frontScene, this._camera)
    }
    _onResize(r, s) {
        this._camera.left = -r / 2,
        this._camera.right = r / 2,
        this._camera.top = s / 2,
        this._camera.bottom = -s / 2,
        this._camera.updateProjectionMatrix(),
        this._updateLayout(),
        this._canvasTexture.dispose(),
        this._canvasTexture = this._carMesh.localUniforms.map = Cv(this.viewer.renderer.domElement)
    }
    _updateLayout() {
        const r = this.viewer.size
          , s = r.width / 1920
          , h = this._frontScene.children;
        h.forEach(l=>l.scale.set(s, s, s)),
        h[0].scale.set(r.width, r.height, 1),
        h[1].position.set(r.width * (-.5 + .2), r.height * (.5 - .2), 0),
        h[2].position.set(r.width * (-.5 + .13), r.height * (-.5 + .15), 0),
        h[3].position.set(r.width * (.5 - .23), r.height * (-.5 + .15), 0),
        h[4].position.set(r.width * (.5 - .15), r.height * (.5 - .2) - 23 * s, 0),
        h[5].position.set(r.width * (.5 - .15), r.height * (.5 - .2), 0)
    }
    _createQRCodeTexture() {
        const r = document.createElement("div");
        return this._qrcode = new kh(r,{
            width: 256,
            height: 256
        }),
        this._qrcode.makeCode("https://gamemcu.com/su7?FFFFFF1010"),
        Cv(this._qrcode._oDrawing._elCanvas)
    }
    _genQRCode(r) {
        this._qrcode.clear(),
        this._qrcode.makeCode(r),
        this._qrcodeTexture.needsUpdate = !0
    }
}
vB([ua()], pM.prototype, "screenshot", 1);
class xB extends Vl {
    constructor() {
        super(...arguments);
        B(this, "_lightMt", null)
    }
    onLoad() {
        const {materials: r} = Ae.sm_car_lightbar.meshData;
        this._lightMt = r.lightbar_Baked,
        this.viewer.addNode(Ae.sm_car_lightbar),
        this.controller = new Proxy({
            visibility: 1
        },{
            set: (s,h,l)=>(s[h] = l,
            !0)
        }),
        this.controller.visibility = 0
    }
    update(r) {
        this._lightMt && (this._lightMt.emissiveIntensity = 500 * this.controller.visibility + 1)
    }
}
var bB = Object.defineProperty
  , wB = Object.getOwnPropertyDescriptor
  , AB = (t,n,r,s)=>{
    for (var h = s > 1 ? void 0 : s ? wB(n, r) : n, l = t.length - 1, g; l >= 0; l--)
        (g = t[l]) && (h = (s ? g(n, r, h) : g(h)) || h);
    return s && h && bB(n, r, h),
    h
}
;
class mM extends wo {
    get state() {
        return Ie.currentShowingState
    }
    set state(n) {
        Ie.emit(Ie.UPDATESHOWINGSTATE, n)
    }
}
AB([ua({
    value: Bn
})], mM.prototype, "state", 1);
class SB extends wo {
    constructor() {
        super(...arguments);
        B(this, "_environment");
        B(this, "_posterGenerator");
        B(this, "_envController");
        B(this, "_springCtr");
        B(this, "_carLightController");
        B(this, "_topLightController");
        B(this, "_carSpeedUpdate");
        B(this, "_bloom");
        B(this, "_projectionProbe");
        B(this, "_accessories")
    }
    start() {
        console.log(ai.VERSION),
        this._preload().then(()=>{
            this._prepareScene(),
            this._createScene(),
            this._compileScene()
        }
        )
    }
    async _preload() {
        const r = new cO(this.viewer.renderer);
        return Promise.all([this.viewer.loadAsset({
            url: ai.autoURL("res/mesh/sm_car.glb")
        }).then(s=>{
            Ae.sm_car = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/mesh/sm_startroom.raw.glb")
        }).then(s=>{
            Ae.sm_startroom = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/mesh/sm_speedup.glb")
        }).then(s=>{
            Ae.sm_speedup = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/mesh/sm_size.glb")
        }).then(s=>{
            Ae.sm_size = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/mesh/sm_curvature.glb")
        }).then(s=>{
            Ae.sm_curvature = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/mesh/sm_windspeed.glb")
        }).then(s=>{
            Ae.sm_windspeed = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/mesh/sm_linecar.glb")
        }).then(s=>{
            Ae.sm_linecar = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/mesh/sm_carradar.glb")
        }).then(s=>{
            Ae.sm_carradar = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/mesh/sm_simplecar.glb")
        }).then(s=>{
            Ae.sm_simpleCar = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/mesh/sm_car_lightbar.glb")
        }).then(s=>{
            Ae.sm_car_lightbar = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_saLine.png"),
            flipY: !1,
            encoding: th,
            wrapS: sc,
            wrapT: sc,
            anisotropy: 4
        }).then(s=>Ae.ut_saLine.value = s), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_car_body_AO.raw.jpg"),
            flipY: !1,
            encoding: th,
            minFilter: rm,
            magFilter: rm
        }).then(s=>Ae.ut_car_body_ao.value = s), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_startroom_ao.raw.jpg"),
            flipY: !1,
            encoding: th
        }).then(s=>{
            Ae.ut_startroom_ao.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_startroom_light.raw.jpg"),
            flipY: !1,
            encoding: Qy
        }).then(s=>{
            Ae.ut_startroom_light.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_floor_normal.webp"),
            flipY: !1,
            encoding: th,
            wrapS: sc,
            wrapT: sc
        }).then(s=>{
            Ae.ut_floor_normal.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_floor_roughness.jpg"),
            flipY: !1,
            encoding: th,
            wrapS: sc,
            wrapT: sc
        }).then(s=>{
            Ae.ut_floor_roughness.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_street.png"),
            flipY: !1,
            wrapS: sc,
            wrapT: sc
        }).then(s=>{
            Ae.ut_street.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_scar_matcap.png"),
            flipY: !1
        }).then(s=>{
            Ae.ut_scar_matcap.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_gm_car_body_bc.png"),
            flipY: !1
        }).then(s=>{
            Ae.ut_car_body_t_gm.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_gm02_car_body_bc.jpg"),
            flipY: !1,
            anisotropy: 4
        }).then(s=>{
            Ae.ut_car_body_t_gm2.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_gm02_car_window_bc.png"),
            flipY: !1
        }).then(s=>{
            Ae.ut_gm02_car_window_bc.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_gm02_car_window_roughness.jpg"),
            flipY: !1,
            minFilter: rm,
            magFilter: rm
        }).then(s=>{
            Ae.ut_gm02_car_window_roughness.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_gm02_floor_bc.png"),
            flipY: !1,
            anisotropy: 4
        }).then(s=>{
            Ae.ut_gm02_floor_bc.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_police_Car_body_BC.png"),
            flipY: !1,
            anisotropy: 4
        }).then(s=>{
            Ae.ut_police_Car_body_BC.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_police_floor_bc.jpg"),
            flipY: !1,
            anisotropy: 4
        }).then(s=>{
            Ae.ut_police_floor_bc.value = s
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_env_night.hdr")
        }).then(s=>{
            Ae.ut_env_night.value = r.fromEquirectangular(s).texture
        }
        ), this.viewer.loadAsset({
            url: ai.autoURL("res/texture/t_env_light.hdr")
        }).then(s=>{
            Ae.ut_env_light.value = r.fromEquirectangular(s).texture
        }
        )])
    }
    _prepareScene() {
        const r = this.viewer;
        r.addNode(uB),
        r.addNode(mM),
        this._environment = r.addNode(new J3({
            scene: r.scene,
            layer: Ae.LAYER_CAPTURE,
            resolution: 512
        })),
        this._environment.blurIntensity = 4.5,
        Ae.ut_cubeCapture = this._environment.cubeTexture,
        Ae.ut_blurCapture = this._environment.blurTexture;
        const s = new Float32Array(4);
        s.set([1, 1, 1, 1]);
        const h = new hA(s,1,1,k_,dA);
        h.needsUpdate = !0,
        Ae.ut_white.value = h;
        const l = new Float32Array(4);
        l.set([0, 0, 0, 1]);
        const g = new hA(l,1,1,k_,dA);
        g.needsUpdate = !0,
        Ae.ut_dark.value = g,
        Ae.ut_floorMap.value = h;
        let _ = Ae.sm_car.meshData;
        Object.values(_.meshes).forEach(m=>{
            m.layers.enable(Ae.LAYER_PLANE_REFLECT)
        }
        ),
        Object.values(_.materials).forEach(m=>{
            m.aoMap = Ae.ut_car_body_ao.value,
            m instanceof mA && (m.onBeforeCompile = D=>{
                AA(D)
            }
            )
        }
        ),
        _.materials.Car_body.map = Ae.ut_white.value,
        _.materials.Car_body.needsUpdate = !0,
        _.materials.M_logo.map.anisotropy = 8;
        const A = _.materials.Car_window;
        A.map = Ae.ut_white.value,
        A.roughnessMap = Ae.ut_dark.value,
        A.metalnessMap = Ae.ut_white.value,
        Ae.u_m_car_window_orignData.color.copy(A.color),
        Ae.u_m_car_window_orignData.opacity = A.opacity,
        Ae.u_m_car_window_orignData.roughness = A.roughness,
        A.needsUpdate = !0,
        _ = Ae.sm_car_lightbar.meshData,
        Ae.sm_car_lightbar.visible = !1,
        Object.values(_.meshes).forEach(m=>{
            m.layers.enable(Ae.LAYER_PLANE_REFLECT)
        }
        ),
        Object.values(_.materials).forEach(m=>{
            m.toneMapped = !1,
            m instanceof mA && (m.onBeforeCompile = D=>{
                AA(D),
                m.name == "lightbar_Baked" && UO(D)
            }
            )
        }
        ),
        _ = Ae.sm_startroom.meshData,
        Object.values(_.materials).forEach(m=>{
            m.aoMap = Ae.ut_startroom_ao.value,
            m.lightMap = Ae.ut_startroom_light.value,
            m.normalMap = Ae.ut_floor_normal.value,
            m.roughnessMap = Ae.ut_floor_roughness.value,
            m.envMapIntensity = 0
        }
        ),
        _ = Ae.sm_speedup.meshData,
        _.meshes.forEach(m=>{
            m.material = kO,
            m.layers.enable(Ae.LAYER_CAPTURE),
            m.layers.enable(Ae.LAYER_PLANE_REFLECT)
        }
        ),
        _ = Ae.sm_size.meshData,
        Object.values(_.materials).forEach(m=>{
            m.transparent = !0,
            m.needsUpdate = !0,
            m.map.anisotropy = 4
        }
        ),
        _ = Ae.sm_curvature.meshData,
        _.meshes.forEach(m=>{
            m.name == "曲率" && (m.material = NO,
            _.materials.m_curvature = m.material,
            m.layers.enable(Ae.LAYER_CAPTURE))
        }
        ),
        Object.values(_.materials).forEach(m=>{
            m.transparent = !0,
            m.needsUpdate = !0
        }
        ),
        _ = Ae.sm_windspeed.meshData,
        _.meshes.forEach(m=>{
            m.material = zO,
            _.materials.m_windLine = m.material,
            m.layers.enable(Ae.LAYER_CAPTURE)
        }
        ),
        _ = Ae.sm_linecar.meshData,
        _.meshes.forEach(m=>{
            m.material = GO,
            _.materials.m_linecar = m.material
        }
        ),
        _ = Ae.sm_carradar.meshData,
        _.meshes.forEach(m=>{
            m.material = HO,
            _.materials.m_carradar = m.material,
            m.layers.enable(Ae.LAYER_CAPTURE)
        }
        ),
        _ = Ae.sm_simpleCar.meshData,
        _.meshes.forEach(m=>{
            m.material = Ag,
            _.materials.m_simpleCar = m.material,
            m.renderOrder = 10
        }
        )
    }
    _createScene() {
        const r = this.viewer;
        ai.DEBUG,
        this._posterGenerator = r.addNode(pM),
        this._posterGenerator.enabled = !1,
        r.scene.background = new Xi(0,0,0);
        const s = r.addNode(RO);
        Ae.u_reflect.u_reflectMatrix.value = s.reflectMatrix,
        Ae.u_reflect.u_reflectTexture.value = s.reflectTexture,
        Ae.sm_startroom.traverse(Be=>{
            (Be.name === "ReflecFloor" || Be.name === "Floor") && FO(Be)
        }
        );
        const h = r.addNode(new YO(Ae.ut_env_night.value,Ae.ut_env_light.value))
          , l = r.addNode(Ae.sm_startroom)
          , g = r.addNode(new qO(l))
          , _ = new dO;
        this.viewer.addComponent(Ae.sm_car, _),
        _.probeBoxMin.set(-3, -.1, -1.5),
        _.probeBoxMax.set(3.6, 3, 1.5);
        const A = this.viewer.addNode(Ae.sm_car)
          , m = r.addNode(new ZO(A))
          , D = r.addNode(new Hl({
            springLength: 11,
            rotation: new go(0,Math.PI * .5,0),
            fov: 33.4,
            lookAt: new Li(0,.8,0)
        }))
          , U = r.addNode(new PO({
            springCamera: D
        }));
        r.addNode(JO);
        const R = r.addNode(new $O(A,U));
        r.addNode(Ae.sm_speedup);
        const ne = r.addNode(cB)
          , ce = r.addNode(xB)
          , xe = r.addNode(eB)
          , Se = r.addNode(tB)
          , $ = r.addNode(nB)
          , q = r.addNode(iB)
          , N = r.addNode(lB)
          , ie = r.addNode(rB)
          , _e = r.addNode(sB)
          , Pe = r.addPlugin(new K3({
            luminanceThreshold: 0,
            luminanceSmoothing: 1.6,
            mipmapBlur: !0
        }));
        r.addPlugin(fO),
        this._envController = h,
        this._springCtr = U,
        this._carLightController = m,
        this._topLightController = g,
        this._carSpeedUpdate = R,
        this._bloom = Pe,
        this._projectionProbe = _,
        this._accessories = {
            s1_c: ne,
            s1_cpcl: ce,
            s2_b: xe,
            s2_c: Se,
            s3_b: $,
            s3_c: q,
            s4_b: N,
            s4_c: ie,
            s4_cSC: _e
        },
        this.eventRegister()
    }
    _compileScene() {
        BO(),
        this.viewer.compile(),
        Ie.emit(Ie.PRELOADED);
        let r = Ae.getCustomParams();
        r && Ie.emit(Ie.CHANGECOLOR, r)
    }
    eventRegister() {
        const r = this._envController
          , s = this._springCtr
          , h = this._carLightController
          , l = this._topLightController
          , g = this._carSpeedUpdate
          , _ = this._bloom
          , A = this._projectionProbe
          , m = this._accessories
          , D = (_e=1,Pe=1,Be=1,Re=1,ct=1.8)=>{
            Jt.TweenManager.KillTweensOf(A),
            Jt.TweenManager.Timeline(A).to({
                probeCenter: new Li(0,0,0),
                probeBoxMax: new Li(3.6,3,1.5)
            }, 1, {
                easing: Jt.Easing.Cubic.InOut,
                onUpdate: ()=>{
                    A.probeCenter = A.probeCenter
                }
            }).start(),
            Jt.TweenManager.KillTweensOf(Ae.u_floorLightMapIntensity),
            Jt.TweenManager.Timeline(Ae.u_floorLightMapIntensity).to({
                value: _e
            }, 1).start(),
            Jt.TweenManager.KillTweensOf(Ae.u_car_envMapIntensity),
            Jt.TweenManager.Timeline(Ae.u_car_envMapIntensity).to({
                value: Pe
            }, 1.5, {
                easing: Jt.Easing.Cubic.InOut
            }).start(),
            Jt.TweenManager.KillTweensOf(this._environment),
            Jt.TweenManager.Tween(this._environment).to({
                exposure: Be
            }, 1).start(),
            Jt.TweenManager.KillTweensOf(l),
            Jt.TweenManager.Timeline(l).to({
                opacity: Re
            }, .5, {}).start(),
            Jt.TweenManager.KillTweensOf(_),
            Jt.TweenManager.Timeline(_).to({
                luminanceSmoothing: ct
            }, 2, {}).start()
        }
          , U = new Xi("#000000")
          , R = new Xi("#C9D573")
          , ne = new Xi("#ffffff")
          , ce = new Xi
          , xe = new Xi;
        Ie.on(Ie.UPDATESHOWINGSTATE, _e=>{
            for (let Pe in m)
                m[Pe].hide();
            switch (this._posterGenerator.hide(),
            g.targetVelocity = 0,
            s.setNewRange(),
            xe.copy(Ae.u_floorLightMapColor.value),
            _e) {
            case Bn.BeginAnim:
                Jt.TweenManager.KillTweensOf(r),
                Jt.TweenManager.Timeline(r).delay(1.5).call(()=>{
                    r.setState(U_.night, 2.5, Jt.Easing.Cubic.In),
                    s.gotoPOI(new Li(0,.8,0), 7, new go(0,Math.PI * .5,0), 4).then(()=>{
                        const Pe = Ae.getCustomParams();
                        Pe == "custom" ? (Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State5),
                        Ie.emit(Ie.UPDATECOLORTABLESTATE, sa.customColorTable)) : Pe ? (Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State5),
                        Ie.emit(Ie.UPDATECOLORTABLESTATE, sa.presetColorTable)) : Ie.emit(Ie.UPDATESHOWINGSTATE, Bn.State1),
                        s.enableControlCamera = !0
                    }
                    )
                }
                ).delay(2.5).call(()=>{
                    r.setState(U_.light, 4, Jt.Easing.Cubic.Out)
                }
                ).start(),
                Jt.TweenManager.KillTweensOf(l),
                Jt.TweenManager.Timeline(l).delay(1.5).to({}, 2.5, {
                    onUpdate: (Pe,Be)=>{
                        ce.copy(U).lerp(R, Be),
                        l.lightEmissiveColor = ce,
                        l.lightEmissiveIntensity = Be * .4
                    }
                }).to({}, 2, {
                    onUpdate: (Pe,Be)=>{
                        ce.copy(R).lerpHSL(ne, Be),
                        l.lightEmissiveColor = ce,
                        l.lightEmissiveIntensity = Be * 2.3 + .4
                    }
                }).start(),
                Jt.TweenManager.KillTweensOf(h),
                Jt.TweenManager.Timeline(h).delay(1).to({
                    lightValue: 1
                }, 1, {
                    easing: Jt.Easing.Cubic.In
                }).start(),
                Jt.TweenManager.KillTweensOf(Ae.u_floorLightMapIntensity),
                Jt.TweenManager.Timeline(Ae.u_floorLightMapIntensity).delay(1.5).to({
                    value: .1
                }, 2.5, {
                    easing: Jt.Easing.Cubic.In,
                    onUpdate: (Pe,Be)=>{
                        ce.copy(xe).lerpHSL(R, Be),
                        Ae.u_floorLightMapColor.value.copy(ce)
                    }
                }).to({
                    value: 1
                }, 2, {
                    easing: Jt.Easing.Linear.None,
                    onUpdate: (Pe,Be)=>{
                        ce.copy(R).lerpHSL(ne, Be),
                        Ae.u_floorLightMapColor.value.copy(ce)
                    }
                }).start(),
                Jt.TweenManager.KillTweensOf(Ae.u_floorReflectIntensity),
                Jt.TweenManager.Timeline(Ae.u_floorReflectIntensity).delay(1.8).to({
                    value: .1
                }, 1.5, {
                    easing: Jt.Easing.Cubic.In
                }).to({
                    value: 1
                }, 1.5, {
                    easing: Jt.Easing.Linear.None
                }).start();
                break;
            case Bn.State1:
                s.setNewTarget(new Li(0,.8,0), 7, new go(0,Math.PI * .5,0)),
                D(),
                s.targetFov = 33.4;
                break;
            case Bn.State2:
                s.setNewTarget(new Li(0,.8,0), 7, new go(0,-.89,.1)),
                m.s2_b.show(),
                s.targetFov = 33.4,
                D();
                break;
            case Bn.State3:
                s.setNewTarget(new Li(.3,.8,0), 7, new go(0,.65,.1)),
                m.s3_b.show(),
                D(0, 0, 10, 0, .5),
                s.targetFov = 33.4,
                Jt.TweenManager.KillTweensOf(A),
                Jt.TweenManager.Timeline(A).to({
                    probeCenter: new Li(0,.5,0),
                    probeBoxMax: new Li(3.6,1.6,1.5)
                }, 1, {
                    easing: Jt.Easing.Cubic.InOut,
                    onUpdate: ()=>{
                        A.probeCenter = A.probeCenter
                    }
                }).start();
                break;
            case Bn.State4:
                s.setNewTarget(new Li(.3,.8,0), 14, new go(0,Math.PI,1.2)),
                s.setNewRange([.2, 1.3]),
                D(.2, 1, 3, 0, 1.5),
                s.targetFov = 33.4,
                m.s4_b.show();
                break;
            case Bn.State5:
                s.setNewTarget(new Li(.2,.8,0), 7, new go(0,-.7,.03)),
                D(1, 1, 1, 0, 1.8),
                s.targetFov = 33.4,
                this._posterGenerator.show();
                break
            }
        }
        );
        let Se = !1
          , $ = Bn.BeginAnim;
        Ie.on(Ie.CLICKEFFECT, _e=>{
            if (Se !== _e || $ !== Ie.currentShowingState)
                Se = _e,
                $ = Ie.currentShowingState,
                Ie.emit(Ie.PRESSED_STATE_CHANGED, Se, $);
            else
                return;
            for (let Pe in m)
                m[Pe].hide();
            switch (Ie.currentShowingState) {
            case Bn.State1:
                Se ? (g.targetVelocity = 8,
                g.lerpStrength = .5,
                s.targetFov = 60,
                s.springlengthOffset = -3,
                s.lerpStrength = .5,
                m.s1_c.show(),
                m.s1_cpcl.show(.5, .2),
                D(0, .1, 1, 0, 0),
                Jt.TweenManager.KillTweensOf(Ae.u_carMetalness),
                Jt.TweenManager.Timeline(Ae.u_carMetalness).to({
                    value: Math.max(0, Ae.u_carMetalness.value - .3)
                }, .8, {
                    easing: Jt.Easing.Cubic.In
                }).start()) : (g.targetVelocity = 0,
                g.lerpStrength = 1.5,
                s.targetFov = 33.4,
                s.lerpStrength = 1.5,
                s.springlengthOffset = 0,
                D(),
                Jt.TweenManager.KillTweensOf(Ae.u_carMetalness),
                Jt.TweenManager.Timeline(Ae.u_carMetalness).to({
                    value: Ae.colors.get(Ie.currentColorIndex).metal ?? 0
                }, 1).start());
                break;
            case Bn.State2:
                Se ? (m.s2_c.show(),
                s.targetFov = 45,
                s.lerpStrength = .5) : (m.s2_b.show(),
                s.targetFov = 33.4,
                s.lerpStrength = .5);
                break;
            case Bn.State3:
                Se ? (m.s3_c.show(1, .2),
                s.targetFov = 60,
                s.springlengthOffset = -3,
                s.lerpStrength = 1.5) : (m.s3_b.show(),
                s.targetFov = 33.4,
                s.springlengthOffset = 0,
                s.lerpStrength = 1.5);
                break;
            case Bn.State4:
                Se ? (g.targetVelocity = 16,
                g.lerpStrength = .5,
                m.s4_c.show(),
                m.s4_cSC.show(),
                m.s1_c.show(),
                m.s1_cpcl.show(.5, .2),
                s.targetFov = 25,
                s.lerpStrength = 1.5,
                s.springlengthOffset = 20,
                s.moveSpeed = [.1, .1],
                D(.2, .3, 3, 0, 1.5)) : (g.targetVelocity = 0,
                g.lerpStrength = 1.5,
                s.targetFov = 33.4,
                s.lerpStrength = 1.5,
                s.springlengthOffset = 0,
                s.moveSpeed = [1, 1],
                m.s4_b.show(),
                D(.2, 1, 3, 0, 1.5));
                break
            }
        }
        );
        const q = new Xi(0,0,0);
        let N = !1
          , ie = "0";
        Ie.on(Ie.CHANGECOLOR, _e=>{
            _e == "11" ? Ae.sm_car_lightbar.visible = !0 : Ae.sm_car_lightbar.visible = !1;
            const {col: Pe, tcar: Be, tw: Re, twr: ct, metal: et, rough: Ze, tf: Nt} = Ae.colors.get(_e)
              , Bt = Ae.sm_car.meshData.materials.Car_body;
            Bt.map = Be ? Be.value : Ae.ut_white.value,
            (Be || N) && Ae.u_carColor.value.copy(q),
            N = !!Be,
            ie != "custom" || _e != "custom" ? (Jt.TweenManager.KillTweensOf(Ae.u_carColor),
            Jt.TweenManager.Timeline(Ae.u_carColor).to({
                value: Pe
            }, .2).start(),
            Jt.TweenManager.KillTweensOf(Ae.u_carRoughness),
            Jt.TweenManager.Timeline(Ae.u_carRoughness).to({
                value: Ze ?? 0
            }, .2).start(),
            Jt.TweenManager.KillTweensOf(Ae.u_carMetalness),
            Jt.TweenManager.Timeline(Ae.u_carMetalness).to({
                value: et ?? 0
            }, .2).start()) : (Ae.u_carColor.value.copy(Pe),
            Ae.u_carRoughness.value = Ze,
            Ae.u_carMetalness.value = et),
            ie = _e,
            Re && ct ? (Ae.sm_car.meshData.materials.Car_window.color = new Xi("#fff").convertSRGBToLinear(),
            Ae.sm_car.meshData.materials.Car_window.opacity = 1,
            Ae.sm_car.meshData.materials.Car_window.roughness = 1,
            Ae.sm_car.meshData.materials.Car_window.map = Re.value,
            Ae.sm_car.meshData.materials.Car_window.roughnessMap = ct.value,
            Ae.sm_car.meshData.materials.Car_window.metalnessMap = ct.value) : (Ae.sm_car.meshData.materials.Car_window.color = Ae.u_m_car_window_orignData.color,
            Ae.sm_car.meshData.materials.Car_window.opacity = Ae.u_m_car_window_orignData.opacity,
            Ae.sm_car.meshData.materials.Car_window.roughness = Ae.u_m_car_window_orignData.roughness,
            Ae.sm_car.meshData.materials.Car_window.map = Ae.ut_white.value,
            Ae.sm_car.meshData.materials.Car_window.roughnessMap = Ae.ut_dark.value,
            Ae.sm_car.meshData.materials.Car_window.metalnessMap = Ae.ut_white.value),
            Ae.ut_floorMap.value = Nt ? Nt.value : Ae.ut_white.value
        }
        )
    }
    update(r) {
        if (Ae.u_speedTime.value += r * Ae.u_speedUpBackgroundValue.value * .2,
        Ae.u_time.value += r,
        Ae.sm_car) {
            const s = Ae.sm_car.meshData.materials.Car_body;
            s.metalness = Ae.u_carMetalness.value,
            s.roughness = Ae.u_carRoughness.value,
            s.color.copy(Ae.u_carColor.value)
        }
    }
}
function TB() {
    const t = nt.useRef(null);
    return nt.useEffect(()=>{
        const n = new Zm({
            root: document.getElementById("root"),
            canvas: t.current,
            orientation: aO.LANDSCAPE,
            antialias: !1,
            toneMapping: Y3,
            loader: {
                onProgress: (r,s,h)=>Ie.loading = Math.max(Ie.loading, s / h),
                onLoad: ()=>Ie.loading = 1
            }
        });
        return n.addNode(SB),
        ()=>{
            n.destroy()
        }
    }
    , []),
    Oe.jsxs("aside", {
        className: "webgl-wrapper",
        children: [Oe.jsx("canvas", {
            ref: t,
            className: "webgl-canvas",
            children: "No Canvas!"
        }), Oe.jsx("div", {
            id: "css-container"
        })]
    })
}
const Zy = nt.createContext({
    transformPagePoint: t=>t,
    isStatic: !1,
    reducedMotion: "never"
})
  , Sg = nt.createContext({})
  , Tg = nt.createContext(null)
  , qy = typeof document < "u"
  , Jy = qy ? nt.useLayoutEffect : nt.useEffect
  , gM = nt.createContext({
    strict: !1
})
  , $y = t=>t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
  , EB = "framerAppearId"
  , vM = "data-" + $y(EB)
  , MB = {
    skipAnimations: !1,
    useManualTiming: !1
};
class DA {
    constructor() {
        this.order = [],
        this.scheduled = new Set
    }
    add(n) {
        if (!this.scheduled.has(n))
            return this.scheduled.add(n),
            this.order.push(n),
            !0
    }
    remove(n) {
        const r = this.order.indexOf(n);
        r !== -1 && (this.order.splice(r, 1),
        this.scheduled.delete(n))
    }
    clear() {
        this.order.length = 0,
        this.scheduled.clear()
    }
}
function CB(t) {
    let n = new DA
      , r = new DA
      , s = 0
      , h = !1
      , l = !1;
    const g = new WeakSet
      , _ = {
        schedule: (A,m=!1,D=!1)=>{
            const U = D && h
              , R = U ? n : r;
            return m && g.add(A),
            R.add(A) && U && h && (s = n.order.length),
            A
        }
        ,
        cancel: A=>{
            r.remove(A),
            g.delete(A)
        }
        ,
        process: A=>{
            if (h) {
                l = !0;
                return
            }
            if (h = !0,
            [n,r] = [r, n],
            r.clear(),
            s = n.order.length,
            s)
                for (let m = 0; m < s; m++) {
                    const D = n.order[m];
                    g.has(D) && (_.schedule(D),
                    t()),
                    D(A)
                }
            h = !1,
            l && (l = !1,
            _.process(A))
        }
    };
    return _
}
const om = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]
  , PB = 40;
function _M(t, n) {
    let r = !1
      , s = !0;
    const h = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , l = om.reduce((U,R)=>(U[R] = CB(()=>r = !0),
    U), {})
      , g = U=>{
        l[U].process(h)
    }
      , _ = ()=>{
        const U = performance.now();
        r = !1,
        h.delta = s ? 1e3 / 60 : Math.max(Math.min(U - h.timestamp, PB), 1),
        h.timestamp = U,
        h.isProcessing = !0,
        om.forEach(g),
        h.isProcessing = !1,
        r && n && (s = !1,
        t(_))
    }
      , A = ()=>{
        r = !0,
        s = !0,
        h.isProcessing || t(_)
    }
    ;
    return {
        schedule: om.reduce((U,R)=>{
            const ne = l[R];
            return U[R] = (ce,xe=!1,Se=!1)=>(r || A(),
            ne.schedule(ce, xe, Se)),
            U
        }
        , {}),
        cancel: U=>om.forEach(R=>l[R].cancel(U)),
        state: h,
        steps: l
    }
}
const {schedule: ex, cancel: Kz} = _M(queueMicrotask, !1);
function RB(t, n, r, s) {
    const {visualElement: h} = nt.useContext(Sg)
      , l = nt.useContext(gM)
      , g = nt.useContext(Tg)
      , _ = nt.useContext(Zy).reducedMotion
      , A = nt.useRef();
    s = s || l.renderer,
    !A.current && s && (A.current = s(t, {
        visualState: n,
        parent: h,
        props: r,
        presenceContext: g,
        blockInitialAnimation: g ? g.initial === !1 : !1,
        reducedMotionConfig: _
    }));
    const m = A.current;
    nt.useInsertionEffect(()=>{
        m && m.update(r, g)
    }
    );
    const D = nt.useRef(!!(r[vM] && !window.HandoffComplete));
    return Jy(()=>{
        m && (ex.postRender(m.render),
        D.current && m.animationState && m.animationState.animateChanges())
    }
    ),
    nt.useEffect(()=>{
        m && (m.updateFeatures(),
        !D.current && m.animationState && m.animationState.animateChanges(),
        D.current && (D.current = !1,
        window.HandoffComplete = !0))
    }
    ),
    m
}
function ph(t) {
    return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current")
}
function DB(t, n, r) {
    return nt.useCallback(s=>{
        s && t.mount && t.mount(s),
        n && (s ? n.mount(s) : n.unmount()),
        r && (typeof r == "function" ? r(s) : ph(r) && (r.current = s))
    }
    , [n])
}
function Sf(t) {
    return typeof t == "string" || Array.isArray(t)
}
function Eg(t) {
    return t !== null && typeof t == "object" && typeof t.start == "function"
}
const tx = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , nx = ["initial", ...tx];
function Mg(t) {
    return Eg(t.animate) || nx.some(n=>Sf(t[n]))
}
function yM(t) {
    return !!(Mg(t) || t.variants)
}
function LB(t, n) {
    if (Mg(t)) {
        const {initial: r, animate: s} = t;
        return {
            initial: r === !1 || Sf(r) ? r : void 0,
            animate: Sf(s) ? s : void 0
        }
    }
    return t.inherit !== !1 ? n : {}
}
function IB(t) {
    const {initial: n, animate: r} = LB(t, nt.useContext(Sg));
    return nt.useMemo(()=>({
        initial: n,
        animate: r
    }), [LA(n), LA(r)])
}
function LA(t) {
    return Array.isArray(t) ? t.join(" ") : t
}
const IA = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , Tf = {};
for (const t in IA)
    Tf[t] = {
        isEnabled: n=>IA[t].some(r=>!!n[r])
    };
function OB(t) {
    for (const n in t)
        Tf[n] = {
            ...Tf[n],
            ...t[n]
        }
}
const ix = nt.createContext({})
  , xM = nt.createContext({})
  , BB = Symbol.for("motionComponentSymbol");
function FB({preloadedFeatures: t, createVisualElement: n, useRender: r, useVisualState: s, Component: h}) {
    t && OB(t);
    function l(_, A) {
        let m;
        const D = {
            ...nt.useContext(Zy),
            ..._,
            layoutId: kB(_)
        }
          , {isStatic: U} = D
          , R = IB(_)
          , ne = s(_, U);
        if (!U && qy) {
            R.visualElement = RB(h, ne, D, n);
            const ce = nt.useContext(xM)
              , xe = nt.useContext(gM).strict;
            R.visualElement && (m = R.visualElement.loadFeatures(D, xe, t, ce))
        }
        return nt.createElement(Sg.Provider, {
            value: R
        }, m && R.visualElement ? nt.createElement(m, {
            visualElement: R.visualElement,
            ...D
        }) : null, r(h, _, DB(ne, R.visualElement, A), ne, U, R.visualElement))
    }
    const g = nt.forwardRef(l);
    return g[BB] = h,
    g
}
function kB({layoutId: t}) {
    const n = nt.useContext(ix).id;
    return n && t !== void 0 ? n + "-" + t : t
}
function UB(t) {
    function n(s, h={}) {
        return FB(t(s, h))
    }
    if (typeof Proxy > "u")
        return n;
    const r = new Map;
    return new Proxy(n,{
        get: (s,h)=>(r.has(h) || r.set(h, n(h)),
        r.get(h))
    })
}
const NB = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function rx(t) {
    return typeof t != "string" || t.includes("-") ? !1 : !!(NB.indexOf(t) > -1 || /[A-Z]/u.test(t))
}
const qm = {};
function zB(t) {
    Object.assign(qm, t)
}
const Of = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , Su = new Set(Of);
function bM(t, {layout: n, layoutId: r}) {
    return Su.has(t) || t.startsWith("origin") || (n || r !== void 0) && (!!qm[t] || t === "opacity")
}
const Zs = t=>!!(t && t.getVelocity)
  , GB = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , HB = Of.length;
function VB(t, {enableHardwareAcceleration: n=!0, allowTransformNone: r=!0}, s, h) {
    let l = "";
    for (let g = 0; g < HB; g++) {
        const _ = Of[g];
        if (t[_] !== void 0) {
            const A = GB[_] || _;
            l += `${A}(${t[_]}) `
        }
    }
    return n && !t.z && (l += "translateZ(0)"),
    l = l.trim(),
    h ? l = h(t, s ? "" : l) : r && s && (l = "none"),
    l
}
const wM = t=>n=>typeof n == "string" && n.startsWith(t)
  , AM = wM("--")
  , WB = wM("var(--")
  , sx = t=>WB(t) ? jB.test(t.split("/*")[0].trim()) : !1
  , jB = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
  , XB = (t,n)=>n && typeof t == "number" ? n.transform(t) : t
  , Ec = (t,n,r)=>r > n ? n : r < t ? t : r
  , Uh = {
    test: t=>typeof t == "number",
    parse: parseFloat,
    transform: t=>t
}
  , $d = {
    ...Uh,
    transform: t=>Ec(0, 1, t)
}
  , am = {
    ...Uh,
    default: 1
}
  , ef = t=>Math.round(t * 1e5) / 1e5
  , ox = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu
  , YB = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu
  , QB = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
function Bf(t) {
    return typeof t == "string"
}
const Ff = t=>({
    test: n=>Bf(n) && n.endsWith(t) && n.split(" ").length === 1,
    parse: parseFloat,
    transform: n=>`${n}${t}`
})
  , ac = Ff("deg")
  , sl = Ff("%")
  , Kn = Ff("px")
  , KB = Ff("vh")
  , ZB = Ff("vw")
  , OA = {
    ...sl,
    parse: t=>sl.parse(t) / 100,
    transform: t=>sl.transform(t * 100)
}
  , BA = {
    ...Uh,
    transform: Math.round
}
  , SM = {
    borderWidth: Kn,
    borderTopWidth: Kn,
    borderRightWidth: Kn,
    borderBottomWidth: Kn,
    borderLeftWidth: Kn,
    borderRadius: Kn,
    radius: Kn,
    borderTopLeftRadius: Kn,
    borderTopRightRadius: Kn,
    borderBottomRightRadius: Kn,
    borderBottomLeftRadius: Kn,
    width: Kn,
    maxWidth: Kn,
    height: Kn,
    maxHeight: Kn,
    size: Kn,
    top: Kn,
    right: Kn,
    bottom: Kn,
    left: Kn,
    padding: Kn,
    paddingTop: Kn,
    paddingRight: Kn,
    paddingBottom: Kn,
    paddingLeft: Kn,
    margin: Kn,
    marginTop: Kn,
    marginRight: Kn,
    marginBottom: Kn,
    marginLeft: Kn,
    rotate: ac,
    rotateX: ac,
    rotateY: ac,
    rotateZ: ac,
    scale: am,
    scaleX: am,
    scaleY: am,
    scaleZ: am,
    skew: ac,
    skewX: ac,
    skewY: ac,
    distance: Kn,
    translateX: Kn,
    translateY: Kn,
    translateZ: Kn,
    x: Kn,
    y: Kn,
    z: Kn,
    perspective: Kn,
    transformPerspective: Kn,
    opacity: $d,
    originX: OA,
    originY: OA,
    originZ: Kn,
    zIndex: BA,
    backgroundPositionX: Kn,
    backgroundPositionY: Kn,
    fillOpacity: $d,
    strokeOpacity: $d,
    numOctaves: BA
};
function ax(t, n, r, s) {
    const {style: h, vars: l, transform: g, transformOrigin: _} = t;
    let A = !1
      , m = !1
      , D = !0;
    for (const U in n) {
        const R = n[U];
        if (AM(U)) {
            l[U] = R;
            continue
        }
        const ne = SM[U]
          , ce = XB(R, ne);
        if (Su.has(U)) {
            if (A = !0,
            g[U] = ce,
            !D)
                continue;
            R !== (ne.default || 0) && (D = !1)
        } else
            U.startsWith("origin") ? (m = !0,
            _[U] = ce) : h[U] = ce
    }
    if (n.transform || (A || s ? h.transform = VB(t.transform, r, D, s) : h.transform && (h.transform = "none")),
    m) {
        const {originX: U="50%", originY: R="50%", originZ: ne=0} = _;
        h.transformOrigin = `${U} ${R} ${ne}`
    }
}
const lx = ()=>({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});
function TM(t, n, r) {
    for (const s in n)
        !Zs(n[s]) && !bM(s, r) && (t[s] = n[s])
}
function qB({transformTemplate: t}, n, r) {
    return nt.useMemo(()=>{
        const s = lx();
        return ax(s, n, {
            enableHardwareAcceleration: !r
        }, t),
        Object.assign({}, s.vars, s.style)
    }
    , [n])
}
function JB(t, n, r) {
    const s = t.style || {}
      , h = {};
    return TM(h, s, t),
    Object.assign(h, qB(t, n, r)),
    h
}
function $B(t, n, r) {
    const s = {}
      , h = JB(t, n, r);
    return t.drag && t.dragListener !== !1 && (s.draggable = !1,
    h.userSelect = h.WebkitUserSelect = h.WebkitTouchCallout = "none",
    h.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`),
    t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (s.tabIndex = 0),
    s.style = h,
    s
}
const eF = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function Jm(t) {
    return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || eF.has(t)
}
let EM = t=>!Jm(t);
function tF(t) {
    t && (EM = n=>n.startsWith("on") ? !Jm(n) : t(n))
}
try {
    tF(require("@emotion/is-prop-valid").default)
} catch {}
function nF(t, n, r) {
    const s = {};
    for (const h in t)
        h === "values" && typeof t.values == "object" || (EM(h) || r === !0 && Jm(h) || !n && !Jm(h) || t.draggable && h.startsWith("onDrag")) && (s[h] = t[h]);
    return s
}
function FA(t, n, r) {
    return typeof t == "string" ? t : Kn.transform(n + r * t)
}
function iF(t, n, r) {
    const s = FA(n, t.x, t.width)
      , h = FA(r, t.y, t.height);
    return `${s} ${h}`
}
const rF = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , sF = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function oF(t, n, r=1, s=0, h=!0) {
    t.pathLength = 1;
    const l = h ? rF : sF;
    t[l.offset] = Kn.transform(-s);
    const g = Kn.transform(n)
      , _ = Kn.transform(r);
    t[l.array] = `${g} ${_}`
}
function cx(t, {attrX: n, attrY: r, attrScale: s, originX: h, originY: l, pathLength: g, pathSpacing: _=1, pathOffset: A=0, ...m}, D, U, R) {
    if (ax(t, m, D, R),
    U) {
        t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
        return
    }
    t.attrs = t.style,
    t.style = {};
    const {attrs: ne, style: ce, dimensions: xe} = t;
    ne.transform && (xe && (ce.transform = ne.transform),
    delete ne.transform),
    xe && (h !== void 0 || l !== void 0 || ce.transform) && (ce.transformOrigin = iF(xe, h !== void 0 ? h : .5, l !== void 0 ? l : .5)),
    n !== void 0 && (ne.x = n),
    r !== void 0 && (ne.y = r),
    s !== void 0 && (ne.scale = s),
    g !== void 0 && oF(ne, g, _, A, !1)
}
const MM = ()=>({
    ...lx(),
    attrs: {}
})
  , ux = t=>typeof t == "string" && t.toLowerCase() === "svg";
function aF(t, n, r, s) {
    const h = nt.useMemo(()=>{
        const l = MM();
        return cx(l, n, {
            enableHardwareAcceleration: !1
        }, ux(s), t.transformTemplate),
        {
            ...l.attrs,
            style: {
                ...l.style
            }
        }
    }
    , [n]);
    if (t.style) {
        const l = {};
        TM(l, t.style, t),
        h.style = {
            ...l,
            ...h.style
        }
    }
    return h
}
function lF(t=!1) {
    return (r,s,h,{latestValues: l},g)=>{
        const A = (rx(r) ? aF : $B)(s, l, g, r)
          , m = nF(s, typeof r == "string", t)
          , D = r !== nt.Fragment ? {
            ...m,
            ...A,
            ref: h
        } : {}
          , {children: U} = s
          , R = nt.useMemo(()=>Zs(U) ? U.get() : U, [U]);
        return nt.createElement(r, {
            ...D,
            children: R
        })
    }
}
function CM(t, {style: n, vars: r}, s, h) {
    Object.assign(t.style, n, h && h.getProjectionStyles(s));
    for (const l in r)
        t.style.setProperty(l, r[l])
}
const PM = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function RM(t, n, r, s) {
    CM(t, n, void 0, s);
    for (const h in n.attrs)
        t.setAttribute(PM.has(h) ? h : $y(h), n.attrs[h])
}
function hx(t, n) {
    const {style: r} = t
      , s = {};
    for (const h in r)
        (Zs(r[h]) || n.style && Zs(n.style[h]) || bM(h, t)) && (s[h] = r[h]);
    return s
}
function DM(t, n) {
    const r = hx(t, n);
    for (const s in t)
        if (Zs(t[s]) || Zs(n[s])) {
            const h = Of.indexOf(s) !== -1 ? "attr" + s.charAt(0).toUpperCase() + s.substring(1) : s;
            r[h] = t[s]
        }
    return r
}
function dx(t, n, r, s={}, h={}) {
    return typeof n == "function" && (n = n(r !== void 0 ? r : t.custom, s, h)),
    typeof n == "string" && (n = t.variants && t.variants[n]),
    typeof n == "function" && (n = n(r !== void 0 ? r : t.custom, s, h)),
    n
}
function LM(t) {
    const n = nt.useRef(null);
    return n.current === null && (n.current = t()),
    n.current
}
const z_ = t=>Array.isArray(t)
  , cF = t=>!!(t && typeof t == "object" && t.mix && t.toValue)
  , uF = t=>z_(t) ? t[t.length - 1] || 0 : t;
function Am(t) {
    const n = Zs(t) ? t.get() : t;
    return cF(n) ? n.toValue() : n
}
function hF({scrapeMotionValuesFromProps: t, createRenderState: n, onMount: r}, s, h, l) {
    const g = {
        latestValues: dF(s, h, l, t),
        renderState: n()
    };
    return r && (g.mount = _=>r(s, _, g)),
    g
}
const IM = t=>(n,r)=>{
    const s = nt.useContext(Sg)
      , h = nt.useContext(Tg)
      , l = ()=>hF(t, n, s, h);
    return r ? l() : LM(l)
}
;
function dF(t, n, r, s) {
    const h = {}
      , l = s(t, {});
    for (const R in l)
        h[R] = Am(l[R]);
    let {initial: g, animate: _} = t;
    const A = Mg(t)
      , m = yM(t);
    n && m && !A && t.inherit !== !1 && (g === void 0 && (g = n.initial),
    _ === void 0 && (_ = n.animate));
    let D = r ? r.initial === !1 : !1;
    D = D || g === !1;
    const U = D ? _ : g;
    return U && typeof U != "boolean" && !Eg(U) && (Array.isArray(U) ? U : [U]).forEach(ne=>{
        const ce = dx(t, ne);
        if (!ce)
            return;
        const {transitionEnd: xe, transition: Se, ...$} = ce;
        for (const q in $) {
            let N = $[q];
            if (Array.isArray(N)) {
                const ie = D ? N.length - 1 : 0;
                N = N[ie]
            }
            N !== null && (h[q] = N)
        }
        for (const q in xe)
            h[q] = xe[q]
    }
    ),
    h
}
const Bs = t=>t
  , {schedule: _s, cancel: Mc, state: Ds, steps: Pv} = _M(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Bs, !0)
  , fF = {
    useVisualState: IM({
        scrapeMotionValuesFromProps: DM,
        createRenderState: MM,
        onMount: (t,n,{renderState: r, latestValues: s})=>{
            _s.read(()=>{
                try {
                    r.dimensions = typeof n.getBBox == "function" ? n.getBBox() : n.getBoundingClientRect()
                } catch {
                    r.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                }
            }
            ),
            _s.render(()=>{
                cx(r, s, {
                    enableHardwareAcceleration: !1
                }, ux(n.tagName), t.transformTemplate),
                RM(n, r)
            }
            )
        }
    })
}
  , pF = {
    useVisualState: IM({
        scrapeMotionValuesFromProps: hx,
        createRenderState: lx
    })
};
function mF(t, {forwardMotionProps: n=!1}, r, s) {
    return {
        ...rx(t) ? fF : pF,
        preloadedFeatures: r,
        useRender: lF(n),
        createVisualElement: s,
        Component: t
    }
}
function Dl(t, n, r, s={
    passive: !0
}) {
    return t.addEventListener(n, r, s),
    ()=>t.removeEventListener(n, r)
}
const OM = t=>t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function Cg(t, n="page") {
    return {
        point: {
            x: t[n + "X"],
            y: t[n + "Y"]
        }
    }
}
const gF = t=>n=>OM(n) && t(n, Cg(n));
function Il(t, n, r, s) {
    return Dl(t, n, gF(r), s)
}
const vF = (t,n)=>r=>n(t(r))
  , Ol = (...t)=>t.reduce(vF);
function BM(t) {
    let n = null;
    return ()=>{
        const r = ()=>{
            n = null
        }
        ;
        return n === null ? (n = t,
        r) : !1
    }
}
const kA = BM("dragHorizontal")
  , UA = BM("dragVertical");
function FM(t) {
    let n = !1;
    if (t === "y")
        n = UA();
    else if (t === "x")
        n = kA();
    else {
        const r = kA()
          , s = UA();
        r && s ? n = ()=>{
            r(),
            s()
        }
        : (r && r(),
        s && s())
    }
    return n
}
function kM() {
    const t = FM(!0);
    return t ? (t(),
    !1) : !0
}
class Oc {
    constructor(n) {
        this.isMounted = !1,
        this.node = n
    }
    update() {}
}
function NA(t, n) {
    const r = "pointer" + (n ? "enter" : "leave")
      , s = "onHover" + (n ? "Start" : "End")
      , h = (l,g)=>{
        if (l.pointerType === "touch" || kM())
            return;
        const _ = t.getProps();
        t.animationState && _.whileHover && t.animationState.setActive("whileHover", n),
        _[s] && _[s](l, g)
    }
    ;
    return Il(t.current, r, h, {
        passive: !t.getProps()[s]
    })
}
class _F extends Oc {
    mount() {
        this.unmount = Ol(NA(this.node, !0), NA(this.node, !1))
    }
    unmount() {}
}
class yF extends Oc {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let n = !1;
        try {
            n = this.node.current.matches(":focus-visible")
        } catch {
            n = !0
        }
        !n || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = Ol(Dl(this.node.current, "focus", ()=>this.onFocus()), Dl(this.node.current, "blur", ()=>this.onBlur()))
    }
    unmount() {}
}
const UM = (t,n)=>n ? t === n ? !0 : UM(t, n.parentElement) : !1;
function Rv(t, n) {
    if (!n)
        return;
    const r = new PointerEvent("pointer" + t);
    n(r, Cg(r))
}
class xF extends Oc {
    constructor() {
        super(...arguments),
        this.removeStartListeners = Bs,
        this.removeEndListeners = Bs,
        this.removeAccessibleListeners = Bs,
        this.startPointerPress = (n,r)=>{
            if (this.isPressing)
                return;
            this.removeEndListeners();
            const s = this.node.getProps()
              , l = Il(window, "pointerup", (_,A)=>{
                if (!this.checkPressEnd())
                    return;
                const {onTap: m, onTapCancel: D, globalTapTarget: U} = this.node.getProps();
                !U && !UM(this.node.current, _.target) ? D && D(_, A) : m && m(_, A)
            }
            , {
                passive: !(s.onTap || s.onPointerUp)
            })
              , g = Il(window, "pointercancel", (_,A)=>this.cancelPress(_, A), {
                passive: !(s.onTapCancel || s.onPointerCancel)
            });
            this.removeEndListeners = Ol(l, g),
            this.startPress(n, r)
        }
        ,
        this.startAccessiblePress = ()=>{
            const n = l=>{
                if (l.key !== "Enter" || this.isPressing)
                    return;
                const g = _=>{
                    _.key !== "Enter" || !this.checkPressEnd() || Rv("up", (A,m)=>{
                        const {onTap: D} = this.node.getProps();
                        D && D(A, m)
                    }
                    )
                }
                ;
                this.removeEndListeners(),
                this.removeEndListeners = Dl(this.node.current, "keyup", g),
                Rv("down", (_,A)=>{
                    this.startPress(_, A)
                }
                )
            }
              , r = Dl(this.node.current, "keydown", n)
              , s = ()=>{
                this.isPressing && Rv("cancel", (l,g)=>this.cancelPress(l, g))
            }
              , h = Dl(this.node.current, "blur", s);
            this.removeAccessibleListeners = Ol(r, h)
        }
    }
    startPress(n, r) {
        this.isPressing = !0;
        const {onTapStart: s, whileTap: h} = this.node.getProps();
        h && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
        s && s(n, r)
    }
    checkPressEnd() {
        return this.removeEndListeners(),
        this.isPressing = !1,
        this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
        !kM()
    }
    cancelPress(n, r) {
        if (!this.checkPressEnd())
            return;
        const {onTapCancel: s} = this.node.getProps();
        s && s(n, r)
    }
    mount() {
        const n = this.node.getProps()
          , r = Il(n.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
            passive: !(n.onTapStart || n.onPointerStart)
        })
          , s = Dl(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = Ol(r, s)
    }
    unmount() {
        this.removeStartListeners(),
        this.removeEndListeners(),
        this.removeAccessibleListeners()
    }
}
const G_ = new WeakMap
  , Dv = new WeakMap
  , bF = t=>{
    const n = G_.get(t.target);
    n && n(t)
}
  , wF = t=>{
    t.forEach(bF)
}
;
function AF({root: t, ...n}) {
    const r = t || document;
    Dv.has(r) || Dv.set(r, {});
    const s = Dv.get(r)
      , h = JSON.stringify(n);
    return s[h] || (s[h] = new IntersectionObserver(wF,{
        root: t,
        ...n
    })),
    s[h]
}
function SF(t, n, r) {
    const s = AF(n);
    return G_.set(t, r),
    s.observe(t),
    ()=>{
        G_.delete(t),
        s.unobserve(t)
    }
}
const TF = {
    some: 0,
    all: 1
};
class EF extends Oc {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: n={}} = this.node.getProps()
          , {root: r, margin: s, amount: h="some", once: l} = n
          , g = {
            root: r ? r.current : void 0,
            rootMargin: s,
            threshold: typeof h == "number" ? h : TF[h]
        }
          , _ = A=>{
            const {isIntersecting: m} = A;
            if (this.isInView === m || (this.isInView = m,
            l && !m && this.hasEnteredView))
                return;
            m && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", m);
            const {onViewportEnter: D, onViewportLeave: U} = this.node.getProps()
              , R = m ? D : U;
            R && R(A)
        }
        ;
        return SF(this.node.current, g, _)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: n, prevProps: r} = this.node;
        ["amount", "margin", "root"].some(MF(n, r)) && this.startObserver()
    }
    unmount() {}
}
function MF({viewport: t={}}, {viewport: n={}}={}) {
    return r=>t[r] !== n[r]
}
const CF = {
    inView: {
        Feature: EF
    },
    tap: {
        Feature: xF
    },
    focus: {
        Feature: yF
    },
    hover: {
        Feature: _F
    }
};
function NM(t, n) {
    if (!Array.isArray(n))
        return !1;
    const r = n.length;
    if (r !== t.length)
        return !1;
    for (let s = 0; s < r; s++)
        if (n[s] !== t[s])
            return !1;
    return !0
}
function PF(t) {
    const n = {};
    return t.values.forEach((r,s)=>n[s] = r.get()),
    n
}
function RF(t) {
    const n = {};
    return t.values.forEach((r,s)=>n[s] = r.getVelocity()),
    n
}
function Pg(t, n, r) {
    const s = t.getProps();
    return dx(s, n, r !== void 0 ? r : s.custom, PF(t), RF(t))
}
const Bl = t=>t * 1e3
  , Fl = t=>t / 1e3
  , DF = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , LF = t=>({
    type: "spring",
    stiffness: 550,
    damping: t === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , IF = {
    type: "keyframes",
    duration: .8
}
  , OF = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , BF = (t,{keyframes: n})=>n.length > 2 ? IF : Su.has(t) ? t.startsWith("scale") ? LF(n[1]) : DF : OF;
function FF({when: t, delay: n, delayChildren: r, staggerChildren: s, staggerDirection: h, repeat: l, repeatType: g, repeatDelay: _, from: A, elapsed: m, ...D}) {
    return !!Object.keys(D).length
}
function fx(t, n) {
    return t[n] || t.default || t
}
const kF = t=>t !== null;
function Rg(t, {repeat: n, repeatType: r="loop"}, s) {
    const h = t.filter(kF)
      , l = n && r !== "loop" && n % 2 === 1 ? 0 : h.length - 1;
    return !l || s === void 0 ? h[l] : s
}
let Sm;
function UF() {
    Sm = void 0
}
const Ac = {
    now: ()=>(Sm === void 0 && Ac.set(Ds.isProcessing || MB.useManualTiming ? Ds.timestamp : performance.now()),
    Sm),
    set: t=>{
        Sm = t,
        queueMicrotask(UF)
    }
}
  , zM = t=>/^0[^.\s]+$/u.test(t);
function NF(t) {
    return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || zM(t) : !0
}
let zF = Bs
  , GM = Bs;
const HM = t=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t)
  , GF = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function HF(t) {
    const n = GF.exec(t);
    if (!n)
        return [, ];
    const [,r,s,h] = n;
    return [`--${r ?? s}`, h]
}
function VM(t, n, r=1) {
    const [s,h] = HF(t);
    if (!s)
        return;
    const l = window.getComputedStyle(n).getPropertyValue(s);
    if (l) {
        const g = l.trim();
        return HM(g) ? parseFloat(g) : g
    }
    return sx(h) ? VM(h, n, r + 1) : h
}
const VF = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
  , zA = t=>t === Uh || t === Kn
  , GA = (t,n)=>parseFloat(t.split(", ")[n])
  , HA = (t,n)=>(r,{transform: s})=>{
    if (s === "none" || !s)
        return 0;
    const h = s.match(/^matrix3d\((.+)\)$/u);
    if (h)
        return GA(h[1], n);
    {
        const l = s.match(/^matrix\((.+)\)$/u);
        return l ? GA(l[1], t) : 0
    }
}
  , WF = new Set(["x", "y", "z"])
  , jF = Of.filter(t=>!WF.has(t));
function VA(t) {
    const n = [];
    return jF.forEach(r=>{
        const s = t.getValue(r);
        s !== void 0 && (n.push([r, s.get()]),
        s.set(r.startsWith("scale") ? 1 : 0))
    }
    ),
    n
}
const Lh = {
    width: ({x: t},{paddingLeft: n="0", paddingRight: r="0"})=>t.max - t.min - parseFloat(n) - parseFloat(r),
    height: ({y: t},{paddingTop: n="0", paddingBottom: r="0"})=>t.max - t.min - parseFloat(n) - parseFloat(r),
    top: (t,{top: n})=>parseFloat(n),
    left: (t,{left: n})=>parseFloat(n),
    bottom: ({y: t},{top: n})=>parseFloat(n) + (t.max - t.min),
    right: ({x: t},{left: n})=>parseFloat(n) + (t.max - t.min),
    x: HA(4, 13),
    y: HA(5, 14)
};
Lh.translateX = Lh.x;
Lh.translateY = Lh.y;
const WM = t=>n=>n.test(t)
  , XF = {
    test: t=>t === "auto",
    parse: t=>t
}
  , jM = [Uh, Kn, sl, ac, ZB, KB, XF]
  , WA = t=>jM.find(WM(t))
  , gu = new Set;
let H_ = !1
  , V_ = !1;
function XM() {
    if (V_) {
        const t = Array.from(gu).filter(s=>s.needsMeasurement)
          , n = new Set(t.map(s=>s.element))
          , r = new Map;
        n.forEach(s=>{
            VA(s).length && (r.set(s, VA(s)),
            s.render())
        }
        ),
        t.forEach(s=>s.measureInitialState()),
        n.forEach(s=>{
            s.render()
        }
        ),
        t.forEach(s=>s.measureEndState()),
        t.forEach(s=>{
            s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY)
        }
        )
    }
    V_ = !1,
    H_ = !1,
    gu.forEach(t=>t.complete()),
    gu.clear()
}
function YM() {
    gu.forEach(t=>{
        t.readKeyframes(),
        t.needsMeasurement && (V_ = !0)
    }
    )
}
function YF() {
    YM(),
    XM()
}
class px {
    constructor(n, r, s, h, l, g=!1) {
        this.isComplete = !1,
        this.isAsync = !1,
        this.needsMeasurement = !1,
        this.isScheduled = !1,
        this.unresolvedKeyframes = [...n],
        this.onComplete = r,
        this.name = s,
        this.motionValue = h,
        this.element = l,
        this.isAsync = g
    }
    scheduleResolve() {
        this.isScheduled = !0,
        this.isAsync ? (gu.add(this),
        H_ || (H_ = !0,
        _s.read(YM),
        _s.resolveKeyframes(XM))) : (this.readKeyframes(),
        this.complete())
    }
    readKeyframes() {
        const {unresolvedKeyframes: n, name: r, element: s, motionValue: h} = this;
        for (let l = 0; l < n.length; l++)
            if (n[l] === null)
                if (l === 0) {
                    const g = h == null ? void 0 : h.get()
                      , _ = n[n.length - 1];
                    if (g !== void 0)
                        n[0] = g;
                    else if (s && r) {
                        const A = s.readValue(r, _);
                        A != null && (n[0] = A)
                    }
                    n[0] === void 0 && (n[0] = _),
                    h && g === void 0 && h.set(n[0])
                } else
                    n[l] = n[l - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0,
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
        gu.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1,
        gu.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const mx = (t,n)=>r=>!!(Bf(r) && QB.test(r) && r.startsWith(t) || n && Object.prototype.hasOwnProperty.call(r, n))
  , QM = (t,n,r)=>s=>{
    if (!Bf(s))
        return s;
    const [h,l,g,_] = s.match(ox);
    return {
        [t]: parseFloat(h),
        [n]: parseFloat(l),
        [r]: parseFloat(g),
        alpha: _ !== void 0 ? parseFloat(_) : 1
    }
}
  , QF = t=>Ec(0, 255, t)
  , Lv = {
    ...Uh,
    transform: t=>Math.round(QF(t))
}
  , fu = {
    test: mx("rgb", "red"),
    parse: QM("red", "green", "blue"),
    transform: ({red: t, green: n, blue: r, alpha: s=1})=>"rgba(" + Lv.transform(t) + ", " + Lv.transform(n) + ", " + Lv.transform(r) + ", " + ef($d.transform(s)) + ")"
};
function KF(t) {
    let n = ""
      , r = ""
      , s = ""
      , h = "";
    return t.length > 5 ? (n = t.substring(1, 3),
    r = t.substring(3, 5),
    s = t.substring(5, 7),
    h = t.substring(7, 9)) : (n = t.substring(1, 2),
    r = t.substring(2, 3),
    s = t.substring(3, 4),
    h = t.substring(4, 5),
    n += n,
    r += r,
    s += s,
    h += h),
    {
        red: parseInt(n, 16),
        green: parseInt(r, 16),
        blue: parseInt(s, 16),
        alpha: h ? parseInt(h, 16) / 255 : 1
    }
}
const W_ = {
    test: mx("#"),
    parse: KF,
    transform: fu.transform
}
  , mh = {
    test: mx("hsl", "hue"),
    parse: QM("hue", "saturation", "lightness"),
    transform: ({hue: t, saturation: n, lightness: r, alpha: s=1})=>"hsla(" + Math.round(t) + ", " + sl.transform(ef(n)) + ", " + sl.transform(ef(r)) + ", " + ef($d.transform(s)) + ")"
}
  , Qs = {
    test: t=>fu.test(t) || W_.test(t) || mh.test(t),
    parse: t=>fu.test(t) ? fu.parse(t) : mh.test(t) ? mh.parse(t) : W_.parse(t),
    transform: t=>Bf(t) ? t : t.hasOwnProperty("red") ? fu.transform(t) : mh.transform(t)
};
function ZF(t) {
    var n, r;
    return isNaN(t) && Bf(t) && (((n = t.match(ox)) === null || n === void 0 ? void 0 : n.length) || 0) + (((r = t.match(YB)) === null || r === void 0 ? void 0 : r.length) || 0) > 0
}
const KM = "number"
  , ZM = "color"
  , qF = "var"
  , JF = "var("
  , jA = "${}"
  , $F = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function $m(t) {
    const n = t.toString()
      , r = []
      , s = {
        color: [],
        number: [],
        var: []
    }
      , h = [];
    let l = 0;
    const _ = n.replace($F, A=>(Qs.test(A) ? (s.color.push(l),
    h.push(ZM),
    r.push(Qs.parse(A))) : A.startsWith(JF) ? (s.var.push(l),
    h.push(qF),
    r.push(A)) : (s.number.push(l),
    h.push(KM),
    r.push(parseFloat(A))),
    ++l,
    jA)).split(jA);
    return {
        values: r,
        split: _,
        indexes: s,
        types: h
    }
}
function qM(t) {
    return $m(t).values
}
function JM(t) {
    const {split: n, types: r} = $m(t)
      , s = n.length;
    return h=>{
        let l = "";
        for (let g = 0; g < s; g++)
            if (l += n[g],
            h[g] !== void 0) {
                const _ = r[g];
                _ === KM ? l += ef(h[g]) : _ === ZM ? l += Qs.transform(h[g]) : l += h[g]
            }
        return l
    }
}
const e4 = t=>typeof t == "number" ? 0 : t;
function t4(t) {
    const n = qM(t);
    return JM(t)(n.map(e4))
}
const Cc = {
    test: ZF,
    parse: qM,
    createTransformer: JM,
    getAnimatableNone: t4
}
  , n4 = new Set(["brightness", "contrast", "saturate", "opacity"]);
function i4(t) {
    const [n,r] = t.slice(0, -1).split("(");
    if (n === "drop-shadow")
        return t;
    const [s] = r.match(ox) || [];
    if (!s)
        return t;
    const h = r.replace(s, "");
    let l = n4.has(n) ? 1 : 0;
    return s !== r && (l *= 100),
    n + "(" + l + h + ")"
}
const r4 = /\b([a-z-]*)\(.*?\)/gu
  , j_ = {
    ...Cc,
    getAnimatableNone: t=>{
        const n = t.match(r4);
        return n ? n.map(i4).join(" ") : t
    }
}
  , s4 = {
    ...SM,
    color: Qs,
    backgroundColor: Qs,
    outlineColor: Qs,
    fill: Qs,
    stroke: Qs,
    borderColor: Qs,
    borderTopColor: Qs,
    borderRightColor: Qs,
    borderBottomColor: Qs,
    borderLeftColor: Qs,
    filter: j_,
    WebkitFilter: j_
}
  , gx = t=>s4[t];
function $M(t, n) {
    let r = gx(t);
    return r !== j_ && (r = Cc),
    r.getAnimatableNone ? r.getAnimatableNone(n) : void 0
}
function o4(t, n, r) {
    let s = 0, h;
    for (; s < t.length && !h; )
        typeof t[s] == "string" && t[s] !== "none" && t[s] !== "0" && (h = t[s]),
        s++;
    if (h && r)
        for (const l of n)
            t[l] = $M(r, h)
}
class eC extends px {
    constructor(n, r, s, h) {
        super(n, r, s, h, h == null ? void 0 : h.owner, !0)
    }
    readKeyframes() {
        const {unresolvedKeyframes: n, element: r, name: s} = this;
        if (!r.current)
            return;
        super.readKeyframes();
        for (let A = 0; A < n.length; A++) {
            const m = n[A];
            if (typeof m == "string" && sx(m)) {
                const D = VM(m, r.current);
                D !== void 0 && (n[A] = D)
            }
        }
        if (!VF.has(s) || n.length !== 2)
            return this.resolveNoneKeyframes();
        const [h,l] = n
          , g = WA(h)
          , _ = WA(l);
        if (g !== _)
            if (zA(g) && zA(_))
                for (let A = 0; A < n.length; A++) {
                    const m = n[A];
                    typeof m == "string" && (n[A] = parseFloat(m))
                }
            else
                this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {unresolvedKeyframes: n, name: r} = this
          , s = [];
        for (let h = 0; h < n.length; h++)
            NF(n[h]) && s.push(h);
        s.length && o4(n, s, r)
    }
    measureInitialState() {
        const {element: n, unresolvedKeyframes: r, name: s} = this;
        if (!n.current)
            return;
        s === "height" && (this.suspendedScrollY = window.pageYOffset),
        this.measuredOrigin = Lh[s](n.measureViewportBox(), window.getComputedStyle(n.current)),
        r[0] = this.measuredOrigin;
        const h = r[r.length - 1];
        h !== void 0 && n.getValue(s, h).jump(h, !1)
    }
    measureEndState() {
        var n;
        const {element: r, name: s, unresolvedKeyframes: h} = this;
        if (!r.current)
            return;
        const l = r.getValue(s);
        l && l.jump(this.measuredOrigin, !1);
        const g = h.length - 1
          , _ = h[g];
        h[g] = Lh[s](r.measureViewportBox(), window.getComputedStyle(r.current)),
        _ !== null && (this.finalKeyframe = _),
        !((n = this.removedTransforms) === null || n === void 0) && n.length && this.removedTransforms.forEach(([A,m])=>{
            r.getValue(A).set(m)
        }
        ),
        this.resolveNoneKeyframes()
    }
}
function a4(t) {
    let n;
    return ()=>(n === void 0 && (n = t()),
    n)
}
const XA = (t,n)=>n === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (Cc.test(t) || t === "0") && !t.startsWith("url("));
function l4(t) {
    const n = t[0];
    if (t.length === 1)
        return !0;
    for (let r = 0; r < t.length; r++)
        if (t[r] !== n)
            return !0
}
function c4(t, n, r, s) {
    const h = t[0];
    if (h === null)
        return !1;
    const l = t[t.length - 1]
      , g = XA(h, n)
      , _ = XA(l, n);
    return !g || !_ ? !1 : l4(t) || r === "spring" && s
}
class tC {
    constructor({autoplay: n=!0, delay: r=0, type: s="keyframes", repeat: h=0, repeatDelay: l=0, repeatType: g="loop", ..._}) {
        this.isStopped = !1,
        this.options = {
            autoplay: n,
            delay: r,
            type: s,
            repeat: h,
            repeatDelay: l,
            repeatType: g,
            ..._
        },
        this.updateFinishedPromise()
    }
    get resolved() {
        return this._resolved || YF(),
        this._resolved
    }
    onKeyframesResolved(n, r) {
        const {name: s, type: h, velocity: l, delay: g, onComplete: _, onUpdate: A} = this.options;
        if (!c4(n, s, h, l))
            if (g)
                this.options.duration = 0;
            else {
                A == null || A(Rg(n, this.options, r)),
                _ == null || _(),
                this.resolveFinishedPromise();
                return
            }
        const m = this.initPlayback(n, r);
        m !== !1 && (this._resolved = {
            keyframes: n,
            finalKeyframe: r,
            ...m
        },
        this.onPostResolved())
    }
    onPostResolved() {}
    then(n, r) {
        return this.currentFinishedPromise.then(n, r)
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(n=>{
            this.resolveFinishedPromise = n
        }
        )
    }
}
function nC(t, n) {
    return n ? t * (1e3 / n) : 0
}
const u4 = 5;
function iC(t, n, r) {
    const s = Math.max(n - u4, 0);
    return nC(r - t(s), n - s)
}
const Iv = .001
  , h4 = .01
  , YA = 10
  , d4 = .05
  , f4 = 1;
function p4({duration: t=800, bounce: n=.25, velocity: r=0, mass: s=1}) {
    let h, l;
    zF(t <= Bl(YA));
    let g = 1 - n;
    g = Ec(d4, f4, g),
    t = Ec(h4, YA, Fl(t)),
    g < 1 ? (h = m=>{
        const D = m * g
          , U = D * t
          , R = D - r
          , ne = X_(m, g)
          , ce = Math.exp(-U);
        return Iv - R / ne * ce
    }
    ,
    l = m=>{
        const U = m * g * t
          , R = U * r + r
          , ne = Math.pow(g, 2) * Math.pow(m, 2) * t
          , ce = Math.exp(-U)
          , xe = X_(Math.pow(m, 2), g);
        return (-h(m) + Iv > 0 ? -1 : 1) * ((R - ne) * ce) / xe
    }
    ) : (h = m=>{
        const D = Math.exp(-m * t)
          , U = (m - r) * t + 1;
        return -Iv + D * U
    }
    ,
    l = m=>{
        const D = Math.exp(-m * t)
          , U = (r - m) * (t * t);
        return D * U
    }
    );
    const _ = 5 / t
      , A = g4(h, l, _);
    if (t = Bl(t),
    isNaN(A))
        return {
            stiffness: 100,
            damping: 10,
            duration: t
        };
    {
        const m = Math.pow(A, 2) * s;
        return {
            stiffness: m,
            damping: g * 2 * Math.sqrt(s * m),
            duration: t
        }
    }
}
const m4 = 12;
function g4(t, n, r) {
    let s = r;
    for (let h = 1; h < m4; h++)
        s = s - t(s) / n(s);
    return s
}
function X_(t, n) {
    return t * Math.sqrt(1 - n * n)
}
const v4 = ["duration", "bounce"]
  , _4 = ["stiffness", "damping", "mass"];
function QA(t, n) {
    return n.some(r=>t[r] !== void 0)
}
function y4(t) {
    let n = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...t
    };
    if (!QA(t, _4) && QA(t, v4)) {
        const r = p4(t);
        n = {
            ...n,
            ...r,
            mass: 1
        },
        n.isResolvedFromDuration = !0
    }
    return n
}
function rC({keyframes: t, restDelta: n, restSpeed: r, ...s}) {
    const h = t[0]
      , l = t[t.length - 1]
      , g = {
        done: !1,
        value: h
    }
      , {stiffness: _, damping: A, mass: m, duration: D, velocity: U, isResolvedFromDuration: R} = y4({
        ...s,
        velocity: -Fl(s.velocity || 0)
    })
      , ne = U || 0
      , ce = A / (2 * Math.sqrt(_ * m))
      , xe = l - h
      , Se = Fl(Math.sqrt(_ / m))
      , $ = Math.abs(xe) < 5;
    r || (r = $ ? .01 : 2),
    n || (n = $ ? .005 : .5);
    let q;
    if (ce < 1) {
        const N = X_(Se, ce);
        q = ie=>{
            const _e = Math.exp(-ce * Se * ie);
            return l - _e * ((ne + ce * Se * xe) / N * Math.sin(N * ie) + xe * Math.cos(N * ie))
        }
    } else if (ce === 1)
        q = N=>l - Math.exp(-Se * N) * (xe + (ne + Se * xe) * N);
    else {
        const N = Se * Math.sqrt(ce * ce - 1);
        q = ie=>{
            const _e = Math.exp(-ce * Se * ie)
              , Pe = Math.min(N * ie, 300);
            return l - _e * ((ne + ce * Se * xe) * Math.sinh(Pe) + N * xe * Math.cosh(Pe)) / N
        }
    }
    return {
        calculatedDuration: R && D || null,
        next: N=>{
            const ie = q(N);
            if (R)
                g.done = N >= D;
            else {
                let _e = ne;
                N !== 0 && (ce < 1 ? _e = iC(q, N, ie) : _e = 0);
                const Pe = Math.abs(_e) <= r
                  , Be = Math.abs(l - ie) <= n;
                g.done = Pe && Be
            }
            return g.value = g.done ? l : ie,
            g
        }
    }
}
function KA({keyframes: t, velocity: n=0, power: r=.8, timeConstant: s=325, bounceDamping: h=10, bounceStiffness: l=500, modifyTarget: g, min: _, max: A, restDelta: m=.5, restSpeed: D}) {
    const U = t[0]
      , R = {
        done: !1,
        value: U
    }
      , ne = Re=>_ !== void 0 && Re < _ || A !== void 0 && Re > A
      , ce = Re=>_ === void 0 ? A : A === void 0 || Math.abs(_ - Re) < Math.abs(A - Re) ? _ : A;
    let xe = r * n;
    const Se = U + xe
      , $ = g === void 0 ? Se : g(Se);
    $ !== Se && (xe = $ - U);
    const q = Re=>-xe * Math.exp(-Re / s)
      , N = Re=>$ + q(Re)
      , ie = Re=>{
        const ct = q(Re)
          , et = N(Re);
        R.done = Math.abs(ct) <= m,
        R.value = R.done ? $ : et
    }
    ;
    let _e, Pe;
    const Be = Re=>{
        ne(R.value) && (_e = Re,
        Pe = rC({
            keyframes: [R.value, ce(R.value)],
            velocity: iC(N, Re, R.value),
            damping: h,
            stiffness: l,
            restDelta: m,
            restSpeed: D
        }))
    }
    ;
    return Be(0),
    {
        calculatedDuration: null,
        next: Re=>{
            let ct = !1;
            return !Pe && _e === void 0 && (ct = !0,
            ie(Re),
            Be(Re)),
            _e !== void 0 && Re >= _e ? Pe.next(Re - _e) : (!ct && ie(Re),
            R)
        }
    }
}
const sC = (t,n,r)=>(((1 - 3 * r + 3 * n) * t + (3 * r - 6 * n)) * t + 3 * n) * t
  , x4 = 1e-7
  , b4 = 12;
function w4(t, n, r, s, h) {
    let l, g, _ = 0;
    do
        g = n + (r - n) / 2,
        l = sC(g, s, h) - t,
        l > 0 ? r = g : n = g;
    while (Math.abs(l) > x4 && ++_ < b4);
    return g
}
function kf(t, n, r, s) {
    if (t === n && r === s)
        return Bs;
    const h = l=>w4(l, 0, 1, t, r);
    return l=>l === 0 || l === 1 ? l : sC(h(l), n, s)
}
const A4 = kf(.42, 0, 1, 1)
  , S4 = kf(0, 0, .58, 1)
  , oC = kf(.42, 0, .58, 1)
  , T4 = t=>Array.isArray(t) && typeof t[0] != "number"
  , aC = t=>n=>n <= .5 ? t(2 * n) / 2 : (2 - t(2 * (1 - n))) / 2
  , lC = t=>n=>1 - t(1 - n)
  , vx = t=>1 - Math.sin(Math.acos(t))
  , cC = lC(vx)
  , E4 = aC(vx)
  , uC = kf(.33, 1.53, .69, .99)
  , _x = lC(uC)
  , M4 = aC(_x)
  , C4 = t=>(t *= 2) < 1 ? .5 * _x(t) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
  , P4 = {
    linear: Bs,
    easeIn: A4,
    easeInOut: oC,
    easeOut: S4,
    circIn: vx,
    circInOut: E4,
    circOut: cC,
    backIn: _x,
    backInOut: M4,
    backOut: uC,
    anticipate: C4
}
  , ZA = t=>{
    if (Array.isArray(t)) {
        GM(t.length === 4);
        const [n,r,s,h] = t;
        return kf(n, r, s, h)
    } else if (typeof t == "string")
        return P4[t];
    return t
}
  , Ef = (t,n,r)=>{
    const s = n - t;
    return s === 0 ? 1 : (r - t) / s
}
  , Ir = (t,n,r)=>t + (n - t) * r;
function Ov(t, n, r) {
    return r < 0 && (r += 1),
    r > 1 && (r -= 1),
    r < 1 / 6 ? t + (n - t) * 6 * r : r < 1 / 2 ? n : r < 2 / 3 ? t + (n - t) * (2 / 3 - r) * 6 : t
}
function R4({hue: t, saturation: n, lightness: r, alpha: s}) {
    t /= 360,
    n /= 100,
    r /= 100;
    let h = 0
      , l = 0
      , g = 0;
    if (!n)
        h = l = g = r;
    else {
        const _ = r < .5 ? r * (1 + n) : r + n - r * n
          , A = 2 * r - _;
        h = Ov(A, _, t + 1 / 3),
        l = Ov(A, _, t),
        g = Ov(A, _, t - 1 / 3)
    }
    return {
        red: Math.round(h * 255),
        green: Math.round(l * 255),
        blue: Math.round(g * 255),
        alpha: s
    }
}
const Bv = (t,n,r)=>{
    const s = t * t
      , h = r * (n * n - s) + s;
    return h < 0 ? 0 : Math.sqrt(h)
}
  , D4 = [W_, fu, mh]
  , L4 = t=>D4.find(n=>n.test(t));
function qA(t) {
    const n = L4(t);
    let r = n.parse(t);
    return n === mh && (r = R4(r)),
    r
}
const JA = (t,n)=>{
    const r = qA(t)
      , s = qA(n)
      , h = {
        ...r
    };
    return l=>(h.red = Bv(r.red, s.red, l),
    h.green = Bv(r.green, s.green, l),
    h.blue = Bv(r.blue, s.blue, l),
    h.alpha = Ir(r.alpha, s.alpha, l),
    fu.transform(h))
}
;
function Y_(t, n) {
    return r=>r > 0 ? n : t
}
function I4(t, n) {
    return r=>Ir(t, n, r)
}
function yx(t) {
    return typeof t == "number" ? I4 : typeof t == "string" ? sx(t) ? Y_ : Qs.test(t) ? JA : F4 : Array.isArray(t) ? hC : typeof t == "object" ? Qs.test(t) ? JA : O4 : Y_
}
function hC(t, n) {
    const r = [...t]
      , s = r.length
      , h = t.map((l,g)=>yx(l)(l, n[g]));
    return l=>{
        for (let g = 0; g < s; g++)
            r[g] = h[g](l);
        return r
    }
}
function O4(t, n) {
    const r = {
        ...t,
        ...n
    }
      , s = {};
    for (const h in r)
        t[h] !== void 0 && n[h] !== void 0 && (s[h] = yx(t[h])(t[h], n[h]));
    return h=>{
        for (const l in s)
            r[l] = s[l](h);
        return r
    }
}
function B4(t, n) {
    var r;
    const s = []
      , h = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let l = 0; l < n.values.length; l++) {
        const g = n.types[l]
          , _ = t.indexes[g][h[g]]
          , A = (r = t.values[_]) !== null && r !== void 0 ? r : 0;
        s[l] = A,
        h[g]++
    }
    return s
}
const F4 = (t,n)=>{
    const r = Cc.createTransformer(n)
      , s = $m(t)
      , h = $m(n);
    return s.indexes.var.length === h.indexes.var.length && s.indexes.color.length === h.indexes.color.length && s.indexes.number.length >= h.indexes.number.length ? Ol(hC(B4(s, h), h.values), r) : Y_(t, n)
}
;
function dC(t, n, r) {
    return typeof t == "number" && typeof n == "number" && typeof r == "number" ? Ir(t, n, r) : yx(t)(t, n)
}
function k4(t, n, r) {
    const s = []
      , h = r || dC
      , l = t.length - 1;
    for (let g = 0; g < l; g++) {
        let _ = h(t[g], t[g + 1]);
        if (n) {
            const A = Array.isArray(n) ? n[g] || Bs : n;
            _ = Ol(A, _)
        }
        s.push(_)
    }
    return s
}
function U4(t, n, {clamp: r=!0, ease: s, mixer: h}={}) {
    const l = t.length;
    if (GM(l === n.length),
    l === 1)
        return ()=>n[0];
    if (l === 2 && t[0] === t[1])
        return ()=>n[1];
    t[0] > t[l - 1] && (t = [...t].reverse(),
    n = [...n].reverse());
    const g = k4(n, s, h)
      , _ = g.length
      , A = m=>{
        let D = 0;
        if (_ > 1)
            for (; D < t.length - 2 && !(m < t[D + 1]); D++)
                ;
        const U = Ef(t[D], t[D + 1], m);
        return g[D](U)
    }
    ;
    return r ? m=>A(Ec(t[0], t[l - 1], m)) : A
}
function N4(t, n) {
    const r = t[t.length - 1];
    for (let s = 1; s <= n; s++) {
        const h = Ef(0, n, s);
        t.push(Ir(r, 1, h))
    }
}
function z4(t) {
    const n = [0];
    return N4(n, t.length - 1),
    n
}
function G4(t, n) {
    return t.map(r=>r * n)
}
function H4(t, n) {
    return t.map(()=>n || oC).splice(0, t.length - 1)
}
function eg({duration: t=300, keyframes: n, times: r, ease: s="easeInOut"}) {
    const h = T4(s) ? s.map(ZA) : ZA(s)
      , l = {
        done: !1,
        value: n[0]
    }
      , g = G4(r && r.length === n.length ? r : z4(n), t)
      , _ = U4(g, n, {
        ease: Array.isArray(h) ? h : H4(n, h)
    });
    return {
        calculatedDuration: t,
        next: A=>(l.value = _(A),
        l.done = A >= t,
        l)
    }
}
const $A = 2e4;
function V4(t) {
    let n = 0;
    const r = 50;
    let s = t.next(n);
    for (; !s.done && n < $A; )
        n += r,
        s = t.next(n);
    return n >= $A ? 1 / 0 : n
}
const W4 = t=>{
    const n = ({timestamp: r})=>t(r);
    return {
        start: ()=>_s.update(n, !0),
        stop: ()=>Mc(n),
        now: ()=>Ds.isProcessing ? Ds.timestamp : Ac.now()
    }
}
  , j4 = {
    decay: KA,
    inertia: KA,
    tween: eg,
    keyframes: eg,
    spring: rC
}
  , X4 = t=>t / 100;
class xx extends tC {
    constructor({KeyframeResolver: n=px, ...r}) {
        super(r),
        this.holdTime = null,
        this.startTime = null,
        this.cancelTime = null,
        this.currentTime = 0,
        this.playbackSpeed = 1,
        this.pendingPlayState = "running",
        this.state = "idle";
        const {name: s, motionValue: h, keyframes: l} = this.options
          , g = (_,A)=>this.onKeyframesResolved(_, A);
        s && h && h.owner ? this.resolver = h.owner.resolveKeyframes(l, g, s, h) : this.resolver = new n(l,g,s,h),
        this.resolver.scheduleResolve()
    }
    initPlayback(n) {
        const {type: r="keyframes", repeat: s=0, repeatDelay: h=0, repeatType: l, velocity: g=0} = this.options
          , _ = j4[r] || eg;
        let A, m;
        _ !== eg && typeof n[0] != "number" && (A = Ol(X4, dC(n[0], n[1])),
        n = [0, 100]);
        const D = _({
            ...this.options,
            keyframes: n
        });
        l === "mirror" && (m = _({
            ...this.options,
            keyframes: [...n].reverse(),
            velocity: -g
        })),
        D.calculatedDuration === null && (D.calculatedDuration = V4(D));
        const {calculatedDuration: U} = D
          , R = U + h
          , ne = R * (s + 1) - h;
        return {
            generator: D,
            mirroredGenerator: m,
            mapPercentToKeyframes: A,
            calculatedDuration: U,
            resolvedDuration: R,
            totalDuration: ne
        }
    }
    onPostResolved() {
        const {autoplay: n=!0} = this.options;
        this.play(),
        this.pendingPlayState === "paused" || !n ? this.pause() : this.state = this.pendingPlayState
    }
    tick(n, r=!1) {
        const {resolved: s} = this;
        if (!s) {
            const {keyframes: Re} = this.options;
            return {
                done: !0,
                value: Re[Re.length - 1]
            }
        }
        const {finalKeyframe: h, generator: l, mirroredGenerator: g, mapPercentToKeyframes: _, keyframes: A, calculatedDuration: m, totalDuration: D, resolvedDuration: U} = s;
        if (this.startTime === null)
            return l.next(0);
        const {delay: R, repeat: ne, repeatType: ce, repeatDelay: xe, onUpdate: Se} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, n) : this.speed < 0 && (this.startTime = Math.min(n - D / this.speed, this.startTime)),
        r ? this.currentTime = n : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(n - this.startTime) * this.speed;
        const $ = this.currentTime - R * (this.speed >= 0 ? 1 : -1)
          , q = this.speed >= 0 ? $ < 0 : $ > D;
        this.currentTime = Math.max($, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = D);
        let N = this.currentTime
          , ie = l;
        if (ne) {
            const Re = Math.min(this.currentTime, D) / U;
            let ct = Math.floor(Re)
              , et = Re % 1;
            !et && Re >= 1 && (et = 1),
            et === 1 && ct--,
            ct = Math.min(ct, ne + 1),
            !!(ct % 2) && (ce === "reverse" ? (et = 1 - et,
            xe && (et -= xe / U)) : ce === "mirror" && (ie = g)),
            N = Ec(0, 1, et) * U
        }
        const _e = q ? {
            done: !1,
            value: A[0]
        } : ie.next(N);
        _ && (_e.value = _(_e.value));
        let {done: Pe} = _e;
        !q && m !== null && (Pe = this.speed >= 0 ? this.currentTime >= D : this.currentTime <= 0);
        const Be = this.holdTime === null && (this.state === "finished" || this.state === "running" && Pe);
        return Be && h !== void 0 && (_e.value = Rg(A, this.options, h)),
        Se && Se(_e.value),
        Be && this.finish(),
        _e
    }
    get duration() {
        const {resolved: n} = this;
        return n ? Fl(n.calculatedDuration) : 0
    }
    get time() {
        return Fl(this.currentTime)
    }
    set time(n) {
        n = Bl(n),
        this.currentTime = n,
        this.holdTime !== null || this.speed === 0 ? this.holdTime = n : this.driver && (this.startTime = this.driver.now() - n / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(n) {
        const r = this.playbackSpeed !== n;
        this.playbackSpeed = n,
        r && (this.time = Fl(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(),
        !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped)
            return;
        const {driver: n=W4, onPlay: r} = this.options;
        this.driver || (this.driver = n(h=>this.tick(h))),
        r && r();
        const s = this.driver.now();
        this.holdTime !== null ? this.startTime = s - this.holdTime : (!this.startTime || this.state === "finished") && (this.startTime = s),
        this.state === "finished" && this.updateFinishedPromise(),
        this.cancelTime = this.startTime,
        this.holdTime = null,
        this.state = "running",
        this.driver.start()
    }
    pause() {
        var n;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused",
        this.holdTime = (n = this.currentTime) !== null && n !== void 0 ? n : 0
    }
    stop() {
        if (this.resolver.cancel(),
        this.isStopped = !0,
        this.state === "idle")
            return;
        this.teardown();
        const {onStop: n} = this.options;
        n && n()
    }
    complete() {
        this.state !== "running" && this.play(),
        this.pendingPlayState = this.state = "finished",
        this.holdTime = null
    }
    finish() {
        this.teardown(),
        this.state = "finished";
        const {onComplete: n} = this.options;
        n && n()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime),
        this.teardown(),
        this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle",
        this.stopDriver(),
        this.resolveFinishedPromise(),
        this.updateFinishedPromise(),
        this.startTime = this.cancelTime = null,
        this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
        this.driver = void 0)
    }
    sample(n) {
        return this.startTime = 0,
        this.tick(n, !0)
    }
}
const fC = t=>Array.isArray(t) && typeof t[0] == "number";
function pC(t) {
    return !!(!t || typeof t == "string" && mC[t] || fC(t) || Array.isArray(t) && t.every(pC))
}
const Vd = ([t,n,r,s])=>`cubic-bezier(${t}, ${n}, ${r}, ${s})`
  , mC = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Vd([0, .65, .55, 1]),
    circOut: Vd([.55, 0, 1, .45]),
    backIn: Vd([.31, .01, .66, -.59]),
    backOut: Vd([.33, 1.53, .69, .99])
};
function gC(t) {
    if (t)
        return fC(t) ? Vd(t) : Array.isArray(t) ? t.map(gC) : mC[t]
}
function Y4(t, n, r, {delay: s=0, duration: h=300, repeat: l=0, repeatType: g="loop", ease: _, times: A}={}) {
    const m = {
        [n]: r
    };
    A && (m.offset = A);
    const D = gC(_);
    return Array.isArray(D) && (m.easing = D),
    t.animate(m, {
        delay: s,
        duration: h,
        easing: Array.isArray(D) ? "linear" : D,
        fill: "both",
        iterations: l + 1,
        direction: g === "reverse" ? "alternate" : "normal"
    })
}
const Q4 = a4(()=>Object.hasOwnProperty.call(Element.prototype, "animate"))
  , K4 = new Set(["opacity", "clipPath", "filter", "transform"])
  , tg = 10
  , Z4 = 2e4;
function q4(t) {
    return t.type === "spring" || t.name === "backgroundColor" || !pC(t.ease)
}
function J4(t, n) {
    const r = new xx({
        ...n,
        keyframes: t,
        repeat: 0,
        delay: 0
    });
    let s = {
        done: !1,
        value: t[0]
    };
    const h = [];
    let l = 0;
    for (; !s.done && l < Z4; )
        s = r.sample(l),
        h.push(s.value),
        l += tg;
    return {
        times: void 0,
        keyframes: h,
        duration: l - tg,
        ease: "linear"
    }
}
class eS extends tC {
    constructor(n) {
        super(n);
        const {name: r, motionValue: s, keyframes: h} = this.options;
        this.resolver = new eC(h,(l,g)=>this.onKeyframesResolved(l, g),r,s),
        this.resolver.scheduleResolve()
    }
    initPlayback(n, r) {
        var s;
        let {duration: h=300, motionValue: l, name: g} = this.options;
        if (!(!((s = l.owner) === null || s === void 0) && s.current))
            return !1;
        if (q4(this.options)) {
            const {onComplete: A, onUpdate: m, motionValue: D, ...U} = this.options
              , R = J4(n, U);
            n = R.keyframes,
            h = R.duration,
            this.options.times = R.times,
            this.options.ease = R.ease
        }
        const _ = Y4(l.owner.current, g, n, {
            ...this.options,
            duration: h
        });
        return _.startTime = Ac.now(),
        this.pendingTimeline ? (_.timeline = this.pendingTimeline,
        this.pendingTimeline = void 0) : _.onfinish = ()=>{
            const {onComplete: A} = this.options;
            l.set(Rg(n, this.options, r)),
            A && A(),
            this.cancel(),
            this.resolveFinishedPromise()
        }
        ,
        {
            animation: _,
            duration: h,
            keyframes: n
        }
    }
    get duration() {
        const {resolved: n} = this;
        if (!n)
            return 0;
        const {duration: r} = n;
        return Fl(r)
    }
    get time() {
        const {resolved: n} = this;
        if (!n)
            return 0;
        const {animation: r} = n;
        return Fl(r.currentTime || 0)
    }
    set time(n) {
        const {resolved: r} = this;
        if (!r)
            return;
        const {animation: s} = r;
        s.currentTime = Bl(n)
    }
    get speed() {
        const {resolved: n} = this;
        if (!n)
            return 1;
        const {animation: r} = n;
        return r.playbackRate
    }
    set speed(n) {
        const {resolved: r} = this;
        if (!r)
            return;
        const {animation: s} = r;
        s.playbackRate = n
    }
    get state() {
        const {resolved: n} = this;
        if (!n)
            return "idle";
        const {animation: r} = n;
        return r.playState
    }
    attachTimeline(n) {
        if (!this._resolved)
            this.pendingTimeline = n;
        else {
            const {resolved: r} = this;
            if (!r)
                return Bs;
            const {animation: s} = r;
            s.timeline = n,
            s.onfinish = null
        }
        return Bs
    }
    play() {
        if (this.isStopped)
            return;
        const {resolved: n} = this;
        if (!n)
            return;
        const {animation: r} = n;
        r.playState === "finished" && this.updateFinishedPromise(),
        r.play()
    }
    pause() {
        const {resolved: n} = this;
        if (!n)
            return;
        const {animation: r} = n;
        r.pause()
    }
    stop() {
        if (this.resolver.cancel(),
        this.isStopped = !0,
        this.state === "idle")
            return;
        const {resolved: n} = this;
        if (!n)
            return;
        const {animation: r, keyframes: s} = n;
        if (!(r.playState === "idle" || r.playState === "finished")) {
            if (this.time) {
                const {motionValue: h, onUpdate: l, onComplete: g, ..._} = this.options
                  , A = new xx({
                    ..._,
                    keyframes: s
                })
                  , m = Bl(this.time);
                h.setWithVelocity(A.sample(m - tg).value, A.sample(m).value, tg)
            }
            this.cancel()
        }
    }
    complete() {
        const {resolved: n} = this;
        n && n.animation.finish()
    }
    cancel() {
        const {resolved: n} = this;
        n && n.animation.cancel()
    }
    static supports(n) {
        const {motionValue: r, name: s, repeatDelay: h, repeatType: l, damping: g, type: _} = n;
        return Q4() && s && K4.has(s) && r && r.owner && r.owner.current instanceof HTMLElement && !r.owner.getProps().onUpdate && !h && l !== "mirror" && g !== 0 && _ !== "inertia"
    }
}
const bx = (t,n,r,s={},h,l)=>g=>{
    const _ = fx(s, t) || {}
      , A = _.delay || s.delay || 0;
    let {elapsed: m=0} = s;
    m = m - Bl(A);
    let D = {
        keyframes: Array.isArray(r) ? r : [null, r],
        ease: "easeOut",
        velocity: n.getVelocity(),
        ..._,
        delay: -m,
        onUpdate: R=>{
            n.set(R),
            _.onUpdate && _.onUpdate(R)
        }
        ,
        onComplete: ()=>{
            g(),
            _.onComplete && _.onComplete()
        }
        ,
        name: t,
        motionValue: n,
        element: l ? void 0 : h
    };
    FF(_) || (D = {
        ...D,
        ...BF(t, D)
    }),
    D.duration && (D.duration = Bl(D.duration)),
    D.repeatDelay && (D.repeatDelay = Bl(D.repeatDelay)),
    D.from !== void 0 && (D.keyframes[0] = D.from);
    let U = !1;
    if (D.type === !1 && (D.duration = 0,
    D.delay === 0 && (U = !0)),
    U && !l && n.get() !== void 0) {
        const R = Rg(D.keyframes, _);
        if (R !== void 0) {
            _s.update(()=>{
                D.onUpdate(R),
                D.onComplete()
            }
            );
            return
        }
    }
    return !l && eS.supports(D) ? new eS(D) : new xx(D)
}
;
function ng(t) {
    return !!(Zs(t) && t.add)
}
function wx(t, n) {
    t.indexOf(n) === -1 && t.push(n)
}
function Ax(t, n) {
    const r = t.indexOf(n);
    r > -1 && t.splice(r, 1)
}
class Sx {
    constructor() {
        this.subscriptions = []
    }
    add(n) {
        return wx(this.subscriptions, n),
        ()=>Ax(this.subscriptions, n)
    }
    notify(n, r, s) {
        const h = this.subscriptions.length;
        if (h)
            if (h === 1)
                this.subscriptions[0](n, r, s);
            else
                for (let l = 0; l < h; l++) {
                    const g = this.subscriptions[l];
                    g && g(n, r, s)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const tS = 30
  , $4 = t=>!isNaN(parseFloat(t));
class ek {
    constructor(n, r={}) {
        this.version = "11.0.20",
        this.canTrackVelocity = !1,
        this.events = {},
        this.updateAndNotify = (s,h=!0)=>{
            const l = Ac.now();
            this.updatedAt !== l && this.setPrevFrameValue(),
            this.prev = this.current,
            this.setCurrent(s),
            this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
            h && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.hasAnimated = !1,
        this.setCurrent(n),
        this.canTrackVelocity = $4(this.current),
        this.owner = r.owner
    }
    setCurrent(n) {
        this.current = n,
        this.updatedAt = Ac.now()
    }
    setPrevFrameValue(n=this.current) {
        this.prevFrameValue = n,
        this.prevUpdatedAt = this.updatedAt
    }
    onChange(n) {
        return this.on("change", n)
    }
    on(n, r) {
        this.events[n] || (this.events[n] = new Sx);
        const s = this.events[n].add(r);
        return n === "change" ? ()=>{
            s(),
            _s.read(()=>{
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : s
    }
    clearListeners() {
        for (const n in this.events)
            this.events[n].clear()
    }
    attach(n, r) {
        this.passiveEffect = n,
        this.stopPassiveEffect = r
    }
    set(n, r=!0) {
        !r || !this.passiveEffect ? this.updateAndNotify(n, r) : this.passiveEffect(n, this.updateAndNotify)
    }
    setWithVelocity(n, r, s) {
        this.set(r),
        this.prev = void 0,
        this.prevFrameValue = n,
        this.prevUpdatedAt = this.updatedAt - s
    }
    jump(n, r=!0) {
        this.updateAndNotify(n),
        this.prev = n,
        this.prevUpdatedAt = this.prevFrameValue = void 0,
        r && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const n = Ac.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || n - this.updatedAt > tS)
            return 0;
        const r = Math.min(this.updatedAt - this.prevUpdatedAt, tS);
        return nC(parseFloat(this.current) - parseFloat(this.prevFrameValue), r)
    }
    start(n) {
        return this.stop(),
        new Promise(r=>{
            this.hasAnimated = !0,
            this.animation = n(r),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then(()=>{
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function Mf(t, n) {
    return new ek(t,n)
}
function tk(t, n, r) {
    t.hasValue(n) ? t.getValue(n).set(r) : t.addValue(n, Mf(r))
}
function nk(t, n) {
    const r = Pg(t, n);
    let {transitionEnd: s={}, transition: h={}, ...l} = r || {};
    l = {
        ...l,
        ...s
    };
    for (const g in l) {
        const _ = uF(l[g]);
        tk(t, g, _)
    }
}
function ik({protectedKeys: t, needsAnimating: n}, r) {
    const s = t.hasOwnProperty(r) && n[r] !== !0;
    return n[r] = !1,
    s
}
function vC(t, n, {delay: r=0, transitionOverride: s, type: h}={}) {
    var l;
    let {transition: g=t.getDefaultTransition(), transitionEnd: _, ...A} = n;
    const m = t.getValue("willChange");
    s && (g = s);
    const D = []
      , U = h && t.animationState && t.animationState.getState()[h];
    for (const R in A) {
        const ne = t.getValue(R, (l = t.latestValues[R]) !== null && l !== void 0 ? l : null)
          , ce = A[R];
        if (ce === void 0 || U && ik(U, R))
            continue;
        const xe = {
            delay: r,
            elapsed: 0,
            ...fx(g || {}, R)
        };
        let Se = !1;
        if (window.HandoffAppearAnimations) {
            const q = t.getProps()[vM];
            if (q) {
                const N = window.HandoffAppearAnimations(q, R);
                N !== null && (xe.elapsed = N,
                Se = !0)
            }
        }
        ne.start(bx(R, ne, ce, t.shouldReduceMotion && Su.has(R) ? {
            type: !1
        } : xe, t, Se));
        const $ = ne.animation;
        $ && (ng(m) && (m.add(R),
        $.then(()=>m.remove(R))),
        D.push($))
    }
    return _ && Promise.all(D).then(()=>{
        _s.update(()=>{
            _ && nk(t, _)
        }
        )
    }
    ),
    D
}
function Q_(t, n, r={}) {
    var s;
    const h = Pg(t, n, r.type === "exit" ? (s = t.presenceContext) === null || s === void 0 ? void 0 : s.custom : void 0);
    let {transition: l=t.getDefaultTransition() || {}} = h || {};
    r.transitionOverride && (l = r.transitionOverride);
    const g = h ? ()=>Promise.all(vC(t, h, r)) : ()=>Promise.resolve()
      , _ = t.variantChildren && t.variantChildren.size ? (m=0)=>{
        const {delayChildren: D=0, staggerChildren: U, staggerDirection: R} = l;
        return rk(t, n, D + m, U, R, r)
    }
    : ()=>Promise.resolve()
      , {when: A} = l;
    if (A) {
        const [m,D] = A === "beforeChildren" ? [g, _] : [_, g];
        return m().then(()=>D())
    } else
        return Promise.all([g(), _(r.delay)])
}
function rk(t, n, r=0, s=0, h=1, l) {
    const g = []
      , _ = (t.variantChildren.size - 1) * s
      , A = h === 1 ? (m=0)=>m * s : (m=0)=>_ - m * s;
    return Array.from(t.variantChildren).sort(sk).forEach((m,D)=>{
        m.notify("AnimationStart", n),
        g.push(Q_(m, n, {
            ...l,
            delay: r + A(D)
        }).then(()=>m.notify("AnimationComplete", n)))
    }
    ),
    Promise.all(g)
}
function sk(t, n) {
    return t.sortNodePosition(n)
}
function ok(t, n, r={}) {
    t.notify("AnimationStart", n);
    let s;
    if (Array.isArray(n)) {
        const h = n.map(l=>Q_(t, l, r));
        s = Promise.all(h)
    } else if (typeof n == "string")
        s = Q_(t, n, r);
    else {
        const h = typeof n == "function" ? Pg(t, n, r.custom) : n;
        s = Promise.all(vC(t, h, r))
    }
    return s.then(()=>{
        _s.postRender(()=>{
            t.notify("AnimationComplete", n)
        }
        )
    }
    )
}
const ak = [...tx].reverse()
  , lk = tx.length;
function ck(t) {
    return n=>Promise.all(n.map(({animation: r, options: s})=>ok(t, r, s)))
}
function uk(t) {
    let n = ck(t);
    const r = dk();
    let s = !0;
    const h = A=>(m,D)=>{
        var U;
        const R = Pg(t, D, A === "exit" ? (U = t.presenceContext) === null || U === void 0 ? void 0 : U.custom : void 0);
        if (R) {
            const {transition: ne, transitionEnd: ce, ...xe} = R;
            m = {
                ...m,
                ...xe,
                ...ce
            }
        }
        return m
    }
    ;
    function l(A) {
        n = A(t)
    }
    function g(A) {
        const m = t.getProps()
          , D = t.getVariantContext(!0) || {}
          , U = []
          , R = new Set;
        let ne = {}
          , ce = 1 / 0;
        for (let Se = 0; Se < lk; Se++) {
            const $ = ak[Se]
              , q = r[$]
              , N = m[$] !== void 0 ? m[$] : D[$]
              , ie = Sf(N)
              , _e = $ === A ? q.isActive : null;
            _e === !1 && (ce = Se);
            let Pe = N === D[$] && N !== m[$] && ie;
            if (Pe && s && t.manuallyAnimateOnMount && (Pe = !1),
            q.protectedKeys = {
                ...ne
            },
            !q.isActive && _e === null || !N && !q.prevProp || Eg(N) || typeof N == "boolean")
                continue;
            let Re = hk(q.prevProp, N) || $ === A && q.isActive && !Pe && ie || Se > ce && ie
              , ct = !1;
            const et = Array.isArray(N) ? N : [N];
            let Ze = et.reduce(h($), {});
            _e === !1 && (Ze = {});
            const {prevResolvedValues: Nt={}} = q
              , Bt = {
                ...Nt,
                ...Ze
            }
              , en = li=>{
                Re = !0,
                R.has(li) && (ct = !0,
                R.delete(li)),
                q.needsAnimating[li] = !0
            }
            ;
            for (const li in Bt) {
                const di = Ze[li]
                  , xi = Nt[li];
                if (ne.hasOwnProperty(li))
                    continue;
                let zt = !1;
                z_(di) && z_(xi) ? zt = !NM(di, xi) : zt = di !== xi,
                zt ? di != null ? en(li) : R.add(li) : di !== void 0 && R.has(li) ? en(li) : q.protectedKeys[li] = !0
            }
            q.prevProp = N,
            q.prevResolvedValues = Ze,
            q.isActive && (ne = {
                ...ne,
                ...Ze
            }),
            s && t.blockInitialAnimation && (Re = !1),
            Re && (!Pe || ct) && U.push(...et.map(li=>({
                animation: li,
                options: {
                    type: $
                }
            })))
        }
        if (R.size) {
            const Se = {};
            R.forEach($=>{
                const q = t.getBaseTarget($);
                Se[$] = q === void 0 ? null : q
            }
            ),
            U.push({
                animation: Se
            })
        }
        let xe = !!U.length;
        return s && (m.initial === !1 || m.initial === m.animate) && !t.manuallyAnimateOnMount && (xe = !1),
        s = !1,
        xe ? n(U) : Promise.resolve()
    }
    function _(A, m) {
        var D;
        if (r[A].isActive === m)
            return Promise.resolve();
        (D = t.variantChildren) === null || D === void 0 || D.forEach(R=>{
            var ne;
            return (ne = R.animationState) === null || ne === void 0 ? void 0 : ne.setActive(A, m)
        }
        ),
        r[A].isActive = m;
        const U = g(A);
        for (const R in r)
            r[R].protectedKeys = {};
        return U
    }
    return {
        animateChanges: g,
        setActive: _,
        setAnimateFunction: l,
        getState: ()=>r
    }
}
function hk(t, n) {
    return typeof n == "string" ? n !== t : Array.isArray(n) ? !NM(n, t) : !1
}
function ru(t=!1) {
    return {
        isActive: t,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function dk() {
    return {
        animate: ru(!0),
        whileInView: ru(),
        whileHover: ru(),
        whileTap: ru(),
        whileDrag: ru(),
        whileFocus: ru(),
        exit: ru()
    }
}
class fk extends Oc {
    constructor(n) {
        super(n),
        n.animationState || (n.animationState = uk(n))
    }
    updateAnimationControlsSubscription() {
        const {animate: n} = this.node.getProps();
        this.unmount(),
        Eg(n) && (this.unmount = n.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: n} = this.node.getProps()
          , {animate: r} = this.node.prevProps || {};
        n !== r && this.updateAnimationControlsSubscription()
    }
    unmount() {}
}
let pk = 0;
class mk extends Oc {
    constructor() {
        super(...arguments),
        this.id = pk++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: n, onExitComplete: r} = this.node.presenceContext
          , {isPresent: s} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || n === s)
            return;
        const h = this.node.animationState.setActive("exit", !n);
        r && !n && h.then(()=>r(this.id))
    }
    mount() {
        const {register: n} = this.node.presenceContext || {};
        n && (this.unmount = n(this.id))
    }
    unmount() {}
}
const gk = {
    animation: {
        Feature: fk
    },
    exit: {
        Feature: mk
    }
}
  , nS = (t,n)=>Math.abs(t - n);
function vk(t, n) {
    const r = nS(t.x, n.x)
      , s = nS(t.y, n.y);
    return Math.sqrt(r ** 2 + s ** 2)
}
class _C {
    constructor(n, r, {transformPagePoint: s, contextWindow: h, dragSnapToOrigin: l=!1}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = window,
        this.updatePoint = ()=>{
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const U = kv(this.lastMoveEventInfo, this.history)
              , R = this.startEvent !== null
              , ne = vk(U.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!R && !ne)
                return;
            const {point: ce} = U
              , {timestamp: xe} = Ds;
            this.history.push({
                ...ce,
                timestamp: xe
            });
            const {onStart: Se, onMove: $} = this.handlers;
            R || (Se && Se(this.lastMoveEvent, U),
            this.startEvent = this.lastMoveEvent),
            $ && $(this.lastMoveEvent, U)
        }
        ,
        this.handlePointerMove = (U,R)=>{
            this.lastMoveEvent = U,
            this.lastMoveEventInfo = Fv(R, this.transformPagePoint),
            _s.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (U,R)=>{
            this.end();
            const {onEnd: ne, onSessionEnd: ce, resumeAnimation: xe} = this.handlers;
            if (this.dragSnapToOrigin && xe && xe(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const Se = kv(U.type === "pointercancel" ? this.lastMoveEventInfo : Fv(R, this.transformPagePoint), this.history);
            this.startEvent && ne && ne(U, Se),
            ce && ce(U, Se)
        }
        ,
        !OM(n))
            return;
        this.dragSnapToOrigin = l,
        this.handlers = r,
        this.transformPagePoint = s,
        this.contextWindow = h || window;
        const g = Cg(n)
          , _ = Fv(g, this.transformPagePoint)
          , {point: A} = _
          , {timestamp: m} = Ds;
        this.history = [{
            ...A,
            timestamp: m
        }];
        const {onSessionStart: D} = r;
        D && D(n, kv(_, this.history)),
        this.removeListeners = Ol(Il(this.contextWindow, "pointermove", this.handlePointerMove), Il(this.contextWindow, "pointerup", this.handlePointerUp), Il(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(n) {
        this.handlers = n
    }
    end() {
        this.removeListeners && this.removeListeners(),
        Mc(this.updatePoint)
    }
}
function Fv(t, n) {
    return n ? {
        point: n(t.point)
    } : t
}
function iS(t, n) {
    return {
        x: t.x - n.x,
        y: t.y - n.y
    }
}
function kv({point: t}, n) {
    return {
        point: t,
        delta: iS(t, yC(n)),
        offset: iS(t, _k(n)),
        velocity: yk(n, .1)
    }
}
function _k(t) {
    return t[0]
}
function yC(t) {
    return t[t.length - 1]
}
function yk(t, n) {
    if (t.length < 2)
        return {
            x: 0,
            y: 0
        };
    let r = t.length - 1
      , s = null;
    const h = yC(t);
    for (; r >= 0 && (s = t[r],
    !(h.timestamp - s.timestamp > Bl(n))); )
        r--;
    if (!s)
        return {
            x: 0,
            y: 0
        };
    const l = Fl(h.timestamp - s.timestamp);
    if (l === 0)
        return {
            x: 0,
            y: 0
        };
    const g = {
        x: (h.x - s.x) / l,
        y: (h.y - s.y) / l
    };
    return g.x === 1 / 0 && (g.x = 0),
    g.y === 1 / 0 && (g.y = 0),
    g
}
function Go(t) {
    return t.max - t.min
}
function K_(t, n=0, r=.01) {
    return Math.abs(t - n) <= r
}
function rS(t, n, r, s=.5) {
    t.origin = s,
    t.originPoint = Ir(n.min, n.max, t.origin),
    t.scale = Go(r) / Go(n),
    (K_(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1),
    t.translate = Ir(r.min, r.max, t.origin) - t.originPoint,
    (K_(t.translate) || isNaN(t.translate)) && (t.translate = 0)
}
function tf(t, n, r, s) {
    rS(t.x, n.x, r.x, s ? s.originX : void 0),
    rS(t.y, n.y, r.y, s ? s.originY : void 0)
}
function sS(t, n, r) {
    t.min = r.min + n.min,
    t.max = t.min + Go(n)
}
function xk(t, n, r) {
    sS(t.x, n.x, r.x),
    sS(t.y, n.y, r.y)
}
function oS(t, n, r) {
    t.min = n.min - r.min,
    t.max = t.min + Go(n)
}
function nf(t, n, r) {
    oS(t.x, n.x, r.x),
    oS(t.y, n.y, r.y)
}
function bk(t, {min: n, max: r}, s) {
    return n !== void 0 && t < n ? t = s ? Ir(n, t, s.min) : Math.max(t, n) : r !== void 0 && t > r && (t = s ? Ir(r, t, s.max) : Math.min(t, r)),
    t
}
function aS(t, n, r) {
    return {
        min: n !== void 0 ? t.min + n : void 0,
        max: r !== void 0 ? t.max + r - (t.max - t.min) : void 0
    }
}
function wk(t, {top: n, left: r, bottom: s, right: h}) {
    return {
        x: aS(t.x, r, h),
        y: aS(t.y, n, s)
    }
}
function lS(t, n) {
    let r = n.min - t.min
      , s = n.max - t.max;
    return n.max - n.min < t.max - t.min && ([r,s] = [s, r]),
    {
        min: r,
        max: s
    }
}
function Ak(t, n) {
    return {
        x: lS(t.x, n.x),
        y: lS(t.y, n.y)
    }
}
function Sk(t, n) {
    let r = .5;
    const s = Go(t)
      , h = Go(n);
    return h > s ? r = Ef(n.min, n.max - s, t.min) : s > h && (r = Ef(t.min, t.max - h, n.min)),
    Ec(0, 1, r)
}
function Tk(t, n) {
    const r = {};
    return n.min !== void 0 && (r.min = n.min - t.min),
    n.max !== void 0 && (r.max = n.max - t.min),
    r
}
const Z_ = .35;
function Ek(t=Z_) {
    return t === !1 ? t = 0 : t === !0 && (t = Z_),
    {
        x: cS(t, "left", "right"),
        y: cS(t, "top", "bottom")
    }
}
function cS(t, n, r) {
    return {
        min: uS(t, n),
        max: uS(t, r)
    }
}
function uS(t, n) {
    return typeof t == "number" ? t : t[n] || 0
}
const hS = ()=>({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , gh = ()=>({
    x: hS(),
    y: hS()
})
  , dS = ()=>({
    min: 0,
    max: 0
})
  , Wr = ()=>({
    x: dS(),
    y: dS()
});
function na(t) {
    return [t("x"), t("y")]
}
function xC({top: t, left: n, right: r, bottom: s}) {
    return {
        x: {
            min: n,
            max: r
        },
        y: {
            min: t,
            max: s
        }
    }
}
function Mk({x: t, y: n}) {
    return {
        top: n.min,
        right: t.max,
        bottom: n.max,
        left: t.min
    }
}
function Ck(t, n) {
    if (!n)
        return t;
    const r = n({
        x: t.left,
        y: t.top
    })
      , s = n({
        x: t.right,
        y: t.bottom
    });
    return {
        top: r.y,
        left: r.x,
        bottom: s.y,
        right: s.x
    }
}
function Uv(t) {
    return t === void 0 || t === 1
}
function q_({scale: t, scaleX: n, scaleY: r}) {
    return !Uv(t) || !Uv(n) || !Uv(r)
}
function au(t) {
    return q_(t) || bC(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY
}
function bC(t) {
    return fS(t.x) || fS(t.y)
}
function fS(t) {
    return t && t !== "0%"
}
function ig(t, n, r) {
    const s = t - r
      , h = n * s;
    return r + h
}
function pS(t, n, r, s, h) {
    return h !== void 0 && (t = ig(t, h, s)),
    ig(t, r, s) + n
}
function J_(t, n=0, r=1, s, h) {
    t.min = pS(t.min, n, r, s, h),
    t.max = pS(t.max, n, r, s, h)
}
function wC(t, {x: n, y: r}) {
    J_(t.x, n.translate, n.scale, n.originPoint),
    J_(t.y, r.translate, r.scale, r.originPoint)
}
function Pk(t, n, r, s=!1) {
    const h = r.length;
    if (!h)
        return;
    n.x = n.y = 1;
    let l, g;
    for (let _ = 0; _ < h; _++) {
        l = r[_],
        g = l.projectionDelta;
        const A = l.instance;
        A && A.style && A.style.display === "contents" || (s && l.options.layoutScroll && l.scroll && l !== l.root && vh(t, {
            x: -l.scroll.offset.x,
            y: -l.scroll.offset.y
        }),
        g && (n.x *= g.x.scale,
        n.y *= g.y.scale,
        wC(t, g)),
        s && au(l.latestValues) && vh(t, l.latestValues))
    }
    n.x = mS(n.x),
    n.y = mS(n.y)
}
function mS(t) {
    return Number.isInteger(t) || t > 1.0000000000001 || t < .999999999999 ? t : 1
}
function uc(t, n) {
    t.min = t.min + n,
    t.max = t.max + n
}
function gS(t, n, [r,s,h]) {
    const l = n[h] !== void 0 ? n[h] : .5
      , g = Ir(t.min, t.max, l);
    J_(t, n[r], n[s], g, n.scale)
}
const Rk = ["x", "scaleX", "originX"]
  , Dk = ["y", "scaleY", "originY"];
function vh(t, n) {
    gS(t.x, n, Rk),
    gS(t.y, n, Dk)
}
function AC(t, n) {
    return xC(Ck(t.getBoundingClientRect(), n))
}
function Lk(t, n, r) {
    const s = AC(t, r)
      , {scroll: h} = n;
    return h && (uc(s.x, h.offset.x),
    uc(s.y, h.offset.y)),
    s
}
const SC = ({current: t})=>t ? t.ownerDocument.defaultView : null
  , Ik = new WeakMap;
class Ok {
    constructor(n) {
        this.openGlobalLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = Wr(),
        this.visualElement = n
    }
    start(n, {snapToCursor: r=!1}={}) {
        const {presenceContext: s} = this.visualElement;
        if (s && s.isPresent === !1)
            return;
        const h = D=>{
            const {dragSnapToOrigin: U} = this.getProps();
            U ? this.pauseAnimation() : this.stopAnimation(),
            r && this.snapToCursor(Cg(D, "page").point)
        }
          , l = (D,U)=>{
            const {drag: R, dragPropagation: ne, onDragStart: ce} = this.getProps();
            if (R && !ne && (this.openGlobalLock && this.openGlobalLock(),
            this.openGlobalLock = FM(R),
            !this.openGlobalLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            na(Se=>{
                let $ = this.getAxisMotionValue(Se).get() || 0;
                if (sl.test($)) {
                    const {projection: q} = this.visualElement;
                    if (q && q.layout) {
                        const N = q.layout.layoutBox[Se];
                        N && ($ = Go(N) * (parseFloat($) / 100))
                    }
                }
                this.originPoint[Se] = $
            }
            ),
            ce && ce(D, U);
            const {animationState: xe} = this.visualElement;
            xe && xe.setActive("whileDrag", !0)
        }
          , g = (D,U)=>{
            const {dragPropagation: R, dragDirectionLock: ne, onDirectionLock: ce, onDrag: xe} = this.getProps();
            if (!R && !this.openGlobalLock)
                return;
            const {offset: Se} = U;
            if (ne && this.currentDirection === null) {
                this.currentDirection = Bk(Se),
                this.currentDirection !== null && ce && ce(this.currentDirection);
                return
            }
            this.updateAxis("x", U.point, Se),
            this.updateAxis("y", U.point, Se),
            this.visualElement.render(),
            xe && xe(D, U)
        }
          , _ = (D,U)=>this.stop(D, U)
          , A = ()=>na(D=>{
            var U;
            return this.getAnimationState(D) === "paused" && ((U = this.getAxisMotionValue(D).animation) === null || U === void 0 ? void 0 : U.play())
        }
        )
          , {dragSnapToOrigin: m} = this.getProps();
        this.panSession = new _C(n,{
            onSessionStart: h,
            onStart: l,
            onMove: g,
            onSessionEnd: _,
            resumeAnimation: A
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: m,
            contextWindow: SC(this.visualElement)
        })
    }
    stop(n, r) {
        const s = this.isDragging;
        if (this.cancel(),
        !s)
            return;
        const {velocity: h} = r;
        this.startAnimation(h);
        const {onDragEnd: l} = this.getProps();
        l && l(n, r)
    }
    cancel() {
        this.isDragging = !1;
        const {projection: n, animationState: r} = this.visualElement;
        n && (n.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: s} = this.getProps();
        !s && this.openGlobalLock && (this.openGlobalLock(),
        this.openGlobalLock = null),
        r && r.setActive("whileDrag", !1)
    }
    updateAxis(n, r, s) {
        const {drag: h} = this.getProps();
        if (!s || !lm(n, h, this.currentDirection))
            return;
        const l = this.getAxisMotionValue(n);
        let g = this.originPoint[n] + s[n];
        this.constraints && this.constraints[n] && (g = bk(g, this.constraints[n], this.elastic[n])),
        l.set(g)
    }
    resolveConstraints() {
        var n;
        const {dragConstraints: r, dragElastic: s} = this.getProps()
          , h = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (n = this.visualElement.projection) === null || n === void 0 ? void 0 : n.layout
          , l = this.constraints;
        r && ph(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && h ? this.constraints = wk(h.layoutBox, r) : this.constraints = !1,
        this.elastic = Ek(s),
        l !== this.constraints && h && this.constraints && !this.hasMutatedConstraints && na(g=>{
            this.getAxisMotionValue(g) && (this.constraints[g] = Tk(h.layoutBox[g], this.constraints[g]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: n, onMeasureDragConstraints: r} = this.getProps();
        if (!n || !ph(n))
            return !1;
        const s = n.current
          , {projection: h} = this.visualElement;
        if (!h || !h.layout)
            return !1;
        const l = Lk(s, h.root, this.visualElement.getTransformPagePoint());
        let g = Ak(h.layout.layoutBox, l);
        if (r) {
            const _ = r(Mk(g));
            this.hasMutatedConstraints = !!_,
            _ && (g = xC(_))
        }
        return g
    }
    startAnimation(n) {
        const {drag: r, dragMomentum: s, dragElastic: h, dragTransition: l, dragSnapToOrigin: g, onDragTransitionEnd: _} = this.getProps()
          , A = this.constraints || {}
          , m = na(D=>{
            if (!lm(D, r, this.currentDirection))
                return;
            let U = A && A[D] || {};
            g && (U = {
                min: 0,
                max: 0
            });
            const R = h ? 200 : 1e6
              , ne = h ? 40 : 1e7
              , ce = {
                type: "inertia",
                velocity: s ? n[D] : 0,
                bounceStiffness: R,
                bounceDamping: ne,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...l,
                ...U
            };
            return this.startAxisValueAnimation(D, ce)
        }
        );
        return Promise.all(m).then(_)
    }
    startAxisValueAnimation(n, r) {
        const s = this.getAxisMotionValue(n);
        return s.start(bx(n, s, 0, r, this.visualElement))
    }
    stopAnimation() {
        na(n=>this.getAxisMotionValue(n).stop())
    }
    pauseAnimation() {
        na(n=>{
            var r;
            return (r = this.getAxisMotionValue(n).animation) === null || r === void 0 ? void 0 : r.pause()
        }
        )
    }
    getAnimationState(n) {
        var r;
        return (r = this.getAxisMotionValue(n).animation) === null || r === void 0 ? void 0 : r.state
    }
    getAxisMotionValue(n) {
        const r = "_drag" + n.toUpperCase()
          , s = this.visualElement.getProps()
          , h = s[r];
        return h || this.visualElement.getValue(n, (s.initial ? s.initial[n] : void 0) || 0)
    }
    snapToCursor(n) {
        na(r=>{
            const {drag: s} = this.getProps();
            if (!lm(r, s, this.currentDirection))
                return;
            const {projection: h} = this.visualElement
              , l = this.getAxisMotionValue(r);
            if (h && h.layout) {
                const {min: g, max: _} = h.layout.layoutBox[r];
                l.set(n[r] - Ir(g, _, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: n, dragConstraints: r} = this.getProps()
          , {projection: s} = this.visualElement;
        if (!ph(r) || !s || !this.constraints)
            return;
        this.stopAnimation();
        const h = {
            x: 0,
            y: 0
        };
        na(g=>{
            const _ = this.getAxisMotionValue(g);
            if (_) {
                const A = _.get();
                h[g] = Sk({
                    min: A,
                    max: A
                }, this.constraints[g])
            }
        }
        );
        const {transformTemplate: l} = this.visualElement.getProps();
        this.visualElement.current.style.transform = l ? l({}, "") : "none",
        s.root && s.root.updateScroll(),
        s.updateLayout(),
        this.resolveConstraints(),
        na(g=>{
            if (!lm(g, n, null))
                return;
            const _ = this.getAxisMotionValue(g)
              , {min: A, max: m} = this.constraints[g];
            _.set(Ir(A, m, h[g]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        Ik.set(this.visualElement, this);
        const n = this.visualElement.current
          , r = Il(n, "pointerdown", A=>{
            const {drag: m, dragListener: D=!0} = this.getProps();
            m && D && this.start(A)
        }
        )
          , s = ()=>{
            const {dragConstraints: A} = this.getProps();
            ph(A) && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: h} = this.visualElement
          , l = h.addEventListener("measure", s);
        h && !h.layout && (h.root && h.root.updateScroll(),
        h.updateLayout()),
        s();
        const g = Dl(window, "resize", ()=>this.scalePositionWithinConstraints())
          , _ = h.addEventListener("didUpdate", ({delta: A, hasLayoutChanged: m})=>{
            this.isDragging && m && (na(D=>{
                const U = this.getAxisMotionValue(D);
                U && (this.originPoint[D] += A[D].translate,
                U.set(U.get() + A[D].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return ()=>{
            g(),
            r(),
            l(),
            _ && _()
        }
    }
    getProps() {
        const n = this.visualElement.getProps()
          , {drag: r=!1, dragDirectionLock: s=!1, dragPropagation: h=!1, dragConstraints: l=!1, dragElastic: g=Z_, dragMomentum: _=!0} = n;
        return {
            ...n,
            drag: r,
            dragDirectionLock: s,
            dragPropagation: h,
            dragConstraints: l,
            dragElastic: g,
            dragMomentum: _
        }
    }
}
function lm(t, n, r) {
    return (n === !0 || n === t) && (r === null || r === t)
}
function Bk(t, n=10) {
    let r = null;
    return Math.abs(t.y) > n ? r = "y" : Math.abs(t.x) > n && (r = "x"),
    r
}
class Fk extends Oc {
    constructor(n) {
        super(n),
        this.removeGroupControls = Bs,
        this.removeListeners = Bs,
        this.controls = new Ok(n)
    }
    mount() {
        const {dragControls: n} = this.node.getProps();
        n && (this.removeGroupControls = n.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || Bs
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const vS = t=>(n,r)=>{
    t && t(n, r)
}
;
class kk extends Oc {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = Bs
    }
    onPointerDown(n) {
        this.session = new _C(n,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: SC(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: n, onPanStart: r, onPan: s, onPanEnd: h} = this.node.getProps();
        return {
            onSessionStart: vS(n),
            onStart: vS(r),
            onMove: s,
            onEnd: (l,g)=>{
                delete this.session,
                h && h(l, g)
            }
        }
    }
    mount() {
        this.removePointerDownListener = Il(this.node.current, "pointerdown", n=>this.onPointerDown(n))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
function Uk() {
    const t = nt.useContext(Tg);
    if (t === null)
        return [!0, null];
    const {isPresent: n, onExitComplete: r, register: s} = t
      , h = nt.useId();
    return nt.useEffect(()=>s(h), []),
    !n && r ? [!1, ()=>r && r(h)] : [!0]
}
const Tm = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function _S(t, n) {
    return n.max === n.min ? 0 : t / (n.max - n.min) * 100
}
const kd = {
    correct: (t,n)=>{
        if (!n.target)
            return t;
        if (typeof t == "string")
            if (Kn.test(t))
                t = parseFloat(t);
            else
                return t;
        const r = _S(t, n.target.x)
          , s = _S(t, n.target.y);
        return `${r}% ${s}%`
    }
}
  , Nk = {
    correct: (t,{treeScale: n, projectionDelta: r})=>{
        const s = t
          , h = Cc.parse(t);
        if (h.length > 5)
            return s;
        const l = Cc.createTransformer(t)
          , g = typeof h[0] != "number" ? 1 : 0
          , _ = r.x.scale * n.x
          , A = r.y.scale * n.y;
        h[0 + g] /= _,
        h[1 + g] /= A;
        const m = Ir(_, A, .5);
        return typeof h[2 + g] == "number" && (h[2 + g] /= m),
        typeof h[3 + g] == "number" && (h[3 + g] /= m),
        l(h)
    }
};
class zk extends Oh.Component {
    componentDidMount() {
        const {visualElement: n, layoutGroup: r, switchLayoutGroup: s, layoutId: h} = this.props
          , {projection: l} = n;
        zB(Gk),
        l && (r.group && r.group.add(l),
        s && s.register && h && s.register(l),
        l.root.didUpdate(),
        l.addEventListener("animationComplete", ()=>{
            this.safeToRemove()
        }
        ),
        l.setOptions({
            ...l.options,
            onExitComplete: ()=>this.safeToRemove()
        })),
        Tm.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(n) {
        const {layoutDependency: r, visualElement: s, drag: h, isPresent: l} = this.props
          , g = s.projection;
        return g && (g.isPresent = l,
        h || n.layoutDependency !== r || r === void 0 ? g.willUpdate() : this.safeToRemove(),
        n.isPresent !== l && (l ? g.promote() : g.relegate() || _s.postRender(()=>{
            const _ = g.getStack();
            (!_ || !_.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: n} = this.props.visualElement;
        n && (n.root.didUpdate(),
        ex.postRender(()=>{
            !n.currentAnimation && n.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: n, layoutGroup: r, switchLayoutGroup: s} = this.props
          , {projection: h} = n;
        h && (h.scheduleCheckAfterUnmount(),
        r && r.group && r.group.remove(h),
        s && s.deregister && s.deregister(h))
    }
    safeToRemove() {
        const {safeToRemove: n} = this.props;
        n && n()
    }
    render() {
        return null
    }
}
function TC(t) {
    const [n,r] = Uk()
      , s = nt.useContext(ix);
    return Oh.createElement(zk, {
        ...t,
        layoutGroup: s,
        switchLayoutGroup: nt.useContext(xM),
        isPresent: n,
        safeToRemove: r
    })
}
const Gk = {
    borderRadius: {
        ...kd,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: kd,
    borderTopRightRadius: kd,
    borderBottomLeftRadius: kd,
    borderBottomRightRadius: kd,
    boxShadow: Nk
}
  , EC = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , Hk = EC.length
  , yS = t=>typeof t == "string" ? parseFloat(t) : t
  , xS = t=>typeof t == "number" || Kn.test(t);
function Vk(t, n, r, s, h, l) {
    h ? (t.opacity = Ir(0, r.opacity !== void 0 ? r.opacity : 1, Wk(s)),
    t.opacityExit = Ir(n.opacity !== void 0 ? n.opacity : 1, 0, jk(s))) : l && (t.opacity = Ir(n.opacity !== void 0 ? n.opacity : 1, r.opacity !== void 0 ? r.opacity : 1, s));
    for (let g = 0; g < Hk; g++) {
        const _ = `border${EC[g]}Radius`;
        let A = bS(n, _)
          , m = bS(r, _);
        if (A === void 0 && m === void 0)
            continue;
        A || (A = 0),
        m || (m = 0),
        A === 0 || m === 0 || xS(A) === xS(m) ? (t[_] = Math.max(Ir(yS(A), yS(m), s), 0),
        (sl.test(m) || sl.test(A)) && (t[_] += "%")) : t[_] = m
    }
    (n.rotate || r.rotate) && (t.rotate = Ir(n.rotate || 0, r.rotate || 0, s))
}
function bS(t, n) {
    return t[n] !== void 0 ? t[n] : t.borderRadius
}
const Wk = MC(0, .5, cC)
  , jk = MC(.5, .95, Bs);
function MC(t, n, r) {
    return s=>s < t ? 0 : s > n ? 1 : r(Ef(t, n, s))
}
function wS(t, n) {
    t.min = n.min,
    t.max = n.max
}
function ta(t, n) {
    wS(t.x, n.x),
    wS(t.y, n.y)
}
function AS(t, n, r, s, h) {
    return t -= n,
    t = ig(t, 1 / r, s),
    h !== void 0 && (t = ig(t, 1 / h, s)),
    t
}
function Xk(t, n=0, r=1, s=.5, h, l=t, g=t) {
    if (sl.test(n) && (n = parseFloat(n),
    n = Ir(g.min, g.max, n / 100) - g.min),
    typeof n != "number")
        return;
    let _ = Ir(l.min, l.max, s);
    t === l && (_ -= n),
    t.min = AS(t.min, n, r, _, h),
    t.max = AS(t.max, n, r, _, h)
}
function SS(t, n, [r,s,h], l, g) {
    Xk(t, n[r], n[s], n[h], n.scale, l, g)
}
const Yk = ["x", "scaleX", "originX"]
  , Qk = ["y", "scaleY", "originY"];
function TS(t, n, r, s) {
    SS(t.x, n, Yk, r ? r.x : void 0, s ? s.x : void 0),
    SS(t.y, n, Qk, r ? r.y : void 0, s ? s.y : void 0)
}
function ES(t) {
    return t.translate === 0 && t.scale === 1
}
function CC(t) {
    return ES(t.x) && ES(t.y)
}
function Kk(t, n) {
    return t.x.min === n.x.min && t.x.max === n.x.max && t.y.min === n.y.min && t.y.max === n.y.max
}
function PC(t, n) {
    return Math.round(t.x.min) === Math.round(n.x.min) && Math.round(t.x.max) === Math.round(n.x.max) && Math.round(t.y.min) === Math.round(n.y.min) && Math.round(t.y.max) === Math.round(n.y.max)
}
function MS(t) {
    return Go(t.x) / Go(t.y)
}
class Zk {
    constructor() {
        this.members = []
    }
    add(n) {
        wx(this.members, n),
        n.scheduleRender()
    }
    remove(n) {
        if (Ax(this.members, n),
        n === this.prevLead && (this.prevLead = void 0),
        n === this.lead) {
            const r = this.members[this.members.length - 1];
            r && this.promote(r)
        }
    }
    relegate(n) {
        const r = this.members.findIndex(h=>n === h);
        if (r === 0)
            return !1;
        let s;
        for (let h = r; h >= 0; h--) {
            const l = this.members[h];
            if (l.isPresent !== !1) {
                s = l;
                break
            }
        }
        return s ? (this.promote(s),
        !0) : !1
    }
    promote(n, r) {
        const s = this.lead;
        if (n !== s && (this.prevLead = s,
        this.lead = n,
        n.show(),
        s)) {
            s.instance && s.scheduleRender(),
            n.scheduleRender(),
            n.resumeFrom = s,
            r && (n.resumeFrom.preserveOpacity = !0),
            s.snapshot && (n.snapshot = s.snapshot,
            n.snapshot.latestValues = s.animationValues || s.latestValues),
            n.root && n.root.isUpdating && (n.isLayoutDirty = !0);
            const {crossfade: h} = n.options;
            h === !1 && s.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(n=>{
            const {options: r, resumingFrom: s} = n;
            r.onExitComplete && r.onExitComplete(),
            s && s.options.onExitComplete && s.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(n=>{
            n.instance && n.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function CS(t, n, r) {
    let s = "";
    const h = t.x.translate / n.x
      , l = t.y.translate / n.y;
    if ((h || l) && (s = `translate3d(${h}px, ${l}px, 0) `),
    (n.x !== 1 || n.y !== 1) && (s += `scale(${1 / n.x}, ${1 / n.y}) `),
    r) {
        const {rotate: A, rotateX: m, rotateY: D, skewX: U, skewY: R} = r;
        A && (s += `rotate(${A}deg) `),
        m && (s += `rotateX(${m}deg) `),
        D && (s += `rotateY(${D}deg) `),
        U && (s += `skewX(${U}deg) `),
        R && (s += `skewY(${R}deg) `)
    }
    const g = t.x.scale * n.x
      , _ = t.y.scale * n.y;
    return (g !== 1 || _ !== 1) && (s += `scale(${g}, ${_})`),
    s || "none"
}
const qk = (t,n)=>t.depth - n.depth;
class Jk {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(n) {
        wx(this.children, n),
        this.isDirty = !0
    }
    remove(n) {
        Ax(this.children, n),
        this.isDirty = !0
    }
    forEach(n) {
        this.isDirty && this.children.sort(qk),
        this.isDirty = !1,
        this.children.forEach(n)
    }
}
function $k(t, n) {
    const r = Ac.now()
      , s = ({timestamp: h})=>{
        const l = h - r;
        l >= n && (Mc(s),
        t(l - n))
    }
    ;
    return _s.read(s, !0),
    ()=>Mc(s)
}
function eU(t) {
    window.MotionDebug && window.MotionDebug.record(t)
}
function tU(t) {
    return t instanceof SVGElement && t.tagName !== "svg"
}
function nU(t, n, r) {
    const s = Zs(t) ? t : Mf(t);
    return s.start(bx("", s, n, r)),
    s.animation
}
const Nv = ["", "X", "Y", "Z"]
  , iU = {
    visibility: "hidden"
}
  , PS = 1e3;
let rU = 0;
const lu = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
};
function RS(t, n, r, s) {
    const {latestValues: h} = n;
    h[t] && (r[t] = h[t],
    n.setStaticValue(t, 0),
    s && (s[t] = 0))
}
function RC({attachResizeListener: t, defaultParent: n, measureScroll: r, checkIsScrollRoot: s, resetTransform: h}) {
    return class {
        constructor(g={}, _=n == null ? void 0 : n()) {
            this.id = rU++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = ()=>{
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = ()=>{
                this.projectionUpdateScheduled = !1,
                lu.totalNodes = lu.resolvedTargetDeltas = lu.recalculatedProjection = 0,
                this.nodes.forEach(aU),
                this.nodes.forEach(dU),
                this.nodes.forEach(fU),
                this.nodes.forEach(lU),
                eU(lu)
            }
            ,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = g,
            this.root = _ ? _.root || _ : this,
            this.path = _ ? [..._.path, _] : [],
            this.parent = _,
            this.depth = _ ? _.depth + 1 : 0;
            for (let A = 0; A < this.path.length; A++)
                this.path[A].shouldResetTransform = !0;
            this.root === this && (this.nodes = new Jk)
        }
        addEventListener(g, _) {
            return this.eventHandlers.has(g) || this.eventHandlers.set(g, new Sx),
            this.eventHandlers.get(g).add(_)
        }
        notifyListeners(g, ..._) {
            const A = this.eventHandlers.get(g);
            A && A.notify(..._)
        }
        hasListeners(g) {
            return this.eventHandlers.has(g)
        }
        mount(g, _=this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = tU(g),
            this.instance = g;
            const {layoutId: A, layout: m, visualElement: D} = this.options;
            if (D && !D.current && D.mount(g),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            _ && (m || A) && (this.isLayoutDirty = !0),
            t) {
                let U;
                const R = ()=>this.root.updateBlockedByResize = !1;
                t(g, ()=>{
                    this.root.updateBlockedByResize = !0,
                    U && U(),
                    U = $k(R, 250),
                    Tm.hasAnimatedSinceResize && (Tm.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(LS))
                }
                )
            }
            A && this.root.registerSharedNode(A, this),
            this.options.animate !== !1 && D && (A || m) && this.addEventListener("didUpdate", ({delta: U, hasLayoutChanged: R, hasRelativeTargetChanged: ne, layout: ce})=>{
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const xe = this.options.transition || D.getDefaultTransition() || _U
                  , {onLayoutAnimationStart: Se, onLayoutAnimationComplete: $} = D.getProps()
                  , q = !this.targetLayout || !PC(this.targetLayout, ce) || ne
                  , N = !R && ne;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || N || R && (q || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(U, N);
                    const ie = {
                        ...fx(xe, "layout"),
                        onPlay: Se,
                        onComplete: $
                    };
                    (D.shouldReduceMotion || this.options.layoutRoot) && (ie.delay = 0,
                    ie.type = !1),
                    this.startAnimation(ie)
                } else
                    R || LS(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = ce
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const g = this.getStack();
            g && g.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            Mc(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(pU),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: g} = this.options;
            return g && g.getProps().transformTemplate
        }
        willUpdate(g=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (!this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let D = 0; D < this.path.length; D++) {
                const U = this.path[D];
                U.shouldResetTransform = !0,
                U.updateScroll("snapshot"),
                U.options.layoutRoot && U.willUpdate(!1)
            }
            const {layoutId: _, layout: A} = this.options;
            if (_ === void 0 && !A)
                return;
            const m = this.getTransformTemplate();
            this.prevTransformTemplateValue = m ? m(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            g && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(DS);
                return
            }
            this.isUpdating || this.nodes.forEach(uU),
            this.isUpdating = !1,
            window.HandoffCancelAllAnimations && window.HandoffCancelAllAnimations(),
            this.nodes.forEach(hU),
            this.nodes.forEach(sU),
            this.nodes.forEach(oU),
            this.clearAllSnapshots();
            const _ = Ac.now();
            Ds.delta = Ec(0, 1e3 / 60, _ - Ds.timestamp),
            Ds.timestamp = _,
            Ds.isProcessing = !0,
            Pv.update.process(Ds),
            Pv.preRender.process(Ds),
            Pv.render.process(Ds),
            Ds.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            ex.read(()=>this.update()))
        }
        clearAllSnapshots() {
            this.nodes.forEach(cU),
            this.sharedNodes.forEach(mU)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            _s.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            _s.postRender(()=>{
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let A = 0; A < this.path.length; A++)
                    this.path[A].updateScroll();
            const g = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = Wr(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: _} = this.options;
            _ && _.notify("LayoutMeasure", this.layout.layoutBox, g ? g.layoutBox : void 0)
        }
        updateScroll(g="measure") {
            let _ = !!(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === g && (_ = !1),
            _ && (this.scroll = {
                animationId: this.root.animationId,
                phase: g,
                isRoot: s(this.instance),
                offset: r(this.instance)
            })
        }
        resetTransform() {
            if (!h)
                return;
            const g = this.isLayoutDirty || this.shouldResetTransform
              , _ = this.projectionDelta && !CC(this.projectionDelta)
              , A = this.getTransformTemplate()
              , m = A ? A(this.latestValues, "") : void 0
              , D = m !== this.prevTransformTemplateValue;
            g && (_ || au(this.latestValues) || D) && (h(this.instance, m),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(g=!0) {
            const _ = this.measurePageBox();
            let A = this.removeElementScroll(_);
            return g && (A = this.removeTransform(A)),
            yU(A),
            {
                animationId: this.root.animationId,
                measuredBox: _,
                layoutBox: A,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            const {visualElement: g} = this.options;
            if (!g)
                return Wr();
            const _ = g.measureViewportBox()
              , {scroll: A} = this.root;
            return A && (uc(_.x, A.offset.x),
            uc(_.y, A.offset.y)),
            _
        }
        removeElementScroll(g) {
            const _ = Wr();
            ta(_, g);
            for (let A = 0; A < this.path.length; A++) {
                const m = this.path[A]
                  , {scroll: D, options: U} = m;
                if (m !== this.root && D && U.layoutScroll) {
                    if (D.isRoot) {
                        ta(_, g);
                        const {scroll: R} = this.root;
                        R && (uc(_.x, -R.offset.x),
                        uc(_.y, -R.offset.y))
                    }
                    uc(_.x, D.offset.x),
                    uc(_.y, D.offset.y)
                }
            }
            return _
        }
        applyTransform(g, _=!1) {
            const A = Wr();
            ta(A, g);
            for (let m = 0; m < this.path.length; m++) {
                const D = this.path[m];
                !_ && D.options.layoutScroll && D.scroll && D !== D.root && vh(A, {
                    x: -D.scroll.offset.x,
                    y: -D.scroll.offset.y
                }),
                au(D.latestValues) && vh(A, D.latestValues)
            }
            return au(this.latestValues) && vh(A, this.latestValues),
            A
        }
        removeTransform(g) {
            const _ = Wr();
            ta(_, g);
            for (let A = 0; A < this.path.length; A++) {
                const m = this.path[A];
                if (!m.instance || !au(m.latestValues))
                    continue;
                q_(m.latestValues) && m.updateSnapshot();
                const D = Wr()
                  , U = m.measurePageBox();
                ta(D, U),
                TS(_, m.latestValues, m.snapshot ? m.snapshot.layoutBox : void 0, D)
            }
            return au(this.latestValues) && TS(_, this.latestValues),
            _
        }
        setTargetDelta(g) {
            this.targetDelta = g,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(g) {
            this.options = {
                ...this.options,
                ...g,
                crossfade: g.crossfade !== void 0 ? g.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ds.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(g=!1) {
            var _;
            const A = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = A.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = A.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = A.isSharedProjectionDirty);
            const m = !!this.resumingFrom || this !== A;
            if (!(g || m && this.isSharedProjectionDirty || this.isProjectionDirty || !((_ = this.parent) === null || _ === void 0) && _.isProjectionDirty || this.attemptToResolveRelativeTarget))
                return;
            const {layout: U, layoutId: R} = this.options;
            if (!(!this.layout || !(U || R))) {
                if (this.resolvedRelativeTargetAt = Ds.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const ne = this.getClosestProjectingParent();
                    ne && ne.layout && this.animationProgress !== 1 ? (this.relativeParent = ne,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = Wr(),
                    this.relativeTargetOrigin = Wr(),
                    nf(this.relativeTargetOrigin, this.layout.layoutBox, ne.layout.layoutBox),
                    ta(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = Wr(),
                    this.targetWithTransforms = Wr()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                    xk(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : ta(this.target, this.layout.layoutBox),
                    wC(this.target, this.targetDelta)) : ta(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const ne = this.getClosestProjectingParent();
                        ne && !!ne.resumingFrom == !!this.resumingFrom && !ne.options.layoutScroll && ne.target && this.animationProgress !== 1 ? (this.relativeParent = ne,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = Wr(),
                        this.relativeTargetOrigin = Wr(),
                        nf(this.relativeTargetOrigin, this.target, ne.target),
                        ta(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    lu.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || q_(this.parent.latestValues) || bC(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var g;
            const _ = this.getLead()
              , A = !!this.resumingFrom || this !== _;
            let m = !0;
            if ((this.isProjectionDirty || !((g = this.parent) === null || g === void 0) && g.isProjectionDirty) && (m = !1),
            A && (this.isSharedProjectionDirty || this.isTransformDirty) && (m = !1),
            this.resolvedRelativeTargetAt === Ds.timestamp && (m = !1),
            m)
                return;
            const {layout: D, layoutId: U} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(D || U))
                return;
            ta(this.layoutCorrected, this.layout.layoutBox);
            const R = this.treeScale.x
              , ne = this.treeScale.y;
            Pk(this.layoutCorrected, this.treeScale, this.path, A),
            _.layout && !_.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (_.target = _.layout.layoutBox,
            _.targetWithTransforms = Wr());
            const {target: ce} = _;
            if (!ce) {
                this.projectionTransform && (this.projectionDelta = gh(),
                this.projectionTransform = "none",
                this.scheduleRender());
                return
            }
            this.projectionDelta || (this.projectionDelta = gh(),
            this.projectionDeltaWithTransform = gh());
            const xe = this.projectionTransform;
            tf(this.projectionDelta, this.layoutCorrected, ce, this.latestValues),
            this.projectionTransform = CS(this.projectionDelta, this.treeScale),
            (this.projectionTransform !== xe || this.treeScale.x !== R || this.treeScale.y !== ne) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", ce)),
            lu.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(g=!0) {
            if (this.options.scheduleRender && this.options.scheduleRender(),
            g) {
                const _ = this.getStack();
                _ && _.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        setAnimationOrigin(g, _=!1) {
            const A = this.snapshot
              , m = A ? A.latestValues : {}
              , D = {
                ...this.latestValues
            }
              , U = gh();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !_;
            const R = Wr()
              , ne = A ? A.source : void 0
              , ce = this.layout ? this.layout.source : void 0
              , xe = ne !== ce
              , Se = this.getStack()
              , $ = !Se || Se.members.length <= 1
              , q = !!(xe && !$ && this.options.crossfade === !0 && !this.path.some(vU));
            this.animationProgress = 0;
            let N;
            this.mixTargetDelta = ie=>{
                const _e = ie / 1e3;
                IS(U.x, g.x, _e),
                IS(U.y, g.y, _e),
                this.setTargetDelta(U),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (nf(R, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                gU(this.relativeTarget, this.relativeTargetOrigin, R, _e),
                N && Kk(this.relativeTarget, N) && (this.isProjectionDirty = !1),
                N || (N = Wr()),
                ta(N, this.relativeTarget)),
                xe && (this.animationValues = D,
                Vk(D, m, this.latestValues, _e, q, $)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = _e
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(g) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (Mc(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = _s.update(()=>{
                Tm.hasAnimatedSinceResize = !0,
                this.currentAnimation = nU(0, PS, {
                    ...g,
                    onUpdate: _=>{
                        this.mixTargetDelta(_),
                        g.onUpdate && g.onUpdate(_)
                    }
                    ,
                    onComplete: ()=>{
                        g.onComplete && g.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const g = this.getStack();
            g && g.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(PS),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const g = this.getLead();
            let {targetWithTransforms: _, target: A, layout: m, latestValues: D} = g;
            if (!(!_ || !A || !m)) {
                if (this !== g && this.layout && m && DC(this.options.animationType, this.layout.layoutBox, m.layoutBox)) {
                    A = this.target || Wr();
                    const U = Go(this.layout.layoutBox.x);
                    A.x.min = g.target.x.min,
                    A.x.max = A.x.min + U;
                    const R = Go(this.layout.layoutBox.y);
                    A.y.min = g.target.y.min,
                    A.y.max = A.y.min + R
                }
                ta(_, A),
                vh(_, D),
                tf(this.projectionDeltaWithTransform, this.layoutCorrected, _, D)
            }
        }
        registerSharedNode(g, _) {
            this.sharedNodes.has(g) || this.sharedNodes.set(g, new Zk),
            this.sharedNodes.get(g).add(_);
            const m = _.options.initialPromotionConfig;
            _.promote({
                transition: m ? m.transition : void 0,
                preserveFollowOpacity: m && m.shouldPreserveFollowOpacity ? m.shouldPreserveFollowOpacity(_) : void 0
            })
        }
        isLead() {
            const g = this.getStack();
            return g ? g.lead === this : !0
        }
        getLead() {
            var g;
            const {layoutId: _} = this.options;
            return _ ? ((g = this.getStack()) === null || g === void 0 ? void 0 : g.lead) || this : this
        }
        getPrevLead() {
            var g;
            const {layoutId: _} = this.options;
            return _ ? (g = this.getStack()) === null || g === void 0 ? void 0 : g.prevLead : void 0
        }
        getStack() {
            const {layoutId: g} = this.options;
            if (g)
                return this.root.sharedNodes.get(g)
        }
        promote({needsReset: g, transition: _, preserveFollowOpacity: A}={}) {
            const m = this.getStack();
            m && m.promote(this, A),
            g && (this.projectionDelta = void 0,
            this.needsReset = !0),
            _ && this.setOptions({
                transition: _
            })
        }
        relegate() {
            const g = this.getStack();
            return g ? g.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {visualElement: g} = this.options;
            if (!g)
                return;
            let _ = !1;
            const {latestValues: A} = g;
            if ((A.rotate || A.rotateX || A.rotateY || A.rotateZ || A.skewX || A.skewY) && (_ = !0),
            !_)
                return;
            const m = {};
            for (let D = 0; D < Nv.length; D++)
                RS(`rotate${Nv[D]}`, g, m, this.animationValues),
                RS(`skew${Nv[D]}`, g, m, this.animationValues);
            g.render();
            for (const D in m)
                g.setStaticValue(D, m[D]),
                this.animationValues && (this.animationValues[D] = m[D]);
            g.scheduleRender()
        }
        getProjectionStyles(g) {
            var _, A;
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return iU;
            const m = {
                visibility: ""
            }
              , D = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                m.opacity = "",
                m.pointerEvents = Am(g == null ? void 0 : g.pointerEvents) || "",
                m.transform = D ? D(this.latestValues, "") : "none",
                m;
            const U = this.getLead();
            if (!this.projectionDelta || !this.layout || !U.target) {
                const xe = {};
                return this.options.layoutId && (xe.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                xe.pointerEvents = Am(g == null ? void 0 : g.pointerEvents) || ""),
                this.hasProjected && !au(this.latestValues) && (xe.transform = D ? D({}, "") : "none",
                this.hasProjected = !1),
                xe
            }
            const R = U.animationValues || U.latestValues;
            this.applyTransformsToTarget(),
            m.transform = CS(this.projectionDeltaWithTransform, this.treeScale, R),
            D && (m.transform = D(R, m.transform));
            const {x: ne, y: ce} = this.projectionDelta;
            m.transformOrigin = `${ne.origin * 100}% ${ce.origin * 100}% 0`,
            U.animationValues ? m.opacity = U === this ? (A = (_ = R.opacity) !== null && _ !== void 0 ? _ : this.latestValues.opacity) !== null && A !== void 0 ? A : 1 : this.preserveOpacity ? this.latestValues.opacity : R.opacityExit : m.opacity = U === this ? R.opacity !== void 0 ? R.opacity : "" : R.opacityExit !== void 0 ? R.opacityExit : 0;
            for (const xe in qm) {
                if (R[xe] === void 0)
                    continue;
                const {correct: Se, applyTo: $} = qm[xe]
                  , q = m.transform === "none" ? R[xe] : Se(R[xe], U);
                if ($) {
                    const N = $.length;
                    for (let ie = 0; ie < N; ie++)
                        m[$[ie]] = q
                } else
                    m[xe] = q
            }
            return this.options.layoutId && (m.pointerEvents = U === this ? Am(g == null ? void 0 : g.pointerEvents) || "" : "none"),
            m
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(g=>{
                var _;
                return (_ = g.currentAnimation) === null || _ === void 0 ? void 0 : _.stop()
            }
            ),
            this.root.nodes.forEach(DS),
            this.root.sharedNodes.clear()
        }
    }
}
function sU(t) {
    t.updateLayout()
}
function oU(t) {
    var n;
    const r = ((n = t.resumeFrom) === null || n === void 0 ? void 0 : n.snapshot) || t.snapshot;
    if (t.isLead() && t.layout && r && t.hasListeners("didUpdate")) {
        const {layoutBox: s, measuredBox: h} = t.layout
          , {animationType: l} = t.options
          , g = r.source !== t.layout.source;
        l === "size" ? na(U=>{
            const R = g ? r.measuredBox[U] : r.layoutBox[U]
              , ne = Go(R);
            R.min = s[U].min,
            R.max = R.min + ne
        }
        ) : DC(l, r.layoutBox, s) && na(U=>{
            const R = g ? r.measuredBox[U] : r.layoutBox[U]
              , ne = Go(s[U]);
            R.max = R.min + ne,
            t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0,
            t.relativeTarget[U].max = t.relativeTarget[U].min + ne)
        }
        );
        const _ = gh();
        tf(_, s, r.layoutBox);
        const A = gh();
        g ? tf(A, t.applyTransform(h, !0), r.measuredBox) : tf(A, s, r.layoutBox);
        const m = !CC(_);
        let D = !1;
        if (!t.resumeFrom) {
            const U = t.getClosestProjectingParent();
            if (U && !U.resumeFrom) {
                const {snapshot: R, layout: ne} = U;
                if (R && ne) {
                    const ce = Wr();
                    nf(ce, r.layoutBox, R.layoutBox);
                    const xe = Wr();
                    nf(xe, s, ne.layoutBox),
                    PC(ce, xe) || (D = !0),
                    U.options.layoutRoot && (t.relativeTarget = xe,
                    t.relativeTargetOrigin = ce,
                    t.relativeParent = U)
                }
            }
        }
        t.notifyListeners("didUpdate", {
            layout: s,
            snapshot: r,
            delta: A,
            layoutDelta: _,
            hasLayoutChanged: m,
            hasRelativeTargetChanged: D
        })
    } else if (t.isLead()) {
        const {onExitComplete: s} = t.options;
        s && s()
    }
    t.options.transition = void 0
}
function aU(t) {
    lu.totalNodes++,
    t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty),
    t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)),
    t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty))
}
function lU(t) {
    t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1
}
function cU(t) {
    t.clearSnapshot()
}
function DS(t) {
    t.clearMeasurements()
}
function uU(t) {
    t.isLayoutDirty = !1
}
function hU(t) {
    const {visualElement: n} = t.options;
    n && n.getProps().onBeforeLayoutMeasure && n.notify("BeforeLayoutMeasure"),
    t.resetTransform()
}
function LS(t) {
    t.finishAnimation(),
    t.targetDelta = t.relativeTarget = t.target = void 0,
    t.isProjectionDirty = !0
}
function dU(t) {
    t.resolveTargetDelta()
}
function fU(t) {
    t.calcProjection()
}
function pU(t) {
    t.resetSkewAndRotation()
}
function mU(t) {
    t.removeLeadSnapshot()
}
function IS(t, n, r) {
    t.translate = Ir(n.translate, 0, r),
    t.scale = Ir(n.scale, 1, r),
    t.origin = n.origin,
    t.originPoint = n.originPoint
}
function OS(t, n, r, s) {
    t.min = Ir(n.min, r.min, s),
    t.max = Ir(n.max, r.max, s)
}
function gU(t, n, r, s) {
    OS(t.x, n.x, r.x, s),
    OS(t.y, n.y, r.y, s)
}
function vU(t) {
    return t.animationValues && t.animationValues.opacityExit !== void 0
}
const _U = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , BS = t=>typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t)
  , FS = BS("applewebkit/") && !BS("chrome/") ? Math.round : Bs;
function kS(t) {
    t.min = FS(t.min),
    t.max = FS(t.max)
}
function yU(t) {
    kS(t.x),
    kS(t.y)
}
function DC(t, n, r) {
    return t === "position" || t === "preserve-aspect" && !K_(MS(n), MS(r), .2)
}
const xU = RC({
    attachResizeListener: (t,n)=>Dl(t, "resize", n),
    measureScroll: ()=>({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: ()=>!0
})
  , zv = {
    current: void 0
}
  , LC = RC({
    measureScroll: t=>({
        x: t.scrollLeft,
        y: t.scrollTop
    }),
    defaultParent: ()=>{
        if (!zv.current) {
            const t = new xU({});
            t.mount(window),
            t.setOptions({
                layoutScroll: !0
            }),
            zv.current = t
        }
        return zv.current
    }
    ,
    resetTransform: (t,n)=>{
        t.style.transform = n !== void 0 ? n : "none"
    }
    ,
    checkIsScrollRoot: t=>window.getComputedStyle(t).position === "fixed"
})
  , bU = {
    pan: {
        Feature: kk
    },
    drag: {
        Feature: Fk,
        ProjectionNode: LC,
        MeasureLayout: TC
    }
}
  , $_ = {
    current: null
}
  , IC = {
    current: !1
};
function wU() {
    if (IC.current = !0,
    !!qy)
        if (window.matchMedia) {
            const t = window.matchMedia("(prefers-reduced-motion)")
              , n = ()=>$_.current = t.matches;
            t.addListener(n),
            n()
        } else
            $_.current = !1
}
function AU(t, n, r) {
    const {willChange: s} = n;
    for (const h in n) {
        const l = n[h]
          , g = r[h];
        if (Zs(l))
            t.addValue(h, l),
            ng(s) && s.add(h);
        else if (Zs(g))
            t.addValue(h, Mf(l, {
                owner: t
            })),
            ng(s) && s.remove(h);
        else if (g !== l)
            if (t.hasValue(h)) {
                const _ = t.getValue(h);
                !_.hasAnimated && _.set(l)
            } else {
                const _ = t.getStaticValue(h);
                t.addValue(h, Mf(_ !== void 0 ? _ : l, {
                    owner: t
                }))
            }
    }
    for (const h in r)
        n[h] === void 0 && t.removeValue(h);
    return n
}
const US = new WeakMap
  , SU = [...jM, Qs, Cc]
  , TU = t=>SU.find(WM(t))
  , OC = Object.keys(Tf)
  , EU = OC.length
  , NS = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
  , MU = nx.length;
class CU {
    constructor({parent: n, props: r, presenceContext: s, reducedMotionConfig: h, blockInitialAnimation: l, visualState: g}, _={}) {
        this.resolveKeyframes = (R,ne,ce,xe)=>new this.KeyframeResolver(R,ne,ce,xe,this),
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.KeyframeResolver = px,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = ()=>this.notify("Update", this.latestValues),
        this.render = ()=>{
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.scheduleRender = ()=>_s.render(this.render, !1, !0);
        const {latestValues: A, renderState: m} = g;
        this.latestValues = A,
        this.baseTarget = {
            ...A
        },
        this.initialValues = r.initial ? {
            ...A
        } : {},
        this.renderState = m,
        this.parent = n,
        this.props = r,
        this.presenceContext = s,
        this.depth = n ? n.depth + 1 : 0,
        this.reducedMotionConfig = h,
        this.options = _,
        this.blockInitialAnimation = !!l,
        this.isControllingVariants = Mg(r),
        this.isVariantNode = yM(r),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(n && n.current);
        const {willChange: D, ...U} = this.scrapeMotionValuesFromProps(r, {});
        for (const R in U) {
            const ne = U[R];
            A[R] !== void 0 && Zs(ne) && (ne.set(A[R], !1),
            ng(D) && D.add(R))
        }
    }
    scrapeMotionValuesFromProps(n, r) {
        return {}
    }
    mount(n) {
        this.current = n,
        US.set(n, this),
        this.projection && !this.projection.instance && this.projection.mount(n),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach((r,s)=>this.bindToMotionValue(s, r)),
        IC.current || wU(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : $_.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        US.delete(this.current),
        this.projection && this.projection.unmount(),
        Mc(this.notifyUpdate),
        Mc(this.render),
        this.valueSubscriptions.forEach(n=>n()),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const n in this.events)
            this.events[n].clear();
        for (const n in this.features)
            this.features[n].unmount();
        this.current = null
    }
    bindToMotionValue(n, r) {
        const s = Su.has(n)
          , h = r.on("change", g=>{
            this.latestValues[n] = g,
            this.props.onUpdate && _s.preRender(this.notifyUpdate),
            s && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , l = r.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(n, ()=>{
            h(),
            l(),
            r.owner && r.stop()
        }
        )
    }
    sortNodePosition(n) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== n.type ? 0 : this.sortInstanceNodePosition(this.current, n.current)
    }
    loadFeatures({children: n, ...r}, s, h, l) {
        let g, _;
        for (let A = 0; A < EU; A++) {
            const m = OC[A]
              , {isEnabled: D, Feature: U, ProjectionNode: R, MeasureLayout: ne} = Tf[m];
            R && (g = R),
            D(r) && (!this.features[m] && U && (this.features[m] = new U(this)),
            ne && (_ = ne))
        }
        if ((this.type === "html" || this.type === "svg") && !this.projection && g) {
            this.projection = new g(this.latestValues,this.parent && this.parent.projection);
            const {layoutId: A, layout: m, drag: D, dragConstraints: U, layoutScroll: R, layoutRoot: ne} = r;
            this.projection.setOptions({
                layoutId: A,
                layout: m,
                alwaysMeasureLayout: !!D || U && ph(U),
                visualElement: this,
                scheduleRender: ()=>this.scheduleRender(),
                animationType: typeof m == "string" ? m : "both",
                initialPromotionConfig: l,
                layoutScroll: R,
                layoutRoot: ne
            })
        }
        return _
    }
    updateFeatures() {
        for (const n in this.features) {
            const r = this.features[n];
            r.isMounted ? r.update() : (r.mount(),
            r.isMounted = !0)
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Wr()
    }
    getStaticValue(n) {
        return this.latestValues[n]
    }
    setStaticValue(n, r) {
        this.latestValues[n] = r
    }
    update(n, r) {
        (n.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = n,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = r;
        for (let s = 0; s < NS.length; s++) {
            const h = NS[s];
            this.propEventSubscriptions[h] && (this.propEventSubscriptions[h](),
            delete this.propEventSubscriptions[h]);
            const l = n["on" + h];
            l && (this.propEventSubscriptions[h] = this.on(h, l))
        }
        this.prevMotionValues = AU(this, this.scrapeMotionValuesFromProps(n, this.prevProps), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(n) {
        return this.props.variants ? this.props.variants[n] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    getVariantContext(n=!1) {
        if (n)
            return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
            const s = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (s.initial = this.props.initial),
            s
        }
        const r = {};
        for (let s = 0; s < MU; s++) {
            const h = nx[s]
              , l = this.props[h];
            (Sf(l) || l === !1) && (r[h] = l)
        }
        return r
    }
    addVariantChild(n) {
        const r = this.getClosestVariantNode();
        if (r)
            return r.variantChildren && r.variantChildren.add(n),
            ()=>r.variantChildren.delete(n)
    }
    addValue(n, r) {
        r !== this.values.get(n) && (this.removeValue(n),
        this.bindToMotionValue(n, r)),
        this.values.set(n, r),
        this.latestValues[n] = r.get()
    }
    removeValue(n) {
        this.values.delete(n);
        const r = this.valueSubscriptions.get(n);
        r && (r(),
        this.valueSubscriptions.delete(n)),
        delete this.latestValues[n],
        this.removeValueFromRenderState(n, this.renderState)
    }
    hasValue(n) {
        return this.values.has(n)
    }
    getValue(n, r) {
        if (this.props.values && this.props.values[n])
            return this.props.values[n];
        let s = this.values.get(n);
        return s === void 0 && r !== void 0 && (s = Mf(r === null ? void 0 : r, {
            owner: this
        }),
        this.addValue(n, s)),
        s
    }
    readValue(n, r) {
        var s;
        let h = this.latestValues[n] !== void 0 || !this.current ? this.latestValues[n] : (s = this.getBaseTargetFromProps(this.props, n)) !== null && s !== void 0 ? s : this.readValueFromInstance(this.current, n, this.options);
        return h != null && (typeof h == "string" && (HM(h) || zM(h)) ? h = parseFloat(h) : !TU(h) && Cc.test(r) && (h = $M(n, r)),
        this.setBaseTarget(n, Zs(h) ? h.get() : h)),
        Zs(h) ? h.get() : h
    }
    setBaseTarget(n, r) {
        this.baseTarget[n] = r
    }
    getBaseTarget(n) {
        var r, s;
        const {initial: h} = this.props
          , l = typeof h == "string" || typeof h == "object" ? (s = dx(this.props, h, (r = this.presenceContext) === null || r === void 0 ? void 0 : r.custom)) === null || s === void 0 ? void 0 : s[n] : void 0;
        if (h && l !== void 0)
            return l;
        const g = this.getBaseTargetFromProps(this.props, n);
        return g !== void 0 && !Zs(g) ? g : this.initialValues[n] !== void 0 && l === void 0 ? void 0 : this.baseTarget[n]
    }
    on(n, r) {
        return this.events[n] || (this.events[n] = new Sx),
        this.events[n].add(r)
    }
    notify(n, ...r) {
        this.events[n] && this.events[n].notify(...r)
    }
}
class BC extends CU {
    constructor() {
        super(...arguments),
        this.KeyframeResolver = eC
    }
    sortInstanceNodePosition(n, r) {
        return n.compareDocumentPosition(r) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(n, r) {
        return n.style ? n.style[r] : void 0
    }
    removeValueFromRenderState(n, {vars: r, style: s}) {
        delete r[n],
        delete s[n]
    }
}
function PU(t) {
    return window.getComputedStyle(t)
}
class RU extends BC {
    constructor() {
        super(...arguments),
        this.type = "html"
    }
    readValueFromInstance(n, r) {
        if (Su.has(r)) {
            const s = gx(r);
            return s && s.default || 0
        } else {
            const s = PU(n)
              , h = (AM(r) ? s.getPropertyValue(r) : s[r]) || 0;
            return typeof h == "string" ? h.trim() : h
        }
    }
    measureInstanceViewportBox(n, {transformPagePoint: r}) {
        return AC(n, r)
    }
    build(n, r, s, h) {
        ax(n, r, s, h.transformTemplate)
    }
    scrapeMotionValuesFromProps(n, r) {
        return hx(n, r)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: n} = this.props;
        Zs(n) && (this.childSubscription = n.on("change", r=>{
            this.current && (this.current.textContent = `${r}`)
        }
        ))
    }
    renderInstance(n, r, s, h) {
        CM(n, r, s, h)
    }
}
class DU extends BC {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1
    }
    getBaseTargetFromProps(n, r) {
        return n[r]
    }
    readValueFromInstance(n, r) {
        if (Su.has(r)) {
            const s = gx(r);
            return s && s.default || 0
        }
        return r = PM.has(r) ? r : $y(r),
        n.getAttribute(r)
    }
    measureInstanceViewportBox() {
        return Wr()
    }
    scrapeMotionValuesFromProps(n, r) {
        return DM(n, r)
    }
    build(n, r, s, h) {
        cx(n, r, s, this.isSVGTag, h.transformTemplate)
    }
    renderInstance(n, r, s, h) {
        RM(n, r, s, h)
    }
    mount(n) {
        this.isSVGTag = ux(n.tagName),
        super.mount(n)
    }
}
const LU = (t,n)=>rx(t) ? new DU(n,{
    enableHardwareAcceleration: !1
}) : new RU(n,{
    enableHardwareAcceleration: !0
})
  , IU = {
    layout: {
        ProjectionNode: LC,
        MeasureLayout: TC
    }
}
  , OU = {
    ...gk,
    ...CF,
    ...bU,
    ...IU
}
  , oo = UB((t,n)=>mF(t, n, OU, LU));
function FC() {
    const t = nt.useRef(!1);
    return Jy(()=>(t.current = !0,
    ()=>{
        t.current = !1
    }
    ), []),
    t
}
function BU() {
    const t = FC()
      , [n,r] = nt.useState(0)
      , s = nt.useCallback(()=>{
        t.current && r(n + 1)
    }
    , [n]);
    return [nt.useCallback(()=>_s.postRender(s), [s]), n]
}
class FU extends nt.Component {
    getSnapshotBeforeUpdate(n) {
        const r = this.props.childRef.current;
        if (r && n.isPresent && !this.props.isPresent) {
            const s = this.props.sizeRef.current;
            s.height = r.offsetHeight || 0,
            s.width = r.offsetWidth || 0,
            s.top = r.offsetTop,
            s.left = r.offsetLeft
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}
function kU({children: t, isPresent: n}) {
    const r = nt.useId()
      , s = nt.useRef(null)
      , h = nt.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0
    })
      , {nonce: l} = nt.useContext(Zy);
    return nt.useInsertionEffect(()=>{
        const {width: g, height: _, top: A, left: m} = h.current;
        if (n || !s.current || !g || !_)
            return;
        s.current.dataset.motionPopId = r;
        const D = document.createElement("style");
        return l && (D.nonce = l),
        document.head.appendChild(D),
        D.sheet && D.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${g}px !important;
            height: ${_}px !important;
            top: ${A}px !important;
            left: ${m}px !important;
          }
        `),
        ()=>{
            document.head.removeChild(D)
        }
    }
    , [n]),
    nt.createElement(FU, {
        isPresent: n,
        childRef: s,
        sizeRef: h
    }, nt.cloneElement(t, {
        ref: s
    }))
}
const Gv = ({children: t, initial: n, isPresent: r, onExitComplete: s, custom: h, presenceAffectsLayout: l, mode: g})=>{
    const _ = LM(UU)
      , A = nt.useId()
      , m = nt.useMemo(()=>({
        id: A,
        initial: n,
        isPresent: r,
        custom: h,
        onExitComplete: D=>{
            _.set(D, !0);
            for (const U of _.values())
                if (!U)
                    return;
            s && s()
        }
        ,
        register: D=>(_.set(D, !1),
        ()=>_.delete(D))
    }), l ? void 0 : [r]);
    return nt.useMemo(()=>{
        _.forEach((D,U)=>_.set(U, !1))
    }
    , [r]),
    nt.useEffect(()=>{
        !r && !_.size && s && s()
    }
    , [r]),
    g === "popLayout" && (t = nt.createElement(kU, {
        isPresent: r
    }, t)),
    nt.createElement(Tg.Provider, {
        value: m
    }, t)
}
;
function UU() {
    return new Map
}
function NU(t) {
    return nt.useEffect(()=>()=>t(), [])
}
const cu = t=>t.key || "";
function zU(t, n) {
    t.forEach(r=>{
        const s = cu(r);
        n.set(s, r)
    }
    )
}
function GU(t) {
    const n = [];
    return nt.Children.forEach(t, r=>{
        nt.isValidElement(r) && n.push(r)
    }
    ),
    n
}
const Pc = ({children: t, custom: n, initial: r=!0, onExitComplete: s, exitBeforeEnter: h, presenceAffectsLayout: l=!0, mode: g="sync"})=>{
    const _ = nt.useContext(ix).forceRender || BU()[0]
      , A = FC()
      , m = GU(t);
    let D = m;
    const U = nt.useRef(new Map).current
      , R = nt.useRef(D)
      , ne = nt.useRef(new Map).current
      , ce = nt.useRef(!0);
    if (Jy(()=>{
        ce.current = !1,
        zU(m, ne),
        R.current = D
    }
    ),
    NU(()=>{
        ce.current = !0,
        ne.clear(),
        U.clear()
    }
    ),
    ce.current)
        return nt.createElement(nt.Fragment, null, D.map(q=>nt.createElement(Gv, {
            key: cu(q),
            isPresent: !0,
            initial: r ? void 0 : !1,
            presenceAffectsLayout: l,
            mode: g
        }, q)));
    D = [...D];
    const xe = R.current.map(cu)
      , Se = m.map(cu)
      , $ = xe.length;
    for (let q = 0; q < $; q++) {
        const N = xe[q];
        Se.indexOf(N) === -1 && !U.has(N) && U.set(N, void 0)
    }
    return g === "wait" && U.size && (D = []),
    U.forEach((q,N)=>{
        if (Se.indexOf(N) !== -1)
            return;
        const ie = ne.get(N);
        if (!ie)
            return;
        const _e = xe.indexOf(N);
        let Pe = q;
        if (!Pe) {
            const Be = ()=>{
                U.delete(N);
                const Re = Array.from(ne.keys()).filter(ct=>!Se.includes(ct));
                if (Re.forEach(ct=>ne.delete(ct)),
                R.current = m.filter(ct=>{
                    const et = cu(ct);
                    return et === N || Re.includes(et)
                }
                ),
                !U.size) {
                    if (A.current === !1)
                        return;
                    _(),
                    s && s()
                }
            }
            ;
            Pe = nt.createElement(Gv, {
                key: cu(ie),
                isPresent: !1,
                onExitComplete: Be,
                custom: n,
                presenceAffectsLayout: l,
                mode: g
            }, ie),
            U.set(N, Pe)
        }
        D.splice(_e, 0, Pe)
    }
    ),
    D = D.map(q=>{
        const N = q.key;
        return U.has(N) ? q : nt.createElement(Gv, {
            key: cu(q),
            isPresent: !0,
            presenceAffectsLayout: l,
            mode: g
        }, q)
    }
    ),
    nt.createElement(nt.Fragment, null, U.size ? D : D.map(q=>nt.cloneElement(q)))
}
  , HU = [Bn.State1, Bn.State2, Bn.State3, Bn.State4, Bn.State5]
  , VU = ["SU7", "车身", "风阻", "雷达", "定制"];
let cm = {
    value: !0
};
function WU() {
    const [t,n] = nt.useState(Bn.Loading)
      , [r,s] = nt.useState(!1);
    return nt.useEffect(()=>{
        const h = g=>{
            n(g)
        }
          , l = g=>{
            s(g)
        }
        ;
        return Ie.on(Ie.UPDATESHOWINGSTATE, h),
        Ie.on(Ie.CLICKEFFECT, l),
        ()=>{
            Ie.off(Ie.UPDATESHOWINGSTATE, h),
            Ie.off(Ie.CLICKEFFECT, l)
        }
    }
    , []),
    Oe.jsx(Oe.Fragment, {
        children: Oe.jsx("div", {
            className: "StateTable-container",
            style: {
                opacity: r ? 0 : 1,
                transition: "0.2s all 0.3s"
            },
            children: Oe.jsx(Pc, {
                mode: "popLayout",
                children: t != Bn.BeginAnim && t != Bn.Loading && Oe.jsxs(oo.div, {
                    className: "StateTable-content",
                    initial: {
                        x: 10,
                        opacity: 0
                    },
                    animate: {
                        x: 0,
                        opacity: 1
                    },
                    exit: {
                        x: -10,
                        opacity: 0
                    },
                    transition: {
                        duration: .5
                    },
                    children: [Oe.jsx("div", {
                        className: "backgroundLine"
                    }), HU.map((h,l)=>Oe.jsxs("div", {
                        className: "item",
                        style: {
                            backgroundColor: h == t ? "rgb(255, 146, 69)" : ""
                        },
                        onClick: ()=>{
                            !Ie.isInClickEffect && h != t && cm.value && (h == Bn.State5 && Ie.emit(Ie.CHANGECOLOR, "custom"),
                            Za() && Ie.emit(Ie.UPDATECOLORTABLESTATE, sa.customColorTable),
                            Ie.emit(Ie.UPDATESHOWINGSTATE, h),
                            Ie.emit(Ie.PLAY_SFX, "click"),
                            cm.value = !1,
                            Jt.TweenManager.Timeline(cm).delay(.3).call(()=>{
                                cm.value = !0
                            }
                            ).start())
                        }
                        ,
                        children: [h == t && Oe.jsx("div", {
                            className: "item-Line"
                        }), Oe.jsx("div", {
                            className: "tableName",
                            children: Oe.jsx("div", {
                                style: {
                                    color: h == t ? "#fff" : "",
                                    fontSize: h == t ? "0.9rem" : ""
                                },
                                children: VU[l]
                            })
                        }), Oe.jsx("div", {
                            className: "clickBox"
                        })]
                    }, l))]
                })
            })
        })
    })
}
function jU() {
    const t = nt.useRef(null)
      , [n,r] = nt.useState(0);
    return nt.useEffect(()=>{
        let s = 0
          , h = !1;
        const l = setInterval(()=>{
            s = sM.damp(s, Ie.loading, .016, 1),
            s >= .99 && (s = 1),
            r(s),
            h && s >= 1 && (h = !1,
            t.current.style.transition = "opacity 600ms cubic-bezier(0,0,.58,1)",
            t.current.style.opacity = "0",
            setTimeout(()=>{
                t.current.style.display = "none",
                Ie.emit(Ie.PLAY_BGM)
            }
            , 600))
        }
        )
          , g = ()=>{
            h = !0
        }
        ;
        return Ie.reset(),
        Ie.on(Ie.PRELOADED, g),
        ()=>{
            clearInterval(l),
            Ie.clear()
        }
    }
    , []),
    Oe.jsxs("aside", {
        id: "preloader",
        ref: t,
        children: [Oe.jsx("div", {
            className: "progress-bar",
            children: Oe.jsxs("svg", {
                className: "progress-bar-svg",
                viewBox: "0 0 1709.0400390625 323.0625",
                fill: "none",
                children: [Oe.jsx("path", {
                    className: "speed-line",
                    id: "process",
                    d: "M2.30809 318.07Q21.0208 316.441 50.1395 311.552Q108.449 301.761 160.401 285.447Q187.503 276.937 211.151 264.212Q225.389 256.551 250.01 240.238Q275.87 223.104 291.318 214.863Q317.146 201.086 347.378 191.695Q407.665 172.97 460.721 167.081Q495.936 163.173 558.47 163.173Q585.817 163.173 628.557 141.714Q654.353 128.763 708.923 94.4123Q742.671 73.1683 758.993 63.6874Q786.229 47.8662 806.111 39.6039Q862.305 16.252 914.714 7.87042Q961.797 0.340553 1040.78 0.0125411Q1117.18 -0.304734 1171.71 7.40653Q1227.48 15.2934 1289.78 35.6259Q1321.15 45.8667 1370.62 65.0861Q1407.99 79.6092 1425.84 85.4202Q1454.72 94.8298 1481 99.0339Q1520.17 105.3 1617.15 102.785Q1665.69 101.526 1706.36 99.0087C1706.42 99.0046 1706.48 99.0025 1706.54 99.0025C1707.92 99.0025 1709.04 100.122 1709.04 101.503C1709.04 102.838 1707.99 103.928 1706.68 103.999Q1665.91 106.522 1617.28 107.783Q1519.84 110.31 1480.22 103.971Q1453.55 99.7051 1424.29 90.1744Q1406.31 84.3207 1368.81 69.7466Q1319.47 50.5771 1288.22 40.3791Q1226.35 20.1827 1171.01 12.3573Q1116.83 4.69672 1040.8 5.0125Q962.205 5.3389 915.504 12.8077Q863.678 21.0959 808.029 44.2211Q788.454 52.356 761.504 68.0109Q745.26 77.4469 711.586 98.6438Q656.812 133.123 630.801 146.182Q587.002 168.173 558.47 168.173Q496.212 168.173 461.273 172.051Q408.69 177.886 348.862 196.47Q319.081 205.72 293.672 219.274Q278.433 227.403 252.771 244.406Q227.96 260.845 213.52 268.615Q189.453 281.565 161.899 290.218Q109.617 306.635 50.9674 316.483Q21.6568 321.404 2.74708 323.05C2.6658 323.058 2.58338 323.063 2.5 323.063C1.11929 323.063 0 321.943 0 320.563C0 319.246 1.01704 318.168 2.30809 318.07Z"
                }), Oe.jsx("defs", {
                    children: Oe.jsxs("linearGradient", {
                        xmlns: "http://www.w3.org/2000/svg",
                        id: "linear_0",
                        x1: "0.14628095304966532%",
                        y1: "50%",
                        x2: "99.85371904695035%",
                        y2: "50%",
                        gradientUnits: "objectBoundingBox",
                        children: [Oe.jsx("stop", {
                            offset: "0",
                            stopColor: "#000000",
                            stopOpacity: "0"
                        }), Oe.jsx("stop", {
                            offset: .2341 * n,
                            stopColor: "#FFFFFF",
                            stopOpacity: "0.44"
                        }), Oe.jsx("stop", {
                            offset: .5278 * n,
                            stopColor: "#FFFFFF",
                            stopOpacity: "1"
                        }), Oe.jsx("stop", {
                            offset: .7698 * n,
                            stopColor: "#FFFFFF",
                            stopOpacity: "0.49"
                        }), Oe.jsx("stop", {
                            offset: 1 * n,
                            stopColor: "#000000",
                            stopOpacity: "0"
                        })]
                    })
                })]
            })
        }), Oe.jsx("div", {
            className: "progress-num",
            children: Oe.jsxs("p", {
                children: [Math.floor(n * 100), "%"]
            })
        }), Oe.jsx("div", {
            className: "version",
            children: ai.VERSION
        })]
    })
}
function XU() {
    const [t,n] = nt.useState(Bn.Loading)
      , [r,s] = nt.useState(!1);
    return nt.useEffect(()=>{
        const h = g=>{
            n(g)
        }
          , l = g=>{
            s(g)
        }
        ;
        return Ie.on(Ie.UPDATESHOWINGSTATE, h),
        Ie.on(Ie.CLICKEFFECT, l),
        ()=>{
            Ie.off(Ie.UPDATESHOWINGSTATE, h),
            Ie.off(Ie.CLICKEFFECT, l)
        }
    }
    , []),
    Oe.jsx(Oe.Fragment, {
        children: Za() ? Oe.jsx("div", {
            className: "TopInfo-container",
            style: {
                opacity: r ? 0 : 1
            },
            children: Oe.jsxs(Pc, {
                mode: "popLayout",
                children: [t == Bn.State1 && Oe.jsxs(oo.div, {
                    className: "TopInfo-content",
                    initial: {
                        y: 10,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -10,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    children: [Oe.jsx("img", {
                        src: `${ai.autoURL("res/icon/xiaomi_su7.webp")}`,
                        alt: "",
                        style: {
                            width: "50vmin",
                            marginTop: "10vmin"
                        }
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#fffb",
                            fontSize: "3vmin"
                        },
                        children: "C级高性能 生态科技轿车"
                    })]
                }, "s1"), t == Bn.State2 && Oe.jsxs(oo.div, {
                    className: "TopInfo-content",
                    initial: {
                        y: 10,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -10,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    children: [Oe.jsx("div", {
                        style: {
                            marginTop: "6vmin",
                            color: "rgba(240, 198, 159, 1)",
                            fontSize: "3vmin"
                        },
                        children: "「外观设计」"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#fff",
                            fontSize: "3vmin"
                        },
                        children: "优雅与速度感并存经得起时间考验的设计"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#aaa",
                            fontSize: "2.5vmin"
                        },
                        children: "遵循「符合直觉」的美学设计理念，造就Xiaomi SU7 经典的流畅车身线条。"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#aaa",
                            fontSize: "2.5vmin"
                        },
                        children: "富有力量的车身线条与自然舒展的车身比例，让优雅与速度相得益彰。"
                    })]
                }, "s2"), t == Bn.State3 && Oe.jsxs(oo.div, {
                    className: "TopInfo-content",
                    initial: {
                        y: 10,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -10,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    children: [Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#fff",
                            fontSize: "2.5vmin"
                        },
                        children: "出色的超低风阻系数"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "1.2vmin",
                            color: "rgba(240, 198, 159, 1)",
                            fontSize: "5vmin"
                        },
                        children: "Cd 0.195"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "1.2vmin",
                            color: "#fff",
                            fontSize: "2.5vmin"
                        },
                        children: "风，就是最好的设计师。"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "1.2vmin",
                            color: "#fff",
                            fontSize: "2.5vmin"
                        },
                        children: "经过 1000 次以上仿真实验和超过 300次油泥模型调整，不断寻找风道、车身曲线的最优解。"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "1.2vmin",
                            color: "#fff",
                            fontSize: "2.5vmin"
                        },
                        children: "最终达成 Cd0.195 超低风阻系数，带来难以想象的低能耗和出色续航表现。"
                    })]
                }, "s3"), t == Bn.State4 && Oe.jsxs(oo.div, {
                    className: "TopInfo-content",
                    initial: {
                        y: 10,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -10,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    children: [Oe.jsx("div", {
                        style: {
                            marginTop: "0vmin",
                            color: "rgba(240, 198, 159, 1)",
                            fontSize: "3vmin"
                        },
                        children: "「智能驾驶」"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#fff",
                            fontSize: "3vmin"
                        },
                        children: "隆重介绍XiaomiPilot更聪明、更安全的智能驾驶系统"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#aaa",
                            fontSize: "2.5vmin"
                        },
                        children: "搭载两颗 NVIDIA DRIVE Orin 芯片，综合算力高达 508 TOPS，感知硬件具备罕见的大范围探测能力；"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#aaa",
                            fontSize: "2.5vmin"
                        },
                        children: "在此之上，以领先行业的智能驾驶算法深度赋能小米全栈自研的全场景智能辅助驾驶。"
                    }), Oe.jsxs("div", {
                        className: "addon",
                        children: [Oe.jsxs("div", {
                            style: {
                                marginTop: "10vmin"
                            },
                            children: [Oe.jsx("div", {
                                children: "激光雷达"
                            }), Oe.jsx("div", {
                                style: {
                                    color: "rgba(255, 146, 69, 1)"
                                },
                                children: "x1"
                            })]
                        }), Oe.jsxs("div", {
                            children: [Oe.jsx("div", {
                                children: "高清摄像头"
                            }), Oe.jsx("div", {
                                style: {
                                    color: "rgba(255, 146, 69, 1)"
                                },
                                children: "x11"
                            })]
                        }), Oe.jsxs("div", {
                            children: [Oe.jsx("div", {
                                children: "毫米波雷达"
                            }), Oe.jsx("div", {
                                style: {
                                    color: "rgba(255, 146, 69, 1)"
                                },
                                children: "x3"
                            })]
                        }), Oe.jsxs("div", {
                            children: [Oe.jsx("div", {
                                children: "超声波雷达"
                            }), Oe.jsx("div", {
                                style: {
                                    color: "rgba(255, 146, 69, 1)"
                                },
                                children: "x12"
                            })]
                        })]
                    })]
                }, "s4")]
            })
        }, "t1") : Oe.jsx("div", {
            className: "TopInfo-container",
            style: {
                opacity: r ? 0 : 1
            },
            children: Oe.jsxs(Pc, {
                mode: "popLayout",
                children: [t == Bn.State1 && Oe.jsxs(oo.div, {
                    className: "TopInfo-content",
                    initial: {
                        y: 10,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -10,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    children: [Oe.jsx("img", {
                        src: `${ai.autoURL("res/icon/xiaomi_su7.webp")}`,
                        alt: "",
                        style: {
                            width: "40vmin",
                            marginTop: "10vmin"
                        }
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#fffb",
                            fontSize: "2vmin"
                        },
                        children: "C级高性能 生态科技轿车"
                    })]
                }, "s1"), t == Bn.State2 && Oe.jsxs(oo.div, {
                    className: "TopInfo-content",
                    initial: {
                        y: 10,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -10,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    children: [Oe.jsx("div", {
                        style: {
                            marginTop: "6vmin",
                            color: "rgba(240, 198, 159, 1)",
                            fontSize: "2vmin"
                        },
                        children: "「外观设计」"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#fff",
                            fontSize: "2vmin"
                        },
                        children: "优雅与速度感并存经得起时间考验的设计"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#aaa",
                            fontSize: "1.4vmin"
                        },
                        children: "遵循「符合直觉」的美学设计理念，造就Xiaomi SU7 经典的流畅车身线条。"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#aaa",
                            fontSize: "1.4vmin"
                        },
                        children: "富有力量的车身线条与自然舒展的车身比例，让优雅与速度相得益彰。"
                    })]
                }, "s2"), t == Bn.State3 && Oe.jsxs(oo.div, {
                    className: "TopInfo-content",
                    initial: {
                        y: 10,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -10,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    children: [Oe.jsx("div", {
                        style: {
                            marginTop: "4vmin",
                            color: "#fff",
                            fontSize: "1.6vmin"
                        },
                        children: "出色的超低风阻系数"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "1.2vmin",
                            color: "rgba(240, 198, 159, 1)",
                            fontSize: "4vmin"
                        },
                        children: "Cd 0.195"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "1.2vmin",
                            color: "#fff",
                            fontSize: "1.6vmin"
                        },
                        children: "风，就是最好的设计师。"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "1.2vmin",
                            color: "#fff",
                            fontSize: "1.6vmin"
                        },
                        children: "经过 1000 次以上仿真实验和超过 300次油泥模型调整，不断寻找风道、车身曲线的最优解。"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "1.2vmin",
                            color: "#fff",
                            fontSize: "1.6vmin"
                        },
                        children: "最终达成 Cd0.195 超低风阻系数，带来难以想象的低能耗和出色续航表现。"
                    })]
                }, "s3"), t == Bn.State4 && Oe.jsxs(oo.div, {
                    className: "TopInfo-content",
                    initial: {
                        y: 10,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -10,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    children: [Oe.jsx("div", {
                        style: {
                            marginTop: "4vmin",
                            color: "rgba(240, 198, 159, 1)",
                            fontSize: "1.8vmin"
                        },
                        children: "「智能驾驶」"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#fff",
                            fontSize: "2vmin"
                        },
                        children: "隆重介绍XiaomiPilot更聪明、更安全的智能驾驶系统"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#aaa",
                            fontSize: "1.4vmin"
                        },
                        children: "搭载两颗 NVIDIA DRIVE Orin 芯片，综合算力高达 508 TOPS，感知硬件具备罕见的大范围探测能力；"
                    }), Oe.jsx("div", {
                        style: {
                            marginTop: "2vmin",
                            color: "#aaa",
                            fontSize: "1.4vmin"
                        },
                        children: "在此之上，以领先行业的智能驾驶算法深度赋能小米全栈自研的全场景智能辅助驾驶。"
                    }), Oe.jsxs("div", {
                        className: "addon",
                        style: {
                            fontSize: "2vmin"
                        },
                        children: [Oe.jsxs("div", {
                            style: {
                                marginTop: "10vmin"
                            },
                            children: [Oe.jsx("div", {
                                children: "激光雷达"
                            }), Oe.jsx("div", {
                                style: {
                                    color: "rgba(255, 146, 69, 1)"
                                },
                                children: "x1"
                            })]
                        }), Oe.jsxs("div", {
                            children: [Oe.jsx("div", {
                                children: "高清摄像头"
                            }), Oe.jsx("div", {
                                style: {
                                    color: "rgba(255, 146, 69, 1)"
                                },
                                children: "x11"
                            })]
                        }), Oe.jsxs("div", {
                            children: [Oe.jsx("div", {
                                children: "毫米波雷达"
                            }), Oe.jsx("div", {
                                style: {
                                    color: "rgba(255, 146, 69, 1)"
                                },
                                children: "x3"
                            })]
                        }), Oe.jsxs("div", {
                            children: [Oe.jsx("div", {
                                children: "超声波雷达"
                            }), Oe.jsx("div", {
                                style: {
                                    color: "rgba(255, 146, 69, 1)"
                                },
                                children: "x12"
                            })]
                        })]
                    })]
                }, "s4")]
            })
        }, "t2")
    })
}
function YU() {
    const [t,n] = nt.useState(Bn.Loading)
      , [r,s] = nt.useState(sa.presetColorTable)
      , [h,l] = nt.useState(!1)
      , [g,_] = nt.useState("0")
      , [A,m] = nt.useState({
        ...Ae.colors.get("custom").hsl
    });
    return nt.useEffect(()=>{
        const D = ne=>{
            l(ne)
        }
          , U = ne=>{
            m({
                ...Ae.colors.get("custom").hsl
            }),
            _(ne)
        }
          , R = ne=>{
            s(ne)
        }
        ;
        return Ie.on(Ie.CLICKEFFECT, D),
        Ie.on(Ie.CHANGECOLOR, U),
        Ie.on(Ie.UPDATECOLORTABLESTATE, R),
        ()=>{
            Ie.off(Ie.CLICKEFFECT, D),
            Ie.off(Ie.CHANGECOLOR, U),
            Ie.off(Ie.UPDATECOLORTABLESTATE, R)
        }
    }
    , []),
    nt.useEffect(()=>{
        const D = U=>{
            U != Bn.State5 && r == sa.customColorTable && Ie.emit(Ie.UPDATECOLORTABLESTATE, sa.presetColorTable),
            n(U)
        }
        ;
        return Ie.on(Ie.UPDATESHOWINGSTATE, D),
        ()=>{
            Ie.off(Ie.UPDATESHOWINGSTATE, D)
        }
    }
    , [r]),
    Oe.jsx(Oe.Fragment, {
        children: Oe.jsx("div", {
            style: {
                opacity: h ? 0 : 1,
                transition: "0.2s all 0.3s"
            },
            children: Oe.jsx(Pc, {
                mode: "popLayout",
                children: t != Bn.BeginAnim && t != Bn.Loading && (!Za() || t != Bn.State5) && Oe.jsx(oo.div, {
                    className: "ColorBar-container",
                    initial: {
                        y: 30,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -30,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    children: Oe.jsx("div", {
                        className: "ColorBar-content",
                        children: Oe.jsx(oo.div, {
                            style: {
                                display: "flex"
                            },
                            initial: {
                                y: 20,
                                opacity: 0
                            },
                            animate: {
                                y: 0,
                                opacity: 1
                            },
                            exit: {
                                y: -20,
                                opacity: 0
                            },
                            transition: {
                                duration: .2
                            },
                            children: Array.from(Ae.colors.keys()).map((D,U)=>Oe.jsx("div", {
                                className: "Bar",
                                style: {
                                    ...D == "custom" ? {
                                        backgroundColor: `hsl(${A.h * 360}, ${A.s * 100}%, ${A.l * 100}%)`
                                    } : {},
                                    backgroundImage: `url(${ai.autoURL("res/icon/" + Ae.colors.get(D).bgUrl)})`
                                },
                                onClick: ()=>{
                                    D != g && (Ie.emit(Ie.CHANGECOLOR, D),
                                    _(D)),
                                    Ie.emit(Ie.PLAY_SFX, "click")
                                }
                                ,
                                children: g == D && Oe.jsx("div", {
                                    className: "Bar-Line"
                                })
                            }, D))
                        }, "preset")
                    })
                })
            })
        })
    })
}
function QU() {
    const [t,n] = nt.useState(!1);
    return Oe.jsxs(Oe.Fragment, {
        children: [Oe.jsx("div", {
            className: "Logo-container",
            onClick: ()=>{
                window.open("https://gamemcu.com")
            }
            ,
            children: Oe.jsxs("div", {
                className: "Logo-content",
                children: [Oe.jsx("p", {
                    style: {
                        marginRight: "0.3rem",
                        fontWeight: "300"
                    },
                    children: "Author:"
                }), Oe.jsx("p", {
                    style: {
                        color: "rgba(255, 141, 26, 1)",
                        fontWeight: "600"
                    },
                    children: "GameMCU"
                }), Oe.jsx("p", {
                    style: {
                        marginRight: "0.3rem",
                        color: "#fff",
                        fontWeight: "300",
                        marginLeft: "0.4rem"
                    },
                    children: "Sound:"
                }), Oe.jsx("p", {
                    style: {
                        color: "rgba(255, 141, 26, 1)",
                        fontWeight: "600"
                    },
                    children: "Cuer_Zhao"
                })]
            })
        }), Oe.jsx("div", {
            className: "Mute-container",
            children: Oe.jsx("div", {
                className: "Mute-content",
                onClick: ()=>{
                    n(!t),
                    Ie.emit(Ie.MUTE, !t)
                }
                ,
                children: Oe.jsx("img", {
                    src: `${ai.autoURL(`res/icon/${t ? "close.png" : "open.png"}`)}`,
                    alt: ""
                })
            })
        })]
    })
}
let zS = 0;
function KU() {
    const t = nt.useRef(null)
      , [n,r] = nt.useState(!1)
      , [s,h] = nt.useState(Bn.Loading)
      , [l,g] = nt.useState(!1);
    nt.useEffect(()=>{
        const D = R=>{
            h(R)
        }
          , U = R=>{
            g(R)
        }
        ;
        return Ie.on(Ie.UPDATESHOWINGSTATE, D),
        Ie.on(Ie.CLICKEFFECT, U),
        ()=>{
            Ie.off(Ie.UPDATESHOWINGSTATE, D),
            Ie.off(Ie.CLICKEFFECT, U)
        }
    }
    , []);
    const _ = nt.useCallback(()=>{
        zS += 1,
        Ie.emit(Ie.SCREENSHOT),
        Ie.emit(Ie.PLAY_SFX, "ka"),
        r(!0),
        t.current.style.display = "block"
    }
    , [])
      , A = nt.useCallback(()=>{
        Ie.emit(Ie.PLAY_SFX, "click"),
        r(!1),
        t.current.style.display = "none"
    }
    , [])
      , m = Za();
    return Oe.jsxs(Oe.Fragment, {
        children: [Oe.jsx("div", {
            style: {
                opacity: l ? 0 : 1,
                transition: "0.2s all 0.3s"
            },
            children: Oe.jsx(Pc, {
                mode: "popLayout",
                children: s == Bn.State5 && Oe.jsxs(oo.div, {
                    id: "screenshot",
                    className: "screenshot",
                    initial: {
                        y: -30,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -30,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    style: {
                        backgroundColor: n ? "#000d" : "",
                        pointerEvents: n ? "all" : "none",
                        zIndex: "2"
                    },
                    children: [Oe.jsxs("div", {
                        ref: t,
                        style: {
                            display: "none"
                        },
                        children: [Oe.jsx("img", {
                            id: "screenshot-img"
                        }), Oe.jsx("p", {
                            children: "长按图片可保存并分享"
                        })]
                    }), Oe.jsxs("div", {
                        className: "camera",
                        style: {
                            marginBottom: m ? "" : "4rem"
                        },
                        children: [!n && Oe.jsx("img", {
                            src: ai.autoURL("res/icon/photo.png"),
                            alt: "",
                            onClick: _,
                            style: m ? {} : {
                                width: "2.4rem"
                            }
                        }), n && Oe.jsx("img", {
                            src: ai.autoURL("res/icon/close2.png"),
                            alt: "",
                            onClick: A,
                            style: m ? {} : {
                                width: "2.4rem"
                            }
                        })]
                    })]
                })
            })
        }), Oe.jsx(Pc, {
            mode: "popLayout",
            children: Oe.jsx("div", {
                className: "key_Light"
            }, zS)
        })]
    })
}
function Ls() {
    return Ls = Object.assign ? Object.assign.bind() : function(t) {
        for (var n = 1; n < arguments.length; n++) {
            var r = arguments[n];
            for (var s in r)
                Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s])
        }
        return t
    }
    ,
    Ls.apply(this, arguments)
}
function Tx(t, n) {
    if (t == null)
        return {};
    var r = {}, s = Object.keys(t), h, l;
    for (l = 0; l < s.length; l++)
        h = s[l],
        !(n.indexOf(h) >= 0) && (r[h] = t[h]);
    return r
}
var um = 100
  , ZU = t=>{
    var {h: n, s: r, l: s, a: h} = qU(t);
    return "hsla(" + n + ", " + r + "%, " + s + "%, " + h + ")"
}
  , qU = t=>{
    var {h: n, s: r, v: s, a: h} = t
      , l = (200 - r) * s / um;
    return {
        h: n,
        s: l > 0 && l < 200 ? r * s / um / (l <= um ? l : 200 - l) * um : 0,
        l: l / 2,
        a: h
    }
}
;
function GS(t) {
    var n = nt.useRef(t);
    return nt.useEffect(()=>{
        n.current = t
    }
    ),
    nt.useCallback((r,s)=>n.current && n.current(r, s), [])
}
var rf = t=>"touches"in t
  , HS = t=>{
    !rf(t) && t.preventDefault && t.preventDefault()
}
  , VS = function(n, r, s) {
    return r === void 0 && (r = 0),
    s === void 0 && (s = 1),
    n > s ? s : n < r ? r : n
}
  , WS = (t,n)=>{
    var r = t.getBoundingClientRect()
      , s = rf(n) ? n.touches[0] : n;
    return {
        left: VS((s.pageX - (r.left + window.pageXOffset)) / r.width),
        top: VS((s.pageY - (r.top + window.pageYOffset)) / r.height),
        width: r.width,
        height: r.height,
        x: s.pageX - (r.left + window.pageXOffset),
        y: s.pageY - (r.top + window.pageYOffset)
    }
}
  , JU = ["prefixCls", "className", "onMove", "onDown"]
  , kC = Oh.forwardRef((t,n)=>{
    var {prefixCls: r="w-color-interactive", className: s, onMove: h, onDown: l} = t
      , g = Tx(t, JU)
      , _ = nt.useRef(null)
      , A = nt.useRef(!1)
      , [m,D] = nt.useState(!1)
      , U = GS(h)
      , R = GS(l)
      , ne = q=>A.current && !rf(q) ? !1 : (A.current = rf(q),
    !0)
      , ce = nt.useCallback(q=>{
        HS(q);
        var N = rf(q) ? q.touches.length > 0 : q.buttons > 0;
        N && _.current ? U && U(WS(_.current, q), q) : D(!1)
    }
    , [U])
      , xe = nt.useCallback(()=>D(!1), [])
      , Se = nt.useCallback(q=>{
        var N = q ? window.addEventListener : window.removeEventListener;
        N(A.current ? "touchmove" : "mousemove", ce),
        N(A.current ? "touchend" : "mouseup", xe)
    }
    , []);
    nt.useEffect(()=>(Se(m),
    ()=>{
        m && Se(!1)
    }
    ), [m, Se]);
    var $ = nt.useCallback(q=>{
        HS(q.nativeEvent),
        ne(q.nativeEvent) && (R && R(WS(_.current, q.nativeEvent), q.nativeEvent),
        D(!0))
    }
    , [R]);
    return Oe.jsx("div", Ls({}, g, {
        className: [r, s || ""].filter(Boolean).join(" "),
        style: Ls({}, g.style, {
            touchAction: "none"
        }),
        ref: _,
        tabIndex: 0,
        onMouseDown: $,
        onTouchStart: $
    }))
}
);
kC.displayName = "Interactive";
const $U = kC;
var eN = ["className", "prefixCls", "left", "top", "style", "fillProps"]
  , tN = t=>{
    var {className: n, prefixCls: r, left: s, top: h, style: l, fillProps: g} = t
      , _ = Tx(t, eN)
      , A = Ls({}, l, {
        position: "absolute",
        left: s,
        top: h
    })
      , m = Ls({
        width: 18,
        height: 18,
        boxShadow: "var(--alpha-pointer-box-shadow)",
        borderRadius: "50%",
        backgroundColor: "var(--alpha-pointer-background-color)"
    }, g == null ? void 0 : g.style, {
        transform: s ? "translate(-9px, -1px)" : "translate(-1px, -9px)"
    });
    return Oe.jsx("div", Ls({
        className: r + "-pointer " + (n || ""),
        style: A
    }, _, {
        children: Oe.jsx("div", Ls({
            className: r + "-fill"
        }, g, {
            style: m
        }))
    }))
}
  , nN = ["prefixCls", "className", "hsva", "background", "bgProps", "innerProps", "pointerProps", "radius", "width", "height", "direction", "style", "onChange", "pointer"]
  , iN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVQ4T2NkYGAQYcAP3uCTZhw1gGGYhAGBZIA/nYDCgBDAm9BGDWAAJyRCgLaBCAAgXwixzAS0pgAAAABJRU5ErkJggg=="
  , UC = Oh.forwardRef((t,n)=>{
    var {prefixCls: r="w-color-alpha", className: s, hsva: h, background: l, bgProps: g={}, innerProps: _={}, pointerProps: A={}, radius: m=0, width: D, height: U=16, direction: R="horizontal", style: ne, onChange: ce, pointer: xe} = t
      , Se = Tx(t, nN)
      , $ = Be=>{
        ce && ce(Ls({}, h, {
            a: R === "horizontal" ? Be.left : Be.top
        }), Be)
    }
      , q = ZU(Object.assign({}, h, {
        a: 1
    }))
      , N = "linear-gradient(to " + (R === "horizontal" ? "right" : "bottom") + ", rgba(244, 67, 54, 0) 0%, " + q + " 100%)"
      , ie = {};
    R === "horizontal" ? ie.left = h.a * 100 + "%" : ie.top = h.a * 100 + "%";
    var _e = Ls({
        "--alpha-background-color": "#fff",
        "--alpha-pointer-background-color": "rgb(248, 248, 248)",
        "--alpha-pointer-box-shadow": "rgb(0 0 0 / 37%) 0px 1px 4px 0px",
        borderRadius: m,
        background: "url(" + iN + ") left center",
        backgroundColor: "var(--alpha-background-color)"
    }, {
        width: D,
        height: U
    }, ne, {
        position: "relative"
    })
      , Pe = xe && typeof xe == "function" ? xe(Ls({
        prefixCls: r
    }, A, ie)) : Oe.jsx(tN, Ls({}, A, {
        prefixCls: r
    }, ie));
    return Oe.jsxs("div", Ls({}, Se, {
        className: [r, r + "-" + R, s || ""].filter(Boolean).join(" "),
        style: _e,
        ref: n,
        children: [Oe.jsx("div", Ls({}, g, {
            style: Ls({
                inset: 0,
                position: "absolute",
                background: l || N,
                borderRadius: m
            }, g.style)
        })), Oe.jsx($U, Ls({}, _, {
            style: Ls({}, _.style, {
                inset: 0,
                zIndex: 1,
                position: "absolute"
            }),
            onMove: $,
            onDown: $,
            children: Pe
        }))]
    }))
}
);
UC.displayName = "Alpha";
const rN = UC
  , Nh = Oh.forwardRef((t,n)=>{
    const {prefixCls: r="w-color-saturation", className: s, onChange: h, direction: l="horizontal", backgroundGradient: g="rgb(0, 0, 0),rgb(255, 255, 255)", hsva: _, ...A} = t;
    return Oe.jsx(rN, {
        ref: n,
        ...A,
        className: `${r} ${s || ""}`,
        hsva: {
            h: _.h,
            s: _.s,
            v: _.v,
            a: _.v / 100
        },
        direction: l,
        background: `linear-gradient(to ${l === "horizontal" ? "right" : "bottom"}, ${g})`,
        onChange: (m,D)=>{
            SO() ? h && h({
                v: l === "horizontal" ? D.top * 100 : 100 - D.left * 100
            }) : h && h({
                v: l === "horizontal" ? D.left * 100 : D.top * 100
            })
        }
    })
}
);
Nh.displayName = "ShadeSlider";
let Hv = !0
  , Ud = "5px";
function sN() {
    const [t,n] = nt.useState(Bn.Loading)
      , [r,s] = nt.useState(Ie.currentColorTableState)
      , [h,l] = nt.useState(!1)
      , [g,_] = nt.useState("0")
      , [A,m] = nt.useState({
        ...Ae.colors.get("custom").hsl
    });
    return nt.useEffect(()=>{
        const D = ce=>{
            n(ce)
        }
          , U = ce=>{
            m({
                ...Ae.colors.get("custom").hsl
            }),
            _(ce)
        }
          , R = ce=>{
            l(ce)
        }
          , ne = ce=>{
            s(ce)
        }
        ;
        return Ie.on(Ie.CLICKEFFECT, R),
        Ie.on(Ie.CHANGECOLOR, U),
        Ie.on(Ie.UPDATESHOWINGSTATE, D),
        Ie.on(Ie.UPDATECOLORTABLESTATE, ne),
        ()=>{
            Ie.off(Ie.CLICKEFFECT, R),
            Ie.off(Ie.CHANGECOLOR, U),
            Ie.off(Ie.UPDATESHOWINGSTATE, D),
            Ie.off(Ie.UPDATECOLORTABLESTATE, ne)
        }
    }
    , []),
    Oe.jsx(Oe.Fragment, {
        children: Oe.jsx("div", {
            style: {
                opacity: h ? 0 : 1,
                transition: "0.2s all 0.3s"
            },
            children: Oe.jsx(Pc, {
                mode: "popLayout",
                children: t == Bn.State5 && Oe.jsx(oo.div, {
                    className: "LeftCustomBar-container",
                    style: {
                        left: Za() ? "0vmin" : "",
                        marginLeft: Za() ? "-1rem" : ""
                    },
                    initial: {
                        y: 30,
                        opacity: 0
                    },
                    animate: {
                        y: 0,
                        opacity: 1
                    },
                    exit: {
                        y: -30,
                        opacity: 0
                    },
                    transition: {
                        duration: .2
                    },
                    children: Oe.jsxs("div", {
                        className: "LeftCustomBar-content",
                        style: {
                            scale: Za() ? "0.7" : ""
                        },
                        children: [Oe.jsx("div", {
                            className: "LeftCustomBar-top",
                            children: Oe.jsxs(Pc, {
                                mode: "popLayout",
                                children: [(r == sa.customColorTable || !Za()) && g == "custom" && Oe.jsxs(oo.div, {
                                    className: "Slider-content",
                                    initial: {
                                        x: 30,
                                        opacity: 0
                                    },
                                    animate: {
                                        x: 0,
                                        opacity: 1
                                    },
                                    exit: {
                                        x: -30,
                                        opacity: 0
                                    },
                                    transition: {
                                        duration: .2
                                    },
                                    children: [Oe.jsxs("div", {
                                        className: "Slider-table",
                                        children: [Oe.jsx("p", {
                                            children: "色相"
                                        }), Oe.jsx(oN, {
                                            height: Ud
                                        })]
                                    }), Oe.jsxs("div", {
                                        className: "Slider-table",
                                        children: [Oe.jsx("p", {
                                            children: "饱和度"
                                        }), Oe.jsx(aN, {
                                            height: Ud
                                        })]
                                    }), Oe.jsxs("div", {
                                        className: "Slider-table",
                                        children: [Oe.jsx("p", {
                                            children: "明度"
                                        }), Oe.jsx(lN, {
                                            height: Ud
                                        })]
                                    }), Oe.jsxs("div", {
                                        className: "Slider-table",
                                        children: [Oe.jsx("p", {
                                            children: "金属度"
                                        }), Oe.jsx(cN, {
                                            height: Ud
                                        })]
                                    }), Oe.jsxs("div", {
                                        className: "Slider-table",
                                        children: [Oe.jsx("p", {
                                            children: "粗糙度"
                                        }), Oe.jsx(uN, {
                                            height: Ud
                                        })]
                                    })]
                                }, "preset"), r == sa.presetColorTable && Za() && Oe.jsxs(oo.div, {
                                    className: "Slider-content",
                                    initial: {
                                        x: 30,
                                        opacity: 0
                                    },
                                    animate: {
                                        x: 0,
                                        opacity: 1
                                    },
                                    exit: {
                                        x: -30,
                                        opacity: 0
                                    },
                                    transition: {
                                        duration: .2
                                    },
                                    children: [Oe.jsx("div", {
                                        className: "Bar-table",
                                        children: Array.from(Ae.colors.keys()).map((D,U)=>{
                                            if (["custom", "00", "01", "02"].includes(D))
                                                return Oe.jsx("div", {
                                                    className: "Bar",
                                                    style: {
                                                        ...D == "custom" ? {
                                                            backgroundColor: `hsl(${A.h * 360}, ${A.s * 100}%, ${A.l * 100}%)`
                                                        } : {},
                                                        backgroundImage: `url(${ai.autoURL("res/icon/" + Ae.colors.get(D).bgUrl)})`
                                                    },
                                                    onClick: ()=>{
                                                        D != g && (Ie.emit(Ie.CHANGECOLOR, D),
                                                        _(D)),
                                                        Ie.emit(Ie.PLAY_SFX, "click")
                                                    }
                                                    ,
                                                    children: g == D && Oe.jsx("div", {
                                                        className: "Bar-Line"
                                                    })
                                                }, D)
                                        }
                                        )
                                    }), Oe.jsx("div", {
                                        className: "Bar-table",
                                        children: Array.from(Ae.colors.keys()).map((D,U)=>{
                                            if (["03", "04", "05", "06"].includes(D))
                                                return Oe.jsx("div", {
                                                    className: "Bar",
                                                    style: {
                                                        ...D == "custom" ? {
                                                            backgroundColor: `hsl(${A.h * 360}, ${A.s * 100}%, ${A.l * 100}%)`
                                                        } : {},
                                                        backgroundImage: `url(${ai.autoURL("res/icon/" + Ae.colors.get(D).bgUrl)})`
                                                    },
                                                    onClick: ()=>{
                                                        D != g && (Ie.emit(Ie.CHANGECOLOR, D),
                                                        _(D)),
                                                        Ie.emit(Ie.PLAY_SFX, "click")
                                                    }
                                                    ,
                                                    children: g == D && Oe.jsx("div", {
                                                        className: "Bar-Line"
                                                    })
                                                }, D)
                                        }
                                        )
                                    }), Oe.jsx("div", {
                                        className: "Bar-table",
                                        children: Array.from(Ae.colors.keys()).map((D,U)=>{
                                            if (["07", "08", "09", "10"].includes(D))
                                                return Oe.jsx("div", {
                                                    className: "Bar",
                                                    style: {
                                                        ...D == "custom" ? {
                                                            backgroundColor: `hsl(${A.h * 360}, ${A.s * 100}%, ${A.l * 100}%)`
                                                        } : {},
                                                        backgroundImage: `url(${ai.autoURL("res/icon/" + Ae.colors.get(D).bgUrl)})`
                                                    },
                                                    onClick: ()=>{
                                                        D != g && (Ie.emit(Ie.CHANGECOLOR, D),
                                                        _(D)),
                                                        Ie.emit(Ie.PLAY_SFX, "click")
                                                    }
                                                    ,
                                                    children: g == D && Oe.jsx("div", {
                                                        className: "Bar-Line"
                                                    })
                                                }, D)
                                        }
                                        )
                                    }), Oe.jsx("div", {
                                        className: "Bar-table",
                                        children: Array.from(Ae.colors.keys()).map((D,U)=>{
                                            if (["11"].includes(D))
                                                return Oe.jsx("div", {
                                                    className: "Bar",
                                                    style: {
                                                        ...D == "custom" ? {
                                                            backgroundColor: `hsl(${A.h * 360}, ${A.s * 100}%, ${A.l * 100}%)`
                                                        } : {},
                                                        backgroundImage: `url(${ai.autoURL("res/icon/" + Ae.colors.get(D).bgUrl)})`
                                                    },
                                                    onClick: ()=>{
                                                        D != g && (Ie.emit(Ie.CHANGECOLOR, D),
                                                        _(D)),
                                                        Ie.emit(Ie.PLAY_SFX, "click")
                                                    }
                                                    ,
                                                    children: g == D && Oe.jsx("div", {
                                                        className: "Bar-Line"
                                                    })
                                                }, D)
                                        }
                                        )
                                    })]
                                }, "custom")]
                            })
                        }), Za() && Oe.jsx("div", {
                            className: "LeftCustomBar-bottom",
                            children: Oe.jsx("img", {
                                src: ai.autoURL("res/icon/ChangeButton.png"),
                                alt: "",
                                onClick: ()=>{
                                    Hv && (Hv = !1,
                                    Ie.emit(Ie.PLAY_SFX, "click"),
                                    setTimeout(()=>{
                                        Hv = !0
                                    }
                                    , 300),
                                    r == sa.customColorTable ? Ie.emit(Ie.UPDATECOLORTABLESTATE, sa.presetColorTable) : (Ie.emit(Ie.CHANGECOLOR, "custom"),
                                    Ie.emit(Ie.UPDATECOLORTABLESTATE, sa.customColorTable)))
                                }
                            })
                        })]
                    })
                }, "ChangeState5Bar-left")
            })
        })
    })
}
function oN({...t}) {
    const [n,r] = nt.useState({
        h: 0,
        s: 0,
        v: Ae.colors.get("custom").hsl.h * 100,
        a: 1
    })
      , [s,h] = nt.useState({
        ...Ae.colors.get("custom").hsl
    });
    return nt.useEffect(()=>{
        const l = ()=>{
            h({
                ...Ae.colors.get("custom").hsl
            })
        }
        ;
        return Ie.on(Ie.CHANGECOLOR, l),
        ()=>{
            Ie.off(Ie.CHANGECOLOR, l)
        }
    }
    , []),
    Oe.jsx(Nh, {
        ...t,
        className: "SliderHue",
        hsva: n,
        style: {
            borderRadius: "50%"
        },
        radius: "3px",
        backgroundGradient: "hsl(0, 100%, 50%) 0%, hsl(60, 100%, 50%) 17%, hsl(120, 100%, 50%) 33%, hsl(180, 100%, 50%) 50%, hsl(240, 100%, 50%) 67%, hsl(300, 100%, 50%) 83%, hsl(0, 100%, 50%) 100%",
        onChange: l=>{
            r({
                ...n,
                ...l
            });
            const g = Ae.colors.get("custom").col
              , _ = Ae.colors.get("custom").hsl;
            _.h = l.v / 100,
            g.setHSL(_.h, _.s, _.l).convertSRGBToLinear(),
            Ae.colors.get("custom").col.copy(g),
            Ie.emit(Ie.CHANGECOLOR, "custom")
        }
    })
}
function aN({...t}) {
    const [n,r] = nt.useState({
        h: 0,
        s: 0,
        v: Ae.colors.get("custom").hsl.s * 100,
        a: 1
    })
      , [s,h] = nt.useState({
        ...Ae.colors.get("custom").hsl
    });
    return nt.useEffect(()=>{
        const l = ()=>{
            h({
                ...Ae.colors.get("custom").hsl
            })
        }
        ;
        return Ie.on(Ie.CHANGECOLOR, l),
        ()=>{
            Ie.off(Ie.CHANGECOLOR, l)
        }
    }
    , []),
    Oe.jsx(Nh, {
        ...t,
        className: "SliderHue",
        hsva: n,
        style: {
            borderRadius: "50%"
        },
        radius: "3px",
        backgroundGradient: `rgb(0, 0, 0), hsl(${s.h * 360}, 100%, 50%)`,
        onChange: l=>{
            r({
                ...n,
                ...l
            });
            const g = Ae.colors.get("custom").col
              , _ = Ae.colors.get("custom").hsl;
            _.s = l.v / 100,
            g.setHSL(_.h, _.s, _.l).convertSRGBToLinear(),
            Ae.colors.get("custom").col.copy(g),
            Ie.emit(Ie.CHANGECOLOR, "custom")
        }
    })
}
function lN({...t}) {
    const [n,r] = nt.useState({
        h: 0,
        s: 0,
        v: Ae.colors.get("custom").hsl.l * 100,
        a: 1
    });
    return Oe.jsx(Nh, {
        ...t,
        className: "SliderHue",
        hsva: n,
        style: {
            borderRadius: "50%"
        },
        radius: "3px",
        onChange: s=>{
            r({
                ...n,
                ...s
            });
            const h = Ae.colors.get("custom").col
              , l = Ae.colors.get("custom").hsl;
            l.l = s.v / 100,
            h.setHSL(l.h, l.s, l.l).convertSRGBToLinear(),
            Ae.colors.get("custom").col.copy(h),
            Ie.emit(Ie.CHANGECOLOR, "custom")
        }
    })
}
function cN({...t}) {
    const [n,r] = nt.useState({
        h: 0,
        s: 0,
        v: Ae.colors.get("custom").metal * 100,
        a: 1
    });
    return Oe.jsx(Nh, {
        ...t,
        className: "SliderHue",
        hsva: n,
        style: {
            borderRadius: "50%"
        },
        radius: "3px",
        onChange: s=>{
            r({
                ...n,
                ...s
            }),
            Ae.colors.get("custom").metal = s.v / 100,
            Ie.emit(Ie.CHANGECOLOR, "custom")
        }
    })
}
function uN({...t}) {
    const [n,r] = nt.useState({
        h: 0,
        s: 0,
        v: Ae.colors.get("custom").rough * 100,
        a: 1
    });
    return Oe.jsx(Nh, {
        ...t,
        className: "SliderHue",
        hsva: n,
        style: {
            borderRadius: "50%"
        },
        radius: "3px",
        onChange: s=>{
            r({
                ...n,
                ...s
            }),
            Ae.colors.get("custom").rough = s.v / 100,
            Ie.emit(Ie.CHANGECOLOR, "custom")
        }
    })
}
function hN() {
    return Oe.jsxs(Oe.Fragment, {
        children: [Oe.jsx(jU, {}), Oe.jsx(TB, {}), Oe.jsx(WU, {}), Oe.jsx(XU, {}), Oe.jsx(YU, {}), Oe.jsx(QU, {}), Oe.jsx(sN, {}), Oe.jsx(KU, {})]
    })
}
Vv.createRoot(document.getElementById("root")).render(Oe.jsx(Oh.StrictMode, {
    children: Oe.jsx(hN, {})
}));
