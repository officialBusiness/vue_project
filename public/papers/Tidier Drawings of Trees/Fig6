PROCEDURE SETUP ( T : LINK; 						(* ROOT OF SUBTREE									*)
									LEVEL: INTEGER; 			(* CURRENT OVERALL LEVEL						*)
									VAR RMOST,
											LMOST EXTREME ); 	(* EXTREME DESCENDANTS							*)

(* THIS PROCEDURE IMPLEMENTS ALGORITHM TR, ASSIGNINE RELATIVE								*)
(* POSITIONINGS TO ALL NODES IN TEE TREE POINTED TO BY PARAMETER T.					*)

VAR
		L, R : LINK;												(* LEFT AND RIGHT SONS							*)
		LR, LL, RR, RL : EXTREME;						(* LR = RIGHTMOST NODE ON						*)
																				(* LOWEST LEVEL OF LEFT SUBTREE			*)
																				(* AND SO ON												*)
		CURSEP, 														(* SEPARATION ON CURRENT LEVEL 			*)
		ROOTSEP, 														(* CURRENT SEPARATION AT NODE T 		*)
		LOFFSUM, ROFFSUM : INTEGER;					(* OFFSET FROM L & R TO T 					*)

BEGIN		(*	SETUP		*)
		IF T = NIL THEN BEGIN 							(* AVOID SELECTING AS EXTREME				*)
				LMOST.LEV := -1;
				RMOST.LEV := -1
		END ELSE BENIN
				T^.YCOORD :- LEVEL;
				L := T^.LLINK; 									(* FOLLOWS CONTOUR OF LEFT SUBTREE	*)
				R := T^.RLINK; 									(* FOLLOWS CONTOUR OF RIGNT SUBTREE *)
				SETUP ( L, LEVEL + 1, LR, LL ); (* POSITION SUBTREES RECURSIVELY		*)
				SETUP ( R, LEVEL + 1, RR, RL );
				IF (R=NIL) AND (L=NIL) THEN BEGIN 	(* LEAF *)
					RMOST.ADDR := T; 							(* A LEAF IS BOTH THE LEFTMOST 			*)
					LMOST.ADDR := T; 							(* AND RIGHTMOST NODE ON THE 				*)
					RMOST.LEV := LEVEL; 					(* LOWEST LEVEL OF THE SUBTREE 			*)
					LMOST.LEV := LEVEL;						(* CONSISTING OF ITSELF							*)
					RMOST.OFF := 0;
					LMOST.OFF := 0;
					T^.OFFSET := 0
				END ELSE BEGIN 									(* T NOT A LEAF 		*)
( SET UP FOR SUBTREE PUSHING. PLACE ROOTS OF R)
(R SUBTREES MINIMUM DISTANCE APART. R)
CURSEP - MINSEP;
ROOTSEP M-INSEP;
LOPPSUM 0;
RODFSUM - U;
(R NOW CONSIDER RACH LEVEL IN TURN UNTIL ONE *)
(R SUBTREE IS EXHAUSTED, PUSHING THE SUOTREES R)
(R APART WHEN NECESSARY. R)
WHILE (L<>NIL) AND (R<>NEL) DO BEGIN
IF CURSEP < MINSEP THEN BEGIN (* PUSH ? *)
ROOTSIP - ROOTSEP + (MINSEP - CURSEP);
CURSEP - MINSEP
ISD; (* ID CURSEP < MINSEP H)
(* ADVANCE L & R *)
IF L^.RLINK <> NIL THEN NEGIN
LOFFSPIM - LOPFSUM + L'.OFFSET;
CURSEP - CURSEP - L'.OFFSET;
L :- L^.RLiNK
END ELSE BEGIN
LOFFSUMK- LOFFSUM - L^.OFFSET;
CURSEP - CURSEP + L^.OFFSET;
L :- L^.LLINK
END;
IF R^.LLINK (> NEL THEN BEGIN
ROFFSUM :- ROFFSUM - R^.OFPSET;
CURSEP - CURSEP - R'.OFFSET;
R :- R^.LLINK
END ELSE BEGIN
ROFFSE :- ROFFSUI + R^.OFFSET;
CURSEP :- CURSEP + R^.OFFSET;
R :- R.RLINK
END; C* ELSE *)
END; (* WHILE *)
(* SET THE OFFSET IN NODE T, AND INCLUDE IT IN *)
(* ACCUMULATED OFFSETS FOR L AND R N)
T'.OFFSET :- (ROOTSEP + 1) DIV 2;
LOFFSUM : LOFFSUM - T^.OFFSET;
ROFFSUM - ROFFSUM + T'.OFFSET;
(R UPDATE EXTREME DESCENDANTS INFOREMATIOS R)
IF (RL.LEV > LL.LEV) OR CT^.LLINK - NIL) THEN BEGIN
LMOST : - RL;
LMOST.OFF :- LMOST.OFF + T^.OFFSET
END ELSE BEGIN
LMOST :- LL;
LMOST.OFF :- LMOST.OFF - T^.OFFSET
END;
IF (LR.LEV > RR.LEV) OR (T^.RLINK - SIL) THEN BEGIN
REOST :- LR;
RMOST.OFF :- RMOST.OFF - T^.OFFSET
END ELSE BEGIN
RMOST :- RR;
RMOST.OFF :- RMOST.OFF + T-.OFFSET
END;
(R IF SUBTREES OF T WERE OF UNEVEN HEIGHTS, CKER R)
(R TO SEE IF THREADING IS NHECESSARY. AT MOST ONE *)
(* THREAD NEEDS TO BE INSERTED. *)
IF (L 0> NEL) AND (L C> T.LLINK) THEEN BEGIN
RR.ADDRE.THREAD TRUE;
RR.ADDR'.OFFSET : ABS(( RR.OFF + T^.OFFSET) - LOFFSUM );
IF LOFFSUM - T^.OFFSET <- R.OFF THEN
RR.ADDR'.LLINK - L
ELSE
RR.ADDR.RLINK - L
END ELSE IF (R <> NIL) AND (R > T^.RLINK) THEN BEGIN
LL.ADDR'.THREAD - TRUE;
LL.ADDR'.OFFSET A-BS(( LL.OFF - T^.OFFSET ) - ROFFSUM );
IF ROFFSUM + T'.OFFSET >- LL.OFF THEN
LL.ADDR'.RLINK RR
ELSE
LL.ADDR'.LLINK- R
END
ESD; (* OF IF NOT LEAF *)
END; (* OF T C> NIL *)
END; (* PROCEDURE SETUP *)