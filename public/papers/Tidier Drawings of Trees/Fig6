PROCEDURE SETUP ( T : LINK; 						(* ROOT OF SUBTREE									*)
									LEVEL: INTEGER; 			(* CURRENT OVERALL LEVEL						*)
									VAR RMOST,
											LMOST EXTREME ); 	(* EXTREME DESCENDANTS							*)

(* THIS PROCEDURE IMPLEMENTS ALGORITHM TR, ASSIGNINE RELATIVE								*)
(* POSITIONINGS TO ALL NODES IN TEE TREE POINTED TO BY PARAMETER T.					*)

VAR
	L, R : LINK;												(* LEFT AND RIGHT SONS							*)
	LR, LL, RR, RL : EXTREME;						(* LR = RIGHTMOST NODE ON						*)
																			(* LOWEST LEVEL OF LEFT SUBTREE			*)
																			(* AND SO ON												*)
	CURSEP, 														(* SEPARATION ON CURRENT LEVEL 			*)
	ROOTSEP, 														(* CURRENT SEPARATION AT NODE T 		*)
	LOFFSUM, ROFFSUM : INTEGER;					(* OFFSET FROM L & R TO T 					*)

BEGIN		(*	SETUP		*)
	IF T = NIL THEN BEGIN 							(* AVOID SELECTING AS EXTREME				*)
		LMOST.LEV := -1;
		RMOST.LEV := -1
	END ELSE BENIN
		T^.YCOORD :- LEVEL;
		L := T^.LLINK; 									(* FOLLOWS CONTOUR OF LEFT SUBTREE	*)
		R := T^.RLINK; 									(* FOLLOWS CONTOUR OF RIGNT SUBTREE *)
		SETUP ( L, LEVEL + 1, LR, LL ); (* POSITION SUBTREES RECURSIVELY		*)
		SETUP ( R, LEVEL + 1, RR, RL );
		IF (R=NIL) AND (L=NIL) THEN BEGIN 	(* LEAF *)
			RMOST.ADDR := T; 							(* A LEAF IS BOTH THE LEFTMOST 			*)
			LMOST.ADDR := T; 							(* AND RIGHTMOST NODE ON THE 				*)
			RMOST.LEV := LEVEL; 					(* LOWEST LEVEL OF THE SUBTREE 			*)
			LMOST.LEV := LEVEL;						(* CONSISTING OF ITSELF							*)
			RMOST.OFF := 0;
			LMOST.OFF := 0;
			T^.OFFSET := 0
		END ELSE BEGIN 									(* T NOT A LEAF 		*)
			(* SET UP FOR SUBTREE PUSHING. PLACE ROOTS OF 		*)
			(* SUBTREES MINIMUM DISTANCE APART. 							*)
			CURSEP := MINSEP;
			ROOTSEP := MINSEP;
			LOFFSUM := 0;
			ROFFSUM := 0;

			(* NOW CONSIDER EACH LEVEL IN TURN UNTIL ONE 			*)
			(* SUBTREE IS EXHAUSTED, PUSHING THE SUBTREES 		*)
			(* APART WHEN NECESSARY. 													*)
			
			WHILE (L<>NIL) AND (R<>NEL) DO BEGIN
				IF CURSEP < MINSEP THEN BEGIN 				(* PUSH ? *)
					ROOTSEP := ROOTSEP + (MINSEP - CURSEP);
					CURSEP := MINSEP
				END; 											(* IF CURSEP < MINSEP *)

				(* ADVANCE L & R *)
				IF L^.RLINK <> NIL THEN BEGIN
					LOFFSUM := LOFFSUM + L^.OFFSET;
					CURSEP := CURSEP - L^.OFFSET;
					L := L^.RLINK
				END ELSE BEGIN
					LOFFSUM := LOFFSUM - L^.OFFSET;
					CURSEP := CURSEP + L^.OFFSET;
					L := L^.LLINK
				END;
					IF R^.LLINK <> NIL THEN BEGIN
					ROFFSUM := ROFFSUM - R^.OFFSET;
					CURSEP := CURSEP - R^.OFFSET;
					R := R^.LLINK
				END ELSE BEGIN
					ROFFSE := ROFFSUM + R^.OFFSET;
					CURSEP := CURSEP + R^.OFFSET;
					R := R.RLINK
				END; (* ELSE *)
			END; (* WHILE *)

			(* SET THE OFFSET IN NODE T, AND INCLUDE IT IN 		*)
			(* ACCUMULATED OFFSETS FOR L AND R 								*)

			T^.OFFSET := (ROOTSEP + 1) DIV 2;
			LOFFSUM := LOFFSUM - T^.OFFSET;
			ROFFSUM := ROFFSUM + T^.OFFSET;

			(* UPDATE EXTREME DESCENDANTS INFOREMATIO *)

			IF (RL.LEV > LL.LEV) OR (T^.LLINK = NIL) THEN BEGIN
				LMOST := RL;
				LMOST.OFF := LMOST.OFF + T^.OFFSET
			END ELSE BEGIN
				LMOST := LL;
				LMOST.OFF := LMOST.OFF - T^.OFFSET
			END;
			IF (LR.LEV > RR.LEV) OR (T^.RLINK = NIL) THEN BEGIN
				RMOST := LR;
				RMOST.OFF := RMOST.OFF - T^.OFFSET
			END ELSE BEGIN
				RMOST := RR;
				RMOST.OFF := RMOST.OFF + T^.OFFSET
			END;

			(* IF SUBTREES OF T WERE OF UNEVEN HEIGHTS, CHECK					*)
			(* TO SEE IF THREADING IS NECESSARY. AT MOST ONE 					*)
			(* THREAD NEEDS TO BE INSERTED. 													*)

			IF (L <> NEL) AND (L <> T^.LLINK) THEEN BEGIN
				RR.ADDR^.THREAD := TRUE;
				RR.ADDR^.OFFSET := ABS(( RR.OFF + T^.OFFSET) - LOFFSUM );
IF LOFFSUM - T^.OFFSET <- R.OFF THEN
RR.ADDR'.LLINK - L
ELSE
RR.ADDR.RLINK - L
END ELSE IF (R <> NIL) AND (R > T^.RLINK) THEN BEGIN
LL.ADDR'.THREAD - TRUE;
LL.ADDR'.OFFSET A-BS(( LL.OFF - T^.OFFSET ) - ROFFSUM );
IF ROFFSUM + T'.OFFSET >- LL.OFF THEN
LL.ADDR'.RLINK RR
ELSE
LL.ADDR'.LLINK- R
END
ESD; (* OF IF NOT LEAF *)
END; (* OF T C> NIL *)
END; (* PROCEDURE SETUP *)