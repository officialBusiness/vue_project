PROCEDURE SETUP ( T : LINK; 						(* ROOT OF SUBTREE									*)
									LEVEL: INTEGER; 			(* CURRENT OVERALL LEVEL						*)
									VAR RMOST,
											LMOST EXTREME ); 	(* EXTREME DESCENDANTS							*)
(* THIS PROCEDURE IMPLEMENTS ALGORITHM TR, ASSIGNINE RELATIVE								*)
(* POSITIONINGS TO ALL NODES IN TEE TREE POINTED TO BY PARAMETER T.					*)
VAR
		L,R : LINK;													(* LEFT AND RIGHT SONS							*)
		LR, LL, RR, RL : EXTREME;						(* LR = RIGHTMOST NODE ON						*)
																				(* LOWEST LEVEL OF LEFT SUBTREE			*)
																				(* AND SO ON												*)
		CURSEP, 														(* SEPARATION ON CURRENT LEVEL 			*)
		ROOTSEP, 														(* CURRENT SEPARATION AT NODE T 		*)
			LOFFSUM, ROFFSUN : INTEGER;				(* OFFSET FROM L & R TO T 					*)
BEGIN		(*	SETUP		*)
	IF T = NIL THEN BEGIN 								(* AVOID SELECTING AS EXTREME				*)
		LMOST.LEV := -1;
		RMOST.LEV := -1
	END ELSE BENIN
		T^.YCOORD :- LEVEL;
		L := T^.LLINK; 											(* FOLLOWS CONTOUR OF LEFT SUBTREE	*)
		R := T^.RLINK; 											(* FOLLOWS CONTOUR OP RIGNT SUBTREE *)
SETUP L, LEVEL+SS LR, LL ); (R POSITION SUBTREES RECURSIVELY R)
SETUP RI, LEVEL+1, RR, RL );
EF (R-NIL) AND (L-NIL) THEN BEGIN (* LEA )
RMOST.ADDR TC; (* A LEAP IS BOTH THE LEPTMOST R)
LMOST.ADDR - T; (E AND RIGHTMOST NODE ON THE R)
RMOST.LEV :- LEVEL; (* LOWEST LEVEL OF THE SUBTREE *)
LMOST.LEV - LEVEL; (S CONSISTING OF ITSELF *)
RMOST.OFF - 0;
LMOST.OFF - 0;
T'.OFPS8T - 0
END ELSE BEGIN (R T NOT A LEA )
( SET UP FOR SUBTREE PUSHING. PLACE ROOTS OF R)
(R SUBTREES MINIMUM DISTANCE APART. R)
CURSEP - MINSEP;
ROOTSEP M-INSEP;
LOPPSUM 0;
RODFSUM - U;
(R NOW CONSIDER RACH LEVEL IN TURN UNTIL ONE *)
(R SUBTREE IS EXHAUSTED, PUSHING THE SUOTREES R)
(R APART WHEN NECESSARY. R)
WHILE (L<>NIL) AND (R<>NEL) DO BEGIN
IF CURSEP < MINSEP THEN BEGIN (* PUSH ? *)
ROOTSIP - ROOTSEP + (MINSEP - CURSEP);
CURSEP - MINSEP
ISD; (* ID CURSEP < MINSEP H)
(* ADVANCE L & R *)
IF L^.RLINK <> NIL THEN NEGIN
LOFFSPIM - LOPFSUM + L'.OFFSET;
CURSEP - CURSEP - L'.OFFSET;
L :- L^.RLiNK
END ELSE BEGIN
LOFFSUMK- LOFFSUM - L^.OFFSET;
CURSEP - CURSEP + L^.OFFSET;
L :- L^.LLINK
END;
IF R^.LLINK (> NEL THEN BEGIN
ROFFSUM :- ROFFSUM - R^.OFPSET;
CURSEP - CURSEP - R'.OFFSET;
R :- R^.LLINK
END ELSE BEGIN
ROFFSE :- ROFFSUI + R^.OFFSET;
CURSEP :- CURSEP + R^.OFFSET;
R :- R.RLINK
END; C* ELSE *)
END; (* WHILE *)
(* SET THE OFFSET IN NODE T, AND INCLUDE IT IN *)
(* ACCUMULATED OFFSETS FOR L AND R N)
T'.OFFSET :- (ROOTSEP + 1) DIV 2;
LOFFSUM : LOFFSUM - T^.OFFSET;
ROFFSUM - ROFFSUM + T'.OFFSET;
(R UPDATE EXTREME DESCENDANTS INFOREMATIOS R)
IF (RL.LEV > LL.LEV) OR CT^.LLINK - NIL) THEN BEGIN
LMOST : - RL;
LMOST.OFF :- LMOST.OFF + T^.OFFSET
END ELSE BEGIN
LMOST :- LL;
LMOST.OFF :- LMOST.OFF - T^.OFFSET
END;
IF (LR.LEV > RR.LEV) OR (T^.RLINK - SIL) THEN BEGIN
REOST :- LR;
RMOST.OFF :- RMOST.OFF - T^.OFFSET
END ELSE BEGIN
RMOST :- RR;
RMOST.OFF :- RMOST.OFF + T-.OFFSET
END;
(R IF SUBTREES OF T WERE OF UNEVEN HEIGHTS, CKER R)
(R TO SEE IF THREADING IS NHECESSARY. AT MOST ONE *)
(* THREAD NEEDS TO BE INSERTED. *)
IF (L 0> NEL) AND (L C> T.LLINK) THEEN BEGIN
RR.ADDRE.THREAD TRUE;
RR.ADDR'.OFFSET : ABS(( RR.OFF + T^.OFFSET) - LOFFSUM );
IF LOFFSUM - T^.OFFSET <- R.OFF THEN
RR.ADDR'.LLINK - L
ELSE
RR.ADDR.RLINK - L
END ELSE IF (R <> NIL) AND (R > T^.RLINK) THEN BEGIN
LL.ADDR'.THREAD - TRUE;
LL.ADDR'.OFFSET A-BS(( LL.OFF - T^.OFFSET ) - ROFFSUM );
IF ROFFSUM + T'.OFFSET >- LL.OFF THEN
LL.ADDR'.RLINK RR
ELSE
LL.ADDR'.LLINK- R
END
ESD; (* OF IF NOT LEAF *)
END; (* OF T C> NIL *)
END; (* PROCEDURE SETUP *)