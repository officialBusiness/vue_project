<!DOCTYPE html>
<html lang="en">
	<head>
		<title>animation1</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="../../examples/main.css">
	</head>

	<body>

		<div id="container"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../../build/three.module.js"
				}
			}
		</script>
		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from '../../examples/jsm/controls/OrbitControls.js';

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setClearColor( 0x000000, 0.0 );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			const scene = new THREE.Scene();

			scene.add( new THREE.AxesHelper( 100 ) );

			const camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
			camera.position.set( 0, 0, 300 );

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.target.set(0, 0, 0);

			const car1 = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 1), new THREE.MeshBasicMaterial({
				color: 0x00ff00
			}));
			scene.add( car1 );

			const car2 = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 1), new THREE.MeshBasicMaterial({
				color: 0x00ff00
			}));

			scene.add( car2 );

			let 
				carState = [
					{
						model: car1,
						path: [
							[car1.position.x, car1.position.y, car1.position.z, ],
							[10, 0, 0],
							[10, 30, 0],
							[0, 20, 0]
						],
						road: [],
						direction: [],
						speed: 0.3,
						nowSegment: 0,
						nowRunRoad: 0,
					},
					{
						model: car2,
						path: [
							[car2.position.x, car2.position.y, car2.position.z, ],
							[-30, 0, 0],
							[-30, -20, 0],
							[0, -20, 0]
						],
						road: [],
						direction: [],
						speed: 0.3,
						nowSegment: 0,
						nowRunRoad: 0,

					},
				];
			carState.forEach((state)=>{
				for(let i = 0, len = state.path.length; i < len; i++){
					let 
						v1 = state.path[i % len],
						v2 = state.path[(i + 1) % len],
						dx = v2[0] - v1[0],
						dy = v2[1] - v1[1],
						dz = v2[2] - v1[2];

					state.road.push(Math.sqrt( dx * dx + dy * dy + dz * dz ));
					state.direction.push(new THREE.Vector3(
						dx, dy, dz
					).normalize());
				}
				rotateCar(state.model, state.direction[0]);
			});

			function rotateCar(car, dir){
				let v2 = dir,
						v1 = new THREE.Vector3(0, 1, 0);
				car.rotation.z = Math.acos( ( v1.x * v2.x + v1.y * v2.y + v1.z * v2.z ) / ( v1.length() * v2.length() ) )
			}

			function carRun(){
				carState.forEach((state, index)=>{
					let car = state.model,
							road = state.road[index];
					state.nowRunRoad += state.speed;
					if( state.nowRunRoad > state.road[state.nowSegment] ){
						state.nowRunRoad = 0;
						state.nowSegment = ( state.nowSegment + 1 ) % 4;
						let v = state.path[state.nowSegment];

						state.model.position.set(v[0], v[1], v[2]);

						rotateCar(state.model, state.direction[state.nowSegment]);
					}else{
						let d = state.direction[state.nowSegment];

						state.model.position.x += d.x * state.speed;
						state.model.position.y += d.y * state.speed;
						state.model.position.z += d.z * state.speed;
					}
				});
			}


			window.addEventListener( 'resize', onWindowResize );
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			animate();
			function animate() {
				carRun();

				requestAnimationFrame( animate );
				// stats.update();
				// controls.update();
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>
