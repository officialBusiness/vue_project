<!DOCTYPE html>
<html lang="en">
	<head>
		<title>animation1</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="../../examples/main.css">
	</head>

	<body>

		<div id="container"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../../build/three.module.js"
				}
			}
		</script>
		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from '../../examples/jsm/controls/OrbitControls.js';
			import { ThreeMFLoader } from '../../examples/jsm/loaders/3MFLoader.js';

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setClearColor( 0xffffff, 1.0 );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			const scene = new THREE.Scene();

			scene.add( new THREE.AxesHelper( 500 ) );

			scene.add(new THREE.AmbientLight( 0x404040 ));

			const camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
			camera.position.set( 0, 0, 30 );

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.target.set(0, 0, 0);

			window.addEventListener( 'resize', onWindowResize );
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
			hemiLight.position.set( 0, 100, 0 );
			scene.add( hemiLight );

			const dirLight = new THREE.DirectionalLight( 0xffffff );
			dirLight.position.set( - 0, 40, 50 );
			dirLight.castShadow = true;
			dirLight.shadow.camera.top = 50;
			dirLight.shadow.camera.bottom = - 25;
			dirLight.shadow.camera.left = - 25;
			dirLight.shadow.camera.right = 25;
			dirLight.shadow.camera.near = 0.1;
			dirLight.shadow.camera.far = 200;
			dirLight.shadow.mapSize.set( 1024, 1024 );
			scene.add( dirLight );

			// 加载模型
			const manager = new THREE.LoadingManager();
			const loader = new ThreeMFLoader( manager );
			loader.load( '../../examples/models/3mf/truck.3mf', function ( object ) {

				object.traverse( function ( child ) {
					child.castShadow = true;
				} );
				// 人工进行模型矫正
				object.position.z = -1;
				object.scale.set( 0.1, 0.1, 0.1 );
				object.rotation.z = Math.PI / 2;
				let model = new THREE.Group();
				model.add(object);
				scene.add( model );

				let 
					modelState = [
						{
							model: model,
							path: [
								[model.position.x, model.position.y, model.position.z, ],
								[10, 0, 0],
								[10, 20,0],
								[0, 10, 0]
							],
							road: [],
							direction: [],
							speed: 0.3,
							nowSegment: 0,
							nowRunRoad: 0,
						},
						// {
						// 	model: model,
						// 	path: [
						// 		[model.position.x, model.position.y, model.position.z, ],
						// 		[-30, 0, 0],
						// 		[-30, -20, 0],
						// 		[0, -20, 0]
						// 	],
						// 	road: [],
						// 	direction: [],
						// 	speed: 0.3,
						// 	nowSegment: 0,
						// 	nowRunRoad: 0,

						// },
					];
				modelState.forEach((state)=>{
					for(let i = 0, len = state.path.length; i < len; i++){
						let 
							v1 = state.path[i % len],
							v2 = state.path[(i + 1) % len],
							dx = v2[0] - v1[0],
							dy = v2[1] - v1[1],
							dz = v2[2] - v1[2];

						state.road.push(Math.sqrt( dx * dx + dy * dy + dz * dz ));
						let direction = new THREE.Vector3( dx, dy, dz ).normalize();
						state.direction.push(direction);

						scene.add( new THREE.ArrowHelper( direction, new THREE.Vector3(v1[0], v1[1], v1[2]), 2 , 0x000000) );
					}
					rotateCar1(state.model, state.direction[0]);
					// rotateCar2(state.model, state.path[1]);
				});
				// 不支持高度的可控旋转
				function rotateCar1(car, dir/*Vector3*/, preDir = new THREE.Vector3(1, 0, 0)){
					let 
						v1 = preDir,
						v2 = dir,

						quaternion = new THREE.Quaternion();
					quaternion.setFromUnitVectors(v1, dir);

					car.applyQuaternion(quaternion);
				}
				// 可以使用 lookAt 增加代码复杂度
				function rotateCar2(car, target){
					console.log('target:', target[0], target[1], target[2]);
					let mtx = new THREE.Matrix4(),
							quaternion = new THREE.Quaternion();

					mtx.lookAt(car.position, new THREE.Vector3(target[0], target[1], target[2]), new THREE.Vector3(0,0,1));
					quaternion.setFromRotationMatrix(mtx);
					car.applyQuaternion(quaternion);
				}

				function carRun(){
					modelState.forEach((state, index)=>{
						let car = state.model,
								road = state.road[index],
								len = state.road.length;
						state.nowRunRoad += state.speed;
						if( state.nowRunRoad > state.road[state.nowSegment] ){
							state.nowRunRoad = 0;
							state.nowSegment = ( state.nowSegment + 1 ) % len;
							let v = state.path[state.nowSegment];

							state.model.position.set(v[0], v[1], v[2]);

							rotateCar1(state.model, state.direction[state.nowSegment], state.direction[(state.nowSegment + len - 1) % len]);
						}else{
							let d = state.direction[state.nowSegment];

							state.model.position.x += d.x * state.speed;
							state.model.position.y += d.y * state.speed;
							state.model.position.z += d.z * state.speed;
						}
					});
				}

				animate();
				function animate() {
					carRun();

					requestAnimationFrame( animate );
					// stats.update();
					// controls.update();
					renderer.render( scene, camera );
				}
			} );

		</script>
	</body>
</html>
